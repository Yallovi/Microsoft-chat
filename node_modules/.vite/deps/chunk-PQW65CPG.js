import {
  AzureKeyCredential,
  bearerTokenAuthenticationPolicy,
  init_src4 as init_src,
  isTokenCredential,
  jwt_decode_esm_default
} from "./chunk-744LOQAW.js";
import {
  __rest,
  init_tslib_es6
} from "./chunk-27DHBYWV.js";

// node_modules/@azure/communication-common/dist-esm/src/tokenParser.js
var parseToken = (token) => {
  const { exp } = jwt_decode_esm_default(token);
  return {
    token,
    expiresOnTimestamp: exp * 1e3
  };
};

// node_modules/@azure/communication-common/dist-esm/src/autoRefreshTokenCredential.js
var expiredToken = { token: "", expiresOnTimestamp: -10 };
var minutesToMs = (minutes) => minutes * 1e3 * 60;
var defaultExpiringSoonInterval = minutesToMs(10);
var defaultRefreshAfterLifetimePercentage = 0.5;
var AutoRefreshTokenCredential = class {
  constructor(refreshArgs) {
    this.expiringSoonIntervalInMs = defaultExpiringSoonInterval;
    this.refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;
    this.activeTokenFetching = null;
    this.activeTokenUpdating = null;
    this.disposed = false;
    const { tokenRefresher, token, refreshProactively } = refreshArgs;
    this.refresh = tokenRefresher;
    this.currentToken = token ? parseToken(token) : expiredToken;
    this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
    if (this.refreshProactively) {
      this.scheduleRefresh();
    }
  }
  async getToken(options) {
    if (!this.isTokenExpiringSoon(this.currentToken)) {
      return this.currentToken;
    }
    if (!this.isTokenValid(this.currentToken)) {
      const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
      await updatePromise;
    }
    return this.currentToken;
  }
  dispose() {
    this.disposed = true;
    this.activeTokenFetching = null;
    this.activeTokenUpdating = null;
    this.currentToken = expiredToken;
    if (this.activeTimeout) {
      clearTimeout(this.activeTimeout);
    }
  }
  async updateTokenAndReschedule(abortSignal) {
    if (this.activeTokenUpdating) {
      return this.activeTokenUpdating;
    }
    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
    try {
      await this.activeTokenUpdating;
    } finally {
      this.activeTokenUpdating = null;
    }
  }
  async refreshTokenAndReschedule(abortSignal) {
    const newToken = await this.refreshToken(abortSignal);
    if (!this.isTokenValid(newToken)) {
      throw new Error("The token returned from the tokenRefresher is expired.");
    }
    this.currentToken = newToken;
    if (this.refreshProactively) {
      this.scheduleRefresh();
    }
  }
  async refreshToken(abortSignal) {
    try {
      if (!this.activeTokenFetching) {
        this.activeTokenFetching = this.refresh(abortSignal);
      }
      return parseToken(await this.activeTokenFetching);
    } finally {
      this.activeTokenFetching = null;
    }
  }
  scheduleRefresh() {
    if (this.disposed) {
      return;
    }
    if (this.activeTimeout) {
      clearTimeout(this.activeTimeout);
    }
    const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();
    let timespanInMs = null;
    if (this.isTokenExpiringSoon(this.currentToken)) {
      timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;
    } else {
      timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;
    }
    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);
  }
  isTokenValid(token) {
    return token && Date.now() < token.expiresOnTimestamp;
  }
  isTokenExpiringSoon(token) {
    return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;
  }
};

// node_modules/@azure/communication-common/dist-esm/src/staticTokenCredential.js
var StaticTokenCredential = class {
  constructor(token) {
    this.token = token;
  }
  async getToken() {
    return this.token;
  }
  dispose() {
  }
};

// node_modules/@azure/communication-common/dist-esm/src/azureCommunicationTokenCredential.js
var AzureCommunicationTokenCredential = class {
  constructor(tokenOrRefreshOptions) {
    this.disposed = false;
    if (typeof tokenOrRefreshOptions === "string") {
      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));
    } else {
      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);
    }
  }
  /**
   * Gets an `AccessToken` for the user. Throws if already disposed.
   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
   */
  async getToken(options) {
    this.throwIfDisposed();
    const token = await this.tokenCredential.getToken(options);
    this.throwIfDisposed();
    return token;
  }
  /**
   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
   */
  dispose() {
    this.disposed = true;
    this.tokenCredential.dispose();
  }
  throwIfDisposed() {
    if (this.disposed) {
      throw new Error("User credential is disposed");
    }
  }
};

// node_modules/@azure/communication-common/dist-esm/src/credential/encodeUtils.browser.js
var encodeUTF8 = (str) => new TextEncoder().encode(str);
function encodeUTF8fromBase64(str) {
  if (typeof atob !== "function") {
    throw new Error("Your browser environment is missing the global `atob` function");
  }
  const binary = atob(str);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
function encodeBase64(value) {
  if (typeof btoa !== "function") {
    throw new Error("Your browser environment is missing the global `btoa` function");
  }
  const bytes = new Uint8Array(value);
  let binary = "";
  for (const byte of bytes) {
    binary += String.fromCharCode(byte);
  }
  return btoa(binary);
}

// node_modules/@azure/communication-common/dist-esm/src/credential/cryptoUtils.browser.js
var _a;
var _b;
var subtle = (_b = (_a = globalThis) === null || _a === void 0 ? void 0 : _a.crypto) === null || _b === void 0 ? void 0 : _b.subtle;
var shaHash = async (content) => {
  const data = encodeUTF8(content);
  const hash = await subtle.digest("SHA-256", data);
  return encodeBase64(hash);
};
var shaHMAC = async (secret, content) => {
  const importParams = { name: "HMAC", hash: { name: "SHA-256" } };
  const encodedMessage = encodeUTF8(content);
  const encodedKey = encodeUTF8fromBase64(secret);
  const crypto = subtle;
  const cryptoKey = await crypto.importKey("raw", encodedKey, importParams, false, ["sign"]);
  const signature = await crypto.sign(importParams, cryptoKey, encodedMessage);
  return encodeBase64(signature);
};

// node_modules/@azure/communication-common/dist-esm/src/credential/isNode.browser.js
var isNode = false;

// node_modules/@azure/communication-common/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js
var communicationAccessKeyCredentialPolicy = "CommunicationAccessKeyCredentialPolicy";
function createCommunicationAccessKeyCredentialPolicy(credential) {
  return {
    name: communicationAccessKeyCredentialPolicy,
    async sendRequest(request, next) {
      var _a2;
      const verb = request.method.toUpperCase();
      const utcNow = new Date().toUTCString();
      const contentHash = await shaHash(((_a2 = request.body) === null || _a2 === void 0 ? void 0 : _a2.toString()) || "");
      const dateHeader = "x-ms-date";
      const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
      const url = new URL(request.url);
      const query = url.searchParams;
      const urlPathAndQuery = query ? `${url.pathname}?${query}` : url.pathname;
      const port = url.port;
      const hostAndPort = port ? `${url.host}:${port}` : url.host;
      const stringToSign = `${verb}
${urlPathAndQuery}
${utcNow};${hostAndPort};${contentHash}`;
      const signature = await shaHMAC(credential.key, stringToSign);
      if (isNode) {
        request.headers.set("Host", hostAndPort || "");
      }
      request.headers.set(dateHeader, utcNow);
      request.headers.set("x-ms-content-sha256", contentHash);
      request.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
      return next(request);
    }
  };
}

// node_modules/@azure/communication-common/dist-esm/src/credential/communicationAuthPolicy.js
init_src();
function createCommunicationAuthPolicy(credential) {
  if (isTokenCredential(credential)) {
    const policyOptions = {
      credential,
      scopes: ["https://communication.azure.com//.default"]
    };
    return bearerTokenAuthenticationPolicy(policyOptions);
  } else {
    return createCommunicationAccessKeyCredentialPolicy(credential);
  }
}

// node_modules/@azure/communication-common/dist-esm/src/credential/clientArguments.js
init_src();

// node_modules/@azure/communication-common/dist-esm/src/credential/connectionString.js
init_src();
var CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;
var tryParseConnectionString = (s) => {
  const match = s.match(CONNECTION_STRING_REGEX);
  if ((match === null || match === void 0 ? void 0 : match[1]) && match[2]) {
    return { endpoint: match[1], credential: new AzureKeyCredential(match[2]) };
  }
  return void 0;
};
var parseConnectionString = (connectionString) => {
  const parsedConnectionString = tryParseConnectionString(connectionString);
  if (parsedConnectionString) {
    return parsedConnectionString;
  } else {
    throw new Error(`Invalid connection string ${connectionString}`);
  }
};

// node_modules/@azure/communication-common/dist-esm/src/credential/clientArguments.js
var isValidEndpoint = (host) => {
  var _a2;
  const url = new URL(host);
  return !!((_a2 = url.protocol) === null || _a2 === void 0 ? void 0 : _a2.match(/^http[s]?/)) && url.host !== void 0 && url.host !== "" && (url.pathname === void 0 || url.pathname === "" || url.pathname === "/");
};
var assertValidEndpoint = (host) => {
  if (!isValidEndpoint(host)) {
    throw new Error(`Invalid endpoint url ${host}`);
  }
};
var isKeyCredential = (credential) => {
  const castCredential = credential;
  return castCredential && typeof castCredential.key === "string" && castCredential.getToken === void 0;
};
var parseClientArguments = (connectionStringOrUrl, credentialOrOptions) => {
  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {
    assertValidEndpoint(connectionStringOrUrl);
    return { url: connectionStringOrUrl, credential: credentialOrOptions };
  } else {
    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);
    assertValidEndpoint(host);
    return { url: host, credential };
  }
};

// node_modules/@azure/communication-common/dist-esm/src/identifierModels.js
var isCommunicationUserIdentifier = (identifier) => {
  return typeof identifier.communicationUserId === "string";
};
var isPhoneNumberIdentifier = (identifier) => {
  return typeof identifier.phoneNumber === "string";
};
var isMicrosoftTeamsUserIdentifier = (identifier) => {
  return typeof identifier.microsoftTeamsUserId === "string";
};
var isUnknownIdentifier = (identifier) => {
  return typeof identifier.id === "string";
};
var getIdentifierKind = (identifier) => {
  if (isCommunicationUserIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), { kind: "communicationUser" });
  }
  if (isPhoneNumberIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), { kind: "phoneNumber" });
  }
  if (isMicrosoftTeamsUserIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), { kind: "microsoftTeamsUser" });
  }
  return Object.assign(Object.assign({}, identifier), { kind: "unknown" });
};

// node_modules/@azure/communication-common/dist-esm/src/identifierModelSerializer.js
init_tslib_es6();
var addRawIdIfExisting = (identifier, rawId) => {
  return rawId === void 0 ? identifier : Object.assign(Object.assign({}, identifier), { rawId });
};
var assertNotNullOrUndefined = (obj, prop) => {
  const subObjName = Object.keys(obj)[0];
  const subObj = obj[subObjName];
  if (prop in subObj) {
    return subObj[prop];
  }
  throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);
};
var assertMaximumOneNestedModel = (identifier) => {
  const { rawId: _rawId } = identifier, props = __rest(identifier, ["rawId"]);
  const keys = Object.keys(props);
  if (keys.length > 1) {
    throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);
  }
};
var serializeCommunicationIdentifier = (identifier) => {
  var _a2, _b2;
  const identifierKind = getIdentifierKind(identifier);
  switch (identifierKind.kind) {
    case "communicationUser":
      return { communicationUser: { id: identifierKind.communicationUserId } };
    case "phoneNumber":
      return addRawIdIfExisting({ phoneNumber: { value: identifierKind.phoneNumber } }, identifierKind.rawId);
    case "microsoftTeamsUser":
      return addRawIdIfExisting({
        microsoftTeamsUser: {
          userId: identifierKind.microsoftTeamsUserId,
          isAnonymous: (_a2 = identifierKind.isAnonymous) !== null && _a2 !== void 0 ? _a2 : false,
          cloud: (_b2 = identifierKind.cloud) !== null && _b2 !== void 0 ? _b2 : "public"
        }
      }, identifierKind.rawId);
    case "unknown":
      return { rawId: identifierKind.id };
    default:
      throw new Error(`Can't serialize an identifier with kind ${identifierKind.kind}`);
  }
};
var deserializeCommunicationIdentifier = (serializedIdentifier) => {
  assertMaximumOneNestedModel(serializedIdentifier);
  const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;
  if (communicationUser) {
    return {
      kind: "communicationUser",
      communicationUserId: assertNotNullOrUndefined({ communicationUser }, "id")
    };
  }
  if (phoneNumber) {
    return {
      kind: "phoneNumber",
      phoneNumber: assertNotNullOrUndefined({ phoneNumber }, "value"),
      rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, "rawId")
    };
  }
  if (microsoftTeamsUser) {
    return {
      kind: "microsoftTeamsUser",
      microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, "userId"),
      isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, "isAnonymous"),
      cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, "cloud"),
      rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, "rawId")
    };
  }
  return {
    kind: "unknown",
    id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, "rawId")
  };
};

export {
  AzureCommunicationTokenCredential,
  createCommunicationAccessKeyCredentialPolicy,
  createCommunicationAuthPolicy,
  parseConnectionString,
  isKeyCredential,
  parseClientArguments,
  isCommunicationUserIdentifier,
  isPhoneNumberIdentifier,
  isMicrosoftTeamsUserIdentifier,
  isUnknownIdentifier,
  getIdentifierKind,
  serializeCommunicationIdentifier,
  deserializeCommunicationIdentifier
};
//# sourceMappingURL=chunk-PQW65CPG.js.map
