import {
  require_react_dom
} from "./chunk-ZB6NVROP.js";
import {
  require_react
} from "./chunk-BCT7PDEY.js";
import {
  BatchResponse,
  BetaGraph,
  CacheService,
  CacheStore,
  ComponentMediaQuery,
  EventDispatcher,
  Graph,
  GraphPageIterator,
  IProvider,
  LocalizationHelper,
  LoginType,
  MICROSOFT_GRAPH_DEFAULT_ENDPOINT,
  MICROSOFT_GRAPH_ENDPOINTS,
  MgtBaseComponent,
  MgtBaseProvider,
  MgtTemplatedComponent,
  MockProvider,
  PACKAGE_VERSION,
  ProviderState,
  Providers,
  ProvidersChangedState,
  ResponseType,
  SimpleProvider,
  TeamsHelper,
  TemplateHelper,
  _$LH,
  arraysAreEqual,
  chainMiddleware,
  createFromProvider,
  css,
  customElement,
  customElementHelper,
  equals,
  html,
  init_browser,
  init_decorators,
  init_es6,
  init_lit,
  init_lit_html,
  mgtHtml,
  noChange,
  prepScopes,
  property,
  state,
  validateBaseURL
} from "./chunk-56JPRE6S.js";
import {
  __decorate,
  init_tslib_es6
} from "./chunk-VCF74VKF.js";
import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __toESM
} from "./chunk-JZQ37OGZ.js";

// node_modules/@microsoft/fast-element/dist/esm/platform.js
function createMetadataLocator() {
  const metadataLookup = /* @__PURE__ */ new WeakMap();
  return function(target2) {
    let metadata = metadataLookup.get(target2);
    if (metadata === void 0) {
      let currentTarget = Reflect.getPrototypeOf(target2);
      while (metadata === void 0 && currentTarget !== null) {
        metadata = metadataLookup.get(currentTarget);
        currentTarget = Reflect.getPrototypeOf(currentTarget);
      }
      metadata = metadata === void 0 ? [] : metadata.slice(0);
      metadataLookup.set(target2, metadata);
    }
    return metadata;
  };
}
var $global, propConfig, FAST, emptyArray;
var init_platform = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/platform.js"() {
    $global = function() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      try {
        return new Function("return this")();
      } catch (_a2) {
        return {};
      }
    }();
    if ($global.trustedTypes === void 0) {
      $global.trustedTypes = { createPolicy: (n, r) => r };
    }
    propConfig = {
      configurable: false,
      enumerable: false,
      writable: false
    };
    if ($global.FAST === void 0) {
      Reflect.defineProperty($global, "FAST", Object.assign({ value: /* @__PURE__ */ Object.create(null) }, propConfig));
    }
    FAST = $global.FAST;
    if (FAST.getById === void 0) {
      const storage = /* @__PURE__ */ Object.create(null);
      Reflect.defineProperty(FAST, "getById", Object.assign({ value(id, initialize) {
        let found = storage[id];
        if (found === void 0) {
          found = initialize ? storage[id] = initialize() : null;
        }
        return found;
      } }, propConfig));
    }
    emptyArray = Object.freeze([]);
  }
});

// node_modules/@microsoft/fast-element/dist/esm/dom.js
var updateQueue, fastHTMLPolicy, htmlPolicy, marker, _interpolationStart, _interpolationEnd, DOM;
var init_dom = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/dom.js"() {
    init_platform();
    updateQueue = $global.FAST.getById(1, () => {
      const tasks = [];
      const pendingErrors = [];
      function throwFirstError() {
        if (pendingErrors.length) {
          throw pendingErrors.shift();
        }
      }
      function tryRunTask(task) {
        try {
          task.call();
        } catch (error) {
          pendingErrors.push(error);
          setTimeout(throwFirstError, 0);
        }
      }
      function process() {
        const capacity = 1024;
        let index = 0;
        while (index < tasks.length) {
          tryRunTask(tasks[index]);
          index++;
          if (index > capacity) {
            for (let scan = 0, newLength = tasks.length - index; scan < newLength; scan++) {
              tasks[scan] = tasks[scan + index];
            }
            tasks.length -= index;
            index = 0;
          }
        }
        tasks.length = 0;
      }
      function enqueue(callable) {
        if (tasks.length < 1) {
          $global.requestAnimationFrame(process);
        }
        tasks.push(callable);
      }
      return Object.freeze({
        enqueue,
        process
      });
    });
    fastHTMLPolicy = $global.trustedTypes.createPolicy("fast-html", {
      createHTML: (html3) => html3
    });
    htmlPolicy = fastHTMLPolicy;
    marker = `fast-${Math.random().toString(36).substring(2, 8)}`;
    _interpolationStart = `${marker}{`;
    _interpolationEnd = `}${marker}`;
    DOM = Object.freeze({
      /**
       * Indicates whether the DOM supports the adoptedStyleSheets feature.
       */
      supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) && "replace" in CSSStyleSheet.prototype,
      /**
       * Sets the HTML trusted types policy used by the templating engine.
       * @param policy - The policy to set for HTML.
       * @remarks
       * This API can only be called once, for security reasons. It should be
       * called by the application developer at the start of their program.
       */
      setHTMLPolicy(policy) {
        if (htmlPolicy !== fastHTMLPolicy) {
          throw new Error("The HTML policy can only be set once.");
        }
        htmlPolicy = policy;
      },
      /**
       * Turns a string into trusted HTML using the configured trusted types policy.
       * @param html - The string to turn into trusted HTML.
       * @remarks
       * Used internally by the template engine when creating templates
       * and setting innerHTML.
       */
      createHTML(html3) {
        return htmlPolicy.createHTML(html3);
      },
      /**
       * Determines if the provided node is a template marker used by the runtime.
       * @param node - The node to test.
       */
      isMarker(node) {
        return node && node.nodeType === 8 && node.data.startsWith(marker);
      },
      /**
       * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.
       * @param node - The marker node to extract the index from.
       */
      extractDirectiveIndexFromMarker(node) {
        return parseInt(node.data.replace(`${marker}:`, ""));
      },
      /**
       * Creates a placeholder string suitable for marking out a location *within*
       * an attribute value or HTML content.
       * @param index - The directive index to create the placeholder for.
       * @remarks
       * Used internally by binding directives.
       */
      createInterpolationPlaceholder(index) {
        return `${_interpolationStart}${index}${_interpolationEnd}`;
      },
      /**
       * Creates a placeholder that manifests itself as an attribute on an
       * element.
       * @param attributeName - The name of the custom attribute.
       * @param index - The directive index to create the placeholder for.
       * @remarks
       * Used internally by attribute directives such as `ref`, `slotted`, and `children`.
       */
      createCustomAttributePlaceholder(attributeName, index) {
        return `${attributeName}="${this.createInterpolationPlaceholder(index)}"`;
      },
      /**
       * Creates a placeholder that manifests itself as a marker within the DOM structure.
       * @param index - The directive index to create the placeholder for.
       * @remarks
       * Used internally by structural directives such as `repeat`.
       */
      createBlockPlaceholder(index) {
        return `<!--${marker}:${index}-->`;
      },
      /**
       * Schedules DOM update work in the next async batch.
       * @param callable - The callable function or object to queue.
       */
      queueUpdate: updateQueue.enqueue,
      /**
       * Immediately processes all work previously scheduled
       * through queueUpdate.
       * @remarks
       * This also forces nextUpdate promises
       * to resolve.
       */
      processUpdates: updateQueue.process,
      /**
       * Resolves with the next DOM update.
       */
      nextUpdate() {
        return new Promise(updateQueue.enqueue);
      },
      /**
       * Sets an attribute value on an element.
       * @param element - The element to set the attribute value on.
       * @param attributeName - The attribute name to set.
       * @param value - The value of the attribute to set.
       * @remarks
       * If the value is `null` or `undefined`, the attribute is removed, otherwise
       * it is set to the provided value using the standard `setAttribute` API.
       */
      setAttribute(element, attributeName, value) {
        if (value === null || value === void 0) {
          element.removeAttribute(attributeName);
        } else {
          element.setAttribute(attributeName, value);
        }
      },
      /**
       * Sets a boolean attribute value.
       * @param element - The element to set the boolean attribute value on.
       * @param attributeName - The attribute name to set.
       * @param value - The value of the attribute to set.
       * @remarks
       * If the value is true, the attribute is added; otherwise it is removed.
       */
      setBooleanAttribute(element, attributeName, value) {
        value ? element.setAttribute(attributeName, "") : element.removeAttribute(attributeName);
      },
      /**
       * Removes all the child nodes of the provided parent node.
       * @param parent - The node to remove the children from.
       */
      removeChildNodes(parent) {
        for (let child = parent.firstChild; child !== null; child = parent.firstChild) {
          parent.removeChild(child);
        }
      },
      /**
       * Creates a TreeWalker configured to walk a template fragment.
       * @param fragment - The fragment to walk.
       */
      createTemplateWalker(fragment) {
        return document.createTreeWalker(
          fragment,
          133,
          // element, text, comment
          null,
          false
        );
      }
    });
  }
});

// node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js
var SubscriberSet, PropertyChangeNotifier;
var init_notifier = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js"() {
    SubscriberSet = class {
      /**
       * Creates an instance of SubscriberSet for the specified source.
       * @param source - The object source that subscribers will receive notifications from.
       * @param initialSubscriber - An initial subscriber to changes.
       */
      constructor(source, initialSubscriber) {
        this.sub1 = void 0;
        this.sub2 = void 0;
        this.spillover = void 0;
        this.source = source;
        this.sub1 = initialSubscriber;
      }
      /**
       * Checks whether the provided subscriber has been added to this set.
       * @param subscriber - The subscriber to test for inclusion in this set.
       */
      has(subscriber) {
        return this.spillover === void 0 ? this.sub1 === subscriber || this.sub2 === subscriber : this.spillover.indexOf(subscriber) !== -1;
      }
      /**
       * Subscribes to notification of changes in an object's state.
       * @param subscriber - The object that is subscribing for change notification.
       */
      subscribe(subscriber) {
        const spillover = this.spillover;
        if (spillover === void 0) {
          if (this.has(subscriber)) {
            return;
          }
          if (this.sub1 === void 0) {
            this.sub1 = subscriber;
            return;
          }
          if (this.sub2 === void 0) {
            this.sub2 = subscriber;
            return;
          }
          this.spillover = [this.sub1, this.sub2, subscriber];
          this.sub1 = void 0;
          this.sub2 = void 0;
        } else {
          const index = spillover.indexOf(subscriber);
          if (index === -1) {
            spillover.push(subscriber);
          }
        }
      }
      /**
       * Unsubscribes from notification of changes in an object's state.
       * @param subscriber - The object that is unsubscribing from change notification.
       */
      unsubscribe(subscriber) {
        const spillover = this.spillover;
        if (spillover === void 0) {
          if (this.sub1 === subscriber) {
            this.sub1 = void 0;
          } else if (this.sub2 === subscriber) {
            this.sub2 = void 0;
          }
        } else {
          const index = spillover.indexOf(subscriber);
          if (index !== -1) {
            spillover.splice(index, 1);
          }
        }
      }
      /**
       * Notifies all subscribers.
       * @param args - Data passed along to subscribers during notification.
       */
      notify(args) {
        const spillover = this.spillover;
        const source = this.source;
        if (spillover === void 0) {
          const sub1 = this.sub1;
          const sub2 = this.sub2;
          if (sub1 !== void 0) {
            sub1.handleChange(source, args);
          }
          if (sub2 !== void 0) {
            sub2.handleChange(source, args);
          }
        } else {
          for (let i = 0, ii = spillover.length; i < ii; ++i) {
            spillover[i].handleChange(source, args);
          }
        }
      }
    };
    PropertyChangeNotifier = class {
      /**
       * Creates an instance of PropertyChangeNotifier for the specified source.
       * @param source - The object source that subscribers will receive notifications from.
       */
      constructor(source) {
        this.subscribers = {};
        this.sourceSubscribers = null;
        this.source = source;
      }
      /**
       * Notifies all subscribers, based on the specified property.
       * @param propertyName - The property name, passed along to subscribers during notification.
       */
      notify(propertyName) {
        var _a2;
        const subscribers = this.subscribers[propertyName];
        if (subscribers !== void 0) {
          subscribers.notify(propertyName);
        }
        (_a2 = this.sourceSubscribers) === null || _a2 === void 0 ? void 0 : _a2.notify(propertyName);
      }
      /**
       * Subscribes to notification of changes in an object's state.
       * @param subscriber - The object that is subscribing for change notification.
       * @param propertyToWatch - The name of the property that the subscriber is interested in watching for changes.
       */
      subscribe(subscriber, propertyToWatch) {
        var _a2;
        if (propertyToWatch) {
          let subscribers = this.subscribers[propertyToWatch];
          if (subscribers === void 0) {
            this.subscribers[propertyToWatch] = subscribers = new SubscriberSet(this.source);
          }
          subscribers.subscribe(subscriber);
        } else {
          this.sourceSubscribers = (_a2 = this.sourceSubscribers) !== null && _a2 !== void 0 ? _a2 : new SubscriberSet(this.source);
          this.sourceSubscribers.subscribe(subscriber);
        }
      }
      /**
       * Unsubscribes from notification of changes in an object's state.
       * @param subscriber - The object that is unsubscribing from change notification.
       * @param propertyToUnwatch - The name of the property that the subscriber is no longer interested in watching.
       */
      unsubscribe(subscriber, propertyToUnwatch) {
        var _a2;
        if (propertyToUnwatch) {
          const subscribers = this.subscribers[propertyToUnwatch];
          if (subscribers !== void 0) {
            subscribers.unsubscribe(subscriber);
          }
        } else {
          (_a2 = this.sourceSubscribers) === null || _a2 === void 0 ? void 0 : _a2.unsubscribe(subscriber);
        }
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/observation/observable.js
function observable(target2, nameOrAccessor) {
  Observable.defineProperty(target2, nameOrAccessor);
}
function volatile(target2, name, descriptor) {
  return Object.assign({}, descriptor, {
    get: function() {
      Observable.trackVolatile();
      return descriptor.get.apply(this);
    }
  });
}
var Observable, contextEvent, ExecutionContext, defaultExecutionContext;
var init_observable = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/observation/observable.js"() {
    init_dom();
    init_platform();
    init_notifier();
    Observable = FAST.getById(2, () => {
      const volatileRegex = /(:|&&|\|\||if)/;
      const notifierLookup = /* @__PURE__ */ new WeakMap();
      const queueUpdate = DOM.queueUpdate;
      let watcher = void 0;
      let createArrayObserver = (array) => {
        throw new Error("Must call enableArrayObservation before observing arrays.");
      };
      function getNotifier(source) {
        let found = source.$fastController || notifierLookup.get(source);
        if (found === void 0) {
          if (Array.isArray(source)) {
            found = createArrayObserver(source);
          } else {
            notifierLookup.set(source, found = new PropertyChangeNotifier(source));
          }
        }
        return found;
      }
      const getAccessors = createMetadataLocator();
      class DefaultObservableAccessor {
        constructor(name) {
          this.name = name;
          this.field = `_${name}`;
          this.callback = `${name}Changed`;
        }
        getValue(source) {
          if (watcher !== void 0) {
            watcher.watch(source, this.name);
          }
          return source[this.field];
        }
        setValue(source, newValue) {
          const field = this.field;
          const oldValue = source[field];
          if (oldValue !== newValue) {
            source[field] = newValue;
            const callback = source[this.callback];
            if (typeof callback === "function") {
              callback.call(source, oldValue, newValue);
            }
            getNotifier(source).notify(this.name);
          }
        }
      }
      class BindingObserverImplementation extends SubscriberSet {
        constructor(binding, initialSubscriber, isVolatileBinding = false) {
          super(binding, initialSubscriber);
          this.binding = binding;
          this.isVolatileBinding = isVolatileBinding;
          this.needsRefresh = true;
          this.needsQueue = true;
          this.first = this;
          this.last = null;
          this.propertySource = void 0;
          this.propertyName = void 0;
          this.notifier = void 0;
          this.next = void 0;
        }
        observe(source, context) {
          if (this.needsRefresh && this.last !== null) {
            this.disconnect();
          }
          const previousWatcher = watcher;
          watcher = this.needsRefresh ? this : void 0;
          this.needsRefresh = this.isVolatileBinding;
          const result = this.binding(source, context);
          watcher = previousWatcher;
          return result;
        }
        disconnect() {
          if (this.last !== null) {
            let current = this.first;
            while (current !== void 0) {
              current.notifier.unsubscribe(this, current.propertyName);
              current = current.next;
            }
            this.last = null;
            this.needsRefresh = this.needsQueue = true;
          }
        }
        watch(propertySource, propertyName) {
          const prev = this.last;
          const notifier = getNotifier(propertySource);
          const current = prev === null ? this.first : {};
          current.propertySource = propertySource;
          current.propertyName = propertyName;
          current.notifier = notifier;
          notifier.subscribe(this, propertyName);
          if (prev !== null) {
            if (!this.needsRefresh) {
              let prevValue;
              watcher = void 0;
              prevValue = prev.propertySource[prev.propertyName];
              watcher = this;
              if (propertySource === prevValue) {
                this.needsRefresh = true;
              }
            }
            prev.next = current;
          }
          this.last = current;
        }
        handleChange() {
          if (this.needsQueue) {
            this.needsQueue = false;
            queueUpdate(this);
          }
        }
        call() {
          if (this.last !== null) {
            this.needsQueue = true;
            this.notify(this);
          }
        }
        records() {
          let next = this.first;
          return {
            next: () => {
              const current = next;
              if (current === void 0) {
                return { value: void 0, done: true };
              } else {
                next = next.next;
                return {
                  value: current,
                  done: false
                };
              }
            },
            [Symbol.iterator]: function() {
              return this;
            }
          };
        }
      }
      return Object.freeze({
        /**
         * @internal
         * @param factory - The factory used to create array observers.
         */
        setArrayObserverFactory(factory) {
          createArrayObserver = factory;
        },
        /**
         * Gets a notifier for an object or Array.
         * @param source - The object or Array to get the notifier for.
         */
        getNotifier,
        /**
         * Records a property change for a source object.
         * @param source - The object to record the change against.
         * @param propertyName - The property to track as changed.
         */
        track(source, propertyName) {
          if (watcher !== void 0) {
            watcher.watch(source, propertyName);
          }
        },
        /**
         * Notifies watchers that the currently executing property getter or function is volatile
         * with respect to its observable dependencies.
         */
        trackVolatile() {
          if (watcher !== void 0) {
            watcher.needsRefresh = true;
          }
        },
        /**
         * Notifies subscribers of a source object of changes.
         * @param source - the object to notify of changes.
         * @param args - The change args to pass to subscribers.
         */
        notify(source, args) {
          getNotifier(source).notify(args);
        },
        /**
         * Defines an observable property on an object or prototype.
         * @param target - The target object to define the observable on.
         * @param nameOrAccessor - The name of the property to define as observable;
         * or a custom accessor that specifies the property name and accessor implementation.
         */
        defineProperty(target2, nameOrAccessor) {
          if (typeof nameOrAccessor === "string") {
            nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);
          }
          getAccessors(target2).push(nameOrAccessor);
          Reflect.defineProperty(target2, nameOrAccessor.name, {
            enumerable: true,
            get: function() {
              return nameOrAccessor.getValue(this);
            },
            set: function(newValue) {
              nameOrAccessor.setValue(this, newValue);
            }
          });
        },
        /**
         * Finds all the observable accessors defined on the target,
         * including its prototype chain.
         * @param target - The target object to search for accessor on.
         */
        getAccessors,
        /**
         * Creates a {@link BindingObserver} that can watch the
         * provided {@link Binding} for changes.
         * @param binding - The binding to observe.
         * @param initialSubscriber - An initial subscriber to changes in the binding value.
         * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.
         */
        binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {
          return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);
        },
        /**
         * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated
         * on every evaluation of the value.
         * @param binding - The binding to inspect.
         */
        isVolatileBinding(binding) {
          return volatileRegex.test(binding.toString());
        }
      });
    });
    contextEvent = FAST.getById(3, () => {
      let current = null;
      return {
        get() {
          return current;
        },
        set(event) {
          current = event;
        }
      };
    });
    ExecutionContext = class {
      constructor() {
        this.index = 0;
        this.length = 0;
        this.parent = null;
        this.parentContext = null;
      }
      /**
       * The current event within an event handler.
       */
      get event() {
        return contextEvent.get();
      }
      /**
       * Indicates whether the current item within a repeat context
       * has an even index.
       */
      get isEven() {
        return this.index % 2 === 0;
      }
      /**
       * Indicates whether the current item within a repeat context
       * has an odd index.
       */
      get isOdd() {
        return this.index % 2 !== 0;
      }
      /**
       * Indicates whether the current item within a repeat context
       * is the first item in the collection.
       */
      get isFirst() {
        return this.index === 0;
      }
      /**
       * Indicates whether the current item within a repeat context
       * is somewhere in the middle of the collection.
       */
      get isInMiddle() {
        return !this.isFirst && !this.isLast;
      }
      /**
       * Indicates whether the current item within a repeat context
       * is the last item in the collection.
       */
      get isLast() {
        return this.index === this.length - 1;
      }
      /**
       * Sets the event for the current execution context.
       * @param event - The event to set.
       * @internal
       */
      static setEvent(event) {
        contextEvent.set(event);
      }
    };
    Observable.defineProperty(ExecutionContext.prototype, "index");
    Observable.defineProperty(ExecutionContext.prototype, "length");
    defaultExecutionContext = Object.seal(new ExecutionContext());
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js
var HTMLDirective, TargetedHTMLDirective, AttachedBehaviorHTMLDirective;
var init_html_directive = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js"() {
    init_dom();
    HTMLDirective = class {
      constructor() {
        this.targetIndex = 0;
      }
    };
    TargetedHTMLDirective = class extends HTMLDirective {
      constructor() {
        super(...arguments);
        this.createPlaceholder = DOM.createInterpolationPlaceholder;
      }
    };
    AttachedBehaviorHTMLDirective = class extends HTMLDirective {
      /**
       *
       * @param name - The name of the behavior; used as a custom attribute on the element.
       * @param behavior - The behavior to instantiate and attach to the element.
       * @param options - Options to pass to the behavior during creation.
       */
      constructor(name, behavior, options) {
        super();
        this.name = name;
        this.behavior = behavior;
        this.options = options;
      }
      /**
       * Creates a placeholder string based on the directive's index within the template.
       * @param index - The index of the directive within the template.
       * @remarks
       * Creates a custom attribute placeholder.
       */
      createPlaceholder(index) {
        return DOM.createCustomAttributePlaceholder(this.name, index);
      }
      /**
       * Creates a behavior for the provided target node.
       * @param target - The node instance to create the behavior for.
       * @remarks
       * Creates an instance of the `behavior` type this directive was constructed with
       * and passes the target and options to that `behavior`'s constructor.
       */
      createBehavior(target2) {
        return new this.behavior(target2, this.options);
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/binding.js
function normalBind(source, context) {
  this.source = source;
  this.context = context;
  if (this.bindingObserver === null) {
    this.bindingObserver = Observable.binding(this.binding, this, this.isBindingVolatile);
  }
  this.updateTarget(this.bindingObserver.observe(source, context));
}
function triggerBind(source, context) {
  this.source = source;
  this.context = context;
  this.target.addEventListener(this.targetName, this);
}
function normalUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
}
function contentUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
  const view = this.target.$fastView;
  if (view !== void 0 && view.isComposed) {
    view.unbind();
    view.needsBindOnly = true;
  }
}
function triggerUnbind() {
  this.target.removeEventListener(this.targetName, this);
  this.source = null;
  this.context = null;
}
function updateAttributeTarget(value) {
  DOM.setAttribute(this.target, this.targetName, value);
}
function updateBooleanAttributeTarget(value) {
  DOM.setBooleanAttribute(this.target, this.targetName, value);
}
function updateContentTarget(value) {
  if (value === null || value === void 0) {
    value = "";
  }
  if (value.create) {
    this.target.textContent = "";
    let view = this.target.$fastView;
    if (view === void 0) {
      view = value.create();
    } else {
      if (this.target.$fastTemplate !== value) {
        if (view.isComposed) {
          view.remove();
          view.unbind();
        }
        view = value.create();
      }
    }
    if (!view.isComposed) {
      view.isComposed = true;
      view.bind(this.source, this.context);
      view.insertBefore(this.target);
      this.target.$fastView = view;
      this.target.$fastTemplate = value;
    } else if (view.needsBindOnly) {
      view.needsBindOnly = false;
      view.bind(this.source, this.context);
    }
  } else {
    const view = this.target.$fastView;
    if (view !== void 0 && view.isComposed) {
      view.isComposed = false;
      view.remove();
      if (view.needsBindOnly) {
        view.needsBindOnly = false;
      } else {
        view.unbind();
      }
    }
    this.target.textContent = value;
  }
}
function updatePropertyTarget(value) {
  this.target[this.targetName] = value;
}
function updateClassTarget(value) {
  const classVersions = this.classVersions || /* @__PURE__ */ Object.create(null);
  const target2 = this.target;
  let version = this.version || 0;
  if (value !== null && value !== void 0 && value.length) {
    const names = value.split(/\s+/);
    for (let i = 0, ii = names.length; i < ii; ++i) {
      const currentName = names[i];
      if (currentName === "") {
        continue;
      }
      classVersions[currentName] = version;
      target2.classList.add(currentName);
    }
  }
  this.classVersions = classVersions;
  this.version = version + 1;
  if (version === 0) {
    return;
  }
  version -= 1;
  for (const name in classVersions) {
    if (classVersions[name] === version) {
      target2.classList.remove(name);
    }
  }
}
var HTMLBindingDirective, BindingBehavior;
var init_binding = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/binding.js"() {
    init_dom();
    init_observable();
    init_html_directive();
    HTMLBindingDirective = class extends TargetedHTMLDirective {
      /**
       * Creates an instance of BindingDirective.
       * @param binding - A binding that returns the data used to update the DOM.
       */
      constructor(binding) {
        super();
        this.binding = binding;
        this.bind = normalBind;
        this.unbind = normalUnbind;
        this.updateTarget = updateAttributeTarget;
        this.isBindingVolatile = Observable.isVolatileBinding(this.binding);
      }
      /**
       * Gets/sets the name of the attribute or property that this
       * binding is targeting.
       */
      get targetName() {
        return this.originalTargetName;
      }
      set targetName(value) {
        this.originalTargetName = value;
        if (value === void 0) {
          return;
        }
        switch (value[0]) {
          case ":":
            this.cleanedTargetName = value.substr(1);
            this.updateTarget = updatePropertyTarget;
            if (this.cleanedTargetName === "innerHTML") {
              const binding = this.binding;
              this.binding = (s, c) => DOM.createHTML(binding(s, c));
            }
            break;
          case "?":
            this.cleanedTargetName = value.substr(1);
            this.updateTarget = updateBooleanAttributeTarget;
            break;
          case "@":
            this.cleanedTargetName = value.substr(1);
            this.bind = triggerBind;
            this.unbind = triggerUnbind;
            break;
          default:
            this.cleanedTargetName = value;
            if (value === "class") {
              this.updateTarget = updateClassTarget;
            }
            break;
        }
      }
      /**
       * Makes this binding target the content of an element rather than
       * a particular attribute or property.
       */
      targetAtContent() {
        this.updateTarget = updateContentTarget;
        this.unbind = contentUnbind;
      }
      /**
       * Creates the runtime BindingBehavior instance based on the configuration
       * information stored in the BindingDirective.
       * @param target - The target node that the binding behavior should attach to.
       */
      createBehavior(target2) {
        return new BindingBehavior(target2, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);
      }
    };
    BindingBehavior = class {
      /**
       * Creates an instance of BindingBehavior.
       * @param target - The target of the data updates.
       * @param binding - The binding that returns the latest value for an update.
       * @param isBindingVolatile - Indicates whether the binding has volatile dependencies.
       * @param bind - The operation to perform during binding.
       * @param unbind - The operation to perform during unbinding.
       * @param updateTarget - The operation to perform when updating.
       * @param targetName - The name of the target attribute or property to update.
       */
      constructor(target2, binding, isBindingVolatile, bind, unbind, updateTarget, targetName) {
        this.source = null;
        this.context = null;
        this.bindingObserver = null;
        this.target = target2;
        this.binding = binding;
        this.isBindingVolatile = isBindingVolatile;
        this.bind = bind;
        this.unbind = unbind;
        this.updateTarget = updateTarget;
        this.targetName = targetName;
      }
      /** @internal */
      handleChange() {
        this.updateTarget(this.bindingObserver.observe(this.source, this.context));
      }
      /** @internal */
      handleEvent(event) {
        ExecutionContext.setEvent(event);
        const result = this.binding(this.source, this.context);
        ExecutionContext.setEvent(null);
        if (result !== true) {
          event.preventDefault();
        }
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js
function createAggregateBinding(parts) {
  if (parts.length === 1) {
    return parts[0];
  }
  let targetName;
  const partCount = parts.length;
  const finalParts = parts.map((x) => {
    if (typeof x === "string") {
      return () => x;
    }
    targetName = x.targetName || targetName;
    return x.binding;
  });
  const binding = (scope, context) => {
    let output = "";
    for (let i = 0; i < partCount; ++i) {
      output += finalParts[i](scope, context);
    }
    return output;
  };
  const directive2 = new HTMLBindingDirective(binding);
  directive2.targetName = targetName;
  return directive2;
}
function parseContent(context, value) {
  const valueParts = value.split(_interpolationStart);
  if (valueParts.length === 1) {
    return null;
  }
  const bindingParts = [];
  for (let i = 0, ii = valueParts.length; i < ii; ++i) {
    const current = valueParts[i];
    const index = current.indexOf(_interpolationEnd);
    let literal;
    if (index === -1) {
      literal = current;
    } else {
      const directiveIndex = parseInt(current.substring(0, index));
      bindingParts.push(context.directives[directiveIndex]);
      literal = current.substring(index + interpolationEndLength);
    }
    if (literal !== "") {
      bindingParts.push(literal);
    }
  }
  return bindingParts;
}
function compileAttributes(context, node, includeBasicValues = false) {
  const attributes = node.attributes;
  for (let i = 0, ii = attributes.length; i < ii; ++i) {
    const attr2 = attributes[i];
    const attrValue = attr2.value;
    const parseResult = parseContent(context, attrValue);
    let result = null;
    if (parseResult === null) {
      if (includeBasicValues) {
        result = new HTMLBindingDirective(() => attrValue);
        result.targetName = attr2.name;
      }
    } else {
      result = createAggregateBinding(parseResult);
    }
    if (result !== null) {
      node.removeAttributeNode(attr2);
      i--;
      ii--;
      context.addFactory(result);
    }
  }
}
function compileContent(context, node, walker) {
  const parseResult = parseContent(context, node.textContent);
  if (parseResult !== null) {
    let lastNode = node;
    for (let i = 0, ii = parseResult.length; i < ii; ++i) {
      const currentPart = parseResult[i];
      const currentNode = i === 0 ? node : lastNode.parentNode.insertBefore(document.createTextNode(""), lastNode.nextSibling);
      if (typeof currentPart === "string") {
        currentNode.textContent = currentPart;
      } else {
        currentNode.textContent = " ";
        context.captureContentBinding(currentPart);
      }
      lastNode = currentNode;
      context.targetIndex++;
      if (currentNode !== node) {
        walker.nextNode();
      }
    }
    context.targetIndex--;
  }
}
function compileTemplate(template, directives) {
  const fragment = template.content;
  document.adoptNode(fragment);
  const context = CompilationContext.borrow(directives);
  compileAttributes(context, template, true);
  const hostBehaviorFactories = context.behaviorFactories;
  context.reset();
  const walker = DOM.createTemplateWalker(fragment);
  let node;
  while (node = walker.nextNode()) {
    context.targetIndex++;
    switch (node.nodeType) {
      case 1:
        compileAttributes(context, node);
        break;
      case 3:
        compileContent(context, node, walker);
        break;
      case 8:
        if (DOM.isMarker(node)) {
          context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);
        }
    }
  }
  let targetOffset = 0;
  if (
    // If the first node in a fragment is a marker, that means it's an unstable first node,
    // because something like a when, repeat, etc. could add nodes before the marker.
    // To mitigate this, we insert a stable first node. However, if we insert a node,
    // that will alter the result of the TreeWalker. So, we also need to offset the target index.
    DOM.isMarker(fragment.firstChild) || // Or if there is only one node and a directive, it means the template's content
    // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by
    // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.
    fragment.childNodes.length === 1 && directives.length
  ) {
    fragment.insertBefore(document.createComment(""), fragment.firstChild);
    targetOffset = -1;
  }
  const viewBehaviorFactories = context.behaviorFactories;
  context.release();
  return {
    fragment,
    viewBehaviorFactories,
    hostBehaviorFactories,
    targetOffset
  };
}
var sharedContext, CompilationContext, interpolationEndLength;
var init_compiler = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js"() {
    init_dom();
    init_binding();
    sharedContext = null;
    CompilationContext = class {
      addFactory(factory) {
        factory.targetIndex = this.targetIndex;
        this.behaviorFactories.push(factory);
      }
      captureContentBinding(directive2) {
        directive2.targetAtContent();
        this.addFactory(directive2);
      }
      reset() {
        this.behaviorFactories = [];
        this.targetIndex = -1;
      }
      release() {
        sharedContext = this;
      }
      static borrow(directives) {
        const shareable = sharedContext || new CompilationContext();
        shareable.directives = directives;
        shareable.reset();
        sharedContext = null;
        return shareable;
      }
    };
    interpolationEndLength = _interpolationEnd.length;
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/view.js
var range, HTMLView;
var init_view = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/view.js"() {
    range = document.createRange();
    HTMLView = class {
      /**
       * Constructs an instance of HTMLView.
       * @param fragment - The html fragment that contains the nodes for this view.
       * @param behaviors - The behaviors to be applied to this view.
       */
      constructor(fragment, behaviors) {
        this.fragment = fragment;
        this.behaviors = behaviors;
        this.source = null;
        this.context = null;
        this.firstChild = fragment.firstChild;
        this.lastChild = fragment.lastChild;
      }
      /**
       * Appends the view's DOM nodes to the referenced node.
       * @param node - The parent node to append the view's DOM nodes to.
       */
      appendTo(node) {
        node.appendChild(this.fragment);
      }
      /**
       * Inserts the view's DOM nodes before the referenced node.
       * @param node - The node to insert the view's DOM before.
       */
      insertBefore(node) {
        if (this.fragment.hasChildNodes()) {
          node.parentNode.insertBefore(this.fragment, node);
        } else {
          const end = this.lastChild;
          if (node.previousSibling === end)
            return;
          const parentNode = node.parentNode;
          let current = this.firstChild;
          let next;
          while (current !== end) {
            next = current.nextSibling;
            parentNode.insertBefore(current, node);
            current = next;
          }
          parentNode.insertBefore(end, node);
        }
      }
      /**
       * Removes the view's DOM nodes.
       * The nodes are not disposed and the view can later be re-inserted.
       */
      remove() {
        const fragment = this.fragment;
        const end = this.lastChild;
        let current = this.firstChild;
        let next;
        while (current !== end) {
          next = current.nextSibling;
          fragment.appendChild(current);
          current = next;
        }
        fragment.appendChild(end);
      }
      /**
       * Removes the view and unbinds its behaviors, disposing of DOM nodes afterward.
       * Once a view has been disposed, it cannot be inserted or bound again.
       */
      dispose() {
        const parent = this.firstChild.parentNode;
        const end = this.lastChild;
        let current = this.firstChild;
        let next;
        while (current !== end) {
          next = current.nextSibling;
          parent.removeChild(current);
          current = next;
        }
        parent.removeChild(end);
        const behaviors = this.behaviors;
        const oldSource = this.source;
        for (let i = 0, ii = behaviors.length; i < ii; ++i) {
          behaviors[i].unbind(oldSource);
        }
      }
      /**
       * Binds a view's behaviors to its binding source.
       * @param source - The binding source for the view's binding behaviors.
       * @param context - The execution context to run the behaviors within.
       */
      bind(source, context) {
        const behaviors = this.behaviors;
        if (this.source === source) {
          return;
        } else if (this.source !== null) {
          const oldSource = this.source;
          this.source = source;
          this.context = context;
          for (let i = 0, ii = behaviors.length; i < ii; ++i) {
            const current = behaviors[i];
            current.unbind(oldSource);
            current.bind(source, context);
          }
        } else {
          this.source = source;
          this.context = context;
          for (let i = 0, ii = behaviors.length; i < ii; ++i) {
            behaviors[i].bind(source, context);
          }
        }
      }
      /**
       * Unbinds a view's behaviors from its binding source.
       */
      unbind() {
        if (this.source === null) {
          return;
        }
        const behaviors = this.behaviors;
        const oldSource = this.source;
        for (let i = 0, ii = behaviors.length; i < ii; ++i) {
          behaviors[i].unbind(oldSource);
        }
        this.source = null;
      }
      /**
       * Efficiently disposes of a contiguous range of synthetic view instances.
       * @param views - A contiguous range of views to be disposed.
       */
      static disposeContiguousBatch(views) {
        if (views.length === 0) {
          return;
        }
        range.setStartBefore(views[0].firstChild);
        range.setEndAfter(views[views.length - 1].lastChild);
        range.deleteContents();
        for (let i = 0, ii = views.length; i < ii; ++i) {
          const view = views[i];
          const behaviors = view.behaviors;
          const oldSource = view.source;
          for (let j = 0, jj = behaviors.length; j < jj; ++j) {
            behaviors[j].unbind(oldSource);
          }
        }
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/template.js
function html2(strings18, ...values) {
  const directives = [];
  let html3 = "";
  for (let i = 0, ii = strings18.length - 1; i < ii; ++i) {
    const currentString = strings18[i];
    let value = values[i];
    html3 += currentString;
    if (value instanceof ViewTemplate) {
      const template = value;
      value = () => template;
    }
    if (typeof value === "function") {
      value = new HTMLBindingDirective(value);
    }
    if (value instanceof TargetedHTMLDirective) {
      const match = lastAttributeNameRegex.exec(currentString);
      if (match !== null) {
        value.targetName = match[2];
      }
    }
    if (value instanceof HTMLDirective) {
      html3 += value.createPlaceholder(directives.length);
      directives.push(value);
    } else {
      html3 += value;
    }
  }
  html3 += strings18[strings18.length - 1];
  return new ViewTemplate(html3, directives);
}
var ViewTemplate, lastAttributeNameRegex;
var init_template = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/template.js"() {
    init_dom();
    init_observable();
    init_compiler();
    init_view();
    init_html_directive();
    init_binding();
    ViewTemplate = class {
      /**
       * Creates an instance of ViewTemplate.
       * @param html - The html representing what this template will instantiate, including placeholders for directives.
       * @param directives - The directives that will be connected to placeholders in the html.
       */
      constructor(html3, directives) {
        this.behaviorCount = 0;
        this.hasHostBehaviors = false;
        this.fragment = null;
        this.targetOffset = 0;
        this.viewBehaviorFactories = null;
        this.hostBehaviorFactories = null;
        this.html = html3;
        this.directives = directives;
      }
      /**
       * Creates an HTMLView instance based on this template definition.
       * @param hostBindingTarget - The element that host behaviors will be bound to.
       */
      create(hostBindingTarget) {
        if (this.fragment === null) {
          let template;
          const html3 = this.html;
          if (typeof html3 === "string") {
            template = document.createElement("template");
            template.innerHTML = DOM.createHTML(html3);
            const fec = template.content.firstElementChild;
            if (fec !== null && fec.tagName === "TEMPLATE") {
              template = fec;
            }
          } else {
            template = html3;
          }
          const result = compileTemplate(template, this.directives);
          this.fragment = result.fragment;
          this.viewBehaviorFactories = result.viewBehaviorFactories;
          this.hostBehaviorFactories = result.hostBehaviorFactories;
          this.targetOffset = result.targetOffset;
          this.behaviorCount = this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;
          this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;
        }
        const fragment = this.fragment.cloneNode(true);
        const viewFactories = this.viewBehaviorFactories;
        const behaviors = new Array(this.behaviorCount);
        const walker = DOM.createTemplateWalker(fragment);
        let behaviorIndex = 0;
        let targetIndex = this.targetOffset;
        let node = walker.nextNode();
        for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {
          const factory = viewFactories[behaviorIndex];
          const factoryIndex = factory.targetIndex;
          while (node !== null) {
            if (targetIndex === factoryIndex) {
              behaviors[behaviorIndex] = factory.createBehavior(node);
              break;
            } else {
              node = walker.nextNode();
              targetIndex++;
            }
          }
        }
        if (this.hasHostBehaviors) {
          const hostFactories = this.hostBehaviorFactories;
          for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {
            behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);
          }
        }
        return new HTMLView(fragment, behaviors);
      }
      /**
       * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.
       * @param source - The data source to bind the template to.
       * @param host - The Element where the template will be rendered.
       * @param hostBindingTarget - An HTML element to target the host bindings at if different from the
       * host that the template is being attached to.
       */
      render(source, host, hostBindingTarget) {
        if (typeof host === "string") {
          host = document.getElementById(host);
        }
        if (hostBindingTarget === void 0) {
          hostBindingTarget = host;
        }
        const view = this.create(hostBindingTarget);
        view.bind(source, defaultExecutionContext);
        view.appendTo(host);
        return view;
      }
    };
    lastAttributeNameRegex = /* eslint-disable-next-line no-control-regex */
    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
  }
});

// node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js
function reduceStyles(styles22) {
  return styles22.map((x) => x instanceof ElementStyles ? reduceStyles(x.styles) : [x]).reduce((prev, curr) => prev.concat(curr), []);
}
function reduceBehaviors(styles22) {
  return styles22.map((x) => x instanceof ElementStyles ? x.behaviors : null).reduce((prev, curr) => {
    if (curr === null) {
      return prev;
    }
    if (prev === null) {
      prev = [];
    }
    return prev.concat(curr);
  }, null);
}
function getNextStyleClass() {
  return `fast-style-class-${++styleClassId}`;
}
var ElementStyles, AdoptedStyleSheetsStyles, styleClassId, StyleElementStyles;
var init_element_styles = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js"() {
    init_dom();
    ElementStyles = class {
      constructor() {
        this.targets = /* @__PURE__ */ new WeakSet();
      }
      /** @internal */
      addStylesTo(target2) {
        this.targets.add(target2);
      }
      /** @internal */
      removeStylesFrom(target2) {
        this.targets.delete(target2);
      }
      /** @internal */
      isAttachedTo(target2) {
        return this.targets.has(target2);
      }
      /**
       * Associates behaviors with this set of styles.
       * @param behaviors - The behaviors to associate.
       */
      withBehaviors(...behaviors) {
        this.behaviors = this.behaviors === null ? behaviors : this.behaviors.concat(behaviors);
        return this;
      }
    };
    ElementStyles.create = (() => {
      if (DOM.supportsAdoptedStyleSheets) {
        const styleSheetCache = /* @__PURE__ */ new Map();
        return (styles22) => (
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          new AdoptedStyleSheetsStyles(styles22, styleSheetCache)
        );
      }
      return (styles22) => new StyleElementStyles(styles22);
    })();
    AdoptedStyleSheetsStyles = class extends ElementStyles {
      constructor(styles22, styleSheetCache) {
        super();
        this.styles = styles22;
        this.styleSheetCache = styleSheetCache;
        this._styleSheets = void 0;
        this.behaviors = reduceBehaviors(styles22);
      }
      get styleSheets() {
        if (this._styleSheets === void 0) {
          const styles22 = this.styles;
          const styleSheetCache = this.styleSheetCache;
          this._styleSheets = reduceStyles(styles22).map((x) => {
            if (x instanceof CSSStyleSheet) {
              return x;
            }
            let sheet = styleSheetCache.get(x);
            if (sheet === void 0) {
              sheet = new CSSStyleSheet();
              sheet.replaceSync(x);
              styleSheetCache.set(x, sheet);
            }
            return sheet;
          });
        }
        return this._styleSheets;
      }
      addStylesTo(target2) {
        target2.adoptedStyleSheets = [...target2.adoptedStyleSheets, ...this.styleSheets];
        super.addStylesTo(target2);
      }
      removeStylesFrom(target2) {
        const sourceSheets = this.styleSheets;
        target2.adoptedStyleSheets = target2.adoptedStyleSheets.filter((x) => sourceSheets.indexOf(x) === -1);
        super.removeStylesFrom(target2);
      }
    };
    styleClassId = 0;
    StyleElementStyles = class extends ElementStyles {
      constructor(styles22) {
        super();
        this.styles = styles22;
        this.behaviors = null;
        this.behaviors = reduceBehaviors(styles22);
        this.styleSheets = reduceStyles(styles22);
        this.styleClass = getNextStyleClass();
      }
      addStylesTo(target2) {
        const styleSheets = this.styleSheets;
        const styleClass = this.styleClass;
        target2 = this.normalizeTarget(target2);
        for (let i = 0; i < styleSheets.length; i++) {
          const element = document.createElement("style");
          element.innerHTML = styleSheets[i];
          element.className = styleClass;
          target2.append(element);
        }
        super.addStylesTo(target2);
      }
      removeStylesFrom(target2) {
        target2 = this.normalizeTarget(target2);
        const styles22 = target2.querySelectorAll(`.${this.styleClass}`);
        for (let i = 0, ii = styles22.length; i < ii; ++i) {
          target2.removeChild(styles22[i]);
        }
        super.removeStylesFrom(target2);
      }
      isAttachedTo(target2) {
        return super.isAttachedTo(this.normalizeTarget(target2));
      }
      normalizeTarget(target2) {
        return target2 === document ? document.body : target2;
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/components/attributes.js
function attr(configOrTarget, prop) {
  let config;
  function decorator($target, $prop) {
    if (arguments.length > 1) {
      config.property = $prop;
    }
    AttributeConfiguration.locate($target.constructor).push(config);
  }
  if (arguments.length > 1) {
    config = {};
    decorator(configOrTarget, prop);
    return;
  }
  config = configOrTarget === void 0 ? {} : configOrTarget;
  return decorator;
}
var AttributeConfiguration, booleanConverter, nullableNumberConverter, AttributeDefinition;
var init_attributes = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/components/attributes.js"() {
    init_observable();
    init_dom();
    init_platform();
    AttributeConfiguration = Object.freeze({
      /**
       * Locates all attribute configurations associated with a type.
       */
      locate: createMetadataLocator()
    });
    booleanConverter = {
      toView(value) {
        return value ? "true" : "false";
      },
      fromView(value) {
        if (value === null || value === void 0 || value === "false" || value === false || value === 0) {
          return false;
        }
        return true;
      }
    };
    nullableNumberConverter = {
      toView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const number = value * 1;
        return isNaN(number) ? null : number.toString();
      },
      fromView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const number = value * 1;
        return isNaN(number) ? null : number;
      }
    };
    AttributeDefinition = class {
      /**
       * Creates an instance of AttributeDefinition.
       * @param Owner - The class constructor that owns this attribute.
       * @param name - The name of the property associated with the attribute.
       * @param attribute - The name of the attribute in HTML.
       * @param mode - The {@link AttributeMode} that describes the behavior of this attribute.
       * @param converter - A {@link ValueConverter} that integrates with the property getter/setter
       * to convert values to and from a DOM string.
       */
      constructor(Owner, name, attribute = name.toLowerCase(), mode = "reflect", converter) {
        this.guards = /* @__PURE__ */ new Set();
        this.Owner = Owner;
        this.name = name;
        this.attribute = attribute;
        this.mode = mode;
        this.converter = converter;
        this.fieldName = `_${name}`;
        this.callbackName = `${name}Changed`;
        this.hasCallback = this.callbackName in Owner.prototype;
        if (mode === "boolean" && converter === void 0) {
          this.converter = booleanConverter;
        }
      }
      /**
       * Sets the value of the attribute/property on the source element.
       * @param source - The source element to access.
       * @param value - The value to set the attribute/property to.
       */
      setValue(source, newValue) {
        const oldValue = source[this.fieldName];
        const converter = this.converter;
        if (converter !== void 0) {
          newValue = converter.fromView(newValue);
        }
        if (oldValue !== newValue) {
          source[this.fieldName] = newValue;
          this.tryReflectToAttribute(source);
          if (this.hasCallback) {
            source[this.callbackName](oldValue, newValue);
          }
          source.$fastController.notify(this.name);
        }
      }
      /**
       * Gets the value of the attribute/property on the source element.
       * @param source - The source element to access.
       */
      getValue(source) {
        Observable.track(source, this.name);
        return source[this.fieldName];
      }
      /** @internal */
      onAttributeChangedCallback(element, value) {
        if (this.guards.has(element)) {
          return;
        }
        this.guards.add(element);
        this.setValue(element, value);
        this.guards.delete(element);
      }
      tryReflectToAttribute(element) {
        const mode = this.mode;
        const guards = this.guards;
        if (guards.has(element) || mode === "fromView") {
          return;
        }
        DOM.queueUpdate(() => {
          guards.add(element);
          const latestValue = element[this.fieldName];
          switch (mode) {
            case "reflect":
              const converter = this.converter;
              DOM.setAttribute(element, this.attribute, converter !== void 0 ? converter.toView(latestValue) : latestValue);
              break;
            case "boolean":
              DOM.setBooleanAttribute(element, this.attribute, latestValue);
              break;
          }
          guards.delete(element);
        });
      }
      /**
       * Collects all attribute definitions associated with the owner.
       * @param Owner - The class constructor to collect attribute for.
       * @param attributeLists - Any existing attributes to collect and merge with those associated with the owner.
       * @internal
       */
      static collect(Owner, ...attributeLists) {
        const attributes = [];
        attributeLists.push(AttributeConfiguration.locate(Owner));
        for (let i = 0, ii = attributeLists.length; i < ii; ++i) {
          const list = attributeLists[i];
          if (list === void 0) {
            continue;
          }
          for (let j = 0, jj = list.length; j < jj; ++j) {
            const config = list[j];
            if (typeof config === "string") {
              attributes.push(new AttributeDefinition(Owner, config));
            } else {
              attributes.push(new AttributeDefinition(Owner, config.property, config.attribute, config.mode, config.converter));
            }
          }
        }
        return attributes;
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js
var defaultShadowOptions, defaultElementOptions, fastRegistry, FASTElementDefinition;
var init_fast_definitions = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js"() {
    init_platform();
    init_observable();
    init_element_styles();
    init_attributes();
    defaultShadowOptions = { mode: "open" };
    defaultElementOptions = {};
    fastRegistry = FAST.getById(4, () => {
      const typeToDefinition = /* @__PURE__ */ new Map();
      return Object.freeze({
        register(definition) {
          if (typeToDefinition.has(definition.type)) {
            return false;
          }
          typeToDefinition.set(definition.type, definition);
          return true;
        },
        getByType(key) {
          return typeToDefinition.get(key);
        }
      });
    });
    FASTElementDefinition = class {
      /**
       * Creates an instance of FASTElementDefinition.
       * @param type - The type this definition is being created for.
       * @param nameOrConfig - The name of the element to define or a config object
       * that describes the element to define.
       */
      constructor(type, nameOrConfig = type.definition) {
        if (typeof nameOrConfig === "string") {
          nameOrConfig = { name: nameOrConfig };
        }
        this.type = type;
        this.name = nameOrConfig.name;
        this.template = nameOrConfig.template;
        const attributes = AttributeDefinition.collect(type, nameOrConfig.attributes);
        const observedAttributes = new Array(attributes.length);
        const propertyLookup = {};
        const attributeLookup = {};
        for (let i = 0, ii = attributes.length; i < ii; ++i) {
          const current = attributes[i];
          observedAttributes[i] = current.attribute;
          propertyLookup[current.name] = current;
          attributeLookup[current.attribute] = current;
        }
        this.attributes = attributes;
        this.observedAttributes = observedAttributes;
        this.propertyLookup = propertyLookup;
        this.attributeLookup = attributeLookup;
        this.shadowOptions = nameOrConfig.shadowOptions === void 0 ? defaultShadowOptions : nameOrConfig.shadowOptions === null ? void 0 : Object.assign(Object.assign({}, defaultShadowOptions), nameOrConfig.shadowOptions);
        this.elementOptions = nameOrConfig.elementOptions === void 0 ? defaultElementOptions : Object.assign(Object.assign({}, defaultElementOptions), nameOrConfig.elementOptions);
        this.styles = nameOrConfig.styles === void 0 ? void 0 : Array.isArray(nameOrConfig.styles) ? ElementStyles.create(nameOrConfig.styles) : nameOrConfig.styles instanceof ElementStyles ? nameOrConfig.styles : ElementStyles.create([nameOrConfig.styles]);
      }
      /**
       * Indicates if this element has been defined in at least one registry.
       */
      get isDefined() {
        return !!fastRegistry.getByType(this.type);
      }
      /**
       * Defines a custom element based on this definition.
       * @param registry - The element registry to define the element in.
       */
      define(registry = customElements) {
        const type = this.type;
        if (fastRegistry.register(this)) {
          const attributes = this.attributes;
          const proto = type.prototype;
          for (let i = 0, ii = attributes.length; i < ii; ++i) {
            Observable.defineProperty(proto, attributes[i]);
          }
          Reflect.defineProperty(type, "observedAttributes", {
            value: this.observedAttributes,
            enumerable: true
          });
        }
        if (!registry.get(this.name)) {
          registry.define(this.name, type, this.elementOptions);
        }
        return this;
      }
    };
    FASTElementDefinition.forType = fastRegistry.getByType;
  }
});

// node_modules/@microsoft/fast-element/dist/esm/components/controller.js
function getShadowRoot(element) {
  return element.shadowRoot || shadowRoots.get(element) || null;
}
var shadowRoots, defaultEventOptions, Controller;
var init_controller = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/components/controller.js"() {
    init_dom();
    init_notifier();
    init_observable();
    init_fast_definitions();
    shadowRoots = /* @__PURE__ */ new WeakMap();
    defaultEventOptions = {
      bubbles: true,
      composed: true,
      cancelable: true
    };
    Controller = class extends PropertyChangeNotifier {
      /**
       * Creates a Controller to control the specified element.
       * @param element - The element to be controlled by this controller.
       * @param definition - The element definition metadata that instructs this
       * controller in how to handle rendering and other platform integrations.
       * @internal
       */
      constructor(element, definition) {
        super(element);
        this.boundObservables = null;
        this.behaviors = null;
        this.needsInitialization = true;
        this._template = null;
        this._styles = null;
        this._isConnected = false;
        this.$fastController = this;
        this.view = null;
        this.element = element;
        this.definition = definition;
        const shadowOptions = definition.shadowOptions;
        if (shadowOptions !== void 0) {
          const shadowRoot = element.attachShadow(shadowOptions);
          if (shadowOptions.mode === "closed") {
            shadowRoots.set(element, shadowRoot);
          }
        }
        const accessors = Observable.getAccessors(element);
        if (accessors.length > 0) {
          const boundObservables = this.boundObservables = /* @__PURE__ */ Object.create(null);
          for (let i = 0, ii = accessors.length; i < ii; ++i) {
            const propertyName = accessors[i].name;
            const value = element[propertyName];
            if (value !== void 0) {
              delete element[propertyName];
              boundObservables[propertyName] = value;
            }
          }
        }
      }
      /**
       * Indicates whether or not the custom element has been
       * connected to the document.
       */
      get isConnected() {
        Observable.track(this, "isConnected");
        return this._isConnected;
      }
      setIsConnected(value) {
        this._isConnected = value;
        Observable.notify(this, "isConnected");
      }
      /**
       * Gets/sets the template used to render the component.
       * @remarks
       * This value can only be accurately read after connect but can be set at any time.
       */
      get template() {
        return this._template;
      }
      set template(value) {
        if (this._template === value) {
          return;
        }
        this._template = value;
        if (!this.needsInitialization) {
          this.renderTemplate(value);
        }
      }
      /**
       * Gets/sets the primary styles used for the component.
       * @remarks
       * This value can only be accurately read after connect but can be set at any time.
       */
      get styles() {
        return this._styles;
      }
      set styles(value) {
        if (this._styles === value) {
          return;
        }
        if (this._styles !== null) {
          this.removeStyles(this._styles);
        }
        this._styles = value;
        if (!this.needsInitialization && value !== null) {
          this.addStyles(value);
        }
      }
      /**
       * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.
       * @param styles - The styles to add.
       */
      addStyles(styles22) {
        const target2 = getShadowRoot(this.element) || this.element.getRootNode();
        if (styles22 instanceof HTMLStyleElement) {
          target2.append(styles22);
        } else if (!styles22.isAttachedTo(target2)) {
          const sourceBehaviors = styles22.behaviors;
          styles22.addStylesTo(target2);
          if (sourceBehaviors !== null) {
            this.addBehaviors(sourceBehaviors);
          }
        }
      }
      /**
       * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.
       * @param styles - the styles to remove.
       */
      removeStyles(styles22) {
        const target2 = getShadowRoot(this.element) || this.element.getRootNode();
        if (styles22 instanceof HTMLStyleElement) {
          target2.removeChild(styles22);
        } else if (styles22.isAttachedTo(target2)) {
          const sourceBehaviors = styles22.behaviors;
          styles22.removeStylesFrom(target2);
          if (sourceBehaviors !== null) {
            this.removeBehaviors(sourceBehaviors);
          }
        }
      }
      /**
       * Adds behaviors to this element.
       * @param behaviors - The behaviors to add.
       */
      addBehaviors(behaviors) {
        const targetBehaviors = this.behaviors || (this.behaviors = /* @__PURE__ */ new Map());
        const length = behaviors.length;
        const behaviorsToBind = [];
        for (let i = 0; i < length; ++i) {
          const behavior = behaviors[i];
          if (targetBehaviors.has(behavior)) {
            targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);
          } else {
            targetBehaviors.set(behavior, 1);
            behaviorsToBind.push(behavior);
          }
        }
        if (this._isConnected) {
          const element = this.element;
          for (let i = 0; i < behaviorsToBind.length; ++i) {
            behaviorsToBind[i].bind(element, defaultExecutionContext);
          }
        }
      }
      /**
       * Removes behaviors from this element.
       * @param behaviors - The behaviors to remove.
       * @param force - Forces unbinding of behaviors.
       */
      removeBehaviors(behaviors, force = false) {
        const targetBehaviors = this.behaviors;
        if (targetBehaviors === null) {
          return;
        }
        const length = behaviors.length;
        const behaviorsToUnbind = [];
        for (let i = 0; i < length; ++i) {
          const behavior = behaviors[i];
          if (targetBehaviors.has(behavior)) {
            const count = targetBehaviors.get(behavior) - 1;
            count === 0 || force ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior) : targetBehaviors.set(behavior, count);
          }
        }
        if (this._isConnected) {
          const element = this.element;
          for (let i = 0; i < behaviorsToUnbind.length; ++i) {
            behaviorsToUnbind[i].unbind(element);
          }
        }
      }
      /**
       * Runs connected lifecycle behavior on the associated element.
       */
      onConnectedCallback() {
        if (this._isConnected) {
          return;
        }
        const element = this.element;
        if (this.needsInitialization) {
          this.finishInitialization();
        } else if (this.view !== null) {
          this.view.bind(element, defaultExecutionContext);
        }
        const behaviors = this.behaviors;
        if (behaviors !== null) {
          for (const [behavior] of behaviors) {
            behavior.bind(element, defaultExecutionContext);
          }
        }
        this.setIsConnected(true);
      }
      /**
       * Runs disconnected lifecycle behavior on the associated element.
       */
      onDisconnectedCallback() {
        if (!this._isConnected) {
          return;
        }
        this.setIsConnected(false);
        const view = this.view;
        if (view !== null) {
          view.unbind();
        }
        const behaviors = this.behaviors;
        if (behaviors !== null) {
          const element = this.element;
          for (const [behavior] of behaviors) {
            behavior.unbind(element);
          }
        }
      }
      /**
       * Runs the attribute changed callback for the associated element.
       * @param name - The name of the attribute that changed.
       * @param oldValue - The previous value of the attribute.
       * @param newValue - The new value of the attribute.
       */
      onAttributeChangedCallback(name, oldValue, newValue) {
        const attrDef = this.definition.attributeLookup[name];
        if (attrDef !== void 0) {
          attrDef.onAttributeChangedCallback(this.element, newValue);
        }
      }
      /**
       * Emits a custom HTML event.
       * @param type - The type name of the event.
       * @param detail - The event detail object to send with the event.
       * @param options - The event options. By default bubbles and composed.
       * @remarks
       * Only emits events if connected.
       */
      emit(type, detail, options) {
        if (this._isConnected) {
          return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));
        }
        return false;
      }
      finishInitialization() {
        const element = this.element;
        const boundObservables = this.boundObservables;
        if (boundObservables !== null) {
          const propertyNames = Object.keys(boundObservables);
          for (let i = 0, ii = propertyNames.length; i < ii; ++i) {
            const propertyName = propertyNames[i];
            element[propertyName] = boundObservables[propertyName];
          }
          this.boundObservables = null;
        }
        const definition = this.definition;
        if (this._template === null) {
          if (this.element.resolveTemplate) {
            this._template = this.element.resolveTemplate();
          } else if (definition.template) {
            this._template = definition.template || null;
          }
        }
        if (this._template !== null) {
          this.renderTemplate(this._template);
        }
        if (this._styles === null) {
          if (this.element.resolveStyles) {
            this._styles = this.element.resolveStyles();
          } else if (definition.styles) {
            this._styles = definition.styles || null;
          }
        }
        if (this._styles !== null) {
          this.addStyles(this._styles);
        }
        this.needsInitialization = false;
      }
      renderTemplate(template) {
        const element = this.element;
        const host = getShadowRoot(element) || element;
        if (this.view !== null) {
          this.view.dispose();
          this.view = null;
        } else if (!this.needsInitialization) {
          DOM.removeChildNodes(host);
        }
        if (template) {
          this.view = template.render(element, host, element);
        }
      }
      /**
       * Locates or creates a controller for the specified element.
       * @param element - The element to return the controller for.
       * @remarks
       * The specified element must have a {@link FASTElementDefinition}
       * registered either through the use of the {@link customElement}
       * decorator or a call to `FASTElement.define`.
       */
      static forCustomElement(element) {
        const controller = element.$fastController;
        if (controller !== void 0) {
          return controller;
        }
        const definition = FASTElementDefinition.forType(element.constructor);
        if (definition === void 0) {
          throw new Error("Missing FASTElement definition.");
        }
        return element.$fastController = new Controller(element, definition);
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/components/fast-element.js
function createFASTElement(BaseType) {
  return class extends BaseType {
    constructor() {
      super();
      Controller.forCustomElement(this);
    }
    $emit(type, detail, options) {
      return this.$fastController.emit(type, detail, options);
    }
    connectedCallback() {
      this.$fastController.onConnectedCallback();
    }
    disconnectedCallback() {
      this.$fastController.onDisconnectedCallback();
    }
    attributeChangedCallback(name, oldValue, newValue) {
      this.$fastController.onAttributeChangedCallback(name, oldValue, newValue);
    }
  };
}
var FASTElement;
var init_fast_element = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/components/fast-element.js"() {
    init_controller();
    init_fast_definitions();
    FASTElement = Object.assign(createFASTElement(HTMLElement), {
      /**
       * Creates a new FASTElement base class inherited from the
       * provided base type.
       * @param BaseType - The base element type to inherit from.
       */
      from(BaseType) {
        return createFASTElement(BaseType);
      },
      /**
       * Defines a platform custom element based on the provided type and definition.
       * @param type - The custom element type to define.
       * @param nameOrDef - The name of the element to define or a definition object
       * that describes the element to define.
       */
      define(type, nameOrDef) {
        return new FASTElementDefinition(type, nameOrDef).define().type;
      }
    });
  }
});

// node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js
var CSSDirective;
var init_css_directive = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js"() {
    CSSDirective = class {
      /**
       * Creates a CSS fragment to interpolate into the CSS document.
       * @returns - the string to interpolate into CSS
       */
      createCSS() {
        return "";
      }
      /**
       * Creates a behavior to bind to the host element.
       * @returns - the behavior to bind to the host element, or undefined.
       */
      createBehavior() {
        return void 0;
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/styles/css.js
function collectStyles(strings18, values) {
  const styles22 = [];
  let cssString = "";
  const behaviors = [];
  for (let i = 0, ii = strings18.length - 1; i < ii; ++i) {
    cssString += strings18[i];
    let value = values[i];
    if (value instanceof CSSDirective) {
      const behavior = value.createBehavior();
      value = value.createCSS();
      if (behavior) {
        behaviors.push(behavior);
      }
    }
    if (value instanceof ElementStyles || value instanceof CSSStyleSheet) {
      if (cssString.trim() !== "") {
        styles22.push(cssString);
        cssString = "";
      }
      styles22.push(value);
    } else {
      cssString += value;
    }
  }
  cssString += strings18[strings18.length - 1];
  if (cssString.trim() !== "") {
    styles22.push(cssString);
  }
  return {
    styles: styles22,
    behaviors
  };
}
function css2(strings18, ...values) {
  const { styles: styles22, behaviors } = collectStyles(strings18, values);
  const elementStyles = ElementStyles.create(styles22);
  if (behaviors.length) {
    elementStyles.withBehaviors(...behaviors);
  }
  return elementStyles;
}
function cssPartial(strings18, ...values) {
  const { styles: styles22, behaviors } = collectStyles(strings18, values);
  return new CSSPartial(styles22, behaviors);
}
var CSSPartial;
var init_css = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/styles/css.js"() {
    init_css_directive();
    init_element_styles();
    CSSPartial = class extends CSSDirective {
      constructor(styles22, behaviors) {
        super();
        this.behaviors = behaviors;
        this.css = "";
        const stylesheets = styles22.reduce((accumulated, current) => {
          if (typeof current === "string") {
            this.css += current;
          } else {
            accumulated.push(current);
          }
          return accumulated;
        }, []);
        if (stylesheets.length) {
          this.styles = ElementStyles.create(stylesheets);
        }
      }
      createBehavior() {
        return this;
      }
      createCSS() {
        return this.css;
      }
      bind(el) {
        if (this.styles) {
          el.$fastController.addStyles(this.styles);
        }
        if (this.behaviors.length) {
          el.$fastController.addBehaviors(this.behaviors);
        }
      }
      unbind(el) {
        if (this.styles) {
          el.$fastController.removeStyles(this.styles);
        }
        if (this.behaviors.length) {
          el.$fastController.removeBehaviors(this.behaviors);
        }
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js
function newSplice(index, removed, addedCount) {
  return {
    index,
    removed,
    addedCount
  };
}
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  const rowCount = oldEnd - oldStart + 1;
  const columnCount = currentEnd - currentStart + 1;
  const distances = new Array(rowCount);
  let north;
  let west;
  for (let i = 0; i < rowCount; ++i) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }
  for (let j = 0; j < columnCount; ++j) {
    distances[0][j] = j;
  }
  for (let i = 1; i < rowCount; ++i) {
    for (let j = 1; j < columnCount; ++j) {
      if (current[currentStart + j - 1] === old[oldStart + i - 1]) {
        distances[i][j] = distances[i - 1][j - 1];
      } else {
        north = distances[i - 1][j] + 1;
        west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }
  return distances;
}
function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  const edits = [];
  while (i > 0 || j > 0) {
    if (i === 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j === 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    const northWest = distances[i - 1][j - 1];
    const west = distances[i - 1][j];
    const north = distances[i][j - 1];
    let min;
    if (west < north) {
      min = west < northWest ? west : northWest;
    } else {
      min = north < northWest ? north : northWest;
    }
    if (min === northWest) {
      if (northWest === current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min === west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }
  edits.reverse();
  return edits;
}
function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; ++i) {
    if (current[i] !== old[i]) {
      return i;
    }
  }
  return searchLength;
}
function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && current[--index1] === old[--index2]) {
    count++;
  }
  return count;
}
function intersect(start1, end1, start2, end2) {
  if (end1 < start2 || end2 < start1) {
    return -1;
  }
  if (end1 === start2 || end2 === start1) {
    return 0;
  }
  if (start1 < start2) {
    if (end1 < end2) {
      return end1 - start2;
    }
    return end2 - start2;
  }
  if (end2 < end1) {
    return end2 - start1;
  }
  return end1 - start1;
}
function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  const minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart === 0 && oldStart === 0) {
    prefixCount = sharedPrefix(current, old, minLength);
  }
  if (currentEnd === current.length && oldEnd === old.length) {
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);
  }
  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;
  if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
    return emptyArray;
  }
  if (currentStart === currentEnd) {
    const splice2 = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd) {
      splice2.removed.push(old[oldStart++]);
    }
    return [splice2];
  } else if (oldStart === oldEnd) {
    return [newSplice(currentStart, [], currentEnd - currentStart)];
  }
  const ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
  const splices = [];
  let splice = void 0;
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i = 0; i < ops.length; ++i) {
    switch (ops[i]) {
      case EDIT_LEAVE:
        if (splice !== void 0) {
          splices.push(splice);
          splice = void 0;
        }
        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (splice === void 0) {
          splice = newSplice(index, [], 0);
        }
        splice.addedCount++;
        index++;
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (splice === void 0) {
          splice = newSplice(index, [], 0);
        }
        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (splice === void 0) {
          splice = newSplice(index, [], 0);
        }
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }
  if (splice !== void 0) {
    splices.push(splice);
  }
  return splices;
}
function mergeSplice(splices, index, removed, addedCount) {
  const splice = newSplice(index, removed, addedCount);
  let inserted = false;
  let insertionOffset = 0;
  for (let i = 0; i < splices.length; i++) {
    const current = splices[i];
    current.index += insertionOffset;
    if (inserted) {
      continue;
    }
    const intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);
    if (intersectCount >= 0) {
      splices.splice(i, 1);
      i--;
      insertionOffset -= current.addedCount - current.removed.length;
      splice.addedCount += current.addedCount - intersectCount;
      const deleteCount = splice.removed.length + current.removed.length - intersectCount;
      if (!splice.addedCount && !deleteCount) {
        inserted = true;
      } else {
        let currentRemoved = current.removed;
        if (splice.index < current.index) {
          const prepend = splice.removed.slice(0, current.index - splice.index);
          $push.apply(prepend, currentRemoved);
          currentRemoved = prepend;
        }
        if (splice.index + splice.removed.length > current.index + current.addedCount) {
          const append = splice.removed.slice(current.index + current.addedCount - splice.index);
          $push.apply(currentRemoved, append);
        }
        splice.removed = currentRemoved;
        if (current.index < splice.index) {
          splice.index = current.index;
        }
      }
    } else if (splice.index < current.index) {
      inserted = true;
      splices.splice(i, 0, splice);
      i++;
      const offset = splice.addedCount - splice.removed.length;
      current.index += offset;
      insertionOffset += offset;
    }
  }
  if (!inserted) {
    splices.push(splice);
  }
}
function createInitialSplices(changeRecords) {
  const splices = [];
  for (let i = 0, ii = changeRecords.length; i < ii; i++) {
    const record = changeRecords[i];
    mergeSplice(splices, record.index, record.removed, record.addedCount);
  }
  return splices;
}
function projectArraySplices(array, changeRecords) {
  let splices = [];
  const initialSplices = createInitialSplices(changeRecords);
  for (let i = 0, ii = initialSplices.length; i < ii; ++i) {
    const splice = initialSplices[i];
    if (splice.addedCount === 1 && splice.removed.length === 1) {
      if (splice.removed[0] !== array[splice.index]) {
        splices.push(splice);
      }
      continue;
    }
    splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
  }
  return splices;
}
var EDIT_LEAVE, EDIT_UPDATE, EDIT_ADD, EDIT_DELETE, $push;
var init_array_change_records = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js"() {
    init_platform();
    EDIT_LEAVE = 0;
    EDIT_UPDATE = 1;
    EDIT_ADD = 2;
    EDIT_DELETE = 3;
    $push = Array.prototype.push;
  }
});

// node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js
function adjustIndex(changeRecord, array) {
  let index = changeRecord.index;
  const arrayLength = array.length;
  if (index > arrayLength) {
    index = arrayLength - changeRecord.addedCount;
  } else if (index < 0) {
    index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
  }
  if (index < 0) {
    index = 0;
  }
  changeRecord.index = index;
  return changeRecord;
}
function enableArrayObservation() {
  if (arrayObservationEnabled) {
    return;
  }
  arrayObservationEnabled = true;
  Observable.setArrayObserverFactory((collection) => {
    return new ArrayObserver(collection);
  });
  const proto = Array.prototype;
  if (proto.$fastPatch) {
    return;
  }
  Reflect.defineProperty(proto, "$fastPatch", {
    value: 1,
    enumerable: false
  });
  const pop = proto.pop;
  const push = proto.push;
  const reverse = proto.reverse;
  const shift = proto.shift;
  const sort = proto.sort;
  const splice = proto.splice;
  const unshift = proto.unshift;
  proto.pop = function() {
    const notEmpty = this.length > 0;
    const methodCallResult = pop.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0 && notEmpty) {
      o.addSplice(newSplice(this.length, [methodCallResult], 0));
    }
    return methodCallResult;
  };
  proto.push = function() {
    const methodCallResult = push.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0) {
      o.addSplice(adjustIndex(newSplice(this.length - arguments.length, [], arguments.length), this));
    }
    return methodCallResult;
  };
  proto.reverse = function() {
    let oldArray;
    const o = this.$fastController;
    if (o !== void 0) {
      o.flush();
      oldArray = this.slice();
    }
    const methodCallResult = reverse.apply(this, arguments);
    if (o !== void 0) {
      o.reset(oldArray);
    }
    return methodCallResult;
  };
  proto.shift = function() {
    const notEmpty = this.length > 0;
    const methodCallResult = shift.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0 && notEmpty) {
      o.addSplice(newSplice(0, [methodCallResult], 0));
    }
    return methodCallResult;
  };
  proto.sort = function() {
    let oldArray;
    const o = this.$fastController;
    if (o !== void 0) {
      o.flush();
      oldArray = this.slice();
    }
    const methodCallResult = sort.apply(this, arguments);
    if (o !== void 0) {
      o.reset(oldArray);
    }
    return methodCallResult;
  };
  proto.splice = function() {
    const methodCallResult = splice.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0) {
      o.addSplice(adjustIndex(newSplice(+arguments[0], methodCallResult, arguments.length > 2 ? arguments.length - 2 : 0), this));
    }
    return methodCallResult;
  };
  proto.unshift = function() {
    const methodCallResult = unshift.apply(this, arguments);
    const o = this.$fastController;
    if (o !== void 0) {
      o.addSplice(adjustIndex(newSplice(0, [], arguments.length), this));
    }
    return methodCallResult;
  };
}
var arrayObservationEnabled, ArrayObserver;
var init_array_observer = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js"() {
    init_dom();
    init_array_change_records();
    init_notifier();
    init_observable();
    arrayObservationEnabled = false;
    ArrayObserver = class extends SubscriberSet {
      constructor(source) {
        super(source);
        this.oldCollection = void 0;
        this.splices = void 0;
        this.needsQueue = true;
        this.call = this.flush;
        Reflect.defineProperty(source, "$fastController", {
          value: this,
          enumerable: false
        });
      }
      subscribe(subscriber) {
        this.flush();
        super.subscribe(subscriber);
      }
      addSplice(splice) {
        if (this.splices === void 0) {
          this.splices = [splice];
        } else {
          this.splices.push(splice);
        }
        if (this.needsQueue) {
          this.needsQueue = false;
          DOM.queueUpdate(this);
        }
      }
      reset(oldCollection) {
        this.oldCollection = oldCollection;
        if (this.needsQueue) {
          this.needsQueue = false;
          DOM.queueUpdate(this);
        }
      }
      flush() {
        const splices = this.splices;
        const oldCollection = this.oldCollection;
        if (splices === void 0 && oldCollection === void 0) {
          return;
        }
        this.needsQueue = true;
        this.splices = void 0;
        this.oldCollection = void 0;
        const finalSplices = oldCollection === void 0 ? projectArraySplices(this.source, splices) : calcSplices(this.source, 0, this.source.length, oldCollection, 0, oldCollection.length);
        this.notify(finalSplices);
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/ref.js
function ref(propertyName) {
  return new AttachedBehaviorHTMLDirective("fast-ref", RefBehavior, propertyName);
}
var RefBehavior;
var init_ref = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/ref.js"() {
    init_html_directive();
    RefBehavior = class {
      /**
       * Creates an instance of RefBehavior.
       * @param target - The element to reference.
       * @param propertyName - The name of the property to assign the reference to.
       */
      constructor(target2, propertyName) {
        this.target = target2;
        this.propertyName = propertyName;
      }
      /**
       * Bind this behavior to the source.
       * @param source - The source to bind to.
       * @param context - The execution context that the binding is operating within.
       */
      bind(source) {
        source[this.propertyName] = this.target;
      }
      /**
       * Unbinds this behavior from the source.
       * @param source - The source to unbind from.
       */
      /* eslint-disable-next-line @typescript-eslint/no-empty-function */
      unbind() {
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/when.js
function when(binding, templateOrTemplateBinding) {
  const getTemplate = typeof templateOrTemplateBinding === "function" ? templateOrTemplateBinding : () => templateOrTemplateBinding;
  return (source, context) => binding(source, context) ? getTemplate(source, context) : null;
}
var init_when = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/when.js"() {
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/repeat.js
function bindWithoutPositioning(view, items, index, context) {
  view.bind(items[index], context);
}
function bindWithPositioning(view, items, index, context) {
  const childContext = Object.create(context);
  childContext.index = index;
  childContext.length = items.length;
  view.bind(items[index], childContext);
}
function repeat2(itemsBinding, templateOrTemplateBinding, options = defaultRepeatOptions) {
  const templateBinding = typeof templateOrTemplateBinding === "function" ? templateOrTemplateBinding : () => templateOrTemplateBinding;
  return new RepeatDirective2(itemsBinding, templateBinding, Object.assign(Object.assign({}, defaultRepeatOptions), options));
}
var defaultRepeatOptions, RepeatBehavior, RepeatDirective2;
var init_repeat = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/repeat.js"() {
    init_dom();
    init_observable();
    init_array_observer();
    init_platform();
    init_html_directive();
    init_view();
    defaultRepeatOptions = Object.freeze({
      positioning: false,
      recycle: true
    });
    RepeatBehavior = class {
      /**
       * Creates an instance of RepeatBehavior.
       * @param location - The location in the DOM to render the repeat.
       * @param itemsBinding - The array to render.
       * @param isItemsBindingVolatile - Indicates whether the items binding has volatile dependencies.
       * @param templateBinding - The template to render for each item.
       * @param isTemplateBindingVolatile - Indicates whether the template binding has volatile dependencies.
       * @param options - Options used to turn on special repeat features.
       */
      constructor(location, itemsBinding, isItemsBindingVolatile, templateBinding, isTemplateBindingVolatile, options) {
        this.location = location;
        this.itemsBinding = itemsBinding;
        this.templateBinding = templateBinding;
        this.options = options;
        this.source = null;
        this.views = [];
        this.items = null;
        this.itemsObserver = null;
        this.originalContext = void 0;
        this.childContext = void 0;
        this.bindView = bindWithoutPositioning;
        this.itemsBindingObserver = Observable.binding(itemsBinding, this, isItemsBindingVolatile);
        this.templateBindingObserver = Observable.binding(templateBinding, this, isTemplateBindingVolatile);
        if (options.positioning) {
          this.bindView = bindWithPositioning;
        }
      }
      /**
       * Bind this behavior to the source.
       * @param source - The source to bind to.
       * @param context - The execution context that the binding is operating within.
       */
      bind(source, context) {
        this.source = source;
        this.originalContext = context;
        this.childContext = Object.create(context);
        this.childContext.parent = source;
        this.childContext.parentContext = this.originalContext;
        this.items = this.itemsBindingObserver.observe(source, this.originalContext);
        this.template = this.templateBindingObserver.observe(source, this.originalContext);
        this.observeItems(true);
        this.refreshAllViews();
      }
      /**
       * Unbinds this behavior from the source.
       * @param source - The source to unbind from.
       */
      unbind() {
        this.source = null;
        this.items = null;
        if (this.itemsObserver !== null) {
          this.itemsObserver.unsubscribe(this);
        }
        this.unbindAllViews();
        this.itemsBindingObserver.disconnect();
        this.templateBindingObserver.disconnect();
      }
      /** @internal */
      handleChange(source, args) {
        if (source === this.itemsBinding) {
          this.items = this.itemsBindingObserver.observe(this.source, this.originalContext);
          this.observeItems();
          this.refreshAllViews();
        } else if (source === this.templateBinding) {
          this.template = this.templateBindingObserver.observe(this.source, this.originalContext);
          this.refreshAllViews(true);
        } else {
          this.updateViews(args);
        }
      }
      observeItems(force = false) {
        if (!this.items) {
          this.items = emptyArray;
          return;
        }
        const oldObserver = this.itemsObserver;
        const newObserver = this.itemsObserver = Observable.getNotifier(this.items);
        const hasNewObserver = oldObserver !== newObserver;
        if (hasNewObserver && oldObserver !== null) {
          oldObserver.unsubscribe(this);
        }
        if (hasNewObserver || force) {
          newObserver.subscribe(this);
        }
      }
      updateViews(splices) {
        const childContext = this.childContext;
        const views = this.views;
        const bindView = this.bindView;
        const items = this.items;
        const template = this.template;
        const recycle = this.options.recycle;
        const leftoverViews = [];
        let leftoverIndex = 0;
        let availableViews = 0;
        for (let i = 0, ii = splices.length; i < ii; ++i) {
          const splice = splices[i];
          const removed = splice.removed;
          let removeIndex = 0;
          let addIndex = splice.index;
          const end = addIndex + splice.addedCount;
          const removedViews = views.splice(splice.index, removed.length);
          const totalAvailableViews = availableViews = leftoverViews.length + removedViews.length;
          for (; addIndex < end; ++addIndex) {
            const neighbor = views[addIndex];
            const location = neighbor ? neighbor.firstChild : this.location;
            let view;
            if (recycle && availableViews > 0) {
              if (removeIndex <= totalAvailableViews && removedViews.length > 0) {
                view = removedViews[removeIndex];
                removeIndex++;
              } else {
                view = leftoverViews[leftoverIndex];
                leftoverIndex++;
              }
              availableViews--;
            } else {
              view = template.create();
            }
            views.splice(addIndex, 0, view);
            bindView(view, items, addIndex, childContext);
            view.insertBefore(location);
          }
          if (removedViews[removeIndex]) {
            leftoverViews.push(...removedViews.slice(removeIndex));
          }
        }
        for (let i = leftoverIndex, ii = leftoverViews.length; i < ii; ++i) {
          leftoverViews[i].dispose();
        }
        if (this.options.positioning) {
          for (let i = 0, ii = views.length; i < ii; ++i) {
            const currentContext = views[i].context;
            currentContext.length = ii;
            currentContext.index = i;
          }
        }
      }
      refreshAllViews(templateChanged = false) {
        const items = this.items;
        const childContext = this.childContext;
        const template = this.template;
        const location = this.location;
        const bindView = this.bindView;
        let itemsLength = items.length;
        let views = this.views;
        let viewsLength = views.length;
        if (itemsLength === 0 || templateChanged || !this.options.recycle) {
          HTMLView.disposeContiguousBatch(views);
          viewsLength = 0;
        }
        if (viewsLength === 0) {
          this.views = views = new Array(itemsLength);
          for (let i = 0; i < itemsLength; ++i) {
            const view = template.create();
            bindView(view, items, i, childContext);
            views[i] = view;
            view.insertBefore(location);
          }
        } else {
          let i = 0;
          for (; i < itemsLength; ++i) {
            if (i < viewsLength) {
              const view = views[i];
              bindView(view, items, i, childContext);
            } else {
              const view = template.create();
              bindView(view, items, i, childContext);
              views.push(view);
              view.insertBefore(location);
            }
          }
          const removed = views.splice(i, viewsLength - i);
          for (i = 0, itemsLength = removed.length; i < itemsLength; ++i) {
            removed[i].dispose();
          }
        }
      }
      unbindAllViews() {
        const views = this.views;
        for (let i = 0, ii = views.length; i < ii; ++i) {
          views[i].unbind();
        }
      }
    };
    RepeatDirective2 = class extends HTMLDirective {
      /**
       * Creates an instance of RepeatDirective.
       * @param itemsBinding - The binding that provides the array to render.
       * @param templateBinding - The template binding used to obtain a template to render for each item in the array.
       * @param options - Options used to turn on special repeat features.
       */
      constructor(itemsBinding, templateBinding, options) {
        super();
        this.itemsBinding = itemsBinding;
        this.templateBinding = templateBinding;
        this.options = options;
        this.createPlaceholder = DOM.createBlockPlaceholder;
        enableArrayObservation();
        this.isItemsBindingVolatile = Observable.isVolatileBinding(itemsBinding);
        this.isTemplateBindingVolatile = Observable.isVolatileBinding(templateBinding);
      }
      /**
       * Creates a behavior for the provided target node.
       * @param target - The node instance to create the behavior for.
       */
      createBehavior(target2) {
        return new RepeatBehavior(target2, this.itemsBinding, this.isItemsBindingVolatile, this.templateBinding, this.isTemplateBindingVolatile, this.options);
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js
function elements(selector) {
  if (selector) {
    return function(value, index, array) {
      return value.nodeType === 1 && value.matches(selector);
    };
  }
  return function(value, index, array) {
    return value.nodeType === 1;
  };
}
var NodeObservationBehavior;
var init_node_observation = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js"() {
    init_observable();
    init_platform();
    NodeObservationBehavior = class {
      /**
       * Creates an instance of NodeObservationBehavior.
       * @param target - The target to assign the nodes property on.
       * @param options - The options to use in configuring node observation.
       */
      constructor(target2, options) {
        this.target = target2;
        this.options = options;
        this.source = null;
      }
      /**
       * Bind this behavior to the source.
       * @param source - The source to bind to.
       * @param context - The execution context that the binding is operating within.
       */
      bind(source) {
        const name = this.options.property;
        this.shouldUpdate = Observable.getAccessors(source).some((x) => x.name === name);
        this.source = source;
        this.updateTarget(this.computeNodes());
        if (this.shouldUpdate) {
          this.observe();
        }
      }
      /**
       * Unbinds this behavior from the source.
       * @param source - The source to unbind from.
       */
      unbind() {
        this.updateTarget(emptyArray);
        this.source = null;
        if (this.shouldUpdate) {
          this.disconnect();
        }
      }
      /** @internal */
      handleEvent() {
        this.updateTarget(this.computeNodes());
      }
      computeNodes() {
        let nodes = this.getNodes();
        if (this.options.filter !== void 0) {
          nodes = nodes.filter(this.options.filter);
        }
        return nodes;
      }
      updateTarget(value) {
        this.source[this.options.property] = value;
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/slotted.js
function slotted(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = { property: propertyOrOptions };
  }
  return new AttachedBehaviorHTMLDirective("fast-slotted", SlottedBehavior, propertyOrOptions);
}
var SlottedBehavior;
var init_slotted = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/slotted.js"() {
    init_html_directive();
    init_node_observation();
    SlottedBehavior = class extends NodeObservationBehavior {
      /**
       * Creates an instance of SlottedBehavior.
       * @param target - The slot element target to observe.
       * @param options - The options to use when observing the slot.
       */
      constructor(target2, options) {
        super(target2, options);
      }
      /**
       * Begins observation of the nodes.
       */
      observe() {
        this.target.addEventListener("slotchange", this);
      }
      /**
       * Disconnects observation of the nodes.
       */
      disconnect() {
        this.target.removeEventListener("slotchange", this);
      }
      /**
       * Retrieves the nodes that should be assigned to the target.
       */
      getNodes() {
        return this.target.assignedNodes(this.options);
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/templating/children.js
function children(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = {
      property: propertyOrOptions
    };
  }
  return new AttachedBehaviorHTMLDirective("fast-children", ChildrenBehavior, propertyOrOptions);
}
var ChildrenBehavior;
var init_children = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/templating/children.js"() {
    init_html_directive();
    init_node_observation();
    ChildrenBehavior = class extends NodeObservationBehavior {
      /**
       * Creates an instance of ChildrenBehavior.
       * @param target - The element target to observe children on.
       * @param options - The options to use when observing the element children.
       */
      constructor(target2, options) {
        super(target2, options);
        this.observer = null;
        options.childList = true;
      }
      /**
       * Begins observation of the nodes.
       */
      observe() {
        if (this.observer === null) {
          this.observer = new MutationObserver(this.handleEvent.bind(this));
        }
        this.observer.observe(this.target, this.options);
      }
      /**
       * Disconnects observation of the nodes.
       */
      disconnect() {
        this.observer.disconnect();
      }
      /**
       * Retrieves the nodes that should be assigned to the target.
       */
      getNodes() {
        if ("subtree" in this.options) {
          return Array.from(this.target.querySelectorAll(this.options.selector));
        }
        return Array.from(this.target.childNodes);
      }
    };
  }
});

// node_modules/@microsoft/fast-element/dist/esm/index.js
var init_esm = __esm({
  "node_modules/@microsoft/fast-element/dist/esm/index.js"() {
    init_platform();
    init_template();
    init_fast_element();
    init_fast_definitions();
    init_attributes();
    init_controller();
    init_compiler();
    init_element_styles();
    init_css();
    init_css_directive();
    init_view();
    init_observable();
    init_notifier();
    init_array_change_records();
    init_array_observer();
    init_dom();
    init_binding();
    init_html_directive();
    init_ref();
    init_when();
    init_repeat();
    init_slotted();
    init_children();
    init_node_observation();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/patterns/start-end.js
var StartEnd, endSlotTemplate, startSlotTemplate, endTemplate, startTemplate;
var init_start_end = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/patterns/start-end.js"() {
    init_esm();
    StartEnd = class {
      handleStartContentChange() {
        this.startContainer.classList.toggle("start", this.start.assignedNodes().length > 0);
      }
      handleEndContentChange() {
        this.endContainer.classList.toggle("end", this.end.assignedNodes().length > 0);
      }
    };
    endSlotTemplate = (context, definition) => html2`
    <span
        part="end"
        ${ref("endContainer")}
        class=${(x) => definition.end ? "end" : void 0}
    >
        <slot name="end" ${ref("end")} @slotchange="${(x) => x.handleEndContentChange()}">
            ${definition.end || ""}
        </slot>
    </span>
`;
    startSlotTemplate = (context, definition) => html2`
    <span
        part="start"
        ${ref("startContainer")}
        class="${(x) => definition.start ? "start" : void 0}"
    >
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${(x) => x.handleStartContentChange()}"
        >
            ${definition.start || ""}
        </slot>
    </span>
`;
    endTemplate = html2`
    <span part="end" ${ref("endContainer")}>
        <slot
            name="end"
            ${ref("end")}
            @slotchange="${(x) => x.handleEndContentChange()}"
        ></slot>
    </span>
`;
    startTemplate = html2`
    <span part="start" ${ref("startContainer")}>
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${(x) => x.handleStartContentChange()}"
        ></slot>
    </span>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.template.js
var accordionItemTemplate;
var init_accordion_item_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.template.js"() {
    init_esm();
    init_start_end();
    accordionItemTemplate = (context, definition) => html2`
    <template class="${(x) => x.expanded ? "expanded" : ""}">
        <div
            class="heading"
            part="heading"
            role="heading"
            aria-level="${(x) => x.headinglevel}"
        >
            <button
                class="button"
                part="button"
                ${ref("expandbutton")}
                aria-expanded="${(x) => x.expanded}"
                aria-controls="${(x) => x.id}-panel"
                id="${(x) => x.id}"
                @click="${(x, c) => x.clickHandler(c.event)}"
            >
                <span class="heading-content" part="heading-content">
                    <slot name="heading"></slot>
                </span>
            </button>
            ${startSlotTemplate(context, definition)}
            ${endSlotTemplate(context, definition)}
            <span class="icon" part="icon" aria-hidden="true">
                <slot name="expanded-icon" part="expanded-icon">
                    ${definition.expandedIcon || ""}
                </slot>
                <slot name="collapsed-icon" part="collapsed-icon">
                    ${definition.collapsedIcon || ""}
                </slot>
            <span>
        </div>
        <div
            class="region"
            part="region"
            id="${(x) => x.id}-panel"
            role="region"
            aria-labelledby="${(x) => x.id}"
        >
            <slot></slot>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/node_modules/tslib/tslib.es6.js
function __decorate5(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
}
var init_tslib_es62 = __esm({
  "node_modules/@microsoft/fast-foundation/node_modules/tslib/tslib.es6.js"() {
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/di/di.js
function cloneArrayWithPossibleProps(source) {
  const clone = source.slice();
  const keys = Object.keys(source);
  const len = keys.length;
  let key;
  for (let i = 0; i < len; ++i) {
    key = keys[i];
    if (!isArrayIndex(key)) {
      clone[key] = source[key];
    }
  }
  return clone;
}
function getParamTypes(key) {
  return (Type) => {
    return Reflect.getOwnMetadata(key, Type);
  };
}
function createResolver(getter) {
  return function(key) {
    const resolver = function(target2, property2, descriptor) {
      DI.inject(resolver)(target2, property2, descriptor);
    };
    resolver.$isResolver = true;
    resolver.resolve = function(handler, requestor) {
      return getter(key, handler, requestor);
    };
    return resolver;
  };
}
function createAllResolver(getter) {
  return function(key, searchAncestors) {
    searchAncestors = !!searchAncestors;
    const resolver = function(target2, property2, descriptor) {
      DI.inject(resolver)(target2, property2, descriptor);
    };
    resolver.$isResolver = true;
    resolver.resolve = function(handler, requestor) {
      return getter(key, handler, requestor, searchAncestors);
    };
    return resolver;
  };
}
function ignore(target2, property2, descriptor) {
  DI.inject(ignore)(target2, property2, descriptor);
}
function createNewInstance(key, handler) {
  return handler.getFactory(key).construct(handler);
}
function containerGetKey(d) {
  return this.get(d);
}
function transformInstance(inst, transform) {
  return transform(inst);
}
function isRegistry(obj) {
  return typeof obj.register === "function";
}
function isSelfRegistry(obj) {
  return isRegistry(obj) && typeof obj.registerInRequestor === "boolean";
}
function isRegisterInRequester(obj) {
  return isSelfRegistry(obj) && obj.registerInRequestor;
}
function isClass(obj) {
  return obj.prototype !== void 0;
}
function cacheCallbackResult(fun) {
  return function(handler, requestor, resolver) {
    if (cache.has(resolver)) {
      return cache.get(resolver);
    }
    const t = fun(handler, requestor, resolver);
    cache.set(resolver, t);
    return t;
  };
}
function validateKey(key) {
  if (key === null || key === void 0) {
    throw new Error("key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?");
  }
}
function buildAllResponse(resolver, handler, requestor) {
  if (resolver instanceof ResolverImpl && resolver.strategy === 4) {
    const state2 = resolver.state;
    let i = state2.length;
    const results = new Array(i);
    while (i--) {
      results[i] = state2[i].resolve(handler, requestor);
    }
    return results;
  }
  return [resolver.resolve(handler, requestor)];
}
function isObject(value) {
  return typeof value === "object" && value !== null || typeof value === "function";
}
function isArrayIndex(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup[value] = false;
      }
      let ch = 0;
      for (let i = 0; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup[value] = false;
        }
      }
      return isNumericLookup[value] = true;
    }
    default:
      return false;
  }
}
var metadataByTarget, ResolverBuilder, DefaultResolver, ContainerConfiguration, dependencyLookup, rootDOMContainer, DI, Container, inject, defaultSingletonOptions, all, lazy, optional, newInstanceForScope, newInstanceOf, ResolverImpl, FactoryImpl, containerResolver, InstrinsicTypeNames, DILocateParentEventType, factories, ContainerImpl, cache, Registration, defaultFriendlyName, isNativeFunction, isNumericLookup;
var init_di = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/di/di.js"() {
    init_esm();
    metadataByTarget = /* @__PURE__ */ new Map();
    if (!("metadata" in Reflect)) {
      Reflect.metadata = function(key, value) {
        return function(target2) {
          Reflect.defineMetadata(key, value, target2);
        };
      };
      Reflect.defineMetadata = function(key, value, target2) {
        let metadata = metadataByTarget.get(target2);
        if (metadata === void 0) {
          metadataByTarget.set(target2, metadata = /* @__PURE__ */ new Map());
        }
        metadata.set(key, value);
      };
      Reflect.getOwnMetadata = function(key, target2) {
        const metadata = metadataByTarget.get(target2);
        if (metadata !== void 0) {
          return metadata.get(key);
        }
        return void 0;
      };
    }
    ResolverBuilder = class {
      /**
       *
       * @param container - The container to create resolvers for.
       * @param key - The key to register resolvers under.
       */
      constructor(container, key) {
        this.container = container;
        this.key = key;
      }
      /**
       * Creates a resolver for an existing object instance.
       * @param value - The instance to resolve.
       * @returns The resolver.
       */
      instance(value) {
        return this.registerResolver(0, value);
      }
      /**
       * Creates a resolver that enforces a singleton lifetime.
       * @param value - The type to create and cache the singleton for.
       * @returns The resolver.
       */
      singleton(value) {
        return this.registerResolver(1, value);
      }
      /**
       * Creates a resolver that creates a new instance for every dependency request.
       * @param value - The type to create instances of.
       * @returns - The resolver.
       */
      transient(value) {
        return this.registerResolver(2, value);
      }
      /**
       * Creates a resolver that invokes a callback function for every dependency resolution
       * request, allowing custom logic to return the dependency.
       * @param value - The callback to call during resolution.
       * @returns The resolver.
       */
      callback(value) {
        return this.registerResolver(3, value);
      }
      /**
       * Creates a resolver that invokes a callback function the first time that a dependency
       * resolution is requested. The returned value is then cached and provided for all
       * subsequent requests.
       * @param value - The callback to call during the first resolution.
       * @returns The resolver.
       */
      cachedCallback(value) {
        return this.registerResolver(3, cacheCallbackResult(value));
      }
      /**
       * Aliases the current key to a different key.
       * @param destinationKey - The key to point the alias to.
       * @returns The resolver.
       */
      aliasTo(destinationKey) {
        return this.registerResolver(5, destinationKey);
      }
      registerResolver(strategy, state2) {
        const { container, key } = this;
        this.container = this.key = void 0;
        return container.registerResolver(key, new ResolverImpl(key, strategy, state2));
      }
    };
    DefaultResolver = Object.freeze({
      /**
       * Disables auto-registration and throws for all un-registered dependencies.
       * @param key - The key to create the resolver for.
       */
      none(key) {
        throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);
      },
      /**
       * Provides default singleton resolution behavior during auto-registration.
       * @param key - The key to create the resolver for.
       * @returns The resolver.
       */
      singleton(key) {
        return new ResolverImpl(key, 1, key);
      },
      /**
       * Provides default transient resolution behavior during auto-registration.
       * @param key - The key to create the resolver for.
       * @returns The resolver.
       */
      transient(key) {
        return new ResolverImpl(key, 2, key);
      }
    });
    ContainerConfiguration = Object.freeze({
      /**
       * The default configuration used when creating a DOM-disconnected container.
       * @remarks
       * The default creates a root container, with no parent container. It does not handle
       * owner requests and it uses singleton resolution behavior for auto-registration.
       */
      default: Object.freeze({
        parentLocator: () => null,
        responsibleForOwnerRequests: false,
        defaultResolver: DefaultResolver.singleton
      })
    });
    dependencyLookup = /* @__PURE__ */ new Map();
    rootDOMContainer = null;
    DI = Object.freeze({
      /**
       * Creates a new dependency injection container.
       * @param config - The configuration for the container.
       * @returns A newly created dependency injection container.
       */
      createContainer(config) {
        return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));
      },
      /**
       * Finds the dependency injection container responsible for providing dependencies
       * to the specified node.
       * @param node - The node to find the responsible container for.
       * @returns The container responsible for providing dependencies to the node.
       * @remarks
       * This will be the same as the parent container if the specified node
       * does not itself host a container configured with responsibleForOwnerRequests.
       */
      findResponsibleContainer(node) {
        const owned = node.$$container$$;
        if (owned && owned.responsibleForOwnerRequests) {
          return owned;
        }
        return DI.findParentContainer(node);
      },
      /**
       * Find the dependency injection container up the DOM tree from this node.
       * @param node - The node to find the parent container for.
       * @returns The parent container of this node.
       * @remarks
       * This will be the same as the responsible container if the specified node
       * does not itself host a container configured with responsibleForOwnerRequests.
       */
      findParentContainer(node) {
        const event = new CustomEvent(DILocateParentEventType, {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: { container: void 0 }
        });
        node.dispatchEvent(event);
        return event.detail.container || DI.getOrCreateDOMContainer();
      },
      /**
       * Returns a dependency injection container if one is explicitly owned by the specified
       * node. If one is not owned, then a new container is created and assigned to the node.
       * @param node - The node to find or create the container for.
       * @param config - The configuration for the container if one needs to be created.
       * @returns The located or created container.
       * @remarks
       * This API does not search for a responsible or parent container. It looks only for a container
       * directly defined on the specified node and creates one at that location if one does not
       * already exist.
       */
      getOrCreateDOMContainer(node, config) {
        if (!node) {
          return rootDOMContainer || (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {
            parentLocator: () => null
          })));
        }
        return node.$$container$$ || new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {
          parentLocator: DI.findParentContainer
        }));
      },
      /**
       * Gets the "design:paramtypes" metadata for the specified type.
       * @param Type - The type to get the metadata for.
       * @returns The metadata array or undefined if no metadata is found.
       */
      getDesignParamtypes: getParamTypes("design:paramtypes"),
      /**
       * Gets the "di:paramtypes" metadata for the specified type.
       * @param Type - The type to get the metadata for.
       * @returns The metadata array or undefined if no metadata is found.
       */
      getAnnotationParamtypes: getParamTypes("di:paramtypes"),
      /**
       *
       * @param Type - Gets the "di:paramtypes" metadata for the specified type. If none is found,
       * an empty metadata array is created and added.
       * @returns The metadata array.
       */
      getOrCreateAnnotationParamTypes(Type) {
        let annotationParamtypes = this.getAnnotationParamtypes(Type);
        if (annotationParamtypes === void 0) {
          Reflect.defineMetadata("di:paramtypes", annotationParamtypes = [], Type);
        }
        return annotationParamtypes;
      },
      /**
       * Gets the dependency keys representing what is needed to instantiate the specified type.
       * @param Type - The type to get the dependencies for.
       * @returns An array of dependency keys.
       */
      getDependencies(Type) {
        let dependencies = dependencyLookup.get(Type);
        if (dependencies === void 0) {
          const inject2 = Type.inject;
          if (inject2 === void 0) {
            const designParamtypes = DI.getDesignParamtypes(Type);
            const annotationParamtypes = DI.getAnnotationParamtypes(Type);
            if (designParamtypes === void 0) {
              if (annotationParamtypes === void 0) {
                const Proto = Object.getPrototypeOf(Type);
                if (typeof Proto === "function" && Proto !== Function.prototype) {
                  dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));
                } else {
                  dependencies = [];
                }
              } else {
                dependencies = cloneArrayWithPossibleProps(annotationParamtypes);
              }
            } else if (annotationParamtypes === void 0) {
              dependencies = cloneArrayWithPossibleProps(designParamtypes);
            } else {
              dependencies = cloneArrayWithPossibleProps(designParamtypes);
              let len = annotationParamtypes.length;
              let auAnnotationParamtype;
              for (let i = 0; i < len; ++i) {
                auAnnotationParamtype = annotationParamtypes[i];
                if (auAnnotationParamtype !== void 0) {
                  dependencies[i] = auAnnotationParamtype;
                }
              }
              const keys = Object.keys(annotationParamtypes);
              len = keys.length;
              let key;
              for (let i = 0; i < len; ++i) {
                key = keys[i];
                if (!isArrayIndex(key)) {
                  dependencies[key] = annotationParamtypes[key];
                }
              }
            }
          } else {
            dependencies = cloneArrayWithPossibleProps(inject2);
          }
          dependencyLookup.set(Type, dependencies);
        }
        return dependencies;
      },
      /**
       * Defines a property on a web component class. The value of this property will
       * be resolved from the dependency injection container responsible for the element
       * instance, based on where it is connected in the DOM.
       * @param target - The target to define the property on.
       * @param propertyName - The name of the property to define.
       * @param key - The dependency injection key.
       * @param respectConnection - Indicates whether or not to update the property value if the
       * hosting component is disconnected and then re-connected at a different location in the DOM.
       * @remarks
       * The respectConnection option is only applicable to elements that descend from FASTElement.
       */
      defineProperty(target2, propertyName, key, respectConnection = false) {
        const diPropertyKey = `$di_${propertyName}`;
        Reflect.defineProperty(target2, propertyName, {
          get: function() {
            let value = this[diPropertyKey];
            if (value === void 0) {
              const container = this instanceof HTMLElement ? DI.findResponsibleContainer(this) : DI.getOrCreateDOMContainer();
              value = container.get(key);
              this[diPropertyKey] = value;
              if (respectConnection && this instanceof FASTElement) {
                const notifier = this.$fastController;
                const handleChange = () => {
                  const newContainer = DI.findResponsibleContainer(this);
                  const newValue = newContainer.get(key);
                  const oldValue = this[diPropertyKey];
                  if (newValue !== oldValue) {
                    this[diPropertyKey] = value;
                    notifier.notify(propertyName);
                  }
                };
                notifier.subscribe({ handleChange }, "isConnected");
              }
            }
            return value;
          }
        });
      },
      /**
       * Creates a dependency injection key.
       * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a
       * default resolution for the dependency.
       * @param configuror - If a friendly name was provided for the first parameter, then an optional
       * lambda that configures a default resolution for the dependency can be provided second.
       * @returns The created key.
       * @remarks
       * The created key can be used as a property decorator or constructor parameter decorator,
       * in addition to its standard use in an inject array or through direct container APIs.
       */
      createInterface(nameConfigOrCallback, configuror) {
        const configure = typeof nameConfigOrCallback === "function" ? nameConfigOrCallback : configuror;
        const friendlyName = typeof nameConfigOrCallback === "string" ? nameConfigOrCallback : nameConfigOrCallback && "friendlyName" in nameConfigOrCallback ? nameConfigOrCallback.friendlyName || defaultFriendlyName : defaultFriendlyName;
        const respectConnection = typeof nameConfigOrCallback === "string" ? false : nameConfigOrCallback && "respectConnection" in nameConfigOrCallback ? nameConfigOrCallback.respectConnection || false : false;
        const Interface = function(target2, property2, index) {
          if (target2 == null || new.target !== void 0) {
            throw new Error(`No registration for interface: '${Interface.friendlyName}'`);
          }
          if (property2) {
            DI.defineProperty(target2, property2, Interface, respectConnection);
          } else {
            const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target2);
            annotationParamtypes[index] = Interface;
          }
        };
        Interface.$isInterface = true;
        Interface.friendlyName = friendlyName == null ? "(anonymous)" : friendlyName;
        if (configure != null) {
          Interface.register = function(container, key) {
            return configure(new ResolverBuilder(container, key !== null && key !== void 0 ? key : Interface));
          };
        }
        Interface.toString = function toString() {
          return `InterfaceSymbol<${Interface.friendlyName}>`;
        };
        return Interface;
      },
      /**
       * A decorator that specifies what to inject into its target.
       * @param dependencies - The dependencies to inject.
       * @returns The decorator to be applied to the target class.
       * @remarks
       * The decorator can be used to decorate a class, listing all of the classes dependencies.
       * Or it can be used to decorate a constructor paramter, indicating what to inject for that
       * parameter.
       * Or it can be used for a web component property, indicating what that property should resolve to.
       */
      inject(...dependencies) {
        return function(target2, key, descriptor) {
          if (typeof descriptor === "number") {
            const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target2);
            const dep = dependencies[0];
            if (dep !== void 0) {
              annotationParamtypes[descriptor] = dep;
            }
          } else if (key) {
            DI.defineProperty(target2, key, dependencies[0]);
          } else {
            const annotationParamtypes = descriptor ? DI.getOrCreateAnnotationParamTypes(descriptor.value) : DI.getOrCreateAnnotationParamTypes(target2);
            let dep;
            for (let i = 0; i < dependencies.length; ++i) {
              dep = dependencies[i];
              if (dep !== void 0) {
                annotationParamtypes[i] = dep;
              }
            }
          }
        };
      },
      /**
       * Registers the `target` class as a transient dependency; each time the dependency is resolved
       * a new instance will be created.
       *
       * @param target - The class / constructor function to register as transient.
       * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
       *
       * @example
       * On an existing class
       * ```ts
       * class Foo { }
       * DI.transient(Foo);
       * ```
       *
       * @example
       * Inline declaration
       *
       * ```ts
       * const Foo = DI.transient(class { });
       * // Foo is now strongly typed with register
       * Foo.register(container);
       * ```
       *
       * @public
       */
      transient(target2) {
        target2.register = function register(container) {
          const registration = Registration.transient(target2, target2);
          return registration.register(container);
        };
        target2.registerInRequestor = false;
        return target2;
      },
      /**
       * Registers the `target` class as a singleton dependency; the class will only be created once. Each
       * consecutive time the dependency is resolved, the same instance will be returned.
       *
       * @param target - The class / constructor function to register as a singleton.
       * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
       * @example
       * On an existing class
       * ```ts
       * class Foo { }
       * DI.singleton(Foo);
       * ```
       *
       * @example
       * Inline declaration
       * ```ts
       * const Foo = DI.singleton(class { });
       * // Foo is now strongly typed with register
       * Foo.register(container);
       * ```
       *
       * @public
       */
      singleton(target2, options = defaultSingletonOptions) {
        target2.register = function register(container) {
          const registration = Registration.singleton(target2, target2);
          return registration.register(container);
        };
        target2.registerInRequestor = options.scoped;
        return target2;
      }
    });
    Container = DI.createInterface("Container");
    inject = DI.inject;
    defaultSingletonOptions = { scoped: false };
    all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));
    lazy = createResolver((key, handler, requestor) => {
      return () => requestor.get(key);
    });
    optional = createResolver((key, handler, requestor) => {
      if (requestor.has(key, true)) {
        return requestor.get(key);
      } else {
        return void 0;
      }
    });
    ignore.$isResolver = true;
    ignore.resolve = () => void 0;
    newInstanceForScope = createResolver((key, handler, requestor) => {
      const instance = createNewInstance(key, handler);
      const resolver = new ResolverImpl(key, 0, instance);
      requestor.registerResolver(key, resolver);
      return instance;
    });
    newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));
    ResolverImpl = class {
      constructor(key, strategy, state2) {
        this.key = key;
        this.strategy = strategy;
        this.state = state2;
        this.resolving = false;
      }
      get $isResolver() {
        return true;
      }
      register(container) {
        return container.registerResolver(this.key, this);
      }
      resolve(handler, requestor) {
        switch (this.strategy) {
          case 0:
            return this.state;
          case 1: {
            if (this.resolving) {
              throw new Error(`Cyclic dependency found: ${this.state.name}`);
            }
            this.resolving = true;
            this.state = handler.getFactory(this.state).construct(requestor);
            this.strategy = 0;
            this.resolving = false;
            return this.state;
          }
          case 2: {
            const factory = handler.getFactory(this.state);
            if (factory === null) {
              throw new Error(`Resolver for ${String(this.key)} returned a null factory`);
            }
            return factory.construct(requestor);
          }
          case 3:
            return this.state(handler, requestor, this);
          case 4:
            return this.state[0].resolve(handler, requestor);
          case 5:
            return requestor.get(this.state);
          default:
            throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);
        }
      }
      getFactory(container) {
        var _a2, _b2, _c;
        switch (this.strategy) {
          case 1:
          case 2:
            return container.getFactory(this.state);
          case 5:
            return (_c = (_b2 = (_a2 = container.getResolver(this.state)) === null || _a2 === void 0 ? void 0 : _a2.getFactory) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, container)) !== null && _c !== void 0 ? _c : null;
          default:
            return null;
        }
      }
    };
    FactoryImpl = class {
      constructor(Type, dependencies) {
        this.Type = Type;
        this.dependencies = dependencies;
        this.transformers = null;
      }
      construct(container, dynamicDependencies) {
        let instance;
        if (dynamicDependencies === void 0) {
          instance = new this.Type(...this.dependencies.map(containerGetKey, container));
        } else {
          instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
        }
        if (this.transformers == null) {
          return instance;
        }
        return this.transformers.reduce(transformInstance, instance);
      }
      registerTransformer(transformer) {
        (this.transformers || (this.transformers = [])).push(transformer);
      }
    };
    containerResolver = {
      $isResolver: true,
      resolve(handler, requestor) {
        return requestor;
      }
    };
    InstrinsicTypeNames = /* @__PURE__ */ new Set([
      "Array",
      "ArrayBuffer",
      "Boolean",
      "DataView",
      "Date",
      "Error",
      "EvalError",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Number",
      "Object",
      "Promise",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "Set",
      "SharedArrayBuffer",
      "String",
      "SyntaxError",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "URIError",
      "WeakMap",
      "WeakSet"
    ]);
    DILocateParentEventType = "__DI_LOCATE_PARENT__";
    factories = /* @__PURE__ */ new Map();
    ContainerImpl = class {
      constructor(owner, config) {
        this.owner = owner;
        this.config = config;
        this._parent = void 0;
        this.registerDepth = 0;
        this.context = null;
        if (owner !== null) {
          owner.$$container$$ = this;
        }
        this.resolvers = /* @__PURE__ */ new Map();
        this.resolvers.set(Container, containerResolver);
        if (owner instanceof Node) {
          owner.addEventListener(DILocateParentEventType, (e) => {
            if (e.composedPath()[0] !== this.owner) {
              e.detail.container = this;
              e.stopImmediatePropagation();
            }
          });
        }
      }
      get parent() {
        if (this._parent === void 0) {
          this._parent = this.config.parentLocator(this.owner);
        }
        return this._parent;
      }
      get depth() {
        return this.parent === null ? 0 : this.parent.depth + 1;
      }
      get responsibleForOwnerRequests() {
        return this.config.responsibleForOwnerRequests;
      }
      registerWithContext(context, ...params) {
        this.context = context;
        this.register(...params);
        this.context = null;
        return this;
      }
      register(...params) {
        if (++this.registerDepth === 100) {
          throw new Error("Unable to autoregister dependency");
        }
        let current;
        let keys;
        let value;
        let j;
        let jj;
        const context = this.context;
        for (let i = 0, ii = params.length; i < ii; ++i) {
          current = params[i];
          if (!isObject(current)) {
            continue;
          }
          if (isRegistry(current)) {
            current.register(this, context);
          } else if (isClass(current)) {
            Registration.singleton(current, current).register(this);
          } else {
            keys = Object.keys(current);
            j = 0;
            jj = keys.length;
            for (; j < jj; ++j) {
              value = current[keys[j]];
              if (!isObject(value)) {
                continue;
              }
              if (isRegistry(value)) {
                value.register(this, context);
              } else {
                this.register(value);
              }
            }
          }
        }
        --this.registerDepth;
        return this;
      }
      registerResolver(key, resolver) {
        validateKey(key);
        const resolvers = this.resolvers;
        const result = resolvers.get(key);
        if (result == null) {
          resolvers.set(key, resolver);
        } else if (result instanceof ResolverImpl && result.strategy === 4) {
          result.state.push(resolver);
        } else {
          resolvers.set(key, new ResolverImpl(key, 4, [result, resolver]));
        }
        return resolver;
      }
      registerTransformer(key, transformer) {
        const resolver = this.getResolver(key);
        if (resolver == null) {
          return false;
        }
        if (resolver.getFactory) {
          const factory = resolver.getFactory(this);
          if (factory == null) {
            return false;
          }
          factory.registerTransformer(transformer);
          return true;
        }
        return false;
      }
      getResolver(key, autoRegister = true) {
        validateKey(key);
        if (key.resolve !== void 0) {
          return key;
        }
        let current = this;
        let resolver;
        while (current != null) {
          resolver = current.resolvers.get(key);
          if (resolver == null) {
            if (current.parent == null) {
              const handler = isRegisterInRequester(key) ? this : current;
              return autoRegister ? this.jitRegister(key, handler) : null;
            }
            current = current.parent;
          } else {
            return resolver;
          }
        }
        return null;
      }
      has(key, searchAncestors = false) {
        return this.resolvers.has(key) ? true : searchAncestors && this.parent != null ? this.parent.has(key, true) : false;
      }
      get(key) {
        validateKey(key);
        if (key.$isResolver) {
          return key.resolve(this, this);
        }
        let current = this;
        let resolver;
        while (current != null) {
          resolver = current.resolvers.get(key);
          if (resolver == null) {
            if (current.parent == null) {
              const handler = isRegisterInRequester(key) ? this : current;
              resolver = this.jitRegister(key, handler);
              return resolver.resolve(current, this);
            }
            current = current.parent;
          } else {
            return resolver.resolve(current, this);
          }
        }
        throw new Error(`Unable to resolve key: ${key}`);
      }
      getAll(key, searchAncestors = false) {
        validateKey(key);
        const requestor = this;
        let current = requestor;
        let resolver;
        if (searchAncestors) {
          let resolutions = emptyArray;
          while (current != null) {
            resolver = current.resolvers.get(key);
            if (resolver != null) {
              resolutions = resolutions.concat(
                /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
                buildAllResponse(resolver, current, requestor)
              );
            }
            current = current.parent;
          }
          return resolutions;
        } else {
          while (current != null) {
            resolver = current.resolvers.get(key);
            if (resolver == null) {
              current = current.parent;
              if (current == null) {
                return emptyArray;
              }
            } else {
              return buildAllResponse(resolver, current, requestor);
            }
          }
        }
        return emptyArray;
      }
      getFactory(Type) {
        let factory = factories.get(Type);
        if (factory === void 0) {
          if (isNativeFunction(Type)) {
            throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);
          }
          factories.set(Type, factory = new FactoryImpl(Type, DI.getDependencies(Type)));
        }
        return factory;
      }
      registerFactory(key, factory) {
        factories.set(key, factory);
      }
      createChild(config) {
        return new ContainerImpl(null, Object.assign({}, this.config, config, { parentLocator: () => this }));
      }
      jitRegister(keyAsValue, handler) {
        if (typeof keyAsValue !== "function") {
          throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);
        }
        if (InstrinsicTypeNames.has(keyAsValue.name)) {
          throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);
        }
        if (isRegistry(keyAsValue)) {
          const registrationResolver = keyAsValue.register(handler);
          if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
            const newResolver = handler.resolvers.get(keyAsValue);
            if (newResolver != void 0) {
              return newResolver;
            }
            throw new Error("A valid resolver was not returned from the static register method");
          }
          return registrationResolver;
        } else if (keyAsValue.$isInterface) {
          throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);
        } else {
          const resolver = this.config.defaultResolver(keyAsValue, handler);
          handler.resolvers.set(keyAsValue, resolver);
          return resolver;
        }
      }
    };
    cache = /* @__PURE__ */ new WeakMap();
    Registration = Object.freeze({
      /**
       * Allows you to pass an instance.
       * Every time you request this {@link Key} you will get this instance back.
       *
       * @example
       * ```
       * Registration.instance(Foo, new Foo()));
       * ```
       *
       * @param key - The key to register the instance under.
       * @param value - The instance to return when the key is requested.
       */
      instance(key, value) {
        return new ResolverImpl(key, 0, value);
      },
      /**
       * Creates an instance from the class.
       * Every time you request this {@link Key} you will get the same one back.
       *
       * @example
       * ```
       * Registration.singleton(Foo, Foo);
       * ```
       *
       * @param key - The key to register the singleton under.
       * @param value - The class to instantiate as a singleton when first requested.
       */
      singleton(key, value) {
        return new ResolverImpl(key, 1, value);
      },
      /**
       * Creates an instance from a class.
       * Every time you request this {@link Key} you will get a new instance.
       *
       * @example
       * ```
       * Registration.instance(Foo, Foo);
       * ```
       *
       * @param key - The key to register the instance type under.
       * @param value - The class to instantiate each time the key is requested.
       */
      transient(key, value) {
        return new ResolverImpl(key, 2, value);
      },
      /**
       * Delegates to a callback function to provide the dependency.
       * Every time you request this {@link Key} the callback will be invoked to provide
       * the dependency.
       *
       * @example
       * ```
       * Registration.callback(Foo, () => new Foo());
       * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));
       * ```
       *
       * @param key - The key to register the callback for.
       * @param callback - The function that is expected to return the dependency.
       */
      callback(key, callback) {
        return new ResolverImpl(key, 3, callback);
      },
      /**
       * Delegates to a callback function to provide the dependency and then caches the
       * dependency for future requests.
       *
       * @example
       * ```
       * Registration.cachedCallback(Foo, () => new Foo());
       * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));
       * ```
       *
       * @param key - The key to register the callback for.
       * @param callback - The function that is expected to return the dependency.
       * @remarks
       * If you pass the same Registration to another container, the same cached value will be used.
       * Should all references to the resolver returned be removed, the cache will expire.
       */
      cachedCallback(key, callback) {
        return new ResolverImpl(key, 3, cacheCallbackResult(callback));
      },
      /**
       * Creates an alternate {@link Key} to retrieve an instance by.
       *
       * @example
       * ```
       * Register.singleton(Foo, Foo)
       * Register.aliasTo(Foo, MyFoos);
       *
       * container.getAll(MyFoos) // contains an instance of Foo
       * ```
       *
       * @param originalKey - The original key that has been registered.
       * @param aliasKey - The alias to the original key.
       */
      aliasTo(originalKey, aliasKey) {
        return new ResolverImpl(aliasKey, 5, originalKey);
      }
    });
    defaultFriendlyName = "(anonymous)";
    isNativeFunction = function() {
      const lookup = /* @__PURE__ */ new WeakMap();
      let isNative = false;
      let sourceText = "";
      let i = 0;
      return function(fn) {
        isNative = lookup.get(fn);
        if (isNative === void 0) {
          sourceText = fn.toString();
          i = sourceText.length;
          isNative = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string
          i >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.
          i <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?
          sourceText.charCodeAt(i - 1) === 125 && // }
          // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.
          sourceText.charCodeAt(i - 2) <= 32 && // whitespace
          sourceText.charCodeAt(i - 3) === 93 && // ]
          sourceText.charCodeAt(i - 4) === 101 && // e
          sourceText.charCodeAt(i - 5) === 100 && // d
          sourceText.charCodeAt(i - 6) === 111 && // o
          sourceText.charCodeAt(i - 7) === 99 && // c
          sourceText.charCodeAt(i - 8) === 32 && //
          sourceText.charCodeAt(i - 9) === 101 && // e
          sourceText.charCodeAt(i - 10) === 118 && // v
          sourceText.charCodeAt(i - 11) === 105 && // i
          sourceText.charCodeAt(i - 12) === 116 && // t
          sourceText.charCodeAt(i - 13) === 97 && // a
          sourceText.charCodeAt(i - 14) === 110 && // n
          sourceText.charCodeAt(i - 15) === 88;
          lookup.set(fn, isNative);
        }
        return isNative;
      };
    }();
    isNumericLookup = {};
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/design-system/component-presentation.js
function presentationKeyFromTag(tagName) {
  return `${tagName.toLowerCase()}:presentation`;
}
var presentationRegistry, ComponentPresentation, DefaultComponentPresentation;
var init_component_presentation = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/design-system/component-presentation.js"() {
    init_esm();
    init_di();
    presentationRegistry = /* @__PURE__ */ new Map();
    ComponentPresentation = Object.freeze({
      /**
       * Defines a component presentation for an element.
       * @param tagName - The element name to define the presentation for.
       * @param presentation - The presentation that will be applied to matching elements.
       * @param container - The dependency injection container to register the configuration in.
       * @public
       */
      define(tagName, presentation, container) {
        const key = presentationKeyFromTag(tagName);
        const existing = presentationRegistry.get(key);
        if (existing === void 0) {
          presentationRegistry.set(key, presentation);
        } else {
          presentationRegistry.set(key, false);
        }
        container.register(Registration.instance(key, presentation));
      },
      /**
       * Finds a component presentation for the specified element name,
       * searching the DOM hierarchy starting from the provided element.
       * @param tagName - The name of the element to locate the presentation for.
       * @param element - The element to begin the search from.
       * @returns The component presentation or null if none is found.
       * @public
       */
      forTag(tagName, element) {
        const key = presentationKeyFromTag(tagName);
        const existing = presentationRegistry.get(key);
        if (existing === false) {
          const container = DI.findResponsibleContainer(element);
          return container.get(key);
        }
        return existing || null;
      }
    });
    DefaultComponentPresentation = class {
      /**
       * Creates an instance of DefaultComponentPresentation.
       * @param template - The template to apply to the element.
       * @param styles - The styles to apply to the element.
       * @public
       */
      constructor(template, styles22) {
        this.template = template || null;
        this.styles = styles22 === void 0 ? null : Array.isArray(styles22) ? ElementStyles.create(styles22) : styles22 instanceof ElementStyles ? styles22 : ElementStyles.create([styles22]);
      }
      /**
       * Applies the presentation details to the specified element.
       * @param element - The element to apply the presentation details to.
       * @public
       */
      applyTo(element) {
        const controller = element.$fastController;
        if (controller.template === null) {
          controller.template = this.template;
        }
        if (controller.styles === null) {
          controller.styles = this.styles;
        }
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/foundation-element.js
function resolveOption(option, context, definition) {
  if (typeof option === "function") {
    return option(context, definition);
  }
  return option;
}
var FoundationElement, FoundationElementRegistry;
var init_foundation_element = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/foundation-element.js"() {
    init_tslib_es62();
    init_esm();
    init_component_presentation();
    FoundationElement = class extends FASTElement {
      constructor() {
        super(...arguments);
        this._presentation = void 0;
      }
      /**
       * A property which resolves the ComponentPresentation instance
       * for the current component.
       * @public
       */
      get $presentation() {
        if (this._presentation === void 0) {
          this._presentation = ComponentPresentation.forTag(this.tagName, this);
        }
        return this._presentation;
      }
      templateChanged() {
        if (this.template !== void 0) {
          this.$fastController.template = this.template;
        }
      }
      stylesChanged() {
        if (this.styles !== void 0) {
          this.$fastController.styles = this.styles;
        }
      }
      /**
       * The connected callback for this FASTElement.
       * @remarks
       * This method is invoked by the platform whenever this FoundationElement
       * becomes connected to the document.
       * @public
       */
      connectedCallback() {
        if (this.$presentation !== null) {
          this.$presentation.applyTo(this);
        }
        super.connectedCallback();
      }
      /**
       * Defines an element registry function with a set of element definition defaults.
       * @param elementDefinition - The definition of the element to create the registry
       * function for.
       * @public
       */
      static compose(elementDefinition) {
        return (overrideDefinition = {}) => new FoundationElementRegistry(this === FoundationElement ? class extends FoundationElement {
        } : this, elementDefinition, overrideDefinition);
      }
    };
    __decorate5([
      observable
    ], FoundationElement.prototype, "template", void 0);
    __decorate5([
      observable
    ], FoundationElement.prototype, "styles", void 0);
    FoundationElementRegistry = class {
      constructor(type, elementDefinition, overrideDefinition) {
        this.type = type;
        this.elementDefinition = elementDefinition;
        this.overrideDefinition = overrideDefinition;
        this.definition = Object.assign(Object.assign({}, this.elementDefinition), this.overrideDefinition);
      }
      register(container, context) {
        const definition = this.definition;
        const overrideDefinition = this.overrideDefinition;
        const prefix = definition.prefix || context.elementPrefix;
        const name = `${prefix}-${definition.baseName}`;
        context.tryDefineElement({
          name,
          type: this.type,
          baseClass: this.elementDefinition.baseClass,
          callback: (x) => {
            const presentation = new DefaultComponentPresentation(resolveOption(definition.template, x, definition), resolveOption(definition.styles, x, definition));
            x.definePresentation(presentation);
            let shadowOptions = resolveOption(definition.shadowOptions, x, definition);
            if (x.shadowRootMode) {
              if (shadowOptions) {
                if (!overrideDefinition.shadowOptions) {
                  shadowOptions.mode = x.shadowRootMode;
                }
              } else if (shadowOptions !== null) {
                shadowOptions = { mode: x.shadowRootMode };
              }
            }
            x.defineElement({
              elementOptions: resolveOption(definition.elementOptions, x, definition),
              shadowOptions,
              attributes: resolveOption(definition.attributes, x, definition)
            });
          }
        });
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/apply-mixins.js
function applyMixins(derivedCtor, ...baseCtors) {
  const derivedAttributes = AttributeConfiguration.locate(derivedCtor);
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      if (name !== "constructor") {
        Object.defineProperty(
          derivedCtor.prototype,
          name,
          /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
          Object.getOwnPropertyDescriptor(baseCtor.prototype, name)
        );
      }
    });
    const baseAttributes = AttributeConfiguration.locate(baseCtor);
    baseAttributes.forEach((x) => derivedAttributes.push(x));
  });
}
var init_apply_mixins = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/apply-mixins.js"() {
    init_esm();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.js
var AccordionItem;
var init_accordion_item = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/accordion-item.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    init_start_end();
    init_apply_mixins();
    AccordionItem = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.headinglevel = 2;
        this.expanded = false;
        this.clickHandler = (e) => {
          this.expanded = !this.expanded;
          this.change();
        };
        this.change = () => {
          this.$emit("change");
        };
      }
    };
    __decorate5([
      attr({
        attribute: "heading-level",
        mode: "fromView",
        converter: nullableNumberConverter
      })
    ], AccordionItem.prototype, "headinglevel", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], AccordionItem.prototype, "expanded", void 0);
    __decorate5([
      attr
    ], AccordionItem.prototype, "id", void 0);
    applyMixins(AccordionItem, StartEnd);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/index.js
var init_accordion_item2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/accordion-item/index.js"() {
    init_accordion_item_template();
    init_accordion_item();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.template.js
var accordionTemplate;
var init_accordion_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.template.js"() {
    init_esm();
    accordionTemplate = (context, definition) => (
      /* TODO: deprecate slot name `item` to only support default slot https://github.com/microsoft/fast/issues/5515 */
      html2`
    <template>
        <slot ${slotted({ property: "accordionItems", filter: elements() })}></slot>
        <slot name="item" part="item" ${slotted("accordionItems")}></slot>
    </template>
`
    );
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/aria.js
var Orientation;
var init_aria = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/aria.js"() {
    Orientation = {
      horizontal: "horizontal",
      vertical: "vertical"
    };
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/array.js
function findLastIndex(array, predicate) {
  let k = array.length;
  while (k--) {
    if (predicate(array[k], k, array)) {
      return k;
    }
  }
  return -1;
}
var init_array = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/array.js"() {
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/class-names.js
var init_class_names = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/class-names.js"() {
  }
});

// node_modules/exenv-es6/dist/can-use-dom.js
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var init_can_use_dom = __esm({
  "node_modules/exenv-es6/dist/can-use-dom.js"() {
  }
});

// node_modules/exenv-es6/dist/can-use-event-listeners.js
var init_can_use_event_listeners = __esm({
  "node_modules/exenv-es6/dist/can-use-event-listeners.js"() {
    init_can_use_dom();
  }
});

// node_modules/exenv-es6/dist/can-use-viewport.js
var init_can_use_viewport = __esm({
  "node_modules/exenv-es6/dist/can-use-viewport.js"() {
    init_can_use_dom();
  }
});

// node_modules/exenv-es6/dist/can-use-workers.js
var init_can_use_workers = __esm({
  "node_modules/exenv-es6/dist/can-use-workers.js"() {
  }
});

// node_modules/exenv-es6/dist/index.js
var init_dist = __esm({
  "node_modules/exenv-es6/dist/index.js"() {
    init_can_use_dom();
    init_can_use_event_listeners();
    init_can_use_viewport();
    init_can_use_workers();
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/dom.js
function isHTMLElement(...args) {
  return args.every((arg) => arg instanceof HTMLElement);
}
function getDisplayedNodes(rootNode, selector) {
  if (!rootNode || !selector || !isHTMLElement(rootNode)) {
    return;
  }
  const nodes = Array.from(rootNode.querySelectorAll(selector));
  return nodes.filter((node) => node.offsetParent !== null);
}
function getNonce() {
  const node = document.querySelector('meta[property="csp-nonce"]');
  if (node) {
    return node.getAttribute("content");
  } else {
    return null;
  }
}
function canUseFocusVisible() {
  if (typeof _canUseFocusVisible === "boolean") {
    return _canUseFocusVisible;
  }
  if (!canUseDOM()) {
    _canUseFocusVisible = false;
    return _canUseFocusVisible;
  }
  const styleElement = document.createElement("style");
  const styleNonce = getNonce();
  if (styleNonce !== null) {
    styleElement.setAttribute("nonce", styleNonce);
  }
  document.head.appendChild(styleElement);
  try {
    styleElement.sheet.insertRule("foo:focus-visible {color:inherit}", 0);
    _canUseFocusVisible = true;
  } catch (e) {
    _canUseFocusVisible = false;
  } finally {
    document.head.removeChild(styleElement);
  }
  return _canUseFocusVisible;
}
var _canUseFocusVisible;
var init_dom2 = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/dom.js"() {
    init_dist();
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/events.js
var eventFocus, eventFocusIn, eventFocusOut, eventKeyDown, eventResize, eventScroll;
var init_events = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/events.js"() {
    eventFocus = "focus";
    eventFocusIn = "focusin";
    eventFocusOut = "focusout";
    eventKeyDown = "keydown";
    eventResize = "resize";
    eventScroll = "scroll";
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/html.js
var init_html = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/html.js"() {
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/key-codes.js
var KeyCodes, keyArrowDown, keyArrowLeft, keyArrowRight, keyArrowUp, keyEnter, keyEscape, keyHome, keyEnd, keyFunction2, keyPageDown, keyPageUp, keySpace, keyTab, keyBackspace, keyDelete, ArrowKeys;
var init_key_codes = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/key-codes.js"() {
    (function(KeyCodes2) {
      KeyCodes2[KeyCodes2["alt"] = 18] = "alt";
      KeyCodes2[KeyCodes2["arrowDown"] = 40] = "arrowDown";
      KeyCodes2[KeyCodes2["arrowLeft"] = 37] = "arrowLeft";
      KeyCodes2[KeyCodes2["arrowRight"] = 39] = "arrowRight";
      KeyCodes2[KeyCodes2["arrowUp"] = 38] = "arrowUp";
      KeyCodes2[KeyCodes2["back"] = 8] = "back";
      KeyCodes2[KeyCodes2["backSlash"] = 220] = "backSlash";
      KeyCodes2[KeyCodes2["break"] = 19] = "break";
      KeyCodes2[KeyCodes2["capsLock"] = 20] = "capsLock";
      KeyCodes2[KeyCodes2["closeBracket"] = 221] = "closeBracket";
      KeyCodes2[KeyCodes2["colon"] = 186] = "colon";
      KeyCodes2[KeyCodes2["colon2"] = 59] = "colon2";
      KeyCodes2[KeyCodes2["comma"] = 188] = "comma";
      KeyCodes2[KeyCodes2["ctrl"] = 17] = "ctrl";
      KeyCodes2[KeyCodes2["delete"] = 46] = "delete";
      KeyCodes2[KeyCodes2["end"] = 35] = "end";
      KeyCodes2[KeyCodes2["enter"] = 13] = "enter";
      KeyCodes2[KeyCodes2["equals"] = 187] = "equals";
      KeyCodes2[KeyCodes2["equals2"] = 61] = "equals2";
      KeyCodes2[KeyCodes2["equals3"] = 107] = "equals3";
      KeyCodes2[KeyCodes2["escape"] = 27] = "escape";
      KeyCodes2[KeyCodes2["forwardSlash"] = 191] = "forwardSlash";
      KeyCodes2[KeyCodes2["function1"] = 112] = "function1";
      KeyCodes2[KeyCodes2["function10"] = 121] = "function10";
      KeyCodes2[KeyCodes2["function11"] = 122] = "function11";
      KeyCodes2[KeyCodes2["function12"] = 123] = "function12";
      KeyCodes2[KeyCodes2["function2"] = 113] = "function2";
      KeyCodes2[KeyCodes2["function3"] = 114] = "function3";
      KeyCodes2[KeyCodes2["function4"] = 115] = "function4";
      KeyCodes2[KeyCodes2["function5"] = 116] = "function5";
      KeyCodes2[KeyCodes2["function6"] = 117] = "function6";
      KeyCodes2[KeyCodes2["function7"] = 118] = "function7";
      KeyCodes2[KeyCodes2["function8"] = 119] = "function8";
      KeyCodes2[KeyCodes2["function9"] = 120] = "function9";
      KeyCodes2[KeyCodes2["home"] = 36] = "home";
      KeyCodes2[KeyCodes2["insert"] = 45] = "insert";
      KeyCodes2[KeyCodes2["menu"] = 93] = "menu";
      KeyCodes2[KeyCodes2["minus"] = 189] = "minus";
      KeyCodes2[KeyCodes2["minus2"] = 109] = "minus2";
      KeyCodes2[KeyCodes2["numLock"] = 144] = "numLock";
      KeyCodes2[KeyCodes2["numPad0"] = 96] = "numPad0";
      KeyCodes2[KeyCodes2["numPad1"] = 97] = "numPad1";
      KeyCodes2[KeyCodes2["numPad2"] = 98] = "numPad2";
      KeyCodes2[KeyCodes2["numPad3"] = 99] = "numPad3";
      KeyCodes2[KeyCodes2["numPad4"] = 100] = "numPad4";
      KeyCodes2[KeyCodes2["numPad5"] = 101] = "numPad5";
      KeyCodes2[KeyCodes2["numPad6"] = 102] = "numPad6";
      KeyCodes2[KeyCodes2["numPad7"] = 103] = "numPad7";
      KeyCodes2[KeyCodes2["numPad8"] = 104] = "numPad8";
      KeyCodes2[KeyCodes2["numPad9"] = 105] = "numPad9";
      KeyCodes2[KeyCodes2["numPadDivide"] = 111] = "numPadDivide";
      KeyCodes2[KeyCodes2["numPadDot"] = 110] = "numPadDot";
      KeyCodes2[KeyCodes2["numPadMinus"] = 109] = "numPadMinus";
      KeyCodes2[KeyCodes2["numPadMultiply"] = 106] = "numPadMultiply";
      KeyCodes2[KeyCodes2["numPadPlus"] = 107] = "numPadPlus";
      KeyCodes2[KeyCodes2["openBracket"] = 219] = "openBracket";
      KeyCodes2[KeyCodes2["pageDown"] = 34] = "pageDown";
      KeyCodes2[KeyCodes2["pageUp"] = 33] = "pageUp";
      KeyCodes2[KeyCodes2["period"] = 190] = "period";
      KeyCodes2[KeyCodes2["print"] = 44] = "print";
      KeyCodes2[KeyCodes2["quote"] = 222] = "quote";
      KeyCodes2[KeyCodes2["scrollLock"] = 145] = "scrollLock";
      KeyCodes2[KeyCodes2["shift"] = 16] = "shift";
      KeyCodes2[KeyCodes2["space"] = 32] = "space";
      KeyCodes2[KeyCodes2["tab"] = 9] = "tab";
      KeyCodes2[KeyCodes2["tilde"] = 192] = "tilde";
      KeyCodes2[KeyCodes2["windowsLeft"] = 91] = "windowsLeft";
      KeyCodes2[KeyCodes2["windowsOpera"] = 219] = "windowsOpera";
      KeyCodes2[KeyCodes2["windowsRight"] = 92] = "windowsRight";
    })(KeyCodes || (KeyCodes = {}));
    keyArrowDown = "ArrowDown";
    keyArrowLeft = "ArrowLeft";
    keyArrowRight = "ArrowRight";
    keyArrowUp = "ArrowUp";
    keyEnter = "Enter";
    keyEscape = "Escape";
    keyHome = "Home";
    keyEnd = "End";
    keyFunction2 = "F2";
    keyPageDown = "PageDown";
    keyPageUp = "PageUp";
    keySpace = " ";
    keyTab = "Tab";
    keyBackspace = "Backspace";
    keyDelete = "Delete";
    ArrowKeys = {
      ArrowDown: keyArrowDown,
      ArrowLeft: keyArrowLeft,
      ArrowRight: keyArrowRight,
      ArrowUp: keyArrowUp
    };
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/localization.js
var Direction;
var init_localization = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/localization.js"() {
    (function(Direction2) {
      Direction2["ltr"] = "ltr";
      Direction2["rtl"] = "rtl";
    })(Direction || (Direction = {}));
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/numbers.js
function wrapInBounds(min, max, value) {
  if (value < min) {
    return max;
  } else if (value > max) {
    return min;
  }
  return value;
}
function limit(min, max, value) {
  return Math.min(Math.max(value, min), max);
}
function inRange(value, min, max = 0) {
  [min, max] = [min, max].sort((a, b) => a - b);
  return min <= value && value < max;
}
var init_numbers = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/numbers.js"() {
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/strings.js
function uniqueId(prefix = "") {
  return `${prefix}${uniqueIdCounter++}`;
}
var uniqueIdCounter;
var init_strings = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/strings.js"() {
    uniqueIdCounter = 0;
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/query.js
var init_query = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/query.js"() {
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/rtl-scroll-converter.js
var RtlScrollConverter;
var init_rtl_scroll_converter = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/rtl-scroll-converter.js"() {
    init_dist();
    init_localization();
    RtlScrollConverter = class {
      /**
       *  Gets the scrollLeft value of the provided element
       */
      static getScrollLeft(scrolledElement, direction2) {
        if (direction2 === Direction.rtl) {
          return RtlScrollConverter.getRtlScrollLeftConverter(scrolledElement);
        }
        return scrolledElement.scrollLeft;
      }
      /**
       * Sets the scrollLeft value of the provided element
       */
      static setScrollLeft(scrolledElement, scrollValue, direction2) {
        if (direction2 === Direction.rtl) {
          RtlScrollConverter.setRtlScrollLeftConverter(scrolledElement, scrollValue);
          return;
        }
        scrolledElement.scrollLeft = scrollValue;
      }
      /**
       * The initial rtl scroll converter getter function, it calls the browser test to set the correct converter
       * functions and then invokes the getter
       */
      static initialGetRtlScrollConverter(scrolledElement) {
        RtlScrollConverter.initializeRtlScrollConverters();
        return RtlScrollConverter.getRtlScrollLeftConverter(scrolledElement);
      }
      /**
       * The "direct" rtl get scroll converter does not need to tamper with the scrollLeft
       * values as the browser is already doing the right thing.  Content start = 0 and
       * scrolling left goes negative.
       */
      static directGetRtlScrollConverter(scrolledElement) {
        return scrolledElement.scrollLeft;
      }
      /**
       * The "inverted" get scroll converter is used when the browser reports scroll left
       * as a positive maximum scroll value at content start and then goes to zero as content
       * is scrolled left
       */
      static invertedGetRtlScrollConverter(scrolledElement) {
        return -Math.abs(scrolledElement.scrollLeft);
      }
      /**
       * The "reverse" get scroll converter is used when the browser reports scroll left
       * as 0 at content start and then goes positive as content is scrolled left
       */
      static reverseGetRtlScrollConverter(scrolledElement) {
        return scrolledElement.scrollLeft - (scrolledElement.scrollWidth - scrolledElement.clientWidth);
      }
      /**
       * The initial rtl scroll converter setter function, it calls the browser test to set the correct converter
       * functions and then invokes the setter
       */
      static initialSetRtlScrollConverter(scrolledElement, newScrollValue) {
        RtlScrollConverter.initializeRtlScrollConverters();
        RtlScrollConverter.setRtlScrollLeftConverter(scrolledElement, newScrollValue);
      }
      /**
       * The "direct" rtl set scroll converter does not need to tamper with the scrollLeft
       * values as the browser is already doing the right thing.  Content start = 0 and
       * scrolling left goes negative.
       */
      static directSetRtlScrollConverter(scrolledElement, newScrollValue) {
        scrolledElement.scrollLeft = newScrollValue;
      }
      /**
       * The "inverted" set scroll converter is used when the browser reports scroll left
       * as a positive maximum scroll value at content start and then goes to zero as content
       * is scrolled left
       */
      static invertedSetRtlScrollConverter(scrolledElement, newScrollValue) {
        scrolledElement.scrollLeft = Math.abs(newScrollValue);
      }
      /**
       * The "reverse" set scroll converter is used when the browser reports scroll left
       * as 0 at content start and then goes positive as content is scrolled left
       */
      static reverseSetRtlScrollConverter(scrolledElement, newScrollValue) {
        const maxScroll = scrolledElement.scrollWidth - scrolledElement.clientWidth;
        scrolledElement.scrollLeft = maxScroll + newScrollValue;
      }
      /**
       * detects the appropriate rtl scroll converter functions and assigns them
       * should only run once
       */
      static initializeRtlScrollConverters() {
        if (!canUseDOM()) {
          RtlScrollConverter.applyDirectScrollConverters();
          return;
        }
        const testElement = RtlScrollConverter.getTestElement();
        document.body.appendChild(testElement);
        RtlScrollConverter.checkForScrollType(testElement);
        document.body.removeChild(testElement);
      }
      /**
       * checks the provided test element to determine scroll type
       * and apply appropriate converters
       */
      static checkForScrollType(testElement) {
        if (RtlScrollConverter.isReverse(testElement)) {
          RtlScrollConverter.applyReverseScrollConverters();
        } else {
          if (RtlScrollConverter.isDirect(testElement)) {
            RtlScrollConverter.applyDirectScrollConverters();
          } else {
            RtlScrollConverter.applyInvertedScrollConverters();
          }
        }
      }
      /**
       * checks test element initial state for rtl "reverse" mode
       */
      static isReverse(testElement) {
        return testElement.scrollLeft > 0;
      }
      /**
       * checks test element for rtl "direct" mode
       */
      static isDirect(testElement) {
        testElement.scrollLeft = -1;
        return testElement.scrollLeft < 0;
      }
      /**
       * apply direct scroll conververters
       */
      static applyDirectScrollConverters() {
        RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.directSetRtlScrollConverter;
        RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.directGetRtlScrollConverter;
      }
      /**
       * apply inverted scroll conververters
       */
      static applyInvertedScrollConverters() {
        RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.invertedSetRtlScrollConverter;
        RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.invertedGetRtlScrollConverter;
      }
      /**
       * apply reverse scroll conververters
       */
      static applyReverseScrollConverters() {
        RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.reverseSetRtlScrollConverter;
        RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.reverseGetRtlScrollConverter;
      }
      /**
       * generate a test element for rtl testing
       */
      static getTestElement() {
        const testElement = document.createElement("div");
        testElement.appendChild(document.createTextNode("ABCD"));
        testElement.dir = "rtl";
        testElement.style.fontSize = "14px";
        testElement.style.width = "4px";
        testElement.style.height = "1px";
        testElement.style.position = "absolute";
        testElement.style.top = "-1000px";
        testElement.style.overflow = "scroll";
        return testElement;
      }
    };
    RtlScrollConverter.getRtlScrollLeftConverter = RtlScrollConverter.initialGetRtlScrollConverter;
    RtlScrollConverter.setRtlScrollLeftConverter = RtlScrollConverter.initialSetRtlScrollConverter;
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/system-colors.js
var SystemColors;
var init_system_colors = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/system-colors.js"() {
    (function(SystemColors2) {
      SystemColors2["Canvas"] = "Canvas";
      SystemColors2["CanvasText"] = "CanvasText";
      SystemColors2["LinkText"] = "LinkText";
      SystemColors2["VisitedText"] = "VisitedText";
      SystemColors2["ActiveText"] = "ActiveText";
      SystemColors2["ButtonFace"] = "ButtonFace";
      SystemColors2["ButtonText"] = "ButtonText";
      SystemColors2["Field"] = "Field";
      SystemColors2["FieldText"] = "FieldText";
      SystemColors2["Highlight"] = "Highlight";
      SystemColors2["HighlightText"] = "HighlightText";
      SystemColors2["GrayText"] = "GrayText";
    })(SystemColors || (SystemColors = {}));
  }
});

// node_modules/@microsoft/fast-web-utilities/dist/index.js
var init_dist2 = __esm({
  "node_modules/@microsoft/fast-web-utilities/dist/index.js"() {
    init_aria();
    init_array();
    init_class_names();
    init_dom2();
    init_events();
    init_html();
    init_key_codes();
    init_localization();
    init_numbers();
    init_strings();
    init_query();
    init_rtl_scroll_converter();
    init_system_colors();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.js
var AccordionExpandMode, Accordion;
var init_accordion = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/accordion/accordion.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_accordion_item();
    AccordionExpandMode = {
      /**
       * Designates only a single {@link @microsoft/fast-foundation#(AccordionItem:class) } can be open a time.
       */
      single: "single",
      /**
       * Designates multiple {@link @microsoft/fast-foundation#(AccordionItem:class) | AccordionItems} can be open simultaneously.
       */
      multi: "multi"
    };
    Accordion = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.expandmode = AccordionExpandMode.multi;
        this.activeItemIndex = 0;
        this.change = () => {
          this.$emit("change", this.activeid);
        };
        this.setItems = () => {
          var _a2;
          if (this.accordionItems.length === 0) {
            return;
          }
          this.accordionIds = this.getItemIds();
          this.accordionItems.forEach((item, index) => {
            if (item instanceof AccordionItem) {
              item.addEventListener("change", this.activeItemChange);
              if (this.isSingleExpandMode()) {
                this.activeItemIndex !== index ? item.expanded = false : item.expanded = true;
              }
            }
            const itemId = this.accordionIds[index];
            item.setAttribute("id", typeof itemId !== "string" ? `accordion-${index + 1}` : itemId);
            this.activeid = this.accordionIds[this.activeItemIndex];
            item.addEventListener("keydown", this.handleItemKeyDown);
            item.addEventListener("focus", this.handleItemFocus);
          });
          if (this.isSingleExpandMode()) {
            const expandedItem = (_a2 = this.findExpandedItem()) !== null && _a2 !== void 0 ? _a2 : this.accordionItems[0];
            expandedItem.setAttribute("aria-disabled", "true");
          }
        };
        this.removeItemListeners = (oldValue) => {
          oldValue.forEach((item, index) => {
            item.removeEventListener("change", this.activeItemChange);
            item.removeEventListener("keydown", this.handleItemKeyDown);
            item.removeEventListener("focus", this.handleItemFocus);
          });
        };
        this.activeItemChange = (event) => {
          if (event.defaultPrevented || event.target !== event.currentTarget) {
            return;
          }
          event.preventDefault();
          const selectedItem = event.target;
          this.activeid = selectedItem.getAttribute("id");
          if (this.isSingleExpandMode()) {
            this.resetItems();
            selectedItem.expanded = true;
            selectedItem.setAttribute("aria-disabled", "true");
            this.accordionItems.forEach((item) => {
              if (!item.hasAttribute("disabled") && item.id !== this.activeid) {
                item.removeAttribute("aria-disabled");
              }
            });
          }
          this.activeItemIndex = Array.from(this.accordionItems).indexOf(selectedItem);
          this.change();
        };
        this.handleItemKeyDown = (event) => {
          if (event.target !== event.currentTarget) {
            return;
          }
          this.accordionIds = this.getItemIds();
          switch (event.key) {
            case keyArrowUp:
              event.preventDefault();
              this.adjust(-1);
              break;
            case keyArrowDown:
              event.preventDefault();
              this.adjust(1);
              break;
            case keyHome:
              this.activeItemIndex = 0;
              this.focusItem();
              break;
            case keyEnd:
              this.activeItemIndex = this.accordionItems.length - 1;
              this.focusItem();
              break;
          }
        };
        this.handleItemFocus = (event) => {
          if (event.target === event.currentTarget) {
            const focusedItem = event.target;
            const focusedIndex = this.activeItemIndex = Array.from(this.accordionItems).indexOf(focusedItem);
            if (this.activeItemIndex !== focusedIndex && focusedIndex !== -1) {
              this.activeItemIndex = focusedIndex;
              this.activeid = this.accordionIds[this.activeItemIndex];
            }
          }
        };
      }
      /**
       * @internal
       */
      accordionItemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.removeItemListeners(oldValue);
          this.setItems();
        }
      }
      findExpandedItem() {
        for (let item = 0; item < this.accordionItems.length; item++) {
          if (this.accordionItems[item].getAttribute("expanded") === "true") {
            return this.accordionItems[item];
          }
        }
        return null;
      }
      resetItems() {
        this.accordionItems.forEach((item, index) => {
          item.expanded = false;
        });
      }
      getItemIds() {
        return this.accordionItems.map((accordionItem) => {
          return accordionItem.getAttribute("id");
        });
      }
      isSingleExpandMode() {
        return this.expandmode === AccordionExpandMode.single;
      }
      adjust(adjustment) {
        this.activeItemIndex = wrapInBounds(0, this.accordionItems.length - 1, this.activeItemIndex + adjustment);
        this.focusItem();
      }
      focusItem() {
        const element = this.accordionItems[this.activeItemIndex];
        if (element instanceof AccordionItem) {
          element.expandbutton.focus();
        }
      }
    };
    __decorate5([
      attr({ attribute: "expand-mode" })
    ], Accordion.prototype, "expandmode", void 0);
    __decorate5([
      observable
    ], Accordion.prototype, "accordionItems", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/accordion/index.js
var init_accordion2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/accordion/index.js"() {
    init_accordion_template();
    init_accordion();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.template.js
var anchorTemplate;
var init_anchor_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.template.js"() {
    init_esm();
    init_start_end();
    anchorTemplate = (context, definition) => html2`
    <a
        class="control"
        part="control"
        download="${(x) => x.download}"
        href="${(x) => x.href}"
        hreflang="${(x) => x.hreflang}"
        ping="${(x) => x.ping}"
        referrerpolicy="${(x) => x.referrerpolicy}"
        rel="${(x) => x.rel}"
        target="${(x) => x.target}"
        type="${(x) => x.type}"
        aria-atomic="${(x) => x.ariaAtomic}"
        aria-busy="${(x) => x.ariaBusy}"
        aria-controls="${(x) => x.ariaControls}"
        aria-current="${(x) => x.ariaCurrent}"
        aria-describedby="${(x) => x.ariaDescribedby}"
        aria-details="${(x) => x.ariaDetails}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-errormessage="${(x) => x.ariaErrormessage}"
        aria-expanded="${(x) => x.ariaExpanded}"
        aria-flowto="${(x) => x.ariaFlowto}"
        aria-haspopup="${(x) => x.ariaHaspopup}"
        aria-hidden="${(x) => x.ariaHidden}"
        aria-invalid="${(x) => x.ariaInvalid}"
        aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
        aria-label="${(x) => x.ariaLabel}"
        aria-labelledby="${(x) => x.ariaLabelledby}"
        aria-live="${(x) => x.ariaLive}"
        aria-owns="${(x) => x.ariaOwns}"
        aria-relevant="${(x) => x.ariaRelevant}"
        aria-roledescription="${(x) => x.ariaRoledescription}"
        ${ref("control")}
    >
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endSlotTemplate(context, definition)}
    </a>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/patterns/aria-global.js
var ARIAGlobalStatesAndProperties;
var init_aria_global = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/patterns/aria-global.js"() {
    init_tslib_es62();
    init_esm();
    ARIAGlobalStatesAndProperties = class {
    };
    __decorate5([
      attr({ attribute: "aria-atomic" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaAtomic", void 0);
    __decorate5([
      attr({ attribute: "aria-busy" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaBusy", void 0);
    __decorate5([
      attr({ attribute: "aria-controls" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaControls", void 0);
    __decorate5([
      attr({ attribute: "aria-current" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaCurrent", void 0);
    __decorate5([
      attr({ attribute: "aria-describedby" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDescribedby", void 0);
    __decorate5([
      attr({ attribute: "aria-details" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDetails", void 0);
    __decorate5([
      attr({ attribute: "aria-disabled" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaDisabled", void 0);
    __decorate5([
      attr({ attribute: "aria-errormessage" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaErrormessage", void 0);
    __decorate5([
      attr({ attribute: "aria-flowto" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaFlowto", void 0);
    __decorate5([
      attr({ attribute: "aria-haspopup" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaHaspopup", void 0);
    __decorate5([
      attr({ attribute: "aria-hidden" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaHidden", void 0);
    __decorate5([
      attr({ attribute: "aria-invalid" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaInvalid", void 0);
    __decorate5([
      attr({ attribute: "aria-keyshortcuts" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaKeyshortcuts", void 0);
    __decorate5([
      attr({ attribute: "aria-label" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLabel", void 0);
    __decorate5([
      attr({ attribute: "aria-labelledby" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLabelledby", void 0);
    __decorate5([
      attr({ attribute: "aria-live" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaLive", void 0);
    __decorate5([
      attr({ attribute: "aria-owns" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaOwns", void 0);
    __decorate5([
      attr({ attribute: "aria-relevant" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaRelevant", void 0);
    __decorate5([
      attr({ attribute: "aria-roledescription" })
    ], ARIAGlobalStatesAndProperties.prototype, "ariaRoledescription", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/patterns/index.js
var init_patterns = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/patterns/index.js"() {
    init_aria_global();
    init_start_end();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.js
var Anchor, DelegatesARIALink;
var init_anchor = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/anchor/anchor.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    init_patterns();
    init_apply_mixins();
    Anchor = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.handleUnsupportedDelegatesFocus = () => {
          var _a2;
          if (window.ShadowRoot && !window.ShadowRoot.prototype.hasOwnProperty("delegatesFocus") && ((_a2 = this.$fastController.definition.shadowOptions) === null || _a2 === void 0 ? void 0 : _a2.delegatesFocus)) {
            this.focus = () => {
              this.control.focus();
            };
          }
        };
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.handleUnsupportedDelegatesFocus();
      }
    };
    __decorate5([
      attr
    ], Anchor.prototype, "download", void 0);
    __decorate5([
      attr
    ], Anchor.prototype, "href", void 0);
    __decorate5([
      attr
    ], Anchor.prototype, "hreflang", void 0);
    __decorate5([
      attr
    ], Anchor.prototype, "ping", void 0);
    __decorate5([
      attr
    ], Anchor.prototype, "referrerpolicy", void 0);
    __decorate5([
      attr
    ], Anchor.prototype, "rel", void 0);
    __decorate5([
      attr
    ], Anchor.prototype, "target", void 0);
    __decorate5([
      attr
    ], Anchor.prototype, "type", void 0);
    __decorate5([
      observable
    ], Anchor.prototype, "defaultSlottedContent", void 0);
    DelegatesARIALink = class {
    };
    __decorate5([
      attr({ attribute: "aria-expanded" })
    ], DelegatesARIALink.prototype, "ariaExpanded", void 0);
    applyMixins(DelegatesARIALink, ARIAGlobalStatesAndProperties);
    applyMixins(Anchor, StartEnd, DelegatesARIALink);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/anchor/index.js
var init_anchor2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/anchor/index.js"() {
    init_anchor_template();
    init_anchor();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.template.js
var anchoredRegionTemplate;
var init_anchored_region_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.template.js"() {
    init_esm();
    anchoredRegionTemplate = (context, definition) => html2`
    <template class="${(x) => x.initialLayoutComplete ? "loaded" : ""}">
        ${when((x) => x.initialLayoutComplete, html2`
                <slot></slot>
            `)}
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/direction.js
var getDirection;
var init_direction = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/direction.js"() {
    init_dist2();
    getDirection = (rootNode) => {
      const dirNode = rootNode.closest("[dir]");
      return dirNode !== null && dirNode.dir === "rtl" ? Direction.rtl : Direction.ltr;
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/intersection-service.js
var IntersectionService;
var init_intersection_service = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/intersection-service.js"() {
    init_esm();
    IntersectionService = class {
      constructor() {
        this.intersectionDetector = null;
        this.observedElements = /* @__PURE__ */ new Map();
        this.requestPosition = (target2, callback) => {
          var _a2;
          if (this.intersectionDetector === null) {
            return;
          }
          if (this.observedElements.has(target2)) {
            (_a2 = this.observedElements.get(target2)) === null || _a2 === void 0 ? void 0 : _a2.push(callback);
            return;
          }
          this.observedElements.set(target2, [callback]);
          this.intersectionDetector.observe(target2);
        };
        this.cancelRequestPosition = (target2, callback) => {
          const callbacks = this.observedElements.get(target2);
          if (callbacks !== void 0) {
            const callBackIndex = callbacks.indexOf(callback);
            if (callBackIndex !== -1) {
              callbacks.splice(callBackIndex, 1);
            }
          }
        };
        this.initializeIntersectionDetector = () => {
          if (!$global.IntersectionObserver) {
            return;
          }
          this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {
            root: null,
            rootMargin: "0px",
            threshold: [0, 1]
          });
        };
        this.handleIntersection = (entries) => {
          if (this.intersectionDetector === null) {
            return;
          }
          const pendingCallbacks = [];
          const pendingCallbackParams = [];
          entries.forEach((entry) => {
            var _a2;
            (_a2 = this.intersectionDetector) === null || _a2 === void 0 ? void 0 : _a2.unobserve(entry.target);
            const thisElementCallbacks = this.observedElements.get(entry.target);
            if (thisElementCallbacks !== void 0) {
              thisElementCallbacks.forEach((callback) => {
                let targetCallbackIndex = pendingCallbacks.indexOf(callback);
                if (targetCallbackIndex === -1) {
                  targetCallbackIndex = pendingCallbacks.length;
                  pendingCallbacks.push(callback);
                  pendingCallbackParams.push([]);
                }
                pendingCallbackParams[targetCallbackIndex].push(entry);
              });
              this.observedElements.delete(entry.target);
            }
          });
          pendingCallbacks.forEach((callback, index) => {
            callback(pendingCallbackParams[index]);
          });
        };
        this.initializeIntersectionDetector();
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.js
var AnchoredRegion;
var init_anchored_region = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_direction();
    init_intersection_service();
    AnchoredRegion = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.anchor = "";
        this.viewport = "";
        this.horizontalPositioningMode = "uncontrolled";
        this.horizontalDefaultPosition = "unset";
        this.horizontalViewportLock = false;
        this.horizontalInset = false;
        this.horizontalScaling = "content";
        this.verticalPositioningMode = "uncontrolled";
        this.verticalDefaultPosition = "unset";
        this.verticalViewportLock = false;
        this.verticalInset = false;
        this.verticalScaling = "content";
        this.fixedPlacement = false;
        this.autoUpdateMode = "anchor";
        this.anchorElement = null;
        this.viewportElement = null;
        this.initialLayoutComplete = false;
        this.resizeDetector = null;
        this.baseHorizontalOffset = 0;
        this.baseVerticalOffset = 0;
        this.pendingPositioningUpdate = false;
        this.pendingReset = false;
        this.currentDirection = Direction.ltr;
        this.regionVisible = false;
        this.forceUpdate = false;
        this.updateThreshold = 0.5;
        this.update = () => {
          if (!this.pendingPositioningUpdate) {
            this.requestPositionUpdates();
          }
        };
        this.startObservers = () => {
          this.stopObservers();
          if (this.anchorElement === null) {
            return;
          }
          this.requestPositionUpdates();
          if (this.resizeDetector !== null) {
            this.resizeDetector.observe(this.anchorElement);
            this.resizeDetector.observe(this);
          }
        };
        this.requestPositionUpdates = () => {
          if (this.anchorElement === null || this.pendingPositioningUpdate) {
            return;
          }
          AnchoredRegion.intersectionService.requestPosition(this, this.handleIntersection);
          AnchoredRegion.intersectionService.requestPosition(this.anchorElement, this.handleIntersection);
          if (this.viewportElement !== null) {
            AnchoredRegion.intersectionService.requestPosition(this.viewportElement, this.handleIntersection);
          }
          this.pendingPositioningUpdate = true;
        };
        this.stopObservers = () => {
          if (this.pendingPositioningUpdate) {
            this.pendingPositioningUpdate = false;
            AnchoredRegion.intersectionService.cancelRequestPosition(this, this.handleIntersection);
            if (this.anchorElement !== null) {
              AnchoredRegion.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection);
            }
            if (this.viewportElement !== null) {
              AnchoredRegion.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection);
            }
          }
          if (this.resizeDetector !== null) {
            this.resizeDetector.disconnect();
          }
        };
        this.getViewport = () => {
          if (typeof this.viewport !== "string" || this.viewport === "") {
            return document.documentElement;
          }
          return document.getElementById(this.viewport);
        };
        this.getAnchor = () => {
          return document.getElementById(this.anchor);
        };
        this.handleIntersection = (entries) => {
          if (!this.pendingPositioningUpdate) {
            return;
          }
          this.pendingPositioningUpdate = false;
          if (!this.applyIntersectionEntries(entries)) {
            return;
          }
          this.updateLayout();
        };
        this.applyIntersectionEntries = (entries) => {
          const regionEntry = entries.find((x) => x.target === this);
          const anchorEntry = entries.find((x) => x.target === this.anchorElement);
          const viewportEntry = entries.find((x) => x.target === this.viewportElement);
          if (regionEntry === void 0 || viewportEntry === void 0 || anchorEntry === void 0) {
            return false;
          }
          if (!this.regionVisible || this.forceUpdate || this.regionRect === void 0 || this.anchorRect === void 0 || this.viewportRect === void 0 || this.isRectDifferent(this.anchorRect, anchorEntry.boundingClientRect) || this.isRectDifferent(this.viewportRect, viewportEntry.boundingClientRect) || this.isRectDifferent(this.regionRect, regionEntry.boundingClientRect)) {
            this.regionRect = regionEntry.boundingClientRect;
            this.anchorRect = anchorEntry.boundingClientRect;
            if (this.viewportElement === document.documentElement) {
              this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x + document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y + document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);
            } else {
              this.viewportRect = viewportEntry.boundingClientRect;
            }
            this.updateRegionOffset();
            this.forceUpdate = false;
            return true;
          }
          return false;
        };
        this.updateRegionOffset = () => {
          if (this.anchorRect && this.regionRect) {
            this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorRect.left - this.regionRect.left) + (this.translateX - this.baseHorizontalOffset);
            this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorRect.top - this.regionRect.top) + (this.translateY - this.baseVerticalOffset);
          }
        };
        this.isRectDifferent = (rectA, rectB) => {
          if (Math.abs(rectA.top - rectB.top) > this.updateThreshold || Math.abs(rectA.right - rectB.right) > this.updateThreshold || Math.abs(rectA.bottom - rectB.bottom) > this.updateThreshold || Math.abs(rectA.left - rectB.left) > this.updateThreshold) {
            return true;
          }
          return false;
        };
        this.handleResize = (entries) => {
          this.update();
        };
        this.reset = () => {
          if (!this.pendingReset) {
            return;
          }
          this.pendingReset = false;
          if (this.anchorElement === null) {
            this.anchorElement = this.getAnchor();
          }
          if (this.viewportElement === null) {
            this.viewportElement = this.getViewport();
          }
          this.currentDirection = getDirection(this);
          this.startObservers();
        };
        this.updateLayout = () => {
          let desiredVerticalPosition = void 0;
          let desiredHorizontalPosition = void 0;
          if (this.horizontalPositioningMode !== "uncontrolled") {
            const horizontalOptions = this.getPositioningOptions(this.horizontalInset);
            if (this.horizontalDefaultPosition === "center") {
              desiredHorizontalPosition = "center";
            } else if (this.horizontalDefaultPosition !== "unset") {
              let dirCorrectedHorizontalDefaultPosition = this.horizontalDefaultPosition;
              if (dirCorrectedHorizontalDefaultPosition === "start" || dirCorrectedHorizontalDefaultPosition === "end") {
                const newDirection = getDirection(this);
                if (newDirection !== this.currentDirection) {
                  this.currentDirection = newDirection;
                  this.initialize();
                  return;
                }
                if (this.currentDirection === Direction.ltr) {
                  dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === "start" ? "left" : "right";
                } else {
                  dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === "start" ? "right" : "left";
                }
              }
              switch (dirCorrectedHorizontalDefaultPosition) {
                case "left":
                  desiredHorizontalPosition = this.horizontalInset ? "insetStart" : "start";
                  break;
                case "right":
                  desiredHorizontalPosition = this.horizontalInset ? "insetEnd" : "end";
                  break;
              }
            }
            const horizontalThreshold = this.horizontalThreshold !== void 0 ? this.horizontalThreshold : this.regionRect !== void 0 ? this.regionRect.width : 0;
            const anchorLeft = this.anchorRect !== void 0 ? this.anchorRect.left : 0;
            const anchorRight = this.anchorRect !== void 0 ? this.anchorRect.right : 0;
            const anchorWidth = this.anchorRect !== void 0 ? this.anchorRect.width : 0;
            const viewportLeft = this.viewportRect !== void 0 ? this.viewportRect.left : 0;
            const viewportRight = this.viewportRect !== void 0 ? this.viewportRect.right : 0;
            if (desiredHorizontalPosition === void 0 || !(this.horizontalPositioningMode === "locktodefault") && this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold) {
              desiredHorizontalPosition = this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) > this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) ? horizontalOptions[0] : horizontalOptions[1];
            }
          }
          if (this.verticalPositioningMode !== "uncontrolled") {
            const verticalOptions = this.getPositioningOptions(this.verticalInset);
            if (this.verticalDefaultPosition === "center") {
              desiredVerticalPosition = "center";
            } else if (this.verticalDefaultPosition !== "unset") {
              switch (this.verticalDefaultPosition) {
                case "top":
                  desiredVerticalPosition = this.verticalInset ? "insetStart" : "start";
                  break;
                case "bottom":
                  desiredVerticalPosition = this.verticalInset ? "insetEnd" : "end";
                  break;
              }
            }
            const verticalThreshold = this.verticalThreshold !== void 0 ? this.verticalThreshold : this.regionRect !== void 0 ? this.regionRect.height : 0;
            const anchorTop = this.anchorRect !== void 0 ? this.anchorRect.top : 0;
            const anchorBottom = this.anchorRect !== void 0 ? this.anchorRect.bottom : 0;
            const anchorHeight = this.anchorRect !== void 0 ? this.anchorRect.height : 0;
            const viewportTop = this.viewportRect !== void 0 ? this.viewportRect.top : 0;
            const viewportBottom = this.viewportRect !== void 0 ? this.viewportRect.bottom : 0;
            if (desiredVerticalPosition === void 0 || !(this.verticalPositioningMode === "locktodefault") && this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold) {
              desiredVerticalPosition = this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) > this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) ? verticalOptions[0] : verticalOptions[1];
            }
          }
          const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);
          const positionChanged = this.horizontalPosition !== desiredHorizontalPosition || this.verticalPosition !== desiredVerticalPosition;
          this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);
          this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);
          this.updateRegionStyle();
          if (!this.initialLayoutComplete) {
            this.initialLayoutComplete = true;
            this.requestPositionUpdates();
            return;
          }
          if (!this.regionVisible) {
            this.regionVisible = true;
            this.style.removeProperty("pointer-events");
            this.style.removeProperty("opacity");
            this.classList.toggle("loaded", true);
            this.$emit("loaded", this, { bubbles: false });
          }
          this.updatePositionClasses();
          if (positionChanged) {
            this.$emit("positionchange", this, { bubbles: false });
          }
        };
        this.updateRegionStyle = () => {
          this.style.width = this.regionWidth;
          this.style.height = this.regionHeight;
          this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;
        };
        this.updatePositionClasses = () => {
          this.classList.toggle("top", this.verticalPosition === "start");
          this.classList.toggle("bottom", this.verticalPosition === "end");
          this.classList.toggle("inset-top", this.verticalPosition === "insetStart");
          this.classList.toggle("inset-bottom", this.verticalPosition === "insetEnd");
          this.classList.toggle("vertical-center", this.verticalPosition === "center");
          this.classList.toggle("left", this.horizontalPosition === "start");
          this.classList.toggle("right", this.horizontalPosition === "end");
          this.classList.toggle("inset-left", this.horizontalPosition === "insetStart");
          this.classList.toggle("inset-right", this.horizontalPosition === "insetEnd");
          this.classList.toggle("horizontal-center", this.horizontalPosition === "center");
        };
        this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {
          if (desiredHorizontalPosition === void 0 || this.regionRect === void 0 || this.anchorRect === void 0 || this.viewportRect === void 0) {
            return;
          }
          let nextRegionWidth = 0;
          switch (this.horizontalScaling) {
            case "anchor":
            case "fill":
              nextRegionWidth = this.horizontalViewportLock ? this.viewportRect.width : nextPositionerDimension.width;
              this.regionWidth = `${nextRegionWidth}px`;
              break;
            case "content":
              nextRegionWidth = this.regionRect.width;
              this.regionWidth = "unset";
              break;
          }
          let sizeDelta = 0;
          switch (desiredHorizontalPosition) {
            case "start":
              this.translateX = this.baseHorizontalOffset - nextRegionWidth;
              if (this.horizontalViewportLock && this.anchorRect.left > this.viewportRect.right) {
                this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.right);
              }
              break;
            case "insetStart":
              this.translateX = this.baseHorizontalOffset - nextRegionWidth + this.anchorRect.width;
              if (this.horizontalViewportLock && this.anchorRect.right > this.viewportRect.right) {
                this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.right);
              }
              break;
            case "insetEnd":
              this.translateX = this.baseHorizontalOffset;
              if (this.horizontalViewportLock && this.anchorRect.left < this.viewportRect.left) {
                this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.left);
              }
              break;
            case "end":
              this.translateX = this.baseHorizontalOffset + this.anchorRect.width;
              if (this.horizontalViewportLock && this.anchorRect.right < this.viewportRect.left) {
                this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.left);
              }
              break;
            case "center":
              sizeDelta = (this.anchorRect.width - nextRegionWidth) / 2;
              this.translateX = this.baseHorizontalOffset + sizeDelta;
              if (this.horizontalViewportLock) {
                const regionLeft = this.anchorRect.left + sizeDelta;
                const regionRight = this.anchorRect.right - sizeDelta;
                if (regionLeft < this.viewportRect.left && !(regionRight > this.viewportRect.right)) {
                  this.translateX = this.translateX - (regionLeft - this.viewportRect.left);
                } else if (regionRight > this.viewportRect.right && !(regionLeft < this.viewportRect.left)) {
                  this.translateX = this.translateX - (regionRight - this.viewportRect.right);
                }
              }
              break;
          }
          this.horizontalPosition = desiredHorizontalPosition;
        };
        this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {
          if (desiredVerticalPosition === void 0 || this.regionRect === void 0 || this.anchorRect === void 0 || this.viewportRect === void 0) {
            return;
          }
          let nextRegionHeight = 0;
          switch (this.verticalScaling) {
            case "anchor":
            case "fill":
              nextRegionHeight = this.verticalViewportLock ? this.viewportRect.height : nextPositionerDimension.height;
              this.regionHeight = `${nextRegionHeight}px`;
              break;
            case "content":
              nextRegionHeight = this.regionRect.height;
              this.regionHeight = "unset";
              break;
          }
          let sizeDelta = 0;
          switch (desiredVerticalPosition) {
            case "start":
              this.translateY = this.baseVerticalOffset - nextRegionHeight;
              if (this.verticalViewportLock && this.anchorRect.top > this.viewportRect.bottom) {
                this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.bottom);
              }
              break;
            case "insetStart":
              this.translateY = this.baseVerticalOffset - nextRegionHeight + this.anchorRect.height;
              if (this.verticalViewportLock && this.anchorRect.bottom > this.viewportRect.bottom) {
                this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.bottom);
              }
              break;
            case "insetEnd":
              this.translateY = this.baseVerticalOffset;
              if (this.verticalViewportLock && this.anchorRect.top < this.viewportRect.top) {
                this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.top);
              }
              break;
            case "end":
              this.translateY = this.baseVerticalOffset + this.anchorRect.height;
              if (this.verticalViewportLock && this.anchorRect.bottom < this.viewportRect.top) {
                this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.top);
              }
              break;
            case "center":
              sizeDelta = (this.anchorRect.height - nextRegionHeight) / 2;
              this.translateY = this.baseVerticalOffset + sizeDelta;
              if (this.verticalViewportLock) {
                const regionTop = this.anchorRect.top + sizeDelta;
                const regionBottom = this.anchorRect.bottom - sizeDelta;
                if (regionTop < this.viewportRect.top && !(regionBottom > this.viewportRect.bottom)) {
                  this.translateY = this.translateY - (regionTop - this.viewportRect.top);
                } else if (regionBottom > this.viewportRect.bottom && !(regionTop < this.viewportRect.top)) {
                  this.translateY = this.translateY - (regionBottom - this.viewportRect.bottom);
                }
              }
          }
          this.verticalPosition = desiredVerticalPosition;
        };
        this.getPositioningOptions = (inset) => {
          if (inset) {
            return ["insetStart", "insetEnd"];
          }
          return ["start", "end"];
        };
        this.getAvailableSpace = (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) => {
          const spaceStart = anchorStart - viewportStart;
          const spaceEnd = viewportEnd - (anchorStart + anchorSpan);
          switch (positionOption) {
            case "start":
              return spaceStart;
            case "insetStart":
              return spaceStart + anchorSpan;
            case "insetEnd":
              return spaceEnd + anchorSpan;
            case "end":
              return spaceEnd;
            case "center":
              return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;
          }
        };
        this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {
          const newRegionDimension = {
            height: this.regionRect !== void 0 ? this.regionRect.height : 0,
            width: this.regionRect !== void 0 ? this.regionRect.width : 0
          };
          if (desiredHorizontalPosition !== void 0 && this.horizontalScaling === "fill") {
            newRegionDimension.width = this.getAvailableSpace(desiredHorizontalPosition, this.anchorRect !== void 0 ? this.anchorRect.left : 0, this.anchorRect !== void 0 ? this.anchorRect.right : 0, this.anchorRect !== void 0 ? this.anchorRect.width : 0, this.viewportRect !== void 0 ? this.viewportRect.left : 0, this.viewportRect !== void 0 ? this.viewportRect.right : 0);
          } else if (this.horizontalScaling === "anchor") {
            newRegionDimension.width = this.anchorRect !== void 0 ? this.anchorRect.width : 0;
          }
          if (desiredVerticalPosition !== void 0 && this.verticalScaling === "fill") {
            newRegionDimension.height = this.getAvailableSpace(desiredVerticalPosition, this.anchorRect !== void 0 ? this.anchorRect.top : 0, this.anchorRect !== void 0 ? this.anchorRect.bottom : 0, this.anchorRect !== void 0 ? this.anchorRect.height : 0, this.viewportRect !== void 0 ? this.viewportRect.top : 0, this.viewportRect !== void 0 ? this.viewportRect.bottom : 0);
          } else if (this.verticalScaling === "anchor") {
            newRegionDimension.height = this.anchorRect !== void 0 ? this.anchorRect.height : 0;
          }
          return newRegionDimension;
        };
        this.startAutoUpdateEventListeners = () => {
          window.addEventListener(eventResize, this.update, { passive: true });
          window.addEventListener(eventScroll, this.update, {
            passive: true,
            capture: true
          });
          if (this.resizeDetector !== null && this.viewportElement !== null) {
            this.resizeDetector.observe(this.viewportElement);
          }
        };
        this.stopAutoUpdateEventListeners = () => {
          window.removeEventListener(eventResize, this.update);
          window.removeEventListener(eventScroll, this.update);
          if (this.resizeDetector !== null && this.viewportElement !== null) {
            this.resizeDetector.unobserve(this.viewportElement);
          }
        };
      }
      anchorChanged() {
        if (this.initialLayoutComplete) {
          this.anchorElement = this.getAnchor();
        }
      }
      viewportChanged() {
        if (this.initialLayoutComplete) {
          this.viewportElement = this.getViewport();
        }
      }
      horizontalPositioningModeChanged() {
        this.requestReset();
      }
      horizontalDefaultPositionChanged() {
        this.updateForAttributeChange();
      }
      horizontalViewportLockChanged() {
        this.updateForAttributeChange();
      }
      horizontalInsetChanged() {
        this.updateForAttributeChange();
      }
      horizontalThresholdChanged() {
        this.updateForAttributeChange();
      }
      horizontalScalingChanged() {
        this.updateForAttributeChange();
      }
      verticalPositioningModeChanged() {
        this.requestReset();
      }
      verticalDefaultPositionChanged() {
        this.updateForAttributeChange();
      }
      verticalViewportLockChanged() {
        this.updateForAttributeChange();
      }
      verticalInsetChanged() {
        this.updateForAttributeChange();
      }
      verticalThresholdChanged() {
        this.updateForAttributeChange();
      }
      verticalScalingChanged() {
        this.updateForAttributeChange();
      }
      fixedPlacementChanged() {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          this.initialize();
        }
      }
      autoUpdateModeChanged(prevMode, newMode) {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          if (prevMode === "auto") {
            this.stopAutoUpdateEventListeners();
          }
          if (newMode === "auto") {
            this.startAutoUpdateEventListeners();
          }
        }
      }
      anchorElementChanged() {
        this.requestReset();
      }
      viewportElementChanged() {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          this.initialize();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (this.autoUpdateMode === "auto") {
          this.startAutoUpdateEventListeners();
        }
        this.initialize();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        if (this.autoUpdateMode === "auto") {
          this.stopAutoUpdateEventListeners();
        }
        this.stopObservers();
        this.disconnectResizeDetector();
      }
      /**
       * @internal
       */
      adoptedCallback() {
        this.initialize();
      }
      /**
       * destroys the instance's resize observer
       */
      disconnectResizeDetector() {
        if (this.resizeDetector !== null) {
          this.resizeDetector.disconnect();
          this.resizeDetector = null;
        }
      }
      /**
       * initializes the instance's resize observer
       */
      initializeResizeDetector() {
        this.disconnectResizeDetector();
        this.resizeDetector = new window.ResizeObserver(this.handleResize);
      }
      /**
       * react to attribute changes that don't require a reset
       */
      updateForAttributeChange() {
        if (this.$fastController.isConnected && this.initialLayoutComplete) {
          this.forceUpdate = true;
          this.update();
        }
      }
      /**
       * fully initializes the component
       */
      initialize() {
        this.initializeResizeDetector();
        if (this.anchorElement === null) {
          this.anchorElement = this.getAnchor();
        }
        this.requestReset();
      }
      /**
       * Request a reset if there are currently no open requests
       */
      requestReset() {
        if (this.$fastController.isConnected && this.pendingReset === false) {
          this.setInitialState();
          DOM.queueUpdate(() => this.reset());
          this.pendingReset = true;
        }
      }
      /**
       * sets the starting configuration for component internal values
       */
      setInitialState() {
        this.initialLayoutComplete = false;
        this.regionVisible = false;
        this.translateX = 0;
        this.translateY = 0;
        this.baseHorizontalOffset = 0;
        this.baseVerticalOffset = 0;
        this.viewportRect = void 0;
        this.regionRect = void 0;
        this.anchorRect = void 0;
        this.verticalPosition = void 0;
        this.horizontalPosition = void 0;
        this.style.opacity = "0";
        this.style.pointerEvents = "none";
        this.forceUpdate = false;
        this.style.position = this.fixedPlacement ? "fixed" : "absolute";
        this.updatePositionClasses();
        this.updateRegionStyle();
      }
    };
    AnchoredRegion.intersectionService = new IntersectionService();
    __decorate5([
      attr
    ], AnchoredRegion.prototype, "anchor", void 0);
    __decorate5([
      attr
    ], AnchoredRegion.prototype, "viewport", void 0);
    __decorate5([
      attr({ attribute: "horizontal-positioning-mode" })
    ], AnchoredRegion.prototype, "horizontalPositioningMode", void 0);
    __decorate5([
      attr({ attribute: "horizontal-default-position" })
    ], AnchoredRegion.prototype, "horizontalDefaultPosition", void 0);
    __decorate5([
      attr({ attribute: "horizontal-viewport-lock", mode: "boolean" })
    ], AnchoredRegion.prototype, "horizontalViewportLock", void 0);
    __decorate5([
      attr({ attribute: "horizontal-inset", mode: "boolean" })
    ], AnchoredRegion.prototype, "horizontalInset", void 0);
    __decorate5([
      attr({ attribute: "horizontal-threshold" })
    ], AnchoredRegion.prototype, "horizontalThreshold", void 0);
    __decorate5([
      attr({ attribute: "horizontal-scaling" })
    ], AnchoredRegion.prototype, "horizontalScaling", void 0);
    __decorate5([
      attr({ attribute: "vertical-positioning-mode" })
    ], AnchoredRegion.prototype, "verticalPositioningMode", void 0);
    __decorate5([
      attr({ attribute: "vertical-default-position" })
    ], AnchoredRegion.prototype, "verticalDefaultPosition", void 0);
    __decorate5([
      attr({ attribute: "vertical-viewport-lock", mode: "boolean" })
    ], AnchoredRegion.prototype, "verticalViewportLock", void 0);
    __decorate5([
      attr({ attribute: "vertical-inset", mode: "boolean" })
    ], AnchoredRegion.prototype, "verticalInset", void 0);
    __decorate5([
      attr({ attribute: "vertical-threshold" })
    ], AnchoredRegion.prototype, "verticalThreshold", void 0);
    __decorate5([
      attr({ attribute: "vertical-scaling" })
    ], AnchoredRegion.prototype, "verticalScaling", void 0);
    __decorate5([
      attr({ attribute: "fixed-placement", mode: "boolean" })
    ], AnchoredRegion.prototype, "fixedPlacement", void 0);
    __decorate5([
      attr({ attribute: "auto-update-mode" })
    ], AnchoredRegion.prototype, "autoUpdateMode", void 0);
    __decorate5([
      observable
    ], AnchoredRegion.prototype, "anchorElement", void 0);
    __decorate5([
      observable
    ], AnchoredRegion.prototype, "viewportElement", void 0);
    __decorate5([
      observable
    ], AnchoredRegion.prototype, "initialLayoutComplete", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region-config.js
var horizontalAnchorOverlay, FlyoutPosTop, FlyoutPosBottom, FlyoutPosTallest, FlyoutPosTopFill, FlyoutPosBottomFill, FlyoutPosTallestFill;
var init_anchored_region_config = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region-config.js"() {
    horizontalAnchorOverlay = {
      horizontalDefaultPosition: "center",
      horizontalPositioningMode: "locktodefault",
      horizontalInset: false,
      horizontalScaling: "anchor"
    };
    FlyoutPosTop = Object.assign(Object.assign({}, horizontalAnchorOverlay), { verticalDefaultPosition: "top", verticalPositioningMode: "locktodefault", verticalInset: false, verticalScaling: "content" });
    FlyoutPosBottom = Object.assign(Object.assign({}, horizontalAnchorOverlay), { verticalDefaultPosition: "bottom", verticalPositioningMode: "locktodefault", verticalInset: false, verticalScaling: "content" });
    FlyoutPosTallest = Object.assign(Object.assign({}, horizontalAnchorOverlay), { verticalPositioningMode: "dynamic", verticalInset: false, verticalScaling: "content" });
    FlyoutPosTopFill = Object.assign(Object.assign({}, FlyoutPosTop), { verticalScaling: "fill" });
    FlyoutPosBottomFill = Object.assign(Object.assign({}, FlyoutPosBottom), { verticalScaling: "fill" });
    FlyoutPosTallestFill = Object.assign(Object.assign({}, FlyoutPosTallest), { verticalScaling: "fill" });
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/index.js
var init_anchored_region2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/index.js"() {
    init_anchored_region_template();
    init_anchored_region();
    init_anchored_region_config();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.template.js
var init_avatar_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.template.js"() {
    init_esm();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.js
var Avatar;
var init_avatar = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/avatar/avatar.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    Avatar = class extends FoundationElement {
      /**
       * Internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.shape) {
          this.shape = "circle";
        }
      }
    };
    __decorate5([
      attr
    ], Avatar.prototype, "fill", void 0);
    __decorate5([
      attr
    ], Avatar.prototype, "color", void 0);
    __decorate5([
      attr
    ], Avatar.prototype, "link", void 0);
    __decorate5([
      attr
    ], Avatar.prototype, "shape", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/avatar/index.js
var init_avatar2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/avatar/index.js"() {
    init_avatar_template();
    init_avatar();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.template.js
var badgeTemplate;
var init_badge_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.template.js"() {
    init_esm();
    badgeTemplate = (context, definition) => html2`
    <template class="${(x) => x.circular ? "circular" : ""}">
        <div class="control" part="control" style="${(x) => x.generateBadgeStyle()}">
            <slot></slot>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.js
var Badge;
var init_badge = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/badge/badge.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    Badge = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.generateBadgeStyle = () => {
          if (!this.fill && !this.color) {
            return;
          }
          const fill = `background-color: var(--badge-fill-${this.fill});`;
          const color = `color: var(--badge-color-${this.color});`;
          if (this.fill && !this.color) {
            return fill;
          } else if (this.color && !this.fill) {
            return color;
          } else {
            return `${color} ${fill}`;
          }
        };
      }
    };
    __decorate5([
      attr({ attribute: "fill" })
    ], Badge.prototype, "fill", void 0);
    __decorate5([
      attr({ attribute: "color" })
    ], Badge.prototype, "color", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], Badge.prototype, "circular", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/badge/index.js
var init_badge2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/badge/index.js"() {
    init_badge_template();
    init_badge();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.template.js
var breadcrumbItemTemplate;
var init_breadcrumb_item_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.template.js"() {
    init_esm();
    init_anchor_template();
    init_start_end();
    breadcrumbItemTemplate = (context, definition) => html2`
    <div role="listitem" class="listitem" part="listitem">
        ${when((x) => x.href && x.href.length > 0, html2`
                ${anchorTemplate(context, definition)}
            `)}
        ${when((x) => !x.href, html2`
                ${startSlotTemplate(context, definition)}
                <slot></slot>
                ${endSlotTemplate(context, definition)}
            `)}
        ${when((x) => x.separator, html2`
                <span class="separator" part="separator" aria-hidden="true">
                    <slot name="separator">${definition.separator || ""}</slot>
                </span>
            `)}
    </div>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.js
var BreadcrumbItem;
var init_breadcrumb_item = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/breadcrumb-item.js"() {
    init_tslib_es62();
    init_esm();
    init_anchor();
    init_patterns();
    init_apply_mixins();
    BreadcrumbItem = class extends Anchor {
      constructor() {
        super(...arguments);
        this.separator = true;
      }
    };
    __decorate5([
      observable
    ], BreadcrumbItem.prototype, "separator", void 0);
    applyMixins(BreadcrumbItem, StartEnd, DelegatesARIALink);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/index.js
var init_breadcrumb_item2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb-item/index.js"() {
    init_breadcrumb_item_template();
    init_breadcrumb_item();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.template.js
var breadcrumbTemplate;
var init_breadcrumb_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.template.js"() {
    init_esm();
    breadcrumbTemplate = (context, definition) => html2`
    <template role="navigation">
        <div role="list" class="list" part="list">
            <slot
                ${slotted({ property: "slottedBreadcrumbItems", filter: elements() })}
            ></slot>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.js
var Breadcrumb;
var init_breadcrumb = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/breadcrumb.js"() {
    init_tslib_es62();
    init_esm();
    init_breadcrumb_item();
    init_foundation_element();
    Breadcrumb = class extends FoundationElement {
      slottedBreadcrumbItemsChanged() {
        if (this.$fastController.isConnected) {
          if (this.slottedBreadcrumbItems === void 0 || this.slottedBreadcrumbItems.length === 0) {
            return;
          }
          const lastNode = this.slottedBreadcrumbItems[this.slottedBreadcrumbItems.length - 1];
          this.slottedBreadcrumbItems.forEach((item) => {
            const itemIsLastNode = item === lastNode;
            this.setItemSeparator(item, itemIsLastNode);
            this.setAriaCurrent(item, itemIsLastNode);
          });
        }
      }
      setItemSeparator(item, isLastNode) {
        if (item instanceof BreadcrumbItem) {
          item.separator = !isLastNode;
        }
      }
      /**
       * Finds href on childnodes in the light DOM or shadow DOM.
       * We look in the shadow DOM because we insert an anchor when breadcrumb-item has an href.
       */
      findChildWithHref(node) {
        var _a2, _b2;
        if (node.childElementCount > 0) {
          return node.querySelector("a[href]");
        } else if ((_a2 = node.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.childElementCount) {
          return (_b2 = node.shadowRoot) === null || _b2 === void 0 ? void 0 : _b2.querySelector("a[href]");
        } else
          return null;
      }
      /**
       *  Sets ARIA Current for the current node
       * If child node with an anchor tag and with href is found then set aria-current to correct value for the child node,
       * otherwise apply aria-current to the host element, with an href
       */
      setAriaCurrent(item, isLastNode) {
        const childNodeWithHref = this.findChildWithHref(item);
        if (childNodeWithHref === null && item.hasAttribute("href") && item instanceof BreadcrumbItem) {
          isLastNode ? item.setAttribute("aria-current", "page") : item.removeAttribute("aria-current");
        } else if (childNodeWithHref !== null) {
          isLastNode ? childNodeWithHref.setAttribute("aria-current", "page") : childNodeWithHref.removeAttribute("aria-current");
        }
      }
    };
    __decorate5([
      observable
    ], Breadcrumb.prototype, "slottedBreadcrumbItems", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/index.js
var init_breadcrumb2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/breadcrumb/index.js"() {
    init_breadcrumb_template();
    init_breadcrumb();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/button/button.template.js
var buttonTemplate;
var init_button_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/button/button.template.js"() {
    init_esm();
    init_start_end();
    buttonTemplate = (context, definition) => html2`
    <button
        class="control"
        part="control"
        ?autofocus="${(x) => x.autofocus}"
        ?disabled="${(x) => x.disabled}"
        form="${(x) => x.formId}"
        formaction="${(x) => x.formaction}"
        formenctype="${(x) => x.formenctype}"
        formmethod="${(x) => x.formmethod}"
        formnovalidate="${(x) => x.formnovalidate}"
        formtarget="${(x) => x.formtarget}"
        name="${(x) => x.name}"
        type="${(x) => x.type}"
        value="${(x) => x.value}"
        aria-atomic="${(x) => x.ariaAtomic}"
        aria-busy="${(x) => x.ariaBusy}"
        aria-controls="${(x) => x.ariaControls}"
        aria-current="${(x) => x.ariaCurrent}"
        aria-describedby="${(x) => x.ariaDescribedby}"
        aria-details="${(x) => x.ariaDetails}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-errormessage="${(x) => x.ariaErrormessage}"
        aria-expanded="${(x) => x.ariaExpanded}"
        aria-flowto="${(x) => x.ariaFlowto}"
        aria-haspopup="${(x) => x.ariaHaspopup}"
        aria-hidden="${(x) => x.ariaHidden}"
        aria-invalid="${(x) => x.ariaInvalid}"
        aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
        aria-label="${(x) => x.ariaLabel}"
        aria-labelledby="${(x) => x.ariaLabelledby}"
        aria-live="${(x) => x.ariaLive}"
        aria-owns="${(x) => x.ariaOwns}"
        aria-pressed="${(x) => x.ariaPressed}"
        aria-relevant="${(x) => x.ariaRelevant}"
        aria-roledescription="${(x) => x.ariaRoledescription}"
        ${ref("control")}
    >
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endSlotTemplate(context, definition)}
    </button>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/form-associated/form-associated.js
function FormAssociated(BaseCtor) {
  const C = class extends BaseCtor {
    constructor(...args) {
      super(...args);
      this.dirtyValue = false;
      this.disabled = false;
      this.proxyEventsToBlock = ["change", "click"];
      this.proxyInitialized = false;
      this.required = false;
      this.initialValue = this.initialValue || "";
      if (!this.elementInternals) {
        this.formResetCallback = this.formResetCallback.bind(this);
      }
    }
    /**
     * Must evaluate to true to enable elementInternals.
     * Feature detects API support and resolve respectively
     *
     * @internal
     */
    static get formAssociated() {
      return supportsElementInternals;
    }
    /**
     * Returns the validity state of the element
     *
     * @alpha
     */
    get validity() {
      return this.elementInternals ? this.elementInternals.validity : this.proxy.validity;
    }
    /**
     * Retrieve a reference to the associated form.
     * Returns null if not associated to any form.
     *
     * @alpha
     */
    get form() {
      return this.elementInternals ? this.elementInternals.form : this.proxy.form;
    }
    /**
     * Retrieve the localized validation message,
     * or custom validation message if set.
     *
     * @alpha
     */
    get validationMessage() {
      return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage;
    }
    /**
     * Whether the element will be validated when the
     * form is submitted
     */
    get willValidate() {
      return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate;
    }
    /**
     * A reference to all associated label elements
     */
    get labels() {
      if (this.elementInternals) {
        return Object.freeze(Array.from(this.elementInternals.labels));
      } else if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) {
        const parentLabels = this.proxy.labels;
        const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));
        const labels = parentLabels ? forLabels.concat(Array.from(parentLabels)) : forLabels;
        return Object.freeze(labels);
      } else {
        return emptyArray;
      }
    }
    /**
     * Invoked when the `value` property changes
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `valueChanged` method
     * They must be sure to invoke `super.valueChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    valueChanged(previous, next) {
      this.dirtyValue = true;
      if (this.proxy instanceof HTMLElement) {
        this.proxy.value = this.value;
      }
      this.currentValue = this.value;
      this.setFormValue(this.value);
      this.validate();
    }
    currentValueChanged() {
      this.value = this.currentValue;
    }
    /**
     * Invoked when the `initialValue` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `initialValueChanged` method
     * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    initialValueChanged(previous, next) {
      if (!this.dirtyValue) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
    }
    /**
     * Invoked when the `disabled` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `disabledChanged` method
     * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    disabledChanged(previous, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.disabled = this.disabled;
      }
      DOM.queueUpdate(() => this.classList.toggle("disabled", this.disabled));
    }
    /**
     * Invoked when the `name` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `nameChanged` method
     * They must be sure to invoke `super.nameChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    nameChanged(previous, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.name = this.name;
      }
    }
    /**
     * Invoked when the `required` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `requiredChanged` method
     * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    requiredChanged(prev, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.required = this.required;
      }
      DOM.queueUpdate(() => this.classList.toggle("required", this.required));
      this.validate();
    }
    /**
     * The element internals object. Will only exist
     * in browsers supporting the attachInternals API
     */
    get elementInternals() {
      if (!supportsElementInternals) {
        return null;
      }
      let internals = InternalsMap.get(this);
      if (!internals) {
        internals = this.attachInternals();
        InternalsMap.set(this, internals);
      }
      return internals;
    }
    /**
     * @internal
     */
    connectedCallback() {
      super.connectedCallback();
      this.addEventListener("keypress", this._keypressHandler);
      if (!this.value) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
      if (!this.elementInternals) {
        this.attachProxy();
        if (this.form) {
          this.form.addEventListener("reset", this.formResetCallback);
        }
      }
    }
    /**
     * @internal
     */
    disconnectedCallback() {
      this.proxyEventsToBlock.forEach((name) => this.proxy.removeEventListener(name, this.stopPropagation));
      if (!this.elementInternals && this.form) {
        this.form.removeEventListener("reset", this.formResetCallback);
      }
    }
    /**
     * Return the current validity of the element.
     */
    checkValidity() {
      return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity();
    }
    /**
     * Return the current validity of the element.
     * If false, fires an invalid event at the element.
     */
    reportValidity() {
      return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity();
    }
    /**
     * Set the validity of the control. In cases when the elementInternals object is not
     * available (and the proxy element is used to report validity), this function will
     * do nothing unless a message is provided, at which point the setCustomValidity method
     * of the proxy element will be invoked with the provided message.
     * @param flags - Validity flags
     * @param message - Optional message to supply
     * @param anchor - Optional element used by UA to display an interactive validation UI
     */
    setValidity(flags, message, anchor) {
      if (this.elementInternals) {
        this.elementInternals.setValidity(flags, message, anchor);
      } else if (typeof message === "string") {
        this.proxy.setCustomValidity(message);
      }
    }
    /**
     * Invoked when a connected component's form or fieldset has its disabled
     * state changed.
     * @param disabled - the disabled value of the form / fieldset
     */
    formDisabledCallback(disabled) {
      this.disabled = disabled;
    }
    formResetCallback() {
      this.value = this.initialValue;
      this.dirtyValue = false;
    }
    /**
     * Attach the proxy element to the DOM
     */
    attachProxy() {
      var _a2;
      if (!this.proxyInitialized) {
        this.proxyInitialized = true;
        this.proxy.style.display = "none";
        this.proxyEventsToBlock.forEach((name) => this.proxy.addEventListener(name, this.stopPropagation));
        this.proxy.disabled = this.disabled;
        this.proxy.required = this.required;
        if (typeof this.name === "string") {
          this.proxy.name = this.name;
        }
        if (typeof this.value === "string") {
          this.proxy.value = this.value;
        }
        this.proxy.setAttribute("slot", proxySlotName);
        this.proxySlot = document.createElement("slot");
        this.proxySlot.setAttribute("name", proxySlotName);
      }
      (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.appendChild(this.proxySlot);
      this.appendChild(this.proxy);
    }
    /**
     * Detach the proxy element from the DOM
     */
    detachProxy() {
      var _a2;
      this.removeChild(this.proxy);
      (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.proxySlot);
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate(anchor) {
      if (this.proxy instanceof HTMLElement) {
        this.setValidity(this.proxy.validity, this.proxy.validationMessage, anchor);
      }
    }
    /**
     * Associates the provided value (and optional state) with the parent form.
     * @param value - The value to set
     * @param state - The state object provided to during session restores and when autofilling.
     */
    setFormValue(value, state2) {
      if (this.elementInternals) {
        this.elementInternals.setFormValue(value, state2 || value);
      }
    }
    _keypressHandler(e) {
      switch (e.key) {
        case keyEnter:
          if (this.form instanceof HTMLFormElement) {
            const defaultButton = this.form.querySelector("[type=submit]");
            defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();
          }
          break;
      }
    }
    /**
     * Used to stop propagation of proxy element events
     * @param e - Event object
     */
    stopPropagation(e) {
      e.stopPropagation();
    }
  };
  attr({ mode: "boolean" })(C.prototype, "disabled");
  attr({ mode: "fromView", attribute: "value" })(C.prototype, "initialValue");
  attr({ attribute: "current-value" })(C.prototype, "currentValue");
  attr(C.prototype, "name");
  attr({ mode: "boolean" })(C.prototype, "required");
  observable(C.prototype, "value");
  return C;
}
function CheckableFormAssociated(BaseCtor) {
  class C extends FormAssociated(BaseCtor) {
  }
  class D extends C {
    constructor(...args) {
      super(args);
      this.dirtyChecked = false;
      this.checkedAttribute = false;
      this.checked = false;
      this.dirtyChecked = false;
    }
    checkedAttributeChanged() {
      this.defaultChecked = this.checkedAttribute;
    }
    /**
     * @internal
     */
    defaultCheckedChanged() {
      if (!this.dirtyChecked) {
        this.checked = this.defaultChecked;
        this.dirtyChecked = false;
      }
    }
    checkedChanged(prev, next) {
      if (!this.dirtyChecked) {
        this.dirtyChecked = true;
      }
      this.currentChecked = this.checked;
      this.updateForm();
      if (this.proxy instanceof HTMLInputElement) {
        this.proxy.checked = this.checked;
      }
      if (prev !== void 0) {
        this.$emit("change");
      }
      this.validate();
    }
    currentCheckedChanged(prev, next) {
      this.checked = this.currentChecked;
    }
    updateForm() {
      const value = this.checked ? this.value : null;
      this.setFormValue(value, value);
    }
    connectedCallback() {
      super.connectedCallback();
      this.updateForm();
    }
    formResetCallback() {
      super.formResetCallback();
      this.checked = !!this.checkedAttribute;
      this.dirtyChecked = false;
    }
  }
  attr({ attribute: "checked", mode: "boolean" })(D.prototype, "checkedAttribute");
  attr({ attribute: "current-checked", converter: booleanConverter })(D.prototype, "currentChecked");
  observable(D.prototype, "defaultChecked");
  observable(D.prototype, "checked");
  return D;
}
var proxySlotName, ElementInternalsKey, supportsElementInternals, InternalsMap;
var init_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/form-associated/form-associated.js"() {
    init_esm();
    init_dist2();
    proxySlotName = "form-associated-proxy";
    ElementInternalsKey = "ElementInternals";
    supportsElementInternals = ElementInternalsKey in window && "setFormValue" in window[ElementInternalsKey].prototype;
    InternalsMap = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/button/button.form-associated.js
var _Button, FormAssociatedButton;
var init_button_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/button/button.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Button = class extends FoundationElement {
    };
    FormAssociatedButton = class extends FormAssociated(_Button) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/button/button.js
var Button, DelegatesARIAButton;
var init_button = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/button/button.js"() {
    init_tslib_es62();
    init_esm();
    init_patterns();
    init_apply_mixins();
    init_button_form_associated();
    Button = class extends FormAssociatedButton {
      constructor() {
        super(...arguments);
        this.handleClick = (e) => {
          var _a2;
          if (this.disabled && ((_a2 = this.defaultSlottedContent) === null || _a2 === void 0 ? void 0 : _a2.length) <= 1) {
            e.stopPropagation();
          }
        };
        this.handleSubmission = () => {
          if (!this.form) {
            return;
          }
          const attached = this.proxy.isConnected;
          if (!attached) {
            this.attachProxy();
          }
          typeof this.form.requestSubmit === "function" ? this.form.requestSubmit(this.proxy) : this.proxy.click();
          if (!attached) {
            this.detachProxy();
          }
        };
        this.handleFormReset = () => {
          var _a2;
          (_a2 = this.form) === null || _a2 === void 0 ? void 0 : _a2.reset();
        };
        this.handleUnsupportedDelegatesFocus = () => {
          var _a2;
          if (window.ShadowRoot && !window.ShadowRoot.prototype.hasOwnProperty("delegatesFocus") && ((_a2 = this.$fastController.definition.shadowOptions) === null || _a2 === void 0 ? void 0 : _a2.delegatesFocus)) {
            this.focus = () => {
              this.control.focus();
            };
          }
        };
      }
      formactionChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formAction = this.formaction;
        }
      }
      formenctypeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formEnctype = this.formenctype;
        }
      }
      formmethodChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formMethod = this.formmethod;
        }
      }
      formnovalidateChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formNoValidate = this.formnovalidate;
        }
      }
      formtargetChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.formTarget = this.formtarget;
        }
      }
      typeChanged(previous, next) {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.type = this.type;
        }
        next === "submit" && this.addEventListener("click", this.handleSubmission);
        previous === "submit" && this.removeEventListener("click", this.handleSubmission);
        next === "reset" && this.addEventListener("click", this.handleFormReset);
        previous === "reset" && this.removeEventListener("click", this.handleFormReset);
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      /**
       * @internal
       */
      connectedCallback() {
        var _a2;
        super.connectedCallback();
        this.proxy.setAttribute("type", this.type);
        this.handleUnsupportedDelegatesFocus();
        const elements2 = Array.from((_a2 = this.control) === null || _a2 === void 0 ? void 0 : _a2.children);
        if (elements2) {
          elements2.forEach((span) => {
            span.addEventListener("click", this.handleClick);
          });
        }
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        var _a2;
        super.disconnectedCallback();
        const elements2 = Array.from((_a2 = this.control) === null || _a2 === void 0 ? void 0 : _a2.children);
        if (elements2) {
          elements2.forEach((span) => {
            span.removeEventListener("click", this.handleClick);
          });
        }
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], Button.prototype, "autofocus", void 0);
    __decorate5([
      attr({ attribute: "form" })
    ], Button.prototype, "formId", void 0);
    __decorate5([
      attr
    ], Button.prototype, "formaction", void 0);
    __decorate5([
      attr
    ], Button.prototype, "formenctype", void 0);
    __decorate5([
      attr
    ], Button.prototype, "formmethod", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], Button.prototype, "formnovalidate", void 0);
    __decorate5([
      attr
    ], Button.prototype, "formtarget", void 0);
    __decorate5([
      attr
    ], Button.prototype, "type", void 0);
    __decorate5([
      observable
    ], Button.prototype, "defaultSlottedContent", void 0);
    DelegatesARIAButton = class {
    };
    __decorate5([
      attr({ attribute: "aria-expanded" })
    ], DelegatesARIAButton.prototype, "ariaExpanded", void 0);
    __decorate5([
      attr({ attribute: "aria-pressed" })
    ], DelegatesARIAButton.prototype, "ariaPressed", void 0);
    applyMixins(DelegatesARIAButton, ARIAGlobalStatesAndProperties);
    applyMixins(Button, StartEnd, DelegatesARIAButton);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/button/index.js
var init_button2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/button/index.js"() {
    init_button_template();
    init_button();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/calendar/date-formatter.js
var DateFormatter;
var init_date_formatter = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/calendar/date-formatter.js"() {
    DateFormatter = class {
      constructor(config) {
        this.dayFormat = "numeric";
        this.weekdayFormat = "long";
        this.monthFormat = "long";
        this.yearFormat = "numeric";
        this.date = /* @__PURE__ */ new Date();
        if (config) {
          for (const key in config) {
            const value = config[key];
            if (key === "date") {
              this.date = this.getDateObject(value);
            } else {
              this[key] = value;
            }
          }
        }
      }
      /**
       * Helper function to make sure that the DateFormatter is working with an instance of Date
       * @param date - The date as an object, string or Date insance
       * @returns - A Date instance
       * @public
       */
      getDateObject(date) {
        if (typeof date === "string") {
          const dates = date.split(/[/-]/);
          if (dates.length < 3) {
            return /* @__PURE__ */ new Date();
          }
          return new Date(parseInt(dates[2], 10), parseInt(dates[0], 10) - 1, parseInt(dates[1], 10));
        } else if ("day" in date && "month" in date && "year" in date) {
          const { day, month, year } = date;
          return new Date(year, month - 1, day);
        }
        return date;
      }
      /**
       *
       * @param date - a valide date as either a Date, string, objec or a DateFormatter
       * @param format - The formatting for the string
       * @param locale - locale data used for formatting
       * @returns A localized string of the date provided
       * @public
       */
      getDate(date = this.date, format = {
        weekday: this.weekdayFormat,
        month: this.monthFormat,
        day: this.dayFormat,
        year: this.yearFormat
      }, locale = this.locale) {
        const dateObj = this.getDateObject(date);
        const optionsWithTimeZone = Object.assign({ timeZone: "utc" }, format);
        return new Intl.DateTimeFormat(locale, optionsWithTimeZone).format(dateObj);
      }
      /**
       *
       * @param day - Day to localize
       * @param format - The formatting for the day
       * @param locale - The locale data used for formatting
       * @returns - A localized number for the day
       * @public
       */
      getDay(day = this.date.getDate(), format = this.dayFormat, locale = this.locale) {
        return this.getDate({ month: 1, day, year: 2020 }, { day: format }, locale);
      }
      /**
       *
       * @param month - The month to localize
       * @param format - The formatting for the month
       * @param locale - The locale data used for formatting
       * @returns - A localized name of the month
       * @public
       */
      getMonth(month = this.date.getMonth() + 1, format = this.monthFormat, locale = this.locale) {
        return this.getDate({ month, day: 2, year: 2020 }, { month: format }, locale);
      }
      /**
       *
       * @param year - The year to localize
       * @param format - The formatting for the year
       * @param locale - The locale data used for formatting
       * @returns - A localized string for the year
       * @public
       */
      getYear(year = this.date.getFullYear(), format = this.yearFormat, locale = this.locale) {
        return this.getDate({ month: 2, day: 2, year }, { year: format }, locale);
      }
      /**
       *
       * @param weekday - The number of the weekday, defaults to Sunday
       * @param format - The formatting for the weekday label
       * @param locale - The locale data used for formatting
       * @returns - A formatted weekday label
       * @public
       */
      getWeekday(weekday = 0, format = this.weekdayFormat, locale = this.locale) {
        const date = `1-${weekday + 1}-2017`;
        return this.getDate(date, { weekday: format }, locale);
      }
      /**
       *
       * @param format - The formatting for the weekdays
       * @param locale - The locale data used for formatting
       * @returns - An array of the weekday labels
       * @public
       */
      getWeekdays(format = this.weekdayFormat, locale = this.locale) {
        return Array(7).fill(null).map((_, day) => this.getWeekday(day, format, locale));
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.js
var Calendar;
var init_calendar = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_date_formatter();
    Calendar = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.dateFormatter = new DateFormatter();
        this.readonly = false;
        this.locale = "en-US";
        this.month = (/* @__PURE__ */ new Date()).getMonth() + 1;
        this.year = (/* @__PURE__ */ new Date()).getFullYear();
        this.dayFormat = "numeric";
        this.weekdayFormat = "short";
        this.monthFormat = "long";
        this.yearFormat = "numeric";
        this.minWeeks = 0;
        this.disabledDates = "";
        this.selectedDates = "";
        this.oneDayInMs = 864e5;
      }
      localeChanged() {
        this.dateFormatter.locale = this.locale;
      }
      dayFormatChanged() {
        this.dateFormatter.dayFormat = this.dayFormat;
      }
      weekdayFormatChanged() {
        this.dateFormatter.weekdayFormat = this.weekdayFormat;
      }
      monthFormatChanged() {
        this.dateFormatter.monthFormat = this.monthFormat;
      }
      yearFormatChanged() {
        this.dateFormatter.yearFormat = this.yearFormat;
      }
      /**
       * Gets data needed to render about a calendar month as well as the previous and next months
       * @param year - year of the calendar
       * @param month - month of the calendar
       * @returns - an object with data about the current and 2 surrounding months
       * @public
       */
      getMonthInfo(month = this.month, year = this.year) {
        const getFirstDay = (date) => new Date(date.getFullYear(), date.getMonth(), 1).getDay();
        const getLength = (date) => {
          const nextMonth2 = new Date(date.getFullYear(), date.getMonth() + 1, 1);
          return new Date(nextMonth2.getTime() - this.oneDayInMs).getDate();
        };
        const thisMonth = new Date(year, month - 1);
        const nextMonth = new Date(year, month);
        const previousMonth = new Date(year, month - 2);
        return {
          length: getLength(thisMonth),
          month,
          start: getFirstDay(thisMonth),
          year,
          previous: {
            length: getLength(previousMonth),
            month: previousMonth.getMonth() + 1,
            start: getFirstDay(previousMonth),
            year: previousMonth.getFullYear()
          },
          next: {
            length: getLength(nextMonth),
            month: nextMonth.getMonth() + 1,
            start: getFirstDay(nextMonth),
            year: nextMonth.getFullYear()
          }
        };
      }
      /**
       * A list of calendar days
       * @param info - an object containing the information needed to render a calendar month
       * @param minWeeks - minimum number of weeks to show
       * @returns a list of days in a calendar month
       * @public
       */
      getDays(info = this.getMonthInfo(), minWeeks = this.minWeeks) {
        minWeeks = minWeeks > 10 ? 10 : minWeeks;
        const { start, length, previous, next } = info;
        const days = [];
        let dayCount = 1 - start;
        while (dayCount < length + 1 || days.length < minWeeks || days[days.length - 1].length % 7 !== 0) {
          const { month, year } = dayCount < 1 ? previous : dayCount > length ? next : info;
          const day = dayCount < 1 ? previous.length + dayCount : dayCount > length ? dayCount - length : dayCount;
          const dateString = `${month}-${day}-${year}`;
          const disabled = this.dateInString(dateString, this.disabledDates);
          const selected = this.dateInString(dateString, this.selectedDates);
          const date = {
            day,
            month,
            year,
            disabled,
            selected
          };
          const target2 = days[days.length - 1];
          if (days.length === 0 || target2.length % 7 === 0) {
            days.push([date]);
          } else {
            target2.push(date);
          }
          dayCount++;
        }
        return days;
      }
      /**
       * A helper function that checks if a date exists in a list of dates
       * @param date - A date objec that includes the day, month and year
       * @param datesString - a comma separated list of dates
       * @returns - Returns true if it found the date in the list of dates
       * @public
       */
      dateInString(date, datesString) {
        const dates = datesString.split(",").map((str) => str.trim());
        date = typeof date === "string" ? date : `${date.getMonth() + 1}-${date.getDate()}-${date.getFullYear()}`;
        return dates.some((d) => d === date);
      }
      /**
       * Creates a class string for the day container
       * @param date - date of the calendar cell
       * @returns - string of class names
       * @public
       */
      getDayClassNames(date, todayString) {
        const { day, month, year, disabled, selected } = date;
        const today = todayString === `${month}-${day}-${year}`;
        const inactive = this.month !== month;
        return [
          "day",
          today && "today",
          inactive && "inactive",
          disabled && "disabled",
          selected && "selected"
        ].filter(Boolean).join(" ");
      }
      /**
       * Returns a list of weekday labels
       * @returns An array of weekday text and full text if abbreviated
       * @public
       */
      getWeekdayText() {
        const weekdayText = this.dateFormatter.getWeekdays().map((text) => ({ text }));
        if (this.weekdayFormat !== "long") {
          const longText = this.dateFormatter.getWeekdays("long");
          weekdayText.forEach((weekday, index) => {
            weekday.abbr = longText[index];
          });
        }
        return weekdayText;
      }
      /**
       * Emits the "date-select" event with the day, month and year.
       * @param date - Date cell
       * @public
       */
      handleDateSelect(event, day) {
        event.preventDefault;
        this.$emit("dateselected", day);
      }
      /**
       * Handles keyboard events on a cell
       * @param event - Keyboard event
       * @param date - Date of the cell selected
       */
      handleKeydown(event, date) {
        if (event.key === keyEnter) {
          this.handleDateSelect(event, date);
        }
        return true;
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], Calendar.prototype, "readonly", void 0);
    __decorate5([
      attr
    ], Calendar.prototype, "locale", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Calendar.prototype, "month", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Calendar.prototype, "year", void 0);
    __decorate5([
      attr({ attribute: "day-format", mode: "fromView" })
    ], Calendar.prototype, "dayFormat", void 0);
    __decorate5([
      attr({ attribute: "weekday-format", mode: "fromView" })
    ], Calendar.prototype, "weekdayFormat", void 0);
    __decorate5([
      attr({ attribute: "month-format", mode: "fromView" })
    ], Calendar.prototype, "monthFormat", void 0);
    __decorate5([
      attr({ attribute: "year-format", mode: "fromView" })
    ], Calendar.prototype, "yearFormat", void 0);
    __decorate5([
      attr({ attribute: "min-weeks", converter: nullableNumberConverter })
    ], Calendar.prototype, "minWeeks", void 0);
    __decorate5([
      attr({ attribute: "disabled-dates" })
    ], Calendar.prototype, "disabledDates", void 0);
    __decorate5([
      attr({ attribute: "selected-dates" })
    ], Calendar.prototype, "selectedDates", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.options.js
var GenerateHeaderOptions, DataGridCellTypes, DataGridRowTypes;
var init_data_grid_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.options.js"() {
    GenerateHeaderOptions = {
      none: "none",
      default: "default",
      sticky: "sticky"
    };
    DataGridCellTypes = {
      default: "default",
      columnHeader: "columnheader",
      rowHeader: "rowheader"
    };
    DataGridRowTypes = {
      default: "default",
      header: "header",
      stickyHeader: "sticky-header"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.js
var DataGridRow;
var init_data_grid_row = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_data_grid_options();
    DataGridRow = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.rowType = DataGridRowTypes.default;
        this.rowData = null;
        this.columnDefinitions = null;
        this.isActiveRow = false;
        this.cellsRepeatBehavior = null;
        this.cellsPlaceholder = null;
        this.focusColumnIndex = 0;
        this.refocusOnLoad = false;
        this.updateRowStyle = () => {
          this.style.gridTemplateColumns = this.gridTemplateColumns;
        };
      }
      gridTemplateColumnsChanged() {
        if (this.$fastController.isConnected) {
          this.updateRowStyle();
        }
      }
      rowTypeChanged() {
        if (this.$fastController.isConnected) {
          this.updateItemTemplate();
        }
      }
      rowDataChanged() {
        if (this.rowData !== null && this.isActiveRow) {
          this.refocusOnLoad = true;
          return;
        }
      }
      cellItemTemplateChanged() {
        this.updateItemTemplate();
      }
      headerCellItemTemplateChanged() {
        this.updateItemTemplate();
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (this.cellsRepeatBehavior === null) {
          this.cellsPlaceholder = document.createComment("");
          this.appendChild(this.cellsPlaceholder);
          this.updateItemTemplate();
          this.cellsRepeatBehavior = new RepeatDirective2((x) => x.columnDefinitions, (x) => x.activeCellItemTemplate, { positioning: true }).createBehavior(this.cellsPlaceholder);
          this.$fastController.addBehaviors([this.cellsRepeatBehavior]);
        }
        this.addEventListener("cell-focused", this.handleCellFocus);
        this.addEventListener(eventFocusOut, this.handleFocusout);
        this.addEventListener(eventKeyDown, this.handleKeydown);
        this.updateRowStyle();
        if (this.refocusOnLoad) {
          this.refocusOnLoad = false;
          if (this.cellElements.length > this.focusColumnIndex) {
            this.cellElements[this.focusColumnIndex].focus();
          }
        }
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("cell-focused", this.handleCellFocus);
        this.removeEventListener(eventFocusOut, this.handleFocusout);
        this.removeEventListener(eventKeyDown, this.handleKeydown);
      }
      handleFocusout(e) {
        if (!this.contains(e.target)) {
          this.isActiveRow = false;
          this.focusColumnIndex = 0;
        }
      }
      handleCellFocus(e) {
        this.isActiveRow = true;
        this.focusColumnIndex = this.cellElements.indexOf(e.target);
        this.$emit("row-focused", this);
      }
      handleKeydown(e) {
        if (e.defaultPrevented) {
          return;
        }
        let newFocusColumnIndex = 0;
        switch (e.key) {
          case keyArrowLeft:
            newFocusColumnIndex = Math.max(0, this.focusColumnIndex - 1);
            this.cellElements[newFocusColumnIndex].focus();
            e.preventDefault();
            break;
          case keyArrowRight:
            newFocusColumnIndex = Math.min(this.cellElements.length - 1, this.focusColumnIndex + 1);
            this.cellElements[newFocusColumnIndex].focus();
            e.preventDefault();
            break;
          case keyHome:
            if (!e.ctrlKey) {
              this.cellElements[0].focus();
              e.preventDefault();
            }
            break;
          case keyEnd:
            if (!e.ctrlKey) {
              this.cellElements[this.cellElements.length - 1].focus();
              e.preventDefault();
            }
            break;
        }
      }
      updateItemTemplate() {
        this.activeCellItemTemplate = this.rowType === DataGridRowTypes.default && this.cellItemTemplate !== void 0 ? this.cellItemTemplate : this.rowType === DataGridRowTypes.default && this.cellItemTemplate === void 0 ? this.defaultCellItemTemplate : this.headerCellItemTemplate !== void 0 ? this.headerCellItemTemplate : this.defaultHeaderCellItemTemplate;
      }
    };
    __decorate5([
      attr({ attribute: "grid-template-columns" })
    ], DataGridRow.prototype, "gridTemplateColumns", void 0);
    __decorate5([
      attr({ attribute: "row-type" })
    ], DataGridRow.prototype, "rowType", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "rowData", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "columnDefinitions", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "cellItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "headerCellItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "rowIndex", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "isActiveRow", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "activeCellItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "defaultCellItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "defaultHeaderCellItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGridRow.prototype, "cellElements", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.template.js
function createRowItemTemplate(context) {
  const rowTag = context.tagFor(DataGridRow);
  return html2`
    <${rowTag}
        :rowData="${(x) => x}"
        :cellItemTemplate="${(x, c) => c.parent.cellItemTemplate}"
        :headerCellItemTemplate="${(x, c) => c.parent.headerCellItemTemplate}"
    ></${rowTag}>
`;
}
var dataGridTemplate;
var init_data_grid_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.template.js"() {
    init_esm();
    init_data_grid_row();
    dataGridTemplate = (context, definition) => {
      const rowItemTemplate = createRowItemTemplate(context);
      const rowTag = context.tagFor(DataGridRow);
      return html2`
        <template
            role="grid"
            tabindex="0"
            :rowElementTag="${() => rowTag}"
            :defaultRowItemTemplate="${rowItemTemplate}"
            ${children({
        property: "rowElements",
        filter: elements("[role=row]")
      })}
        >
            <slot></slot>
        </template>
    `;
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.js
var DataGrid;
var init_data_grid = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_data_grid_options();
    DataGrid = class extends FoundationElement {
      constructor() {
        super();
        this.noTabbing = false;
        this.generateHeader = GenerateHeaderOptions.default;
        this.rowsData = [];
        this.columnDefinitions = null;
        this.focusRowIndex = 0;
        this.focusColumnIndex = 0;
        this.rowsPlaceholder = null;
        this.generatedHeader = null;
        this.isUpdatingFocus = false;
        this.pendingFocusUpdate = false;
        this.rowindexUpdateQueued = false;
        this.columnDefinitionsStale = true;
        this.generatedGridTemplateColumns = "";
        this.focusOnCell = (rowIndex, columnIndex, scrollIntoView) => {
          if (this.rowElements.length === 0) {
            this.focusRowIndex = 0;
            this.focusColumnIndex = 0;
            return;
          }
          const focusRowIndex = Math.max(0, Math.min(this.rowElements.length - 1, rowIndex));
          const focusRow = this.rowElements[focusRowIndex];
          const cells = focusRow.querySelectorAll('[role="cell"], [role="gridcell"], [role="columnheader"], [role="rowheader"]');
          const focusColumnIndex = Math.max(0, Math.min(cells.length - 1, columnIndex));
          const focusTarget = cells[focusColumnIndex];
          if (scrollIntoView && this.scrollHeight !== this.clientHeight && (focusRowIndex < this.focusRowIndex && this.scrollTop > 0 || focusRowIndex > this.focusRowIndex && this.scrollTop < this.scrollHeight - this.clientHeight)) {
            focusTarget.scrollIntoView({ block: "center", inline: "center" });
          }
          focusTarget.focus();
        };
        this.onChildListChange = (mutations, observer2) => {
          if (mutations && mutations.length) {
            mutations.forEach((mutation) => {
              mutation.addedNodes.forEach((newNode) => {
                if (newNode.nodeType === 1 && newNode.getAttribute("role") === "row") {
                  newNode.columnDefinitions = this.columnDefinitions;
                }
              });
            });
            this.queueRowIndexUpdate();
          }
        };
        this.queueRowIndexUpdate = () => {
          if (!this.rowindexUpdateQueued) {
            this.rowindexUpdateQueued = true;
            DOM.queueUpdate(this.updateRowIndexes);
          }
        };
        this.updateRowIndexes = () => {
          let newGridTemplateColumns = this.gridTemplateColumns;
          if (newGridTemplateColumns === void 0) {
            if (this.generatedGridTemplateColumns === "" && this.rowElements.length > 0) {
              const firstRow = this.rowElements[0];
              this.generatedGridTemplateColumns = new Array(firstRow.cellElements.length).fill("1fr").join(" ");
            }
            newGridTemplateColumns = this.generatedGridTemplateColumns;
          }
          this.rowElements.forEach((element, index) => {
            const thisRow = element;
            thisRow.rowIndex = index;
            thisRow.gridTemplateColumns = newGridTemplateColumns;
            if (this.columnDefinitionsStale) {
              thisRow.columnDefinitions = this.columnDefinitions;
            }
          });
          this.rowindexUpdateQueued = false;
          this.columnDefinitionsStale = false;
        };
      }
      /**
       *  generates a gridTemplateColumns based on columndata array
       */
      static generateTemplateColumns(columnDefinitions) {
        let templateColumns = "";
        columnDefinitions.forEach((column) => {
          templateColumns = `${templateColumns}${templateColumns === "" ? "" : " "}${"1fr"}`;
        });
        return templateColumns;
      }
      noTabbingChanged() {
        if (this.$fastController.isConnected) {
          if (this.noTabbing) {
            this.setAttribute("tabIndex", "-1");
          } else {
            this.setAttribute("tabIndex", this.contains(document.activeElement) || this === document.activeElement ? "-1" : "0");
          }
        }
      }
      generateHeaderChanged() {
        if (this.$fastController.isConnected) {
          this.toggleGeneratedHeader();
        }
      }
      gridTemplateColumnsChanged() {
        if (this.$fastController.isConnected) {
          this.updateRowIndexes();
        }
      }
      rowsDataChanged() {
        if (this.columnDefinitions === null && this.rowsData.length > 0) {
          this.columnDefinitions = DataGrid.generateColumns(this.rowsData[0]);
        }
        if (this.$fastController.isConnected) {
          this.toggleGeneratedHeader();
        }
      }
      columnDefinitionsChanged() {
        if (this.columnDefinitions === null) {
          this.generatedGridTemplateColumns = "";
          return;
        }
        this.generatedGridTemplateColumns = DataGrid.generateTemplateColumns(this.columnDefinitions);
        if (this.$fastController.isConnected) {
          this.columnDefinitionsStale = true;
          this.queueRowIndexUpdate();
        }
      }
      headerCellItemTemplateChanged() {
        if (this.$fastController.isConnected) {
          if (this.generatedHeader !== null) {
            this.generatedHeader.headerCellItemTemplate = this.headerCellItemTemplate;
          }
        }
      }
      focusRowIndexChanged() {
        if (this.$fastController.isConnected) {
          this.queueFocusUpdate();
        }
      }
      focusColumnIndexChanged() {
        if (this.$fastController.isConnected) {
          this.queueFocusUpdate();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (this.rowItemTemplate === void 0) {
          this.rowItemTemplate = this.defaultRowItemTemplate;
        }
        this.rowsPlaceholder = document.createComment("");
        this.appendChild(this.rowsPlaceholder);
        this.toggleGeneratedHeader();
        this.rowsRepeatBehavior = new RepeatDirective2((x) => x.rowsData, (x) => x.rowItemTemplate, { positioning: true }).createBehavior(this.rowsPlaceholder);
        this.$fastController.addBehaviors([this.rowsRepeatBehavior]);
        this.addEventListener("row-focused", this.handleRowFocus);
        this.addEventListener(eventFocus, this.handleFocus);
        this.addEventListener(eventKeyDown, this.handleKeydown);
        this.addEventListener(eventFocusOut, this.handleFocusOut);
        this.observer = new MutationObserver(this.onChildListChange);
        this.observer.observe(this, { childList: true });
        if (this.noTabbing) {
          this.setAttribute("tabindex", "-1");
        }
        DOM.queueUpdate(this.queueRowIndexUpdate);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("row-focused", this.handleRowFocus);
        this.removeEventListener(eventFocus, this.handleFocus);
        this.removeEventListener(eventKeyDown, this.handleKeydown);
        this.removeEventListener(eventFocusOut, this.handleFocusOut);
        this.observer.disconnect();
        this.rowsPlaceholder = null;
        this.generatedHeader = null;
      }
      /**
       * @internal
       */
      handleRowFocus(e) {
        this.isUpdatingFocus = true;
        const focusRow = e.target;
        this.focusRowIndex = this.rowElements.indexOf(focusRow);
        this.focusColumnIndex = focusRow.focusColumnIndex;
        this.setAttribute("tabIndex", "-1");
        this.isUpdatingFocus = false;
      }
      /**
       * @internal
       */
      handleFocus(e) {
        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);
      }
      /**
       * @internal
       */
      handleFocusOut(e) {
        if (e.relatedTarget === null || !this.contains(e.relatedTarget)) {
          this.setAttribute("tabIndex", this.noTabbing ? "-1" : "0");
        }
      }
      /**
       * @internal
       */
      handleKeydown(e) {
        if (e.defaultPrevented) {
          return;
        }
        let newFocusRowIndex;
        const maxIndex = this.rowElements.length - 1;
        const currentGridBottom = this.offsetHeight + this.scrollTop;
        const lastRow = this.rowElements[maxIndex];
        switch (e.key) {
          case keyArrowUp:
            e.preventDefault();
            this.focusOnCell(this.focusRowIndex - 1, this.focusColumnIndex, true);
            break;
          case keyArrowDown:
            e.preventDefault();
            this.focusOnCell(this.focusRowIndex + 1, this.focusColumnIndex, true);
            break;
          case keyPageUp:
            e.preventDefault();
            if (this.rowElements.length === 0) {
              this.focusOnCell(0, 0, false);
              break;
            }
            if (this.focusRowIndex === 0) {
              this.focusOnCell(0, this.focusColumnIndex, false);
              return;
            }
            newFocusRowIndex = this.focusRowIndex - 1;
            for (newFocusRowIndex; newFocusRowIndex >= 0; newFocusRowIndex--) {
              const thisRow = this.rowElements[newFocusRowIndex];
              if (thisRow.offsetTop < this.scrollTop) {
                this.scrollTop = thisRow.offsetTop + thisRow.clientHeight - this.clientHeight;
                break;
              }
            }
            this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);
            break;
          case keyPageDown:
            e.preventDefault();
            if (this.rowElements.length === 0) {
              this.focusOnCell(0, 0, false);
              break;
            }
            if (this.focusRowIndex >= maxIndex || lastRow.offsetTop + lastRow.offsetHeight <= currentGridBottom) {
              this.focusOnCell(maxIndex, this.focusColumnIndex, false);
              return;
            }
            newFocusRowIndex = this.focusRowIndex + 1;
            for (newFocusRowIndex; newFocusRowIndex <= maxIndex; newFocusRowIndex++) {
              const thisRow = this.rowElements[newFocusRowIndex];
              if (thisRow.offsetTop + thisRow.offsetHeight > currentGridBottom) {
                let stickyHeaderOffset = 0;
                if (this.generateHeader === GenerateHeaderOptions.sticky && this.generatedHeader !== null) {
                  stickyHeaderOffset = this.generatedHeader.clientHeight;
                }
                this.scrollTop = thisRow.offsetTop - stickyHeaderOffset;
                break;
              }
            }
            this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);
            break;
          case keyHome:
            if (e.ctrlKey) {
              e.preventDefault();
              this.focusOnCell(0, 0, true);
            }
            break;
          case keyEnd:
            if (e.ctrlKey && this.columnDefinitions !== null) {
              e.preventDefault();
              this.focusOnCell(this.rowElements.length - 1, this.columnDefinitions.length - 1, true);
            }
            break;
        }
      }
      queueFocusUpdate() {
        if (this.isUpdatingFocus && (this.contains(document.activeElement) || this === document.activeElement)) {
          return;
        }
        if (this.pendingFocusUpdate === false) {
          this.pendingFocusUpdate = true;
          DOM.queueUpdate(() => this.updateFocus());
        }
      }
      updateFocus() {
        this.pendingFocusUpdate = false;
        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);
      }
      toggleGeneratedHeader() {
        if (this.generatedHeader !== null) {
          this.removeChild(this.generatedHeader);
          this.generatedHeader = null;
        }
        if (this.generateHeader !== GenerateHeaderOptions.none && this.rowsData.length > 0) {
          const generatedHeaderElement = document.createElement(this.rowElementTag);
          this.generatedHeader = generatedHeaderElement;
          this.generatedHeader.columnDefinitions = this.columnDefinitions;
          this.generatedHeader.gridTemplateColumns = this.gridTemplateColumns;
          this.generatedHeader.rowType = this.generateHeader === GenerateHeaderOptions.sticky ? DataGridRowTypes.stickyHeader : DataGridRowTypes.header;
          if (this.firstChild !== null || this.rowsPlaceholder !== null) {
            this.insertBefore(generatedHeaderElement, this.firstChild !== null ? this.firstChild : this.rowsPlaceholder);
          }
          return;
        }
      }
    };
    DataGrid.generateColumns = (row) => {
      return Object.getOwnPropertyNames(row).map((property2, index) => {
        return {
          columnDataKey: property2,
          gridColumn: `${index}`
        };
      });
    };
    __decorate5([
      attr({ attribute: "no-tabbing", mode: "boolean" })
    ], DataGrid.prototype, "noTabbing", void 0);
    __decorate5([
      attr({ attribute: "generate-header" })
    ], DataGrid.prototype, "generateHeader", void 0);
    __decorate5([
      attr({ attribute: "grid-template-columns" })
    ], DataGrid.prototype, "gridTemplateColumns", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "rowsData", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "columnDefinitions", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "rowItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "cellItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "headerCellItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "focusRowIndex", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "focusColumnIndex", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "defaultRowItemTemplate", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "rowElementTag", void 0);
    __decorate5([
      observable
    ], DataGrid.prototype, "rowElements", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.js
var defaultCellContentsTemplate, defaultHeaderCellContentsTemplate, DataGridCell;
var init_data_grid_cell = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_data_grid_options();
    defaultCellContentsTemplate = html2`
    <template>
        ${(x) => x.rowData === null || x.columnDefinition === null || x.columnDefinition.columnDataKey === null ? null : x.rowData[x.columnDefinition.columnDataKey]}
    </template>
`;
    defaultHeaderCellContentsTemplate = html2`
    <template>
        ${(x) => x.columnDefinition === null ? null : x.columnDefinition.title === void 0 ? x.columnDefinition.columnDataKey : x.columnDefinition.title}
    </template>
`;
    DataGridCell = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.cellType = DataGridCellTypes.default;
        this.rowData = null;
        this.columnDefinition = null;
        this.isActiveCell = false;
        this.customCellView = null;
        this.updateCellStyle = () => {
          this.style.gridColumn = this.gridColumn;
        };
      }
      cellTypeChanged() {
        if (this.$fastController.isConnected) {
          this.updateCellView();
        }
      }
      gridColumnChanged() {
        if (this.$fastController.isConnected) {
          this.updateCellStyle();
        }
      }
      columnDefinitionChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.updateCellView();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        var _a2;
        super.connectedCallback();
        this.addEventListener(eventFocusIn, this.handleFocusin);
        this.addEventListener(eventFocusOut, this.handleFocusout);
        this.addEventListener(eventKeyDown, this.handleKeydown);
        this.style.gridColumn = `${((_a2 = this.columnDefinition) === null || _a2 === void 0 ? void 0 : _a2.gridColumn) === void 0 ? 0 : this.columnDefinition.gridColumn}`;
        this.updateCellView();
        this.updateCellStyle();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener(eventFocusIn, this.handleFocusin);
        this.removeEventListener(eventFocusOut, this.handleFocusout);
        this.removeEventListener(eventKeyDown, this.handleKeydown);
        this.disconnectCellView();
      }
      handleFocusin(e) {
        if (this.isActiveCell) {
          return;
        }
        this.isActiveCell = true;
        switch (this.cellType) {
          case DataGridCellTypes.columnHeader:
            if (this.columnDefinition !== null && this.columnDefinition.headerCellInternalFocusQueue !== true && typeof this.columnDefinition.headerCellFocusTargetCallback === "function") {
              const focusTarget = this.columnDefinition.headerCellFocusTargetCallback(this);
              if (focusTarget !== null) {
                focusTarget.focus();
              }
            }
            break;
          default:
            if (this.columnDefinition !== null && this.columnDefinition.cellInternalFocusQueue !== true && typeof this.columnDefinition.cellFocusTargetCallback === "function") {
              const focusTarget = this.columnDefinition.cellFocusTargetCallback(this);
              if (focusTarget !== null) {
                focusTarget.focus();
              }
            }
            break;
        }
        this.$emit("cell-focused", this);
      }
      handleFocusout(e) {
        if (this !== document.activeElement && !this.contains(document.activeElement)) {
          this.isActiveCell = false;
        }
      }
      handleKeydown(e) {
        if (e.defaultPrevented || this.columnDefinition === null || this.cellType === DataGridCellTypes.default && this.columnDefinition.cellInternalFocusQueue !== true || this.cellType === DataGridCellTypes.columnHeader && this.columnDefinition.headerCellInternalFocusQueue !== true) {
          return;
        }
        switch (e.key) {
          case keyEnter:
          case keyFunction2:
            if (this.contains(document.activeElement) && document.activeElement !== this) {
              return;
            }
            switch (this.cellType) {
              case DataGridCellTypes.columnHeader:
                if (this.columnDefinition.headerCellFocusTargetCallback !== void 0) {
                  const focusTarget = this.columnDefinition.headerCellFocusTargetCallback(this);
                  if (focusTarget !== null) {
                    focusTarget.focus();
                  }
                  e.preventDefault();
                }
                break;
              default:
                if (this.columnDefinition.cellFocusTargetCallback !== void 0) {
                  const focusTarget = this.columnDefinition.cellFocusTargetCallback(this);
                  if (focusTarget !== null) {
                    focusTarget.focus();
                  }
                  e.preventDefault();
                }
                break;
            }
            break;
          case keyEscape:
            if (this.contains(document.activeElement) && document.activeElement !== this) {
              this.focus();
              e.preventDefault();
            }
            break;
        }
      }
      updateCellView() {
        this.disconnectCellView();
        if (this.columnDefinition === null) {
          return;
        }
        switch (this.cellType) {
          case DataGridCellTypes.columnHeader:
            if (this.columnDefinition.headerCellTemplate !== void 0) {
              this.customCellView = this.columnDefinition.headerCellTemplate.render(this, this);
            } else {
              this.customCellView = defaultHeaderCellContentsTemplate.render(this, this);
            }
            break;
          case void 0:
          case DataGridCellTypes.rowHeader:
          case DataGridCellTypes.default:
            if (this.columnDefinition.cellTemplate !== void 0) {
              this.customCellView = this.columnDefinition.cellTemplate.render(this, this);
            } else {
              this.customCellView = defaultCellContentsTemplate.render(this, this);
            }
            break;
        }
      }
      disconnectCellView() {
        if (this.customCellView !== null) {
          this.customCellView.dispose();
          this.customCellView = null;
        }
      }
    };
    __decorate5([
      attr({ attribute: "cell-type" })
    ], DataGridCell.prototype, "cellType", void 0);
    __decorate5([
      attr({ attribute: "grid-column" })
    ], DataGridCell.prototype, "gridColumn", void 0);
    __decorate5([
      observable
    ], DataGridCell.prototype, "rowData", void 0);
    __decorate5([
      observable
    ], DataGridCell.prototype, "columnDefinition", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.template.js
function createCellItemTemplate(context) {
  const cellTag = context.tagFor(DataGridCell);
  return html2`
    <${cellTag}
        cell-type="${(x) => x.isRowHeader ? "rowheader" : void 0}"
        grid-column="${(x, c) => c.index + 1}"
        :rowData="${(x, c) => c.parent.rowData}"
        :columnDefinition="${(x) => x}"
    ></${cellTag}>
`;
}
function createHeaderCellItemTemplate(context) {
  const cellTag = context.tagFor(DataGridCell);
  return html2`
    <${cellTag}
        cell-type="columnheader"
        grid-column="${(x, c) => c.index + 1}"
        :columnDefinition="${(x) => x}"
    ></${cellTag}>
`;
}
var dataGridRowTemplate;
var init_data_grid_row_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-row.template.js"() {
    init_esm();
    init_data_grid_cell();
    dataGridRowTemplate = (context, definition) => {
      const cellItemTemplate = createCellItemTemplate(context);
      const headerCellItemTemplate = createHeaderCellItemTemplate(context);
      return html2`
        <template
            role="row"
            class="${(x) => x.rowType !== "default" ? x.rowType : ""}"
            :defaultCellItemTemplate="${cellItemTemplate}"
            :defaultHeaderCellItemTemplate="${headerCellItemTemplate}"
            ${children({
        property: "cellElements",
        filter: elements('[role="cell"],[role="gridcell"],[role="columnheader"],[role="rowheader"]')
      })}
        >
            <slot ${slotted("slottedCellElements")}></slot>
        </template>
    `;
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.template.js
var dataGridCellTemplate;
var init_data_grid_cell_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid-cell.template.js"() {
    init_esm();
    dataGridCellTemplate = (context, definition) => {
      return html2`
        <template
            tabindex="-1"
            role="${(x) => !x.cellType || x.cellType === "default" ? "gridcell" : x.cellType}"
            class="
            ${(x) => x.cellType === "columnheader" ? "column-header" : x.cellType === "rowheader" ? "row-header" : ""}
            "
        >
            <slot></slot>
        </template>
    `;
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/data-grid/index.js
var init_data_grid2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/data-grid/index.js"() {
    init_data_grid_template();
    init_data_grid();
    init_data_grid_row_template();
    init_data_grid_row();
    init_data_grid_cell_template();
    init_data_grid_cell();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.template.js
var CalendarTitleTemplate, calendarWeekdayTemplate, calendarCellTemplate, calendarRowTemplate, interactiveCalendarGridTemplate, noninteractiveCalendarTemplate, calendarTemplate;
var init_calendar_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/calendar/calendar.template.js"() {
    init_esm();
    init_start_end();
    init_data_grid2();
    CalendarTitleTemplate = html2`
    <div
        class="title"
        part="title"
        aria-label="${(x) => x.dateFormatter.getDate(`${x.month}-2-${x.year}`, {
      month: "long",
      year: "numeric"
    })}"
    >
        <span part="month">
            ${(x) => x.dateFormatter.getMonth(x.month)}
        </span>
        <span part="year">${(x) => x.dateFormatter.getYear(x.year)}</span>
    </div>
`;
    calendarWeekdayTemplate = (context) => {
      const cellTag = context.tagFor(DataGridCell);
      return html2`
        <${cellTag}
            class="week-day"
            part="week-day"
            tabindex="-1"
            grid-column="${(x, c) => c.index + 1}"
            abbr="${(x) => x.abbr}"
        >
            ${(x) => x.text}
        </${cellTag}>
    `;
    };
    calendarCellTemplate = (context, todayString) => {
      const cellTag = context.tagFor(DataGridCell);
      return html2`
        <${cellTag}
            class="${(x, c) => c.parentContext.parent.getDayClassNames(x, todayString)}"
            part="day"
            tabindex="-1"
            role="gridcell"
            grid-column="${(x, c) => c.index + 1}"
            @click="${(x, c) => c.parentContext.parent.handleDateSelect(c.event, x)}"
            @keydown="${(x, c) => c.parentContext.parent.handleKeydown(c.event, x)}"
            aria-label="${(x, c) => c.parentContext.parent.dateFormatter.getDate(`${x.month}-${x.day}-${x.year}`, { month: "long", day: "numeric" })}"
        >
            <div
                class="date"
                part="${(x) => todayString === `${x.month}-${x.day}-${x.year}` ? "today" : "date"}"
            >
                ${(x, c) => c.parentContext.parent.dateFormatter.getDay(x.day)}
            </div>
            <slot name="${(x) => x.month}-${(x) => x.day}-${(x) => x.year}"></slot>
        </${cellTag}>
    `;
    };
    calendarRowTemplate = (context, todayString) => {
      const rowTag = context.tagFor(DataGridRow);
      return html2`
        <${rowTag}
            class="week"
            part="week"
            role="row"
            role-type="default"
            grid-template-columns="1fr 1fr 1fr 1fr 1fr 1fr 1fr"
        >
        ${repeat2((x) => x, calendarCellTemplate(context, todayString), {
        positioning: true
      })}
        </${rowTag}>
    `;
    };
    interactiveCalendarGridTemplate = (context, todayString) => {
      const gridTag = context.tagFor(DataGrid);
      const rowTag = context.tagFor(DataGridRow);
      return html2`
    <${gridTag} class="days interact" part="days" generate-header="none">
        <${rowTag}
            class="week-days"
            part="week-days"
            role="row"
            row-type="header"
            grid-template-columns="1fr 1fr 1fr 1fr 1fr 1fr 1fr"
        >
            ${repeat2((x) => x.getWeekdayText(), calendarWeekdayTemplate(context), {
        positioning: true
      })}
        </${rowTag}>
        ${repeat2((x) => x.getDays(), calendarRowTemplate(context, todayString))}
    </${gridTag}>
`;
    };
    noninteractiveCalendarTemplate = (todayString) => {
      return html2`
        <div class="days" part="days">
            <div class="week-days" part="week-days">
                ${repeat2((x) => x.getWeekdayText(), html2`
                        <div class="week-day" part="week-day" abbr="${(x) => x.abbr}">
                            ${(x) => x.text}
                        </div>
                    `)}
            </div>
            ${repeat2((x) => x.getDays(), html2`
                    <div class="week">
                        ${repeat2((x) => x, html2`
                                <div
                                    class="${(x, c) => c.parentContext.parent.getDayClassNames(x, todayString)}"
                                    part="day"
                                    aria-label="${(x, c) => c.parentContext.parent.dateFormatter.getDate(`${x.month}-${x.day}-${x.year}`, { month: "long", day: "numeric" })}"
                                >
                                    <div
                                        class="date"
                                        part="${(x) => todayString === `${x.month}-${x.day}-${x.year}` ? "today" : "date"}"
                                    >
                                        ${(x, c) => c.parentContext.parent.dateFormatter.getDay(x.day)}
                                    </div>
                                    <slot
                                        name="${(x) => x.month}-${(x) => x.day}-${(x) => x.year}"
                                    ></slot>
                                </div>
                            `)}
                    </div>
                `)}
        </div>
    `;
    };
    calendarTemplate = (context, definition) => {
      var _a2;
      const today = /* @__PURE__ */ new Date();
      const todayString = `${today.getMonth() + 1}-${today.getDate()}-${today.getFullYear()}`;
      return html2`
        <template>
            ${startTemplate}
            ${definition.title instanceof Function ? definition.title(context, definition) : (_a2 = definition.title) !== null && _a2 !== void 0 ? _a2 : ""}
            <slot></slot>
            ${when((x) => x.readonly === false, interactiveCalendarGridTemplate(context, todayString))}
            ${when((x) => x.readonly === true, noninteractiveCalendarTemplate(todayString))}
            ${endTemplate}
        </template>
    `;
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/calendar/index.js
var init_calendar2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/calendar/index.js"() {
    init_calendar();
    init_calendar_template();
    init_date_formatter();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/card/card.template.js
var cardTemplate;
var init_card_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/card/card.template.js"() {
    init_esm();
    cardTemplate = (context, definition) => html2`
    <slot></slot>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/card/card.js
var Card;
var init_card = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/card/card.js"() {
    init_foundation_element();
    Card = class extends FoundationElement {
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/card/index.js
var init_card2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/card/index.js"() {
    init_card_template();
    init_card();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.template.js
var checkboxTemplate;
var init_checkbox_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.template.js"() {
    init_esm();
    checkboxTemplate = (context, definition) => html2`
    <template
        role="checkbox"
        aria-checked="${(x) => x.checked}"
        aria-required="${(x) => x.required}"
        aria-disabled="${(x) => x.disabled}"
        aria-readonly="${(x) => x.readOnly}"
        tabindex="${(x) => x.disabled ? null : 0}"
        @keypress="${(x, c) => x.keypressHandler(c.event)}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        class="${(x) => x.readOnly ? "readonly" : ""} ${(x) => x.checked ? "checked" : ""} ${(x) => x.indeterminate ? "indeterminate" : ""}"
    >
        <div part="control" class="control">
            <slot name="checked-indicator">
                ${definition.checkedIndicator || ""}
            </slot>
            <slot name="indeterminate-indicator">
                ${definition.indeterminateIndicator || ""}
            </slot>
        </div>
        <label
            part="label"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.form-associated.js
var _Checkbox, FormAssociatedCheckbox;
var init_checkbox_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Checkbox = class extends FoundationElement {
    };
    FormAssociatedCheckbox = class extends CheckableFormAssociated(_Checkbox) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.js
var Checkbox;
var init_checkbox = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_checkbox_form_associated();
    Checkbox = class extends FormAssociatedCheckbox {
      constructor() {
        super();
        this.initialValue = "on";
        this.indeterminate = false;
        this.keypressHandler = (e) => {
          if (this.readOnly) {
            return;
          }
          switch (e.key) {
            case keySpace:
              if (this.indeterminate) {
                this.indeterminate = false;
              }
              this.checked = !this.checked;
              break;
          }
        };
        this.clickHandler = (e) => {
          if (!this.disabled && !this.readOnly) {
            if (this.indeterminate) {
              this.indeterminate = false;
            }
            this.checked = !this.checked;
          }
        };
        this.proxy.setAttribute("type", "checkbox");
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Checkbox.prototype, "readOnly", void 0);
    __decorate5([
      observable
    ], Checkbox.prototype, "defaultSlottedNodes", void 0);
    __decorate5([
      observable
    ], Checkbox.prototype, "indeterminate", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/checkbox/index.js
var init_checkbox2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/checkbox/index.js"() {
    init_checkbox_template();
    init_checkbox();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.js
function isListboxOption(el) {
  return isHTMLElement(el) && (el.getAttribute("role") === "option" || el instanceof HTMLOptionElement);
}
var ListboxOption, DelegatesARIAListboxOption;
var init_listbox_option = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_aria_global();
    init_start_end();
    init_apply_mixins();
    ListboxOption = class extends FoundationElement {
      constructor(text, value, defaultSelected, selected) {
        super();
        this.defaultSelected = false;
        this.dirtySelected = false;
        this.selected = this.defaultSelected;
        this.dirtyValue = false;
        if (text) {
          this.textContent = text;
        }
        if (value) {
          this.initialValue = value;
        }
        if (defaultSelected) {
          this.defaultSelected = defaultSelected;
        }
        if (selected) {
          this.selected = selected;
        }
        this.proxy = new Option(`${this.textContent}`, this.initialValue, this.defaultSelected, this.selected);
        this.proxy.disabled = this.disabled;
      }
      /**
       * Updates the ariaChecked property when the checked property changes.
       *
       * @param prev - the previous checked value
       * @param next - the current checked value
       *
       * @public
       */
      checkedChanged(prev, next) {
        if (typeof next === "boolean") {
          this.ariaChecked = next ? "true" : "false";
          return;
        }
        this.ariaChecked = null;
      }
      /**
       * Updates the proxy's text content when the default slot changes.
       * @param prev - the previous content value
       * @param next - the current content value
       *
       * @internal
       */
      contentChanged(prev, next) {
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.textContent = this.textContent;
        }
        this.$emit("contentchange", null, { bubbles: true });
      }
      defaultSelectedChanged() {
        if (!this.dirtySelected) {
          this.selected = this.defaultSelected;
          if (this.proxy instanceof HTMLOptionElement) {
            this.proxy.selected = this.defaultSelected;
          }
        }
      }
      disabledChanged(prev, next) {
        this.ariaDisabled = this.disabled ? "true" : "false";
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.disabled = this.disabled;
        }
      }
      selectedAttributeChanged() {
        this.defaultSelected = this.selectedAttribute;
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.defaultSelected = this.defaultSelected;
        }
      }
      selectedChanged() {
        this.ariaSelected = this.selected ? "true" : "false";
        if (!this.dirtySelected) {
          this.dirtySelected = true;
        }
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.selected = this.selected;
        }
      }
      initialValueChanged(previous, next) {
        if (!this.dirtyValue) {
          this.value = this.initialValue;
          this.dirtyValue = false;
        }
      }
      get label() {
        var _a2;
        return (_a2 = this.value) !== null && _a2 !== void 0 ? _a2 : this.text;
      }
      get text() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.textContent) === null || _a2 === void 0 ? void 0 : _a2.replace(/\s+/g, " ").trim()) !== null && _b2 !== void 0 ? _b2 : "";
      }
      set value(next) {
        const newValue = `${next !== null && next !== void 0 ? next : ""}`;
        this._value = newValue;
        this.dirtyValue = true;
        if (this.proxy instanceof HTMLOptionElement) {
          this.proxy.value = newValue;
        }
        Observable.notify(this, "value");
      }
      get value() {
        var _a2;
        Observable.track(this, "value");
        return (_a2 = this._value) !== null && _a2 !== void 0 ? _a2 : this.text;
      }
      get form() {
        return this.proxy ? this.proxy.form : null;
      }
    };
    __decorate5([
      observable
    ], ListboxOption.prototype, "checked", void 0);
    __decorate5([
      observable
    ], ListboxOption.prototype, "content", void 0);
    __decorate5([
      observable
    ], ListboxOption.prototype, "defaultSelected", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], ListboxOption.prototype, "disabled", void 0);
    __decorate5([
      attr({ attribute: "selected", mode: "boolean" })
    ], ListboxOption.prototype, "selectedAttribute", void 0);
    __decorate5([
      observable
    ], ListboxOption.prototype, "selected", void 0);
    __decorate5([
      attr({ attribute: "value", mode: "fromView" })
    ], ListboxOption.prototype, "initialValue", void 0);
    DelegatesARIAListboxOption = class {
    };
    __decorate5([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaChecked", void 0);
    __decorate5([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaPosInSet", void 0);
    __decorate5([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaSelected", void 0);
    __decorate5([
      observable
    ], DelegatesARIAListboxOption.prototype, "ariaSetSize", void 0);
    applyMixins(DelegatesARIAListboxOption, ARIAGlobalStatesAndProperties);
    applyMixins(ListboxOption, StartEnd, DelegatesARIAListboxOption);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.js
var Listbox, DelegatesARIAListbox;
var init_listbox = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_listbox_option();
    init_aria_global();
    init_apply_mixins();
    Listbox = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this._options = [];
        this.selectedIndex = -1;
        this.selectedOptions = [];
        this.shouldSkipFocus = false;
        this.typeaheadBuffer = "";
        this.typeaheadExpired = true;
        this.typeaheadTimeout = -1;
      }
      /**
       * The first selected option.
       *
       * @internal
       */
      get firstSelectedOption() {
        var _a2;
        return (_a2 = this.selectedOptions[0]) !== null && _a2 !== void 0 ? _a2 : null;
      }
      /**
       * Returns true if there is one or more selectable option.
       *
       * @internal
       */
      get hasSelectableOptions() {
        return this.options.length > 0 && !this.options.every((o) => o.disabled);
      }
      /**
       * The number of options.
       *
       * @public
       */
      get length() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0;
      }
      /**
       * The list of options.
       *
       * @public
       */
      get options() {
        Observable.track(this, "options");
        return this._options;
      }
      set options(value) {
        this._options = value;
        Observable.notify(this, "options");
      }
      /**
       * Flag for the typeahead timeout expiration.
       *
       * @deprecated use `Listbox.typeaheadExpired`
       * @internal
       */
      get typeAheadExpired() {
        return this.typeaheadExpired;
      }
      set typeAheadExpired(value) {
        this.typeaheadExpired = value;
      }
      /**
       * Handle click events for listbox options.
       *
       * @internal
       */
      clickHandler(e) {
        const captured = e.target.closest(`option,[role=option]`);
        if (captured && !captured.disabled) {
          this.selectedIndex = this.options.indexOf(captured);
          return true;
        }
      }
      /**
       * Ensures that the provided option is focused and scrolled into view.
       *
       * @param optionToFocus - The option to focus
       * @internal
       */
      focusAndScrollOptionIntoView(optionToFocus = this.firstSelectedOption) {
        if (this.contains(document.activeElement) && optionToFocus !== null) {
          optionToFocus.focus();
          requestAnimationFrame(() => {
            optionToFocus.scrollIntoView({ block: "nearest" });
          });
        }
      }
      /**
       * Handles `focusin` actions for the component. When the component receives focus,
       * the list of selected options is refreshed and the first selected option is scrolled
       * into view.
       *
       * @internal
       */
      focusinHandler(e) {
        if (!this.shouldSkipFocus && e.target === e.currentTarget) {
          this.setSelectedOptions();
          this.focusAndScrollOptionIntoView();
        }
        this.shouldSkipFocus = false;
      }
      /**
       * Returns the options which match the current typeahead buffer.
       *
       * @internal
       */
      getTypeaheadMatches() {
        const pattern = this.typeaheadBuffer.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
        const re = new RegExp(`^${pattern}`, "gi");
        return this.options.filter((o) => o.text.trim().match(re));
      }
      /**
       * Determines the index of the next option which is selectable, if any.
       *
       * @param prev - the previous selected index
       * @param next - the next index to select
       *
       * @internal
       */
      getSelectableIndex(prev = this.selectedIndex, next) {
        const direction2 = prev > next ? -1 : prev < next ? 1 : 0;
        const potentialDirection = prev + direction2;
        let nextSelectableOption = null;
        switch (direction2) {
          case -1: {
            nextSelectableOption = this.options.reduceRight((nextSelectableOption2, thisOption, index) => !nextSelectableOption2 && !thisOption.disabled && index < potentialDirection ? thisOption : nextSelectableOption2, nextSelectableOption);
            break;
          }
          case 1: {
            nextSelectableOption = this.options.reduce((nextSelectableOption2, thisOption, index) => !nextSelectableOption2 && !thisOption.disabled && index > potentialDirection ? thisOption : nextSelectableOption2, nextSelectableOption);
            break;
          }
        }
        return this.options.indexOf(nextSelectableOption);
      }
      /**
       * Handles external changes to child options.
       *
       * @param source - the source object
       * @param propertyName - the property
       *
       * @internal
       */
      handleChange(source, propertyName) {
        switch (propertyName) {
          case "selected": {
            if (Listbox.slottedOptionFilter(source)) {
              this.selectedIndex = this.options.indexOf(source);
            }
            this.setSelectedOptions();
            break;
          }
        }
      }
      /**
       * Moves focus to an option whose label matches characters typed by the user.
       * Consecutive keystrokes are batched into a buffer of search text used
       * to match against the set of options.  If `TYPE_AHEAD_TIMEOUT_MS` passes
       * between consecutive keystrokes, the search restarts.
       *
       * @param key - the key to be evaluated
       *
       * @internal
       */
      handleTypeAhead(key) {
        if (this.typeaheadTimeout) {
          window.clearTimeout(this.typeaheadTimeout);
        }
        this.typeaheadTimeout = window.setTimeout(() => this.typeaheadExpired = true, Listbox.TYPE_AHEAD_TIMEOUT_MS);
        if (key.length > 1) {
          return;
        }
        this.typeaheadBuffer = `${this.typeaheadExpired ? "" : this.typeaheadBuffer}${key}`;
      }
      /**
       * Handles `keydown` actions for listbox navigation and typeahead.
       *
       * @internal
       */
      keydownHandler(e) {
        if (this.disabled) {
          return true;
        }
        this.shouldSkipFocus = false;
        const key = e.key;
        switch (key) {
          case keyHome: {
            if (!e.shiftKey) {
              e.preventDefault();
              this.selectFirstOption();
            }
            break;
          }
          case keyArrowDown: {
            if (!e.shiftKey) {
              e.preventDefault();
              this.selectNextOption();
            }
            break;
          }
          case keyArrowUp: {
            if (!e.shiftKey) {
              e.preventDefault();
              this.selectPreviousOption();
            }
            break;
          }
          case keyEnd: {
            e.preventDefault();
            this.selectLastOption();
            break;
          }
          case keyTab: {
            this.focusAndScrollOptionIntoView();
            return true;
          }
          case keyEnter:
          case keyEscape: {
            return true;
          }
          case keySpace: {
            if (this.typeaheadExpired) {
              return true;
            }
          }
          default: {
            if (key.length === 1) {
              this.handleTypeAhead(`${key}`);
            }
            return true;
          }
        }
      }
      /**
       * Prevents `focusin` events from firing before `click` events when the
       * element is unfocused.
       *
       * @internal
       */
      mousedownHandler(e) {
        this.shouldSkipFocus = !this.contains(document.activeElement);
        return true;
      }
      /**
       * Switches between single-selection and multi-selection mode.
       *
       * @param prev - the previous value of the `multiple` attribute
       * @param next - the next value of the `multiple` attribute
       *
       * @internal
       */
      multipleChanged(prev, next) {
        this.ariaMultiSelectable = next ? "true" : null;
      }
      /**
       * Updates the list of selected options when the `selectedIndex` changes.
       *
       * @param prev - the previous selected index value
       * @param next - the current selected index value
       *
       * @internal
       */
      selectedIndexChanged(prev, next) {
        var _a2;
        if (!this.hasSelectableOptions) {
          this.selectedIndex = -1;
          return;
        }
        if (((_a2 = this.options[this.selectedIndex]) === null || _a2 === void 0 ? void 0 : _a2.disabled) && typeof prev === "number") {
          const selectableIndex = this.getSelectableIndex(prev, next);
          const newNext = selectableIndex > -1 ? selectableIndex : prev;
          this.selectedIndex = newNext;
          if (next === newNext) {
            this.selectedIndexChanged(next, newNext);
          }
          return;
        }
        this.setSelectedOptions();
      }
      /**
       * Updates the selectedness of each option when the list of selected options changes.
       *
       * @param prev - the previous list of selected options
       * @param next - the current list of selected options
       *
       * @internal
       */
      selectedOptionsChanged(prev, next) {
        var _a2;
        const filteredNext = next.filter(Listbox.slottedOptionFilter);
        (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.forEach((o) => {
          const notifier = Observable.getNotifier(o);
          notifier.unsubscribe(this, "selected");
          o.selected = filteredNext.includes(o);
          notifier.subscribe(this, "selected");
        });
      }
      /**
       * Moves focus to the first selectable option.
       *
       * @public
       */
      selectFirstOption() {
        var _a2, _b2;
        if (!this.disabled) {
          this.selectedIndex = (_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.findIndex((o) => !o.disabled)) !== null && _b2 !== void 0 ? _b2 : -1;
        }
      }
      /**
       * Moves focus to the last selectable option.
       *
       * @internal
       */
      selectLastOption() {
        if (!this.disabled) {
          this.selectedIndex = findLastIndex(this.options, (o) => !o.disabled);
        }
      }
      /**
       * Moves focus to the next selectable option.
       *
       * @internal
       */
      selectNextOption() {
        if (!this.disabled && this.selectedIndex < this.options.length - 1) {
          this.selectedIndex += 1;
        }
      }
      /**
       * Moves focus to the previous selectable option.
       *
       * @internal
       */
      selectPreviousOption() {
        if (!this.disabled && this.selectedIndex > 0) {
          this.selectedIndex = this.selectedIndex - 1;
        }
      }
      /**
       * Updates the selected index to match the first selected option.
       *
       * @internal
       */
      setDefaultSelectedOption() {
        var _a2, _b2;
        this.selectedIndex = (_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.findIndex((el) => el.defaultSelected)) !== null && _b2 !== void 0 ? _b2 : -1;
      }
      /**
       * Sets an option as selected and gives it focus.
       *
       * @public
       */
      setSelectedOptions() {
        var _a2, _b2, _c;
        if ((_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.length) {
          this.selectedOptions = [this.options[this.selectedIndex]];
          this.ariaActiveDescendant = (_c = (_b2 = this.firstSelectedOption) === null || _b2 === void 0 ? void 0 : _b2.id) !== null && _c !== void 0 ? _c : "";
          this.focusAndScrollOptionIntoView();
        }
      }
      /**
       * Updates the list of options and resets the selected option when the slotted option content changes.
       *
       * @param prev - the previous list of slotted options
       * @param next - the current list of slotted options
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        this.options = next.reduce((options, item) => {
          if (isListboxOption(item)) {
            options.push(item);
          }
          return options;
        }, []);
        const setSize = `${this.options.length}`;
        this.options.forEach((option, index) => {
          if (!option.id) {
            option.id = uniqueId("option-");
          }
          option.ariaPosInSet = `${index + 1}`;
          option.ariaSetSize = setSize;
        });
        if (this.$fastController.isConnected) {
          this.setSelectedOptions();
          this.setDefaultSelectedOption();
        }
      }
      /**
       * Updates the filtered list of options when the typeahead buffer changes.
       *
       * @param prev - the previous typeahead buffer value
       * @param next - the current typeahead buffer value
       *
       * @internal
       */
      typeaheadBufferChanged(prev, next) {
        if (this.$fastController.isConnected) {
          const typeaheadMatches = this.getTypeaheadMatches();
          if (typeaheadMatches.length) {
            const selectedIndex = this.options.indexOf(typeaheadMatches[0]);
            if (selectedIndex > -1) {
              this.selectedIndex = selectedIndex;
            }
          }
          this.typeaheadExpired = false;
        }
      }
    };
    Listbox.slottedOptionFilter = (n) => isListboxOption(n) && !n.hidden;
    Listbox.TYPE_AHEAD_TIMEOUT_MS = 1e3;
    __decorate5([
      attr({ mode: "boolean" })
    ], Listbox.prototype, "disabled", void 0);
    __decorate5([
      observable
    ], Listbox.prototype, "selectedIndex", void 0);
    __decorate5([
      observable
    ], Listbox.prototype, "selectedOptions", void 0);
    __decorate5([
      observable
    ], Listbox.prototype, "slottedOptions", void 0);
    __decorate5([
      observable
    ], Listbox.prototype, "typeaheadBuffer", void 0);
    DelegatesARIAListbox = class {
    };
    __decorate5([
      observable
    ], DelegatesARIAListbox.prototype, "ariaActiveDescendant", void 0);
    __decorate5([
      observable
    ], DelegatesARIAListbox.prototype, "ariaDisabled", void 0);
    __decorate5([
      observable
    ], DelegatesARIAListbox.prototype, "ariaExpanded", void 0);
    __decorate5([
      observable
    ], DelegatesARIAListbox.prototype, "ariaMultiSelectable", void 0);
    applyMixins(DelegatesARIAListbox, ARIAGlobalStatesAndProperties);
    applyMixins(Listbox, DelegatesARIAListbox);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/select/select.options.js
var SelectPosition;
var init_select_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/select/select.options.js"() {
    SelectPosition = {
      above: "above",
      below: "below"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.form-associated.js
var _Combobox, FormAssociatedCombobox;
var init_combobox_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.form-associated.js"() {
    init_form_associated();
    init_listbox();
    _Combobox = class extends Listbox {
    };
    FormAssociatedCombobox = class extends FormAssociated(_Combobox) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.options.js
var ComboboxAutocomplete;
var init_combobox_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.options.js"() {
    ComboboxAutocomplete = {
      inline: "inline",
      list: "list",
      both: "both",
      none: "none"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.js
var Combobox, DelegatesARIACombobox;
var init_combobox = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_listbox();
    init_start_end();
    init_select_options();
    init_apply_mixins();
    init_combobox_form_associated();
    init_combobox_options();
    Combobox = class extends FormAssociatedCombobox {
      constructor() {
        super(...arguments);
        this._value = "";
        this.filteredOptions = [];
        this.filter = "";
        this.forcedPosition = false;
        this.listboxId = uniqueId("listbox-");
        this.maxHeight = 0;
        this.open = false;
      }
      /**
       * Reset the element to its first selectable option when its parent form is reset.
       *
       * @internal
       */
      formResetCallback() {
        super.formResetCallback();
        this.setDefaultSelectedOption();
        this.updateValue();
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      get isAutocompleteInline() {
        return this.autocomplete === ComboboxAutocomplete.inline || this.isAutocompleteBoth;
      }
      get isAutocompleteList() {
        return this.autocomplete === ComboboxAutocomplete.list || this.isAutocompleteBoth;
      }
      get isAutocompleteBoth() {
        return this.autocomplete === ComboboxAutocomplete.both;
      }
      /**
       * Sets focus and synchronize ARIA attributes when the open property changes.
       *
       * @param prev - the previous open value
       * @param next - the current open value
       *
       * @internal
       */
      openChanged() {
        if (this.open) {
          this.ariaControls = this.listboxId;
          this.ariaExpanded = "true";
          this.setPositioning();
          this.focusAndScrollOptionIntoView();
          DOM.queueUpdate(() => this.focus());
          return;
        }
        this.ariaControls = "";
        this.ariaExpanded = "false";
      }
      /**
       * The list of options.
       *
       * @public
       * @remarks
       * Overrides `Listbox.options`.
       */
      get options() {
        Observable.track(this, "options");
        return this.filteredOptions.length ? this.filteredOptions : this._options;
      }
      set options(value) {
        this._options = value;
        Observable.notify(this, "options");
      }
      /**
       * Updates the placeholder on the proxy element.
       * @internal
       */
      placeholderChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.placeholder = this.placeholder;
        }
      }
      positionChanged(prev, next) {
        this.positionAttribute = next;
        this.setPositioning();
      }
      /**
       * The value property.
       *
       * @public
       */
      get value() {
        Observable.track(this, "value");
        return this._value;
      }
      set value(next) {
        var _a2, _b2, _c;
        const prev = `${this._value}`;
        if (this.$fastController.isConnected && this.options) {
          const selectedIndex = this.options.findIndex((el) => el.text.toLowerCase() === next.toLowerCase());
          const prevSelectedValue = (_a2 = this.options[this.selectedIndex]) === null || _a2 === void 0 ? void 0 : _a2.text;
          const nextSelectedValue = (_b2 = this.options[selectedIndex]) === null || _b2 === void 0 ? void 0 : _b2.text;
          this.selectedIndex = prevSelectedValue !== nextSelectedValue ? selectedIndex : this.selectedIndex;
          next = ((_c = this.firstSelectedOption) === null || _c === void 0 ? void 0 : _c.text) || next;
        }
        if (prev !== next) {
          this._value = next;
          super.valueChanged(prev, next);
          Observable.notify(this, "value");
        }
      }
      /**
       * Handle opening and closing the listbox when the combobox is clicked.
       *
       * @param e - the mouse event
       * @internal
       */
      clickHandler(e) {
        if (this.disabled) {
          return;
        }
        if (this.open) {
          const captured = e.target.closest(`option,[role=option]`);
          if (!captured || captured.disabled) {
            return;
          }
          this.selectedOptions = [captured];
          this.control.value = captured.text;
          this.clearSelectionRange();
          this.updateValue(true);
        }
        this.open = !this.open;
        if (this.open) {
          this.control.focus();
        }
        return true;
      }
      connectedCallback() {
        super.connectedCallback();
        this.forcedPosition = !!this.positionAttribute;
        if (this.value) {
          this.initialValue = this.value;
        }
      }
      /**
       * Synchronize the `aria-disabled` property when the `disabled` property changes.
       *
       * @param prev - The previous disabled value
       * @param next - The next disabled value
       *
       * @internal
       */
      disabledChanged(prev, next) {
        if (super.disabledChanged) {
          super.disabledChanged(prev, next);
        }
        this.ariaDisabled = this.disabled ? "true" : "false";
      }
      /**
       * Filter available options by text value.
       *
       * @public
       */
      filterOptions() {
        if (!this.autocomplete || this.autocomplete === ComboboxAutocomplete.none) {
          this.filter = "";
        }
        const filter = this.filter.toLowerCase();
        this.filteredOptions = this._options.filter((o) => o.text.toLowerCase().startsWith(this.filter.toLowerCase()));
        if (this.isAutocompleteList) {
          if (!this.filteredOptions.length && !filter) {
            this.filteredOptions = this._options;
          }
          this._options.forEach((o) => {
            o.hidden = !this.filteredOptions.includes(o);
          });
        }
      }
      /**
       * Focus the control and scroll the first selected option into view.
       *
       * @internal
       * @remarks
       * Overrides: `Listbox.focusAndScrollOptionIntoView`
       */
      focusAndScrollOptionIntoView() {
        if (this.contains(document.activeElement)) {
          this.control.focus();
          if (this.firstSelectedOption) {
            requestAnimationFrame(() => {
              var _a2;
              (_a2 = this.firstSelectedOption) === null || _a2 === void 0 ? void 0 : _a2.scrollIntoView({ block: "nearest" });
            });
          }
        }
      }
      /**
       * Handle focus state when the element or its children lose focus.
       *
       * @param e - The focus event
       * @internal
       */
      focusoutHandler(e) {
        this.syncValue();
        if (!this.open) {
          return true;
        }
        const focusTarget = e.relatedTarget;
        if (this.isSameNode(focusTarget)) {
          this.focus();
          return;
        }
        if (!this.options || !this.options.includes(focusTarget)) {
          this.open = false;
        }
      }
      /**
       * Handle content changes on the control input.
       *
       * @param e - the input event
       * @internal
       */
      inputHandler(e) {
        this.filter = this.control.value;
        this.filterOptions();
        if (!this.isAutocompleteInline) {
          this.selectedIndex = this.options.map((option) => option.text).indexOf(this.control.value);
        }
        if (e.inputType.includes("deleteContent") || !this.filter.length) {
          return true;
        }
        if (this.isAutocompleteList && !this.open) {
          this.open = true;
        }
        if (this.isAutocompleteInline) {
          if (this.filteredOptions.length) {
            this.selectedOptions = [this.filteredOptions[0]];
            this.selectedIndex = this.options.indexOf(this.firstSelectedOption);
            this.setInlineSelection();
          } else {
            this.selectedIndex = -1;
          }
        }
        return;
      }
      /**
       * Handle keydown actions for listbox navigation.
       *
       * @param e - the keyboard event
       * @internal
       */
      keydownHandler(e) {
        const key = e.key;
        if (e.ctrlKey || e.shiftKey) {
          return true;
        }
        switch (key) {
          case "Enter": {
            this.syncValue();
            if (this.isAutocompleteInline) {
              this.filter = this.value;
            }
            this.open = false;
            this.clearSelectionRange();
            break;
          }
          case "Escape": {
            if (!this.isAutocompleteInline) {
              this.selectedIndex = -1;
            }
            if (this.open) {
              this.open = false;
              break;
            }
            this.value = "";
            this.control.value = "";
            this.filter = "";
            this.filterOptions();
            break;
          }
          case "Tab": {
            this.setInputToSelection();
            if (!this.open) {
              return true;
            }
            e.preventDefault();
            this.open = false;
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            this.filterOptions();
            if (!this.open) {
              this.open = true;
              break;
            }
            if (this.filteredOptions.length > 0) {
              super.keydownHandler(e);
            }
            if (this.isAutocompleteInline) {
              this.setInlineSelection();
            }
            break;
          }
          default: {
            return true;
          }
        }
      }
      /**
       * Handle keyup actions for value input and text field manipulations.
       *
       * @param e - the keyboard event
       * @internal
       */
      keyupHandler(e) {
        const key = e.key;
        switch (key) {
          case "ArrowLeft":
          case "ArrowRight":
          case "Backspace":
          case "Delete":
          case "Home":
          case "End": {
            this.filter = this.control.value;
            this.selectedIndex = -1;
            this.filterOptions();
            break;
          }
        }
      }
      /**
       * Ensure that the selectedIndex is within the current allowable filtered range.
       *
       * @param prev - the previous selected index value
       * @param next - the current selected index value
       *
       * @internal
       */
      selectedIndexChanged(prev, next) {
        if (this.$fastController.isConnected) {
          next = limit(-1, this.options.length - 1, next);
          if (next !== this.selectedIndex) {
            this.selectedIndex = next;
            return;
          }
          super.selectedIndexChanged(prev, next);
        }
      }
      /**
       * Move focus to the previous selectable option.
       *
       * @internal
       * @remarks
       * Overrides `Listbox.selectPreviousOption`
       */
      selectPreviousOption() {
        if (!this.disabled && this.selectedIndex >= 0) {
          this.selectedIndex = this.selectedIndex - 1;
        }
      }
      /**
       * Set the default selected options at initialization or reset.
       *
       * @internal
       * @remarks
       * Overrides `Listbox.setDefaultSelectedOption`
       */
      setDefaultSelectedOption() {
        if (this.$fastController.isConnected && this.options) {
          const selectedIndex = this.options.findIndex((el) => el.getAttribute("selected") !== null || el.selected);
          this.selectedIndex = selectedIndex;
          if (!this.dirtyValue && this.firstSelectedOption) {
            this.value = this.firstSelectedOption.text;
          }
          this.setSelectedOptions();
        }
      }
      /**
       * Focus and set the content of the control based on the first selected option.
       *
       * @internal
       */
      setInputToSelection() {
        if (this.firstSelectedOption) {
          this.control.value = this.firstSelectedOption.text;
          this.control.focus();
        }
      }
      /**
       * Focus, set and select the content of the control based on the first selected option.
       *
       * @internal
       */
      setInlineSelection() {
        if (this.firstSelectedOption) {
          this.setInputToSelection();
          this.control.setSelectionRange(this.filter.length, this.control.value.length, "backward");
        }
      }
      /**
       * Determines if a value update should involve emitting a change event, then updates the value.
       *
       * @internal
       */
      syncValue() {
        var _a2;
        const newValue = this.selectedIndex > -1 ? (_a2 = this.firstSelectedOption) === null || _a2 === void 0 ? void 0 : _a2.text : this.control.value;
        this.updateValue(this.value !== newValue);
      }
      /**
       * Calculate and apply listbox positioning based on available viewport space.
       *
       * @param force - direction to force the listbox to display
       * @public
       */
      setPositioning() {
        const currentBox = this.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const availableBottom = viewportHeight - currentBox.bottom;
        this.position = this.forcedPosition ? this.positionAttribute : currentBox.top > availableBottom ? SelectPosition.above : SelectPosition.below;
        this.positionAttribute = this.forcedPosition ? this.positionAttribute : this.position;
        this.maxHeight = this.position === SelectPosition.above ? ~~currentBox.top : ~~availableBottom;
      }
      /**
       * Ensure that the entire list of options is used when setting the selected property.
       *
       * @param prev - the previous list of selected options
       * @param next - the current list of selected options
       *
       * @internal
       * @remarks
       * Overrides: `Listbox.selectedOptionsChanged`
       */
      selectedOptionsChanged(prev, next) {
        if (this.$fastController.isConnected) {
          this._options.forEach((o) => {
            o.selected = next.includes(o);
          });
        }
      }
      /**
       * Synchronize the form-associated proxy and update the value property of the element.
       *
       * @param prev - the previous collection of slotted option elements
       * @param next - the next collection of slotted option elements
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        super.slottedOptionsChanged(prev, next);
        this.updateValue();
      }
      /**
       * Sets the value and to match the first selected option.
       *
       * @param shouldEmit - if true, the change event will be emitted
       *
       * @internal
       */
      updateValue(shouldEmit) {
        var _a2;
        if (this.$fastController.isConnected) {
          this.value = ((_a2 = this.firstSelectedOption) === null || _a2 === void 0 ? void 0 : _a2.text) || this.control.value;
          this.control.value = this.value;
        }
        if (shouldEmit) {
          this.$emit("change");
        }
      }
      /**
       * @internal
       */
      clearSelectionRange() {
        const controlValueLength = this.control.value.length;
        this.control.setSelectionRange(controlValueLength, controlValueLength);
      }
    };
    __decorate5([
      attr({ attribute: "autocomplete", mode: "fromView" })
    ], Combobox.prototype, "autocomplete", void 0);
    __decorate5([
      observable
    ], Combobox.prototype, "maxHeight", void 0);
    __decorate5([
      attr({ attribute: "open", mode: "boolean" })
    ], Combobox.prototype, "open", void 0);
    __decorate5([
      attr
    ], Combobox.prototype, "placeholder", void 0);
    __decorate5([
      attr({ attribute: "position" })
    ], Combobox.prototype, "positionAttribute", void 0);
    __decorate5([
      observable
    ], Combobox.prototype, "position", void 0);
    DelegatesARIACombobox = class {
    };
    __decorate5([
      observable
    ], DelegatesARIACombobox.prototype, "ariaAutoComplete", void 0);
    __decorate5([
      observable
    ], DelegatesARIACombobox.prototype, "ariaControls", void 0);
    applyMixins(DelegatesARIACombobox, DelegatesARIAListbox);
    applyMixins(Combobox, StartEnd, DelegatesARIACombobox);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.template.js
var comboboxTemplate;
var init_combobox_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/combobox/combobox.template.js"() {
    init_esm();
    init_listbox();
    init_start_end();
    comboboxTemplate = (context, definition) => html2`
    <template
        aria-disabled="${(x) => x.ariaDisabled}"
        autocomplete="${(x) => x.autocomplete}"
        class="${(x) => x.open ? "open" : ""} ${(x) => x.disabled ? "disabled" : ""} ${(x) => x.position}"
        ?open="${(x) => x.open}"
        tabindex="${(x) => !x.disabled ? "0" : null}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @focusout="${(x, c) => x.focusoutHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
    >
        <div class="control" part="control">
            ${startSlotTemplate(context, definition)}
            <slot name="control">
                <input
                    aria-activedescendant="${(x) => x.open ? x.ariaActiveDescendant : null}"
                    aria-autocomplete="${(x) => x.ariaAutoComplete}"
                    aria-controls="${(x) => x.ariaControls}"
                    aria-disabled="${(x) => x.ariaDisabled}"
                    aria-expanded="${(x) => x.ariaExpanded}"
                    aria-haspopup="listbox"
                    class="selected-value"
                    part="selected-value"
                    placeholder="${(x) => x.placeholder}"
                    role="combobox"
                    type="text"
                    ?disabled="${(x) => x.disabled}"
                    :value="${(x) => x.value}"
                    @input="${(x, c) => x.inputHandler(c.event)}"
                    @keyup="${(x, c) => x.keyupHandler(c.event)}"
                    ${ref("control")}
                />
                <div class="indicator" part="indicator" aria-hidden="true">
                    <slot name="indicator">
                        ${definition.indicator || ""}
                    </slot>
                </div>
            </slot>
            ${endSlotTemplate(context, definition)}
        </div>
        <div
            class="listbox"
            id="${(x) => x.listboxId}"
            part="listbox"
            role="listbox"
            ?disabled="${(x) => x.disabled}"
            ?hidden="${(x) => !x.open}"
            ${ref("listbox")}
        >
            <slot
                ${slotted({
      filter: Listbox.slottedOptionFilter,
      flatten: true,
      property: "slottedOptions"
    })}
            ></slot>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/combobox/index.js
var init_combobox2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/combobox/index.js"() {
    init_combobox();
    init_combobox_options();
    init_combobox_template();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-parent.js
function composedParent(element) {
  const parentNode = element.parentElement;
  if (parentNode) {
    return parentNode;
  } else {
    const rootNode = element.getRootNode();
    if (rootNode.host instanceof HTMLElement) {
      return rootNode.host;
    }
  }
  return null;
}
var init_composed_parent = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-parent.js"() {
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-contains.js
function composedContains(reference, test) {
  let current = test;
  while (current !== null) {
    if (current === reference) {
      return true;
    }
    current = composedParent(current);
  }
  return false;
}
var init_composed_contains = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/composed-contains.js"() {
    init_composed_parent();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/design-token/custom-property-manager.js
function isFastElement(element) {
  return element instanceof FASTElement;
}
var defaultElement, QueuedStyleSheetTarget, ConstructableStyleSheetTarget, DocumentStyleSheetTarget, HeadStyleElementStyleSheetTarget, StyleElementStyleSheetTarget, ElementStyleSheetTarget, RootStyleSheetTarget, propertyTargetCache, propertyTargetCtor, PropertyTargetManager;
var init_custom_property_manager = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/design-token/custom-property-manager.js"() {
    init_tslib_es62();
    init_esm();
    defaultElement = document.createElement("div");
    QueuedStyleSheetTarget = class {
      setProperty(name, value) {
        DOM.queueUpdate(() => this.target.setProperty(name, value));
      }
      removeProperty(name) {
        DOM.queueUpdate(() => this.target.removeProperty(name));
      }
    };
    ConstructableStyleSheetTarget = class extends QueuedStyleSheetTarget {
      constructor(source) {
        super();
        const sheet = new CSSStyleSheet();
        this.target = sheet.cssRules[sheet.insertRule(":host{}")].style;
        source.$fastController.addStyles(ElementStyles.create([sheet]));
      }
    };
    DocumentStyleSheetTarget = class extends QueuedStyleSheetTarget {
      constructor() {
        super();
        const sheet = new CSSStyleSheet();
        this.target = sheet.cssRules[sheet.insertRule(":root{}")].style;
        document.adoptedStyleSheets = [
          ...document.adoptedStyleSheets,
          sheet
        ];
      }
    };
    HeadStyleElementStyleSheetTarget = class extends QueuedStyleSheetTarget {
      constructor() {
        super();
        this.style = document.createElement("style");
        document.head.appendChild(this.style);
        const { sheet } = this.style;
        if (sheet) {
          const index = sheet.insertRule(":root{}", sheet.cssRules.length);
          this.target = sheet.cssRules[index].style;
        }
      }
    };
    StyleElementStyleSheetTarget = class {
      constructor(target2) {
        this.store = /* @__PURE__ */ new Map();
        this.target = null;
        const controller = target2.$fastController;
        this.style = document.createElement("style");
        controller.addStyles(this.style);
        Observable.getNotifier(controller).subscribe(this, "isConnected");
        this.handleChange(controller, "isConnected");
      }
      targetChanged() {
        if (this.target !== null) {
          for (const [key, value] of this.store.entries()) {
            this.target.setProperty(key, value);
          }
        }
      }
      setProperty(name, value) {
        this.store.set(name, value);
        DOM.queueUpdate(() => {
          if (this.target !== null) {
            this.target.setProperty(name, value);
          }
        });
      }
      removeProperty(name) {
        this.store.delete(name);
        DOM.queueUpdate(() => {
          if (this.target !== null) {
            this.target.removeProperty(name);
          }
        });
      }
      handleChange(source, key) {
        const { sheet } = this.style;
        if (sheet) {
          const index = sheet.insertRule(":host{}", sheet.cssRules.length);
          this.target = sheet.cssRules[index].style;
        } else {
          this.target = null;
        }
      }
    };
    __decorate5([
      observable
    ], StyleElementStyleSheetTarget.prototype, "target", void 0);
    ElementStyleSheetTarget = class {
      constructor(source) {
        this.target = source.style;
      }
      setProperty(name, value) {
        DOM.queueUpdate(() => this.target.setProperty(name, value));
      }
      removeProperty(name) {
        DOM.queueUpdate(() => this.target.removeProperty(name));
      }
    };
    RootStyleSheetTarget = class {
      setProperty(name, value) {
        RootStyleSheetTarget.properties[name] = value;
        for (const target2 of RootStyleSheetTarget.roots.values()) {
          PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(target2)).setProperty(name, value);
        }
      }
      removeProperty(name) {
        delete RootStyleSheetTarget.properties[name];
        for (const target2 of RootStyleSheetTarget.roots.values()) {
          PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(target2)).removeProperty(name);
        }
      }
      static registerRoot(root) {
        const { roots } = RootStyleSheetTarget;
        if (!roots.has(root)) {
          roots.add(root);
          const target2 = PropertyTargetManager.getOrCreate(this.normalizeRoot(root));
          for (const key in RootStyleSheetTarget.properties) {
            target2.setProperty(key, RootStyleSheetTarget.properties[key]);
          }
        }
      }
      static unregisterRoot(root) {
        const { roots } = RootStyleSheetTarget;
        if (roots.has(root)) {
          roots.delete(root);
          const target2 = PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(root));
          for (const key in RootStyleSheetTarget.properties) {
            target2.removeProperty(key);
          }
        }
      }
      /**
       * Returns the document when provided the default element,
       * otherwise is a no-op
       * @param root - the root to normalize
       */
      static normalizeRoot(root) {
        return root === defaultElement ? document : root;
      }
    };
    RootStyleSheetTarget.roots = /* @__PURE__ */ new Set();
    RootStyleSheetTarget.properties = {};
    propertyTargetCache = /* @__PURE__ */ new WeakMap();
    propertyTargetCtor = DOM.supportsAdoptedStyleSheets ? ConstructableStyleSheetTarget : StyleElementStyleSheetTarget;
    PropertyTargetManager = Object.freeze({
      getOrCreate(source) {
        if (propertyTargetCache.has(source)) {
          return propertyTargetCache.get(source);
        }
        let target2;
        if (source === defaultElement) {
          target2 = new RootStyleSheetTarget();
        } else if (source instanceof Document) {
          target2 = DOM.supportsAdoptedStyleSheets ? new DocumentStyleSheetTarget() : new HeadStyleElementStyleSheetTarget();
        } else if (isFastElement(source)) {
          target2 = new propertyTargetCtor(source);
        } else {
          target2 = new ElementStyleSheetTarget(source);
        }
        propertyTargetCache.set(source, target2);
        return target2;
      }
    });
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/design-token/design-token.js
function create(nameOrConfig) {
  return DesignTokenImpl.from(nameOrConfig);
}
var DesignTokenImpl, CustomPropertyReflector, DesignTokenBindingObserver, Store, nodeCache, childToParent, DesignTokenNode, DesignToken;
var init_design_token = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/design-token/design-token.js"() {
    init_tslib_es62();
    init_esm();
    init_composed_parent();
    init_composed_contains();
    init_custom_property_manager();
    init_custom_property_manager();
    DesignTokenImpl = class extends CSSDirective {
      constructor(configuration) {
        super();
        this.subscribers = /* @__PURE__ */ new WeakMap();
        this._appliedTo = /* @__PURE__ */ new Set();
        this.name = configuration.name;
        if (configuration.cssCustomPropertyName !== null) {
          this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;
          this.cssVar = `var(${this.cssCustomProperty})`;
        }
        this.id = DesignTokenImpl.uniqueId();
        DesignTokenImpl.tokensById.set(this.id, this);
      }
      get appliedTo() {
        return [...this._appliedTo];
      }
      static from(nameOrConfig) {
        return new DesignTokenImpl({
          name: typeof nameOrConfig === "string" ? nameOrConfig : nameOrConfig.name,
          cssCustomPropertyName: typeof nameOrConfig === "string" ? nameOrConfig : nameOrConfig.cssCustomPropertyName === void 0 ? nameOrConfig.name : nameOrConfig.cssCustomPropertyName
        });
      }
      static isCSSDesignToken(token) {
        return typeof token.cssCustomProperty === "string";
      }
      static isDerivedDesignTokenValue(value) {
        return typeof value === "function";
      }
      /**
       * Gets a token by ID. Returns undefined if the token was not found.
       * @param id - The ID of the token
       * @returns
       */
      static getTokenById(id) {
        return DesignTokenImpl.tokensById.get(id);
      }
      getOrCreateSubscriberSet(target2 = this) {
        return this.subscribers.get(target2) || this.subscribers.set(target2, /* @__PURE__ */ new Set()) && this.subscribers.get(target2);
      }
      createCSS() {
        return this.cssVar || "";
      }
      getValueFor(element) {
        const value = DesignTokenNode.getOrCreate(element).get(this);
        if (value !== void 0) {
          return value;
        }
        throw new Error(`Value could not be retrieved for token named "${this.name}". Ensure the value is set for ${element} or an ancestor of ${element}.`);
      }
      setValueFor(element, value) {
        this._appliedTo.add(element);
        if (value instanceof DesignTokenImpl) {
          value = this.alias(value);
        }
        DesignTokenNode.getOrCreate(element).set(this, value);
        return this;
      }
      deleteValueFor(element) {
        this._appliedTo.delete(element);
        if (DesignTokenNode.existsFor(element)) {
          DesignTokenNode.getOrCreate(element).delete(this);
        }
        return this;
      }
      withDefault(value) {
        this.setValueFor(defaultElement, value);
        return this;
      }
      subscribe(subscriber, target2) {
        const subscriberSet = this.getOrCreateSubscriberSet(target2);
        if (target2 && !DesignTokenNode.existsFor(target2)) {
          DesignTokenNode.getOrCreate(target2);
        }
        if (!subscriberSet.has(subscriber)) {
          subscriberSet.add(subscriber);
        }
      }
      unsubscribe(subscriber, target2) {
        const list = this.subscribers.get(target2 || this);
        if (list && list.has(subscriber)) {
          list.delete(subscriber);
        }
      }
      /**
       * Notifies subscribers that the value for an element has changed.
       * @param element - The element to emit a notification for
       */
      notify(element) {
        const record = Object.freeze({ token: this, target: element });
        if (this.subscribers.has(this)) {
          this.subscribers.get(this).forEach((sub) => sub.handleChange(record));
        }
        if (this.subscribers.has(element)) {
          this.subscribers.get(element).forEach((sub) => sub.handleChange(record));
        }
      }
      /**
       * Alias the token to the provided token.
       * @param token - the token to alias to
       */
      alias(token) {
        return (target2) => token.getValueFor(target2);
      }
    };
    DesignTokenImpl.uniqueId = (() => {
      let id = 0;
      return () => {
        id++;
        return id.toString(16);
      };
    })();
    DesignTokenImpl.tokensById = /* @__PURE__ */ new Map();
    CustomPropertyReflector = class {
      startReflection(token, target2) {
        token.subscribe(this, target2);
        this.handleChange({ token, target: target2 });
      }
      stopReflection(token, target2) {
        token.unsubscribe(this, target2);
        this.remove(token, target2);
      }
      handleChange(record) {
        const { token, target: target2 } = record;
        this.add(token, target2);
      }
      add(token, target2) {
        PropertyTargetManager.getOrCreate(target2).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target2).get(token)));
      }
      remove(token, target2) {
        PropertyTargetManager.getOrCreate(target2).removeProperty(token.cssCustomProperty);
      }
      resolveCSSValue(value) {
        return value && typeof value.createCSS === "function" ? value.createCSS() : value;
      }
    };
    DesignTokenBindingObserver = class {
      constructor(source, token, node) {
        this.source = source;
        this.token = token;
        this.node = node;
        this.dependencies = /* @__PURE__ */ new Set();
        this.observer = Observable.binding(source, this, false);
        this.observer.handleChange = this.observer.call;
        this.handleChange();
      }
      disconnect() {
        this.observer.disconnect();
      }
      /**
       * @internal
       */
      handleChange() {
        this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));
      }
    };
    Store = class {
      constructor() {
        this.values = /* @__PURE__ */ new Map();
      }
      set(token, value) {
        if (this.values.get(token) !== value) {
          this.values.set(token, value);
          Observable.getNotifier(this).notify(token.id);
        }
      }
      get(token) {
        Observable.track(this, token.id);
        return this.values.get(token);
      }
      delete(token) {
        this.values.delete(token);
      }
      all() {
        return this.values.entries();
      }
    };
    nodeCache = /* @__PURE__ */ new WeakMap();
    childToParent = /* @__PURE__ */ new WeakMap();
    DesignTokenNode = class {
      constructor(target2) {
        this.target = target2;
        this.store = new Store();
        this.children = [];
        this.assignedValues = /* @__PURE__ */ new Map();
        this.reflecting = /* @__PURE__ */ new Set();
        this.bindingObservers = /* @__PURE__ */ new Map();
        this.tokenValueChangeHandler = {
          handleChange: (source, arg) => {
            const token = DesignTokenImpl.getTokenById(arg);
            if (token) {
              token.notify(this.target);
              if (DesignTokenImpl.isCSSDesignToken(token)) {
                const parent = this.parent;
                const reflecting = this.isReflecting(token);
                if (parent) {
                  const parentValue = parent.get(token);
                  const sourceValue = source.get(token);
                  if (parentValue !== sourceValue && !reflecting) {
                    this.reflectToCSS(token);
                  } else if (parentValue === sourceValue && reflecting) {
                    this.stopReflectToCSS(token);
                  }
                } else if (!reflecting) {
                  this.reflectToCSS(token);
                }
              }
            }
          }
        };
        nodeCache.set(target2, this);
        Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);
        if (target2 instanceof FASTElement) {
          target2.$fastController.addBehaviors([this]);
        } else if (target2.isConnected) {
          this.bind();
        }
      }
      /**
       * Returns a DesignTokenNode for an element.
       * Creates a new instance if one does not already exist for a node,
       * otherwise returns the cached instance
       *
       * @param target - The HTML element to retrieve a DesignTokenNode for
       */
      static getOrCreate(target2) {
        return nodeCache.get(target2) || new DesignTokenNode(target2);
      }
      /**
       * Determines if a DesignTokenNode has been created for a target
       * @param target - The element to test
       */
      static existsFor(target2) {
        return nodeCache.has(target2);
      }
      /**
       * Searches for and return the nearest parent DesignTokenNode.
       * Null is returned if no node is found or the node provided is for a default element.
       */
      static findParent(node) {
        if (!(defaultElement === node.target)) {
          let parent = composedParent(node.target);
          while (parent !== null) {
            if (nodeCache.has(parent)) {
              return nodeCache.get(parent);
            }
            parent = composedParent(parent);
          }
          return DesignTokenNode.getOrCreate(defaultElement);
        }
        return null;
      }
      /**
       * Finds the closest node with a value explicitly assigned for a token, otherwise null.
       * @param token - The token to look for
       * @param start - The node to start looking for value assignment
       * @returns
       */
      static findClosestAssignedNode(token, start) {
        let current = start;
        do {
          if (current.has(token)) {
            return current;
          }
          current = current.parent ? current.parent : current.target !== defaultElement ? DesignTokenNode.getOrCreate(defaultElement) : null;
        } while (current !== null);
        return null;
      }
      /**
       * The parent DesignTokenNode, or null.
       */
      get parent() {
        return childToParent.get(this) || null;
      }
      /**
       * Checks if a token has been assigned an explicit value the node.
       * @param token - the token to check.
       */
      has(token) {
        return this.assignedValues.has(token);
      }
      /**
       * Gets the value of a token for a node
       * @param token - The token to retrieve the value for
       * @returns
       */
      get(token) {
        const value = this.store.get(token);
        if (value !== void 0) {
          return value;
        }
        const raw = this.getRaw(token);
        if (raw !== void 0) {
          this.hydrate(token, raw);
          return this.get(token);
        }
      }
      /**
       * Retrieves the raw assigned value of a token from the nearest assigned node.
       * @param token - The token to retrieve a raw value for
       * @returns
       */
      getRaw(token) {
        var _a2;
        if (this.assignedValues.has(token)) {
          return this.assignedValues.get(token);
        }
        return (_a2 = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a2 === void 0 ? void 0 : _a2.getRaw(token);
      }
      /**
       * Sets a token to a value for a node
       * @param token - The token to set
       * @param value - The value to set the token to
       */
      set(token, value) {
        if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {
          this.tearDownBindingObserver(token);
        }
        this.assignedValues.set(token, value);
        if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {
          this.setupBindingObserver(token, value);
        } else {
          this.store.set(token, value);
        }
      }
      /**
       * Deletes a token value for the node.
       * @param token - The token to delete the value for
       */
      delete(token) {
        this.assignedValues.delete(token);
        this.tearDownBindingObserver(token);
        const upstream = this.getRaw(token);
        if (upstream) {
          this.hydrate(token, upstream);
        } else {
          this.store.delete(token);
        }
      }
      /**
       * Invoked when the DesignTokenNode.target is attached to the document
       */
      bind() {
        const parent = DesignTokenNode.findParent(this);
        if (parent) {
          parent.appendChild(this);
        }
        for (const key of this.assignedValues.keys()) {
          key.notify(this.target);
        }
      }
      /**
       * Invoked when the DesignTokenNode.target is detached from the document
       */
      unbind() {
        if (this.parent) {
          const parent = childToParent.get(this);
          parent.removeChild(this);
        }
      }
      /**
       * Appends a child to a parent DesignTokenNode.
       * @param child - The child to append to the node
       */
      appendChild(child) {
        if (child.parent) {
          childToParent.get(child).removeChild(child);
        }
        const reParent = this.children.filter((x) => child.contains(x));
        childToParent.set(child, this);
        this.children.push(child);
        reParent.forEach((x) => child.appendChild(x));
        Observable.getNotifier(this.store).subscribe(child);
        for (const [token, value] of this.store.all()) {
          child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);
        }
      }
      /**
       * Removes a child from a node.
       * @param child - The child to remove.
       */
      removeChild(child) {
        const childIndex = this.children.indexOf(child);
        if (childIndex !== -1) {
          this.children.splice(childIndex, 1);
        }
        Observable.getNotifier(this.store).unsubscribe(child);
        return child.parent === this ? childToParent.delete(child) : false;
      }
      /**
       * Tests whether a provided node is contained by
       * the calling node.
       * @param test - The node to test
       */
      contains(test) {
        return composedContains(this.target, test.target);
      }
      /**
       * Instructs the node to reflect a design token for the provided token.
       * @param token - The design token to reflect
       */
      reflectToCSS(token) {
        if (!this.isReflecting(token)) {
          this.reflecting.add(token);
          DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);
        }
      }
      /**
       * Stops reflecting a DesignToken to CSS
       * @param token - The design token to stop reflecting
       */
      stopReflectToCSS(token) {
        if (this.isReflecting(token)) {
          this.reflecting.delete(token);
          DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);
        }
      }
      /**
       * Determines if a token is being reflected to CSS for a node.
       * @param token - The token to check for reflection
       * @returns
       */
      isReflecting(token) {
        return this.reflecting.has(token);
      }
      /**
       * Handle changes to upstream tokens
       * @param source - The parent DesignTokenNode
       * @param property - The token ID that changed
       */
      handleChange(source, property2) {
        const token = DesignTokenImpl.getTokenById(property2);
        if (!token) {
          return;
        }
        this.hydrate(token, this.getRaw(token));
      }
      /**
       * Hydrates a token with a DesignTokenValue, making retrieval available.
       * @param token - The token to hydrate
       * @param value - The value to hydrate
       */
      hydrate(token, value) {
        if (!this.has(token)) {
          const observer2 = this.bindingObservers.get(token);
          if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {
            if (observer2) {
              if (observer2.source !== value) {
                this.tearDownBindingObserver(token);
                this.setupBindingObserver(token, value);
              }
            } else {
              this.setupBindingObserver(token, value);
            }
          } else {
            if (observer2) {
              this.tearDownBindingObserver(token);
            }
            this.store.set(token, value);
          }
        }
      }
      /**
       * Sets up a binding observer for a derived token value that notifies token
       * subscribers on change.
       *
       * @param token - The token to notify when the binding updates
       * @param source - The binding source
       */
      setupBindingObserver(token, source) {
        const binding = new DesignTokenBindingObserver(source, token, this);
        this.bindingObservers.set(token, binding);
        return binding;
      }
      /**
       * Tear down a binding observer for a token.
       */
      tearDownBindingObserver(token) {
        if (this.bindingObservers.has(token)) {
          this.bindingObservers.get(token).disconnect();
          this.bindingObservers.delete(token);
          return true;
        }
        return false;
      }
    };
    DesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();
    __decorate5([
      observable
    ], DesignTokenNode.prototype, "children", void 0);
    DesignToken = Object.freeze({
      create,
      /**
       * Informs DesignToken that an HTMLElement for which tokens have
       * been set has been connected to the document.
       *
       * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness
       * in all scenarios, so invoking this method manually is necessary when:
       *
       * 1. Token values are set for an HTMLElement.
       * 2. The HTMLElement does not inherit from FASTElement.
       * 3. The HTMLElement is not connected to the document when token values are set.
       *
       * @param element - The element to notify
       * @returns - true if notification was successful, otherwise false.
       */
      notifyConnection(element) {
        if (!element.isConnected || !DesignTokenNode.existsFor(element)) {
          return false;
        }
        DesignTokenNode.getOrCreate(element).bind();
        return true;
      },
      /**
       * Informs DesignToken that an HTMLElement for which tokens have
       * been set has been disconnected to the document.
       *
       * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness
       * in all scenarios, so invoking this method manually is necessary when:
       *
       * 1. Token values are set for an HTMLElement.
       * 2. The HTMLElement does not inherit from FASTElement.
       *
       * @param element - The element to notify
       * @returns - true if notification was successful, otherwise false.
       */
      notifyDisconnection(element) {
        if (element.isConnected || !DesignTokenNode.existsFor(element)) {
          return false;
        }
        DesignTokenNode.getOrCreate(element).unbind();
        return true;
      },
      /**
       * Registers and element or document as a DesignToken root.
       * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via
       * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all
       * registered roots.
       * @param target - The root to register
       */
      registerRoot(target2 = defaultElement) {
        RootStyleSheetTarget.registerRoot(target2);
      },
      /**
       * Unregister an element or document as a DesignToken root.
       * @param target - The root to deregister
       */
      unregisterRoot(target2 = defaultElement) {
        RootStyleSheetTarget.unregisterRoot(target2);
      }
    });
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/design-system/design-system.js
function extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback) {
  if (typeof params === "string") {
    return {
      name: params,
      type: elementDefinitionType,
      callback: elementDefinitionCallback
    };
  } else {
    return params;
  }
}
var ElementDisambiguation, elementTypesByTag, elementTagsByType, rootDesignSystem, designSystemKey, DesignSystem, DefaultDesignSystem, ElementDefinitionEntry;
var init_design_system = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/design-system/design-system.js"() {
    init_esm();
    init_foundation_element();
    init_di();
    init_design_token();
    init_component_presentation();
    ElementDisambiguation = Object.freeze({
      /**
       * Skip defining the element but still call the provided callback passed
       * to DesignSystemRegistrationContext.tryDefineElement
       */
      definitionCallbackOnly: null,
      /**
       * Ignore the duplicate element entirely.
       */
      ignoreDuplicate: Symbol()
    });
    elementTypesByTag = /* @__PURE__ */ new Map();
    elementTagsByType = /* @__PURE__ */ new Map();
    rootDesignSystem = null;
    designSystemKey = DI.createInterface((x) => x.cachedCallback((handler) => {
      if (rootDesignSystem === null) {
        rootDesignSystem = new DefaultDesignSystem(null, handler);
      }
      return rootDesignSystem;
    }));
    DesignSystem = Object.freeze({
      /**
       * Returns the HTML element name that the type is defined as.
       * @param type - The type to lookup.
       * @public
       */
      tagFor(type) {
        return elementTagsByType.get(type);
      },
      /**
       * Searches the DOM hierarchy for the design system that is responsible
       * for the provided element.
       * @param element - The element to locate the design system for.
       * @returns The located design system.
       * @public
       */
      responsibleFor(element) {
        const owned = element.$$designSystem$$;
        if (owned) {
          return owned;
        }
        const container = DI.findResponsibleContainer(element);
        return container.get(designSystemKey);
      },
      /**
       * Gets the DesignSystem if one is explicitly defined on the provided element;
       * otherwise creates a design system defined directly on the element.
       * @param element - The element to get or create a design system for.
       * @returns The design system.
       * @public
       */
      getOrCreate(node) {
        if (!node) {
          if (rootDesignSystem === null) {
            rootDesignSystem = DI.getOrCreateDOMContainer().get(designSystemKey);
          }
          return rootDesignSystem;
        }
        const owned = node.$$designSystem$$;
        if (owned) {
          return owned;
        }
        const container = DI.getOrCreateDOMContainer(node);
        if (container.has(designSystemKey, false)) {
          return container.get(designSystemKey);
        } else {
          const system = new DefaultDesignSystem(node, container);
          container.register(Registration.instance(designSystemKey, system));
          return system;
        }
      }
    });
    DefaultDesignSystem = class {
      constructor(owner, container) {
        this.owner = owner;
        this.container = container;
        this.designTokensInitialized = false;
        this.prefix = "fast";
        this.shadowRootMode = void 0;
        this.disambiguate = () => ElementDisambiguation.definitionCallbackOnly;
        if (owner !== null) {
          owner.$$designSystem$$ = this;
        }
      }
      withPrefix(prefix) {
        this.prefix = prefix;
        return this;
      }
      withShadowRootMode(mode) {
        this.shadowRootMode = mode;
        return this;
      }
      withElementDisambiguation(callback) {
        this.disambiguate = callback;
        return this;
      }
      withDesignTokenRoot(root) {
        this.designTokenRoot = root;
        return this;
      }
      register(...registrations) {
        const container = this.container;
        const elementDefinitionEntries = [];
        const disambiguate = this.disambiguate;
        const shadowRootMode = this.shadowRootMode;
        const context = {
          elementPrefix: this.prefix,
          tryDefineElement(params, elementDefinitionType, elementDefinitionCallback) {
            const extractedParams = extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback);
            const { name, callback, baseClass } = extractedParams;
            let { type } = extractedParams;
            let elementName = name;
            let typeFoundByName = elementTypesByTag.get(elementName);
            let needsDefine = true;
            while (typeFoundByName) {
              const result = disambiguate(elementName, type, typeFoundByName);
              switch (result) {
                case ElementDisambiguation.ignoreDuplicate:
                  return;
                case ElementDisambiguation.definitionCallbackOnly:
                  needsDefine = false;
                  typeFoundByName = void 0;
                  break;
                default:
                  elementName = result;
                  typeFoundByName = elementTypesByTag.get(elementName);
                  break;
              }
            }
            if (needsDefine) {
              if (elementTagsByType.has(type) || type === FoundationElement) {
                type = class extends type {
                };
              }
              elementTypesByTag.set(elementName, type);
              elementTagsByType.set(type, elementName);
              if (baseClass) {
                elementTagsByType.set(baseClass, elementName);
              }
            }
            elementDefinitionEntries.push(new ElementDefinitionEntry(container, elementName, type, shadowRootMode, callback, needsDefine));
          }
        };
        if (!this.designTokensInitialized) {
          this.designTokensInitialized = true;
          if (this.designTokenRoot !== null) {
            DesignToken.registerRoot(this.designTokenRoot);
          }
        }
        container.registerWithContext(context, ...registrations);
        for (const entry of elementDefinitionEntries) {
          entry.callback(entry);
          if (entry.willDefine && entry.definition !== null) {
            entry.definition.define();
          }
        }
        return this;
      }
    };
    ElementDefinitionEntry = class {
      constructor(container, name, type, shadowRootMode, callback, willDefine) {
        this.container = container;
        this.name = name;
        this.type = type;
        this.shadowRootMode = shadowRootMode;
        this.callback = callback;
        this.willDefine = willDefine;
        this.definition = null;
      }
      definePresentation(presentation) {
        ComponentPresentation.define(this.name, presentation, this.container);
      }
      defineElement(definition) {
        this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), { name: this.name }));
      }
      tagFor(type) {
        return DesignSystem.tagFor(type);
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/design-system/registration-context.js
var init_registration_context = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/design-system/registration-context.js"() {
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/design-system/index.js
var init_design_system2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/design-system/index.js"() {
    init_design_system();
    init_component_presentation();
    init_registration_context();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/design-token/interfaces.js
var init_interfaces = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/design-token/interfaces.js"() {
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/di/index.js
var init_di2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/di/index.js"() {
    init_di();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.template.js
var dialogTemplate;
var init_dialog_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.template.js"() {
    init_esm();
    dialogTemplate = (context, definition) => html2`
    <div class="positioning-region" part="positioning-region">
        ${when((x) => x.modal, html2`
                <div
                    class="overlay"
                    part="overlay"
                    role="presentation"
                    @click="${(x) => x.dismiss()}"
                ></div>
            `)}
        <div
            role="dialog"
            tabindex="-1"
            class="control"
            part="control"
            aria-modal="${(x) => x.modal}"
            aria-describedby="${(x) => x.ariaDescribedby}"
            aria-labelledby="${(x) => x.ariaLabelledby}"
            aria-label="${(x) => x.ariaLabel}"
            ${ref("dialog")}
        >
            <slot></slot>
        </div>
    </div>
`;
  }
});

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors, candidateSelector, NoElement, matches, getRootNode, getTabindex, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isZeroArea, isHidden, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isTabbable, focusableCandidateSelector, isFocusable;
var init_index_esm = __esm({
  "node_modules/tabbable/dist/index.esm.js"() {
    candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
    candidateSelector = candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      return element.getRootNode();
    } : function(element) {
      return element.ownerDocument;
    };
    getTabindex = function getTabindex2(node, isScope) {
      if (node.tabIndex < 0) {
        if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r;
    };
    getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked && nodes[i].form === form) {
          return nodes[i];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot2 = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      var nodeRootHost = getRootNode(node).host;
      var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
      if (!displayCheck || displayCheck === "full") {
        if (typeof getShadowRoot2 === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot2(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (nodeIsAttached) {
          return !node.getClientRects().length;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
      if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
        return false;
      }
      return true;
    };
    isTabbable = function isTabbable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options, node);
    };
    focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
    isFocusable = function isFocusable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options, node);
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.js
var Dialog;
var init_dialog = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_index_esm();
    init_foundation_element();
    Dialog = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.modal = true;
        this.hidden = false;
        this.trapFocus = true;
        this.trapFocusChanged = () => {
          if (this.$fastController.isConnected) {
            this.updateTrapFocus();
          }
        };
        this.isTrappingFocus = false;
        this.handleDocumentKeydown = (e) => {
          if (!e.defaultPrevented && !this.hidden) {
            switch (e.key) {
              case keyEscape:
                this.dismiss();
                e.preventDefault();
                break;
              case keyTab:
                this.handleTabKeyDown(e);
                break;
            }
          }
        };
        this.handleDocumentFocus = (e) => {
          if (!e.defaultPrevented && this.shouldForceFocus(e.target)) {
            this.focusFirstElement();
            e.preventDefault();
          }
        };
        this.handleTabKeyDown = (e) => {
          if (!this.trapFocus || this.hidden) {
            return;
          }
          const bounds = this.getTabQueueBounds();
          if (bounds.length === 0) {
            return;
          }
          if (bounds.length === 1) {
            bounds[0].focus();
            e.preventDefault();
            return;
          }
          if (e.shiftKey && e.target === bounds[0]) {
            bounds[bounds.length - 1].focus();
            e.preventDefault();
          } else if (!e.shiftKey && e.target === bounds[bounds.length - 1]) {
            bounds[0].focus();
            e.preventDefault();
          }
          return;
        };
        this.getTabQueueBounds = () => {
          const bounds = [];
          return Dialog.reduceTabbableItems(bounds, this);
        };
        this.focusFirstElement = () => {
          const bounds = this.getTabQueueBounds();
          if (bounds.length > 0) {
            bounds[0].focus();
          } else {
            if (this.dialog instanceof HTMLElement) {
              this.dialog.focus();
            }
          }
        };
        this.shouldForceFocus = (currentFocusElement) => {
          return this.isTrappingFocus && !this.contains(currentFocusElement);
        };
        this.shouldTrapFocus = () => {
          return this.trapFocus && !this.hidden;
        };
        this.updateTrapFocus = (shouldTrapFocusOverride) => {
          const shouldTrapFocus = shouldTrapFocusOverride === void 0 ? this.shouldTrapFocus() : shouldTrapFocusOverride;
          if (shouldTrapFocus && !this.isTrappingFocus) {
            this.isTrappingFocus = true;
            document.addEventListener("focusin", this.handleDocumentFocus);
            DOM.queueUpdate(() => {
              if (this.shouldForceFocus(document.activeElement)) {
                this.focusFirstElement();
              }
            });
          } else if (!shouldTrapFocus && this.isTrappingFocus) {
            this.isTrappingFocus = false;
            document.removeEventListener("focusin", this.handleDocumentFocus);
          }
        };
      }
      /**
       * @internal
       */
      dismiss() {
        this.$emit("dismiss");
        this.$emit("cancel");
      }
      /**
       * The method to show the dialog.
       *
       * @public
       */
      show() {
        this.hidden = false;
      }
      /**
       * The method to hide the dialog.
       *
       * @public
       */
      hide() {
        this.hidden = true;
        this.$emit("close");
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        document.addEventListener("keydown", this.handleDocumentKeydown);
        this.notifier = Observable.getNotifier(this);
        this.notifier.subscribe(this, "hidden");
        this.updateTrapFocus();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        document.removeEventListener("keydown", this.handleDocumentKeydown);
        this.updateTrapFocus(false);
        this.notifier.unsubscribe(this, "hidden");
      }
      /**
       * @internal
       */
      handleChange(source, propertyName) {
        switch (propertyName) {
          case "hidden":
            this.updateTrapFocus();
            break;
          default:
            break;
        }
      }
      /**
       * Reduce a collection to only its focusable elements.
       *
       * @param elements - Collection of elements to reduce
       * @param element - The current element
       *
       * @internal
       */
      static reduceTabbableItems(elements2, element) {
        if (element.getAttribute("tabindex") === "-1") {
          return elements2;
        }
        if (isTabbable(element) || Dialog.isFocusableFastElement(element) && Dialog.hasTabbableShadow(element)) {
          elements2.push(element);
          return elements2;
        }
        if (element.childElementCount) {
          return elements2.concat(Array.from(element.children).reduce(Dialog.reduceTabbableItems, []));
        }
        return elements2;
      }
      /**
       * Test if element is focusable fast element
       *
       * @param element - The element to check
       *
       * @internal
       */
      static isFocusableFastElement(element) {
        var _a2, _b2;
        return !!((_b2 = (_a2 = element.$fastController) === null || _a2 === void 0 ? void 0 : _a2.definition.shadowOptions) === null || _b2 === void 0 ? void 0 : _b2.delegatesFocus);
      }
      /**
       * Test if the element has a focusable shadow
       *
       * @param element - The element to check
       *
       * @internal
       */
      static hasTabbableShadow(element) {
        var _a2, _b2;
        return Array.from((_b2 = (_a2 = element.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll("*")) !== null && _b2 !== void 0 ? _b2 : []).some((x) => {
          return isTabbable(x);
        });
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], Dialog.prototype, "modal", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], Dialog.prototype, "hidden", void 0);
    __decorate5([
      attr({ attribute: "trap-focus", mode: "boolean" })
    ], Dialog.prototype, "trapFocus", void 0);
    __decorate5([
      attr({ attribute: "aria-describedby" })
    ], Dialog.prototype, "ariaDescribedby", void 0);
    __decorate5([
      attr({ attribute: "aria-labelledby" })
    ], Dialog.prototype, "ariaLabelledby", void 0);
    __decorate5([
      attr({ attribute: "aria-label" })
    ], Dialog.prototype, "ariaLabel", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/dialog/index.js
var init_dialog2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/dialog/index.js"() {
    init_dialog_template();
    init_dialog();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/directives/reflect-attributes.js
var observer, AttributeReflectionSubscriptionSet;
var init_reflect_attributes = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/directives/reflect-attributes.js"() {
    init_esm();
    observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        AttributeReflectionSubscriptionSet.getOrCreateFor(mutation.target).notify(mutation.attributeName);
      }
    });
    AttributeReflectionSubscriptionSet = class extends SubscriberSet {
      constructor(source) {
        super(source);
        this.watchedAttributes = /* @__PURE__ */ new Set();
        AttributeReflectionSubscriptionSet.subscriberCache.set(source, this);
      }
      subscribe(subscriber) {
        super.subscribe(subscriber);
        if (!this.watchedAttributes.has(subscriber.attributes)) {
          this.watchedAttributes.add(subscriber.attributes);
          this.observe();
        }
      }
      unsubscribe(subscriber) {
        super.unsubscribe(subscriber);
        if (this.watchedAttributes.has(subscriber.attributes)) {
          this.watchedAttributes.delete(subscriber.attributes);
          this.observe();
        }
      }
      static getOrCreateFor(source) {
        return this.subscriberCache.get(source) || new AttributeReflectionSubscriptionSet(source);
      }
      observe() {
        const attributeFilter = [];
        for (const attributes of this.watchedAttributes.values()) {
          for (let i = 0; i < attributes.length; i++) {
            attributeFilter.push(attributes[i]);
          }
        }
        observer.observe(this.source, { attributeFilter });
      }
    };
    AttributeReflectionSubscriptionSet.subscriberCache = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.template.js
var init_disclosure_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.template.js"() {
    init_esm();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.js
var Disclosure;
var init_disclosure = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/disclosure/disclosure.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    Disclosure = class extends FoundationElement {
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.setup();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.details.removeEventListener("toggle", this.onToggle);
      }
      /**
       * Show extra content.
       */
      show() {
        this.details.open = true;
      }
      /**
       * Hide extra content.
       */
      hide() {
        this.details.open = false;
      }
      /**
       * Toggle the current(expanded/collapsed) state.
       */
      toggle() {
        this.details.open = !this.details.open;
      }
      /**
       * Register listener and set default disclosure mode
       */
      setup() {
        this.onToggle = this.onToggle.bind(this);
        this.details.addEventListener("toggle", this.onToggle);
        if (this.expanded) {
          this.show();
        }
      }
      /**
       * Update the aria attr and fire `toggle` event
       */
      onToggle() {
        this.expanded = this.details.open;
        this.$emit("toggle");
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], Disclosure.prototype, "expanded", void 0);
    __decorate5([
      attr
    ], Disclosure.prototype, "title", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/disclosure/index.js
var init_disclosure2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/disclosure/index.js"() {
    init_disclosure_template();
    init_disclosure();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.template.js
var dividerTemplate;
var init_divider_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.template.js"() {
    init_esm();
    dividerTemplate = (context, definition) => html2`
    <template role="${(x) => x.role}" aria-orientation="${(x) => x.orientation}"></template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.options.js
var DividerRole;
var init_divider_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.options.js"() {
    DividerRole = {
      /**
       * The divider semantically separates content
       */
      separator: "separator",
      /**
       * The divider has no semantic value and is for visual presentation only.
       */
      presentation: "presentation"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.js
var Divider;
var init_divider = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/divider/divider.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_divider_options();
    Divider = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.role = DividerRole.separator;
        this.orientation = Orientation.horizontal;
      }
    };
    __decorate5([
      attr
    ], Divider.prototype, "role", void 0);
    __decorate5([
      attr
    ], Divider.prototype, "orientation", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/divider/index.js
var init_divider2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/divider/index.js"() {
    init_divider_template();
    init_divider();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.options.js
var FlipperDirection;
var init_flipper_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.options.js"() {
    FlipperDirection = {
      next: "next",
      previous: "previous"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.template.js
var flipperTemplate;
var init_flipper_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.template.js"() {
    init_esm();
    init_flipper_options();
    flipperTemplate = (context, definition) => html2`
    <template
        role="button"
        aria-disabled="${(x) => x.disabled ? true : void 0}"
        tabindex="${(x) => x.hiddenFromAT ? -1 : 0}"
        class="${(x) => x.direction} ${(x) => x.disabled ? "disabled" : ""}"
        @keyup="${(x, c) => x.keyupHandler(c.event)}"
    >
        ${when((x) => x.direction === FlipperDirection.next, html2`
                <span part="next" class="next">
                    <slot name="next">
                        ${definition.next || ""}
                    </slot>
                </span>
            `)}
        ${when((x) => x.direction === FlipperDirection.previous, html2`
                <span part="previous" class="previous">
                    <slot name="previous">
                        ${definition.previous || ""}
                    </slot>
                </span>
            `)}
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.js
var Flipper;
var init_flipper = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/flipper/flipper.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    init_flipper_options();
    Flipper = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.hiddenFromAT = true;
        this.direction = FlipperDirection.next;
      }
      /**
       * Simulate a click event when the flipper has focus and the user hits enter or space keys
       * Blur focus if the user hits escape key
       * @param e - Keyboard event
       * @public
       */
      keyupHandler(e) {
        if (!this.hiddenFromAT) {
          const key = e.key;
          if (key === "Enter" || key === "Space") {
            this.$emit("click", e);
          }
          if (key === "Escape") {
            this.blur();
          }
        }
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], Flipper.prototype, "disabled", void 0);
    __decorate5([
      attr({ attribute: "aria-hidden", converter: booleanConverter })
    ], Flipper.prototype, "hiddenFromAT", void 0);
    __decorate5([
      attr
    ], Flipper.prototype, "direction", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/flipper/index.js
var init_flipper2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/flipper/index.js"() {
    init_flipper_template();
    init_flipper();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/form-associated/index.js
var init_form_associated2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/form-associated/index.js"() {
    init_form_associated();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/index.js
var init_foundation_element2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/foundation-element/index.js"() {
    init_foundation_element();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.template.js
var listboxOptionTemplate;
var init_listbox_option_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/listbox-option.template.js"() {
    init_esm();
    init_start_end();
    listboxOptionTemplate = (context, definition) => html2`
    <template
        aria-checked="${(x) => x.ariaChecked}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-posinset="${(x) => x.ariaPosInSet}"
        aria-selected="${(x) => x.ariaSelected}"
        aria-setsize="${(x) => x.ariaSetSize}"
        class="${(x) => [x.checked && "checked", x.selected && "selected", x.disabled && "disabled"].filter(Boolean).join(" ")}"
        role="option"
    >
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot ${slotted("content")}></slot>
        </span>
        ${endSlotTemplate(context, definition)}
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/index.js
var init_listbox_option2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/listbox-option/index.js"() {
    init_listbox_option();
    init_listbox_option_template();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.element.js
var ListboxElement;
var init_listbox_element = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.element.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_listbox();
    ListboxElement = class extends Listbox {
      constructor() {
        super(...arguments);
        this.activeIndex = -1;
        this.rangeStartIndex = -1;
      }
      /**
       * Returns the last checked option.
       *
       * @internal
       */
      get activeOption() {
        return this.options[this.activeIndex];
      }
      /**
       * Returns the list of checked options.
       *
       * @internal
       */
      get checkedOptions() {
        var _a2;
        return (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.filter((o) => o.checked);
      }
      /**
       * Returns the index of the first selected option.
       *
       * @internal
       */
      get firstSelectedOptionIndex() {
        return this.options.indexOf(this.firstSelectedOption);
      }
      /**
       * Updates the `ariaActiveDescendant` property when the active index changes.
       *
       * @param prev - the previous active index
       * @param next - the next active index
       *
       * @internal
       */
      activeIndexChanged(prev, next) {
        var _a2, _b2;
        this.ariaActiveDescendant = (_b2 = (_a2 = this.options[next]) === null || _a2 === void 0 ? void 0 : _a2.id) !== null && _b2 !== void 0 ? _b2 : "";
        this.focusAndScrollOptionIntoView();
      }
      /**
       * Toggles the checked state for the currently active option.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @internal
       */
      checkActiveIndex() {
        if (!this.multiple) {
          return;
        }
        const activeItem = this.activeOption;
        if (activeItem) {
          activeItem.checked = true;
        }
      }
      /**
       * Sets the active index to the first option and marks it as checked.
       *
       * @remarks
       * Multi-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkFirstOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex + 1;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.rangeStartIndex);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex = 0;
        this.checkActiveIndex();
      }
      /**
       * Decrements the active index and sets the matching option as checked.
       *
       * @remarks
       * Multi-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkLastOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.rangeStartIndex, this.options.length);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex = this.options.length - 1;
        this.checkActiveIndex();
      }
      /**
       * @override
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.addEventListener("focusout", this.focusoutHandler);
      }
      /**
       * @override
       * @internal
       */
      disconnectedCallback() {
        this.removeEventListener("focusout", this.focusoutHandler);
        super.disconnectedCallback();
      }
      /**
       * Increments the active index and marks the matching option as checked.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkNextOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.rangeStartIndex, this.activeIndex + 1);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex += this.activeIndex < this.options.length - 1 ? 1 : 0;
        this.checkActiveIndex();
      }
      /**
       * Decrements the active index and marks the matching option as checked.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @param preserveChecked - mark all options unchecked before changing the active index
       *
       * @internal
       */
      checkPreviousOption(preserveChecked = false) {
        if (preserveChecked) {
          if (this.rangeStartIndex === -1) {
            this.rangeStartIndex = this.activeIndex;
          }
          if (this.checkedOptions.length === 1) {
            this.rangeStartIndex += 1;
          }
          this.options.forEach((o, i) => {
            o.checked = inRange(i, this.activeIndex, this.rangeStartIndex);
          });
        } else {
          this.uncheckAllOptions();
        }
        this.activeIndex -= this.activeIndex > 0 ? 1 : 0;
        this.checkActiveIndex();
      }
      /**
       * Handles click events for listbox options.
       *
       * @param e - the event object
       *
       * @override
       * @internal
       */
      clickHandler(e) {
        var _a2;
        if (!this.multiple) {
          return super.clickHandler(e);
        }
        const captured = (_a2 = e.target) === null || _a2 === void 0 ? void 0 : _a2.closest(`[role=option]`);
        if (!captured || captured.disabled) {
          return;
        }
        this.uncheckAllOptions();
        this.activeIndex = this.options.indexOf(captured);
        this.checkActiveIndex();
        this.toggleSelectedForAllCheckedOptions();
        return true;
      }
      /**
       * @override
       * @internal
       */
      focusAndScrollOptionIntoView() {
        super.focusAndScrollOptionIntoView(this.activeOption);
      }
      /**
       * In multiple-selection mode:
       * If any options are selected, the first selected option is checked when
       * the listbox receives focus. If no options are selected, the first
       * selectable option is checked.
       *
       * @override
       * @internal
       */
      focusinHandler(e) {
        if (!this.multiple) {
          return super.focusinHandler(e);
        }
        if (!this.shouldSkipFocus && e.target === e.currentTarget) {
          this.uncheckAllOptions();
          if (this.activeIndex === -1) {
            this.activeIndex = this.firstSelectedOptionIndex !== -1 ? this.firstSelectedOptionIndex : 0;
          }
          this.checkActiveIndex();
          this.setSelectedOptions();
          this.focusAndScrollOptionIntoView();
        }
        this.shouldSkipFocus = false;
      }
      /**
       * Unchecks all options when the listbox loses focus.
       *
       * @internal
       */
      focusoutHandler(e) {
        if (this.multiple) {
          this.uncheckAllOptions();
        }
      }
      /**
       * Handles keydown actions for listbox navigation and typeahead
       *
       * @override
       * @internal
       */
      keydownHandler(e) {
        if (!this.multiple) {
          return super.keydownHandler(e);
        }
        if (this.disabled) {
          return true;
        }
        const { key, shiftKey } = e;
        this.shouldSkipFocus = false;
        switch (key) {
          case keyHome: {
            this.checkFirstOption(shiftKey);
            return;
          }
          case keyArrowDown: {
            this.checkNextOption(shiftKey);
            return;
          }
          case keyArrowUp: {
            this.checkPreviousOption(shiftKey);
            return;
          }
          case keyEnd: {
            this.checkLastOption(shiftKey);
            return;
          }
          case keyTab: {
            this.focusAndScrollOptionIntoView();
            return true;
          }
          case keyEscape: {
            this.uncheckAllOptions();
            this.checkActiveIndex();
            return true;
          }
          case keySpace: {
            e.preventDefault();
            if (this.typeAheadExpired) {
              this.toggleSelectedForAllCheckedOptions();
              return;
            }
          }
          default: {
            if (key.length === 1) {
              this.handleTypeAhead(`${key}`);
            }
            return true;
          }
        }
      }
      /**
       * Prevents `focusin` events from firing before `click` events when the
       * element is unfocused.
       *
       * @override
       * @internal
       */
      mousedownHandler(e) {
        if (e.offsetX >= 0 && e.offsetX <= this.scrollWidth) {
          return super.mousedownHandler(e);
        }
      }
      /**
       * Switches between single-selection and multi-selection mode.
       *
       * @internal
       */
      multipleChanged(prev, next) {
        var _a2;
        this.ariaMultiSelectable = next ? "true" : null;
        (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.forEach((o) => {
          o.checked = next ? false : void 0;
        });
        this.setSelectedOptions();
      }
      /**
       * Sets an option as selected and gives it focus.
       *
       * @override
       * @public
       */
      setSelectedOptions() {
        if (!this.multiple) {
          super.setSelectedOptions();
          return;
        }
        if (this.$fastController.isConnected && this.options) {
          this.selectedOptions = this.options.filter((o) => o.selected);
          this.focusAndScrollOptionIntoView();
        }
      }
      /**
       * Ensures the size is a positive integer when the property is updated.
       *
       * @param prev - the previous size value
       * @param next - the current size value
       *
       * @internal
       */
      sizeChanged(prev, next) {
        var _a2;
        const size = Math.max(0, parseInt((_a2 = next === null || next === void 0 ? void 0 : next.toFixed()) !== null && _a2 !== void 0 ? _a2 : "", 10));
        if (size !== next) {
          DOM.queueUpdate(() => {
            this.size = size;
          });
        }
      }
      /**
       * Toggles the selected state of the provided options. If any provided items
       * are in an unselected state, all items are set to selected. If every
       * provided item is selected, they are all unselected.
       *
       * @internal
       */
      toggleSelectedForAllCheckedOptions() {
        const enabledCheckedOptions = this.checkedOptions.filter((o) => !o.disabled);
        const force = !enabledCheckedOptions.every((o) => o.selected);
        enabledCheckedOptions.forEach((o) => o.selected = force);
        this.selectedIndex = this.options.indexOf(enabledCheckedOptions[enabledCheckedOptions.length - 1]);
        this.setSelectedOptions();
      }
      /**
       * @override
       * @internal
       */
      typeaheadBufferChanged(prev, next) {
        if (!this.multiple) {
          super.typeaheadBufferChanged(prev, next);
          return;
        }
        if (this.$fastController.isConnected) {
          const typeaheadMatches = this.getTypeaheadMatches();
          const activeIndex = this.options.indexOf(typeaheadMatches[0]);
          if (activeIndex > -1) {
            this.activeIndex = activeIndex;
            this.uncheckAllOptions();
            this.checkActiveIndex();
          }
          this.typeAheadExpired = false;
        }
      }
      /**
       * Unchecks all options.
       *
       * @remarks
       * Multiple-selection mode only.
       *
       * @param preserveChecked - reset the rangeStartIndex
       *
       * @internal
       */
      uncheckAllOptions(preserveChecked = false) {
        this.options.forEach((o) => o.checked = this.multiple ? false : void 0);
        if (!preserveChecked) {
          this.rangeStartIndex = -1;
        }
      }
    };
    __decorate5([
      observable
    ], ListboxElement.prototype, "activeIndex", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], ListboxElement.prototype, "multiple", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], ListboxElement.prototype, "size", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.template.js
var listboxTemplate;
var init_listbox_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.template.js"() {
    init_esm();
    init_listbox_element();
    listboxTemplate = (context, definition) => html2`
    <template
        aria-activedescendant="${(x) => x.ariaActiveDescendant}"
        aria-multiselectable="${(x) => x.ariaMultiSelectable}"
        class="listbox"
        role="listbox"
        tabindex="${(x) => !x.disabled ? "0" : null}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @focusin="${(x, c) => x.focusinHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        @mousedown="${(x, c) => x.mousedownHandler(c.event)}"
    >
        <slot
            ${slotted({
      filter: ListboxElement.slottedOptionFilter,
      flatten: true,
      property: "slottedOptions"
    })}
        ></slot>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/listbox/index.js
var init_listbox2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/listbox/index.js"() {
    init_listbox();
    init_listbox_element();
    init_listbox_template();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.js
var PickerMenu;
var init_picker_menu = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.js"() {
    init_tslib_es62();
    init_dist2();
    init_esm();
    init_foundation_element();
    PickerMenu = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.optionElements = [];
      }
      menuElementsChanged() {
        this.updateOptions();
      }
      headerElementsChanged() {
        this.updateOptions();
      }
      footerElementsChanged() {
        this.updateOptions();
      }
      updateOptions() {
        this.optionElements.splice(0, this.optionElements.length);
        this.addSlottedListItems(this.headerElements);
        this.addSlottedListItems(this.menuElements);
        this.addSlottedListItems(this.footerElements);
        this.$emit("optionsupdated", { bubbles: false });
      }
      addSlottedListItems(slotChildren) {
        if (slotChildren === void 0) {
          return;
        }
        slotChildren.forEach((child) => {
          if (child.nodeType === 1 && child.getAttribute("role") === "listitem") {
            child.id = child.id || uniqueId("option-");
            this.optionElements.push(child);
          }
        });
      }
    };
    __decorate5([
      observable
    ], PickerMenu.prototype, "menuElements", void 0);
    __decorate5([
      observable
    ], PickerMenu.prototype, "headerElements", void 0);
    __decorate5([
      observable
    ], PickerMenu.prototype, "footerElements", void 0);
    __decorate5([
      observable
    ], PickerMenu.prototype, "suggestionsAvailableText", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.js
var defaultContentsTemplate, PickerMenuOption;
var init_picker_menu_option = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    defaultContentsTemplate = html2`
    <template>
        ${(x) => x.value}
    </template>
`;
    PickerMenuOption = class extends FoundationElement {
      contentsTemplateChanged() {
        if (this.$fastController.isConnected) {
          this.updateView();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.updateView();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.disconnectView();
      }
      handleClick(e) {
        if (e.defaultPrevented) {
          return false;
        }
        this.handleInvoked();
        return false;
      }
      handleInvoked() {
        this.$emit("pickeroptioninvoked");
      }
      updateView() {
        var _a2, _b2;
        this.disconnectView();
        this.customView = (_b2 = (_a2 = this.contentsTemplate) === null || _a2 === void 0 ? void 0 : _a2.render(this, this)) !== null && _b2 !== void 0 ? _b2 : defaultContentsTemplate.render(this, this);
      }
      disconnectView() {
        var _a2;
        (_a2 = this.customView) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        this.customView = void 0;
      }
    };
    __decorate5([
      attr({ attribute: "value" })
    ], PickerMenuOption.prototype, "value", void 0);
    __decorate5([
      observable
    ], PickerMenuOption.prototype, "contentsTemplate", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.js
var init_picker_list = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.js"() {
    init_foundation_element();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.js
var defaultContentsTemplate2, PickerListItem;
var init_picker_list_item = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    defaultContentsTemplate2 = html2`
    <template>
        ${(x) => x.value}
    </template>
`;
    PickerListItem = class extends FoundationElement {
      contentsTemplateChanged() {
        if (this.$fastController.isConnected) {
          this.updateView();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.updateView();
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        this.disconnectView();
        super.disconnectedCallback();
      }
      handleKeyDown(e) {
        if (e.defaultPrevented) {
          return false;
        }
        if (e.key === keyEnter) {
          this.handleInvoke();
          return false;
        }
        return true;
      }
      handleClick(e) {
        if (!e.defaultPrevented) {
          this.handleInvoke();
        }
        return false;
      }
      handleInvoke() {
        this.$emit("pickeriteminvoked");
      }
      updateView() {
        var _a2, _b2;
        this.disconnectView();
        this.customView = (_b2 = (_a2 = this.contentsTemplate) === null || _a2 === void 0 ? void 0 : _a2.render(this, this)) !== null && _b2 !== void 0 ? _b2 : defaultContentsTemplate2.render(this, this);
      }
      disconnectView() {
        var _a2;
        (_a2 = this.customView) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        this.customView = void 0;
      }
    };
    __decorate5([
      attr({ attribute: "value" })
    ], PickerListItem.prototype, "value", void 0);
    __decorate5([
      observable
    ], PickerListItem.prototype, "contentsTemplate", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.template.js
var init_picker_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.template.js"() {
    init_esm();
    init_anchored_region();
    init_picker_menu();
    init_picker_menu_option();
    init_picker_list();
    init_picker_list_item();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.form-associated.js
var _Picker, FormAssociatedPicker;
var init_picker_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Picker = class extends FoundationElement {
    };
    FormAssociatedPicker = class extends FormAssociated(_Picker) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.js
var pickerInputTemplate, Picker2;
var init_picker = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_anchored_region2();
    init_picker_menu_option();
    init_picker_list_item();
    init_picker_form_associated();
    pickerInputTemplate = html2`
    <input
        slot="input-region"
        role="combobox"
        type="text"
        autocapitalize="off"
        autocomplete="off"
        haspopup="list"
        aria-label="${(x) => x.label}"
        aria-labelledby="${(x) => x.labelledBy}"
        placeholder="${(x) => x.placeholder}"
        ${ref("inputElement")}
    ></input>
`;
    Picker2 = class extends FormAssociatedPicker {
      constructor() {
        super(...arguments);
        this.selection = "";
        this.filterSelected = true;
        this.filterQuery = true;
        this.noSuggestionsText = "No suggestions available";
        this.suggestionsAvailableText = "Suggestions available";
        this.loadingText = "Loading suggestions";
        this.menuPlacement = "bottom-fill";
        this.showLoading = false;
        this.optionsList = [];
        this.filteredOptionsList = [];
        this.flyoutOpen = false;
        this.menuFocusIndex = -1;
        this.showNoOptions = false;
        this.selectedItems = [];
        this.inputElementView = null;
        this.handleTextInput = (e) => {
          this.query = this.inputElement.value;
        };
        this.handleInputClick = (e) => {
          e.preventDefault();
          this.toggleFlyout(true);
        };
        this.setRegionProps = () => {
          if (!this.flyoutOpen) {
            return;
          }
          if (this.region === null || this.region === void 0) {
            DOM.queueUpdate(this.setRegionProps);
            return;
          }
          this.region.anchorElement = this.inputElement;
        };
        this.configLookup = {
          top: FlyoutPosTop,
          bottom: FlyoutPosBottom,
          tallest: FlyoutPosTallest,
          "top-fill": FlyoutPosTopFill,
          "bottom-fill": FlyoutPosBottomFill,
          "tallest-fill": FlyoutPosTallestFill
        };
      }
      selectionChanged() {
        if (this.$fastController.isConnected) {
          this.handleSelectionChange();
          if (this.proxy instanceof HTMLInputElement) {
            this.proxy.value = this.selection;
            this.validate();
          }
        }
      }
      optionsChanged() {
        this.optionsList = this.options.split(",").map((opt) => opt.trim()).filter((opt) => opt !== "");
      }
      menuPlacementChanged() {
        if (this.$fastController.isConnected) {
          this.updateMenuConfig();
        }
      }
      showLoadingChanged() {
        if (this.$fastController.isConnected) {
          DOM.queueUpdate(() => {
            this.setFocusedOption(0);
          });
        }
      }
      listItemTemplateChanged() {
        this.updateListItemTemplate();
      }
      defaultListItemTemplateChanged() {
        this.updateListItemTemplate();
      }
      menuOptionTemplateChanged() {
        this.updateOptionTemplate();
      }
      defaultMenuOptionTemplateChanged() {
        this.updateOptionTemplate();
      }
      optionsListChanged() {
        this.updateFilteredOptions();
      }
      queryChanged() {
        if (this.$fastController.isConnected) {
          if (this.inputElement.value !== this.query) {
            this.inputElement.value = this.query;
          }
          this.updateFilteredOptions();
          this.$emit("querychange", { bubbles: false });
        }
      }
      filteredOptionsListChanged() {
        if (this.$fastController.isConnected) {
          this.showNoOptions = this.filteredOptionsList.length === 0 && this.menuElement.querySelectorAll('[role="listitem"]').length === 0;
          this.setFocusedOption(this.showNoOptions ? -1 : 0);
        }
      }
      flyoutOpenChanged() {
        if (this.flyoutOpen) {
          DOM.queueUpdate(this.setRegionProps);
          this.$emit("menuopening", { bubbles: false });
        } else {
          this.$emit("menuclosing", { bubbles: false });
        }
      }
      showNoOptionsChanged() {
        if (this.$fastController.isConnected) {
          DOM.queueUpdate(() => {
            this.setFocusedOption(0);
          });
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.listElement = document.createElement(this.selectedListTag);
        this.appendChild(this.listElement);
        this.itemsPlaceholderElement = document.createComment("");
        this.listElement.append(this.itemsPlaceholderElement);
        this.inputElementView = pickerInputTemplate.render(this, this.listElement);
        const match = this.menuTag.toUpperCase();
        this.menuElement = Array.from(this.children).find((element) => {
          return element.tagName === match;
        });
        if (this.menuElement === void 0) {
          this.menuElement = document.createElement(this.menuTag);
          this.appendChild(this.menuElement);
        }
        if (this.menuElement.id === "") {
          this.menuElement.id = uniqueId("listbox-");
        }
        this.menuId = this.menuElement.id;
        this.optionsPlaceholder = document.createComment("");
        this.menuElement.append(this.optionsPlaceholder);
        this.updateMenuConfig();
        DOM.queueUpdate(() => this.initialize());
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        this.toggleFlyout(false);
        this.inputElement.removeEventListener("input", this.handleTextInput);
        this.inputElement.removeEventListener("click", this.handleInputClick);
        if (this.inputElementView !== null) {
          this.inputElementView.dispose();
          this.inputElementView = null;
        }
      }
      /**
       * Move focus to the input element
       * @public
       */
      focus() {
        this.inputElement.focus();
      }
      /**
       * Initialize the component.  This is delayed a frame to ensure children are connected as well.
       */
      initialize() {
        this.updateListItemTemplate();
        this.updateOptionTemplate();
        this.itemsRepeatBehavior = new RepeatDirective2((x) => x.selectedItems, (x) => x.activeListItemTemplate, { positioning: true }).createBehavior(this.itemsPlaceholderElement);
        this.inputElement.addEventListener("input", this.handleTextInput);
        this.inputElement.addEventListener("click", this.handleInputClick);
        this.$fastController.addBehaviors([this.itemsRepeatBehavior]);
        this.menuElement.suggestionsAvailableText = this.suggestionsAvailableText;
        this.menuElement.addEventListener("optionsupdated", this.handleMenuOptionsUpdated);
        this.optionsRepeatBehavior = new RepeatDirective2((x) => x.filteredOptionsList, (x) => x.activeMenuOptionTemplate, { positioning: true }).createBehavior(this.optionsPlaceholder);
        this.$fastController.addBehaviors([this.optionsRepeatBehavior]);
        this.handleSelectionChange();
      }
      /**
       * Toggles the menu flyout
       */
      toggleFlyout(open) {
        if (this.flyoutOpen === open) {
          return;
        }
        if (open && document.activeElement === this.inputElement) {
          this.flyoutOpen = open;
          DOM.queueUpdate(() => {
            if (this.menuElement !== void 0) {
              this.setFocusedOption(0);
            } else {
              this.disableMenu();
            }
          });
          return;
        }
        this.flyoutOpen = false;
        this.disableMenu();
        return;
      }
      /**
       * Handle the menu options updated event from the child menu
       */
      handleMenuOptionsUpdated(e) {
        e.preventDefault();
        if (this.flyoutOpen) {
          this.setFocusedOption(0);
        }
      }
      /**
       * Handle key down events.
       */
      handleKeyDown(e) {
        if (e.defaultPrevented) {
          return false;
        }
        switch (e.key) {
          case keyArrowDown: {
            if (!this.flyoutOpen) {
              this.toggleFlyout(true);
            } else {
              const nextFocusOptionIndex = this.flyoutOpen ? Math.min(this.menuFocusIndex + 1, this.menuElement.optionElements.length - 1) : 0;
              this.setFocusedOption(nextFocusOptionIndex);
            }
            return false;
          }
          case keyArrowUp: {
            if (!this.flyoutOpen) {
              this.toggleFlyout(true);
            } else {
              const previousFocusOptionIndex = this.flyoutOpen ? Math.max(this.menuFocusIndex - 1, 0) : 0;
              this.setFocusedOption(previousFocusOptionIndex);
            }
            return false;
          }
          case keyEscape: {
            this.toggleFlyout(false);
            return false;
          }
          case keyEnter: {
            if (this.menuFocusIndex !== -1 && this.menuElement.optionElements.length > this.menuFocusIndex) {
              this.menuElement.optionElements[this.menuFocusIndex].click();
            }
            return false;
          }
          case keyArrowRight: {
            if (document.activeElement !== this.inputElement) {
              this.incrementFocusedItem(1);
              return false;
            }
            return true;
          }
          case keyArrowLeft: {
            if (this.inputElement.selectionStart === 0) {
              this.incrementFocusedItem(-1);
              return false;
            }
            return true;
          }
          case keyDelete:
          case keyBackspace: {
            if (document.activeElement === null) {
              return true;
            }
            if (document.activeElement === this.inputElement) {
              if (this.inputElement.selectionStart === 0) {
                this.selection = this.selectedItems.slice(0, this.selectedItems.length - 1).toString();
                this.toggleFlyout(false);
                return false;
              }
              return true;
            }
            const selectedItems = Array.from(this.listElement.children);
            const currentFocusedItemIndex = selectedItems.indexOf(document.activeElement);
            if (currentFocusedItemIndex > -1) {
              this.selection = this.selectedItems.splice(currentFocusedItemIndex, 1).toString();
              DOM.queueUpdate(() => {
                selectedItems[Math.min(selectedItems.length, currentFocusedItemIndex)].focus();
              });
              return false;
            }
            return true;
          }
        }
        this.toggleFlyout(true);
        return true;
      }
      /**
       * Handle focus in events.
       */
      handleFocusIn(e) {
        return false;
      }
      /**
       * Handle focus out events.
       */
      handleFocusOut(e) {
        if (this.menuElement === void 0 || !this.menuElement.contains(e.relatedTarget)) {
          this.toggleFlyout(false);
        }
        return false;
      }
      /**
       * The list of selected items has changed
       */
      handleSelectionChange() {
        if (this.selectedItems.toString() === this.selection) {
          return;
        }
        this.selectedItems = this.selection === "" ? [] : this.selection.split(",");
        this.updateFilteredOptions();
        DOM.queueUpdate(() => {
          this.checkMaxItems();
        });
        this.$emit("selectionchange", { bubbles: false });
      }
      /**
       * Anchored region is loaded, menu and options exist in the DOM.
       */
      handleRegionLoaded(e) {
        DOM.queueUpdate(() => {
          this.setFocusedOption(0);
          this.$emit("menuloaded", { bubbles: false });
        });
      }
      /**
       * Checks if the maximum number of items has been chosen and updates the ui.
       */
      checkMaxItems() {
        if (this.inputElement === void 0) {
          return;
        }
        if (this.maxSelected !== void 0 && this.selectedItems.length >= this.maxSelected) {
          if (document.activeElement === this.inputElement) {
            const selectedItemInstances = Array.from(this.listElement.querySelectorAll("[role='listitem']"));
            selectedItemInstances[selectedItemInstances.length - 1].focus();
          }
          this.inputElement.hidden = true;
        } else {
          this.inputElement.hidden = false;
        }
      }
      /**
       * A list item has been invoked.
       */
      handleItemInvoke(e) {
        if (e.defaultPrevented) {
          return false;
        }
        if (e.target instanceof PickerListItem) {
          const listItems = Array.from(this.listElement.querySelectorAll("[role='listitem']"));
          const itemIndex = listItems.indexOf(e.target);
          if (itemIndex !== -1) {
            const newSelection = this.selectedItems.slice();
            newSelection.splice(itemIndex, 1);
            this.selection = newSelection.toString();
            DOM.queueUpdate(() => this.incrementFocusedItem(0));
          }
          return false;
        }
        return true;
      }
      /**
       * A menu option has been invoked.
       */
      handleOptionInvoke(e) {
        if (e.defaultPrevented) {
          return false;
        }
        if (e.target instanceof PickerMenuOption) {
          if (e.target.value !== void 0) {
            this.selection = `${this.selection}${this.selection === "" ? "" : ","}${e.target.value}`;
          }
          this.inputElement.value = "";
          this.query = "";
          this.inputElement.focus();
          this.toggleFlyout(false);
          return false;
        }
        return true;
      }
      /**
       * Increments the focused list item by the specified amount
       */
      incrementFocusedItem(increment) {
        if (this.selectedItems.length === 0) {
          this.inputElement.focus();
          return;
        }
        const selectedItemsAsElements = Array.from(this.listElement.querySelectorAll("[role='listitem']"));
        if (document.activeElement !== null) {
          let currentFocusedItemIndex = selectedItemsAsElements.indexOf(document.activeElement);
          if (currentFocusedItemIndex === -1) {
            currentFocusedItemIndex = selectedItemsAsElements.length;
          }
          const newFocusedItemIndex = Math.min(selectedItemsAsElements.length, Math.max(0, currentFocusedItemIndex + increment));
          if (newFocusedItemIndex === selectedItemsAsElements.length) {
            if (this.maxSelected !== void 0 && this.selectedItems.length >= this.maxSelected) {
              selectedItemsAsElements[newFocusedItemIndex - 1].focus();
            } else {
              this.inputElement.focus();
            }
          } else {
            selectedItemsAsElements[newFocusedItemIndex].focus();
          }
        }
      }
      /**
       * Disables the menu. Note that the menu can be open, just doens't have any valid options on display.
       */
      disableMenu() {
        var _a2, _b2, _c;
        this.menuFocusIndex = -1;
        this.menuFocusOptionId = void 0;
        (_a2 = this.inputElement) === null || _a2 === void 0 ? void 0 : _a2.removeAttribute("aria-activedescendant");
        (_b2 = this.inputElement) === null || _b2 === void 0 ? void 0 : _b2.removeAttribute("aria-owns");
        (_c = this.inputElement) === null || _c === void 0 ? void 0 : _c.removeAttribute("aria-expanded");
      }
      /**
       * Sets the currently focused menu option by index
       */
      setFocusedOption(optionIndex) {
        if (!this.flyoutOpen || optionIndex === -1 || this.showNoOptions || this.showLoading) {
          this.disableMenu();
          return;
        }
        if (this.menuElement.optionElements.length === 0) {
          return;
        }
        this.menuElement.optionElements.forEach((element) => {
          element.setAttribute("aria-selected", "false");
        });
        this.menuFocusIndex = optionIndex;
        if (this.menuFocusIndex > this.menuElement.optionElements.length - 1) {
          this.menuFocusIndex = this.menuElement.optionElements.length - 1;
        }
        this.menuFocusOptionId = this.menuElement.optionElements[this.menuFocusIndex].id;
        this.inputElement.setAttribute("aria-owns", this.menuId);
        this.inputElement.setAttribute("aria-expanded", "true");
        this.inputElement.setAttribute("aria-activedescendant", this.menuFocusOptionId);
        const focusedOption = this.menuElement.optionElements[this.menuFocusIndex];
        focusedOption.setAttribute("aria-selected", "true");
        this.menuElement.scrollTo(0, focusedOption.offsetTop);
      }
      /**
       * Updates the template used for the list item repeat behavior
       */
      updateListItemTemplate() {
        var _a2;
        this.activeListItemTemplate = (_a2 = this.listItemTemplate) !== null && _a2 !== void 0 ? _a2 : this.defaultListItemTemplate;
      }
      /**
       * Updates the template used for the menu option repeat behavior
       */
      updateOptionTemplate() {
        var _a2;
        this.activeMenuOptionTemplate = (_a2 = this.menuOptionTemplate) !== null && _a2 !== void 0 ? _a2 : this.defaultMenuOptionTemplate;
      }
      /**
       * Updates the filtered options array
       */
      updateFilteredOptions() {
        this.filteredOptionsList = this.optionsList.slice(0);
        if (this.filterSelected) {
          this.filteredOptionsList = this.filteredOptionsList.filter((el) => this.selectedItems.indexOf(el) === -1);
        }
        if (this.filterQuery && this.query !== "" && this.query !== void 0) {
          this.filteredOptionsList = this.filteredOptionsList.filter((el) => el.indexOf(this.query) !== -1);
        }
      }
      /**
       * Updates the menu configuration
       */
      updateMenuConfig() {
        let newConfig = this.configLookup[this.menuPlacement];
        if (newConfig === null) {
          newConfig = FlyoutPosBottomFill;
        }
        this.menuConfig = Object.assign(Object.assign({}, newConfig), { autoUpdateMode: "auto", fixedPlacement: true, horizontalViewportLock: false, verticalViewportLock: false });
      }
    };
    __decorate5([
      attr({ attribute: "selection" })
    ], Picker2.prototype, "selection", void 0);
    __decorate5([
      attr({ attribute: "options" })
    ], Picker2.prototype, "options", void 0);
    __decorate5([
      attr({ attribute: "filter-selected", mode: "boolean" })
    ], Picker2.prototype, "filterSelected", void 0);
    __decorate5([
      attr({ attribute: "filter-query", mode: "boolean" })
    ], Picker2.prototype, "filterQuery", void 0);
    __decorate5([
      attr({ attribute: "max-selected" })
    ], Picker2.prototype, "maxSelected", void 0);
    __decorate5([
      attr({ attribute: "no-suggestions-text" })
    ], Picker2.prototype, "noSuggestionsText", void 0);
    __decorate5([
      attr({ attribute: "suggestions-available-text" })
    ], Picker2.prototype, "suggestionsAvailableText", void 0);
    __decorate5([
      attr({ attribute: "loading-text" })
    ], Picker2.prototype, "loadingText", void 0);
    __decorate5([
      attr({ attribute: "label" })
    ], Picker2.prototype, "label", void 0);
    __decorate5([
      attr({ attribute: "labelledby" })
    ], Picker2.prototype, "labelledBy", void 0);
    __decorate5([
      attr({ attribute: "placeholder" })
    ], Picker2.prototype, "placeholder", void 0);
    __decorate5([
      attr({ attribute: "menu-placement" })
    ], Picker2.prototype, "menuPlacement", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "showLoading", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "listItemTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "defaultListItemTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "activeListItemTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "menuOptionTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "defaultMenuOptionTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "activeMenuOptionTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "listItemContentsTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "menuOptionContentsTemplate", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "optionsList", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "query", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "filteredOptionsList", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "flyoutOpen", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "menuId", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "selectedListTag", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "menuTag", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "menuFocusIndex", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "menuFocusOptionId", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "showNoOptions", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "menuConfig", void 0);
    __decorate5([
      observable
    ], Picker2.prototype, "selectedItems", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.template.js
var init_picker_menu_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu.template.js"() {
    init_esm();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.template.js
var init_picker_menu_option_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-menu-option.template.js"() {
    init_esm();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.template.js
var init_picker_list_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list.template.js"() {
    init_esm();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.template.js
var init_picker_list_item_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/picker-list-item.template.js"() {
    init_esm();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/picker/index.js
var init_picker2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/picker/index.js"() {
    init_picker_template();
    init_picker();
    init_picker_menu_template();
    init_picker_menu();
    init_picker_menu_option_template();
    init_picker_menu_option();
    init_picker_list_template();
    init_picker_list();
    init_picker_list_item_template();
    init_picker_list_item();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.options.js
var MenuItemRole, roleForMenuItem;
var init_menu_item_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.options.js"() {
    MenuItemRole = {
      /**
       * The menu item has a "menuitem" role
       */
      menuitem: "menuitem",
      /**
       * The menu item has a "menuitemcheckbox" role
       */
      menuitemcheckbox: "menuitemcheckbox",
      /**
       * The menu item has a "menuitemradio" role
       */
      menuitemradio: "menuitemradio"
    };
    roleForMenuItem = {
      [MenuItemRole.menuitem]: "menuitem",
      [MenuItemRole.menuitemcheckbox]: "menuitemcheckbox",
      [MenuItemRole.menuitemradio]: "menuitemradio"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.js
var MenuItem;
var init_menu_item = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_foundation_element();
    init_start_end();
    init_direction();
    init_apply_mixins();
    init_menu_item_options();
    MenuItem = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.role = MenuItemRole.menuitem;
        this.hasSubmenu = false;
        this.currentDirection = Direction.ltr;
        this.focusSubmenuOnLoad = false;
        this.handleMenuItemKeyDown = (e) => {
          if (e.defaultPrevented) {
            return false;
          }
          switch (e.key) {
            case keyEnter:
            case keySpace:
              this.invoke();
              return false;
            case keyArrowRight:
              this.expandAndFocus();
              return false;
            case keyArrowLeft:
              if (this.expanded) {
                this.expanded = false;
                this.focus();
                return false;
              }
          }
          return true;
        };
        this.handleMenuItemClick = (e) => {
          if (e.defaultPrevented || this.disabled) {
            return false;
          }
          this.invoke();
          return false;
        };
        this.submenuLoaded = () => {
          if (!this.focusSubmenuOnLoad) {
            return;
          }
          this.focusSubmenuOnLoad = false;
          if (this.hasSubmenu) {
            this.submenu.focus();
            this.setAttribute("tabindex", "-1");
          }
        };
        this.handleMouseOver = (e) => {
          if (this.disabled || !this.hasSubmenu || this.expanded) {
            return false;
          }
          this.expanded = true;
          return false;
        };
        this.handleMouseOut = (e) => {
          if (!this.expanded || this.contains(document.activeElement)) {
            return false;
          }
          this.expanded = false;
          return false;
        };
        this.expandAndFocus = () => {
          if (!this.hasSubmenu) {
            return;
          }
          this.focusSubmenuOnLoad = true;
          this.expanded = true;
        };
        this.invoke = () => {
          if (this.disabled) {
            return;
          }
          switch (this.role) {
            case MenuItemRole.menuitemcheckbox:
              this.checked = !this.checked;
              break;
            case MenuItemRole.menuitem:
              this.updateSubmenu();
              if (this.hasSubmenu) {
                this.expandAndFocus();
              } else {
                this.$emit("change");
              }
              break;
            case MenuItemRole.menuitemradio:
              if (!this.checked) {
                this.checked = true;
              }
              break;
          }
        };
        this.updateSubmenu = () => {
          this.submenu = this.domChildren().find((element) => {
            return element.getAttribute("role") === "menu";
          });
          this.hasSubmenu = this.submenu === void 0 ? false : true;
        };
      }
      expandedChanged(oldValue) {
        if (this.$fastController.isConnected) {
          if (this.submenu === void 0) {
            return;
          }
          if (this.expanded === false) {
            this.submenu.collapseExpandedItem();
          } else {
            this.currentDirection = getDirection(this);
          }
          this.$emit("expanded-change", this, { bubbles: false });
        }
      }
      checkedChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.$emit("change");
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        DOM.queueUpdate(() => {
          this.updateSubmenu();
        });
        if (!this.startColumnCount) {
          this.startColumnCount = 1;
        }
        this.observer = new MutationObserver(this.updateSubmenu);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.submenu = void 0;
        if (this.observer !== void 0) {
          this.observer.disconnect();
          this.observer = void 0;
        }
      }
      /**
       * get an array of valid DOM children
       */
      domChildren() {
        return Array.from(this.children).filter((child) => !child.hasAttribute("hidden"));
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], MenuItem.prototype, "disabled", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], MenuItem.prototype, "expanded", void 0);
    __decorate5([
      observable
    ], MenuItem.prototype, "startColumnCount", void 0);
    __decorate5([
      attr
    ], MenuItem.prototype, "role", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], MenuItem.prototype, "checked", void 0);
    __decorate5([
      observable
    ], MenuItem.prototype, "submenuRegion", void 0);
    __decorate5([
      observable
    ], MenuItem.prototype, "hasSubmenu", void 0);
    __decorate5([
      observable
    ], MenuItem.prototype, "currentDirection", void 0);
    __decorate5([
      observable
    ], MenuItem.prototype, "submenu", void 0);
    applyMixins(MenuItem, StartEnd);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.template.js
var menuItemTemplate;
var init_menu_item_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/menu-item/menu-item.template.js"() {
    init_esm();
    init_anchored_region();
    init_start_end();
    init_menu_item();
    menuItemTemplate = (context, definition) => html2`
    <template
        role="${(x) => x.role}"
        aria-haspopup="${(x) => x.hasSubmenu ? "menu" : void 0}"
        aria-checked="${(x) => x.role !== MenuItemRole.menuitem ? x.checked : void 0}"
        aria-disabled="${(x) => x.disabled}"
        aria-expanded="${(x) => x.expanded}"
        @keydown="${(x, c) => x.handleMenuItemKeyDown(c.event)}"
        @click="${(x, c) => x.handleMenuItemClick(c.event)}"
        @mouseover="${(x, c) => x.handleMouseOver(c.event)}"
        @mouseout="${(x, c) => x.handleMouseOut(c.event)}"
        class="${(x) => x.disabled ? "disabled" : ""} ${(x) => x.expanded ? "expanded" : ""} ${(x) => `indent-${x.startColumnCount}`}"
    >
            ${when((x) => x.role === MenuItemRole.menuitemcheckbox, html2`
                    <div part="input-container" class="input-container">
                        <span part="checkbox" class="checkbox">
                            <slot name="checkbox-indicator">
                                ${definition.checkboxIndicator || ""}
                            </slot>
                        </span>
                    </div>
                `)}
            ${when((x) => x.role === MenuItemRole.menuitemradio, html2`
                    <div part="input-container" class="input-container">
                        <span part="radio" class="radio">
                            <slot name="radio-indicator">
                                ${definition.radioIndicator || ""}
                            </slot>
                        </span>
                    </div>
                `)}
        </div>
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot></slot>
        </span>
        ${endSlotTemplate(context, definition)}
        ${when((x) => x.hasSubmenu, html2`
                <div
                    part="expand-collapse-glyph-container"
                    class="expand-collapse-glyph-container"
                >
                    <span part="expand-collapse" class="expand-collapse">
                        <slot name="expand-collapse-indicator">
                            ${definition.expandCollapseGlyph || ""}
                        </slot>
                    </span>
                </div>
            `)}
        ${when((x) => x.expanded, html2`
                <${context.tagFor(AnchoredRegion)}
                    :anchorElement="${(x) => x}"
                    vertical-positioning-mode="dynamic"
                    vertical-default-position="bottom"
                    vertical-inset="true"
                    horizontal-positioning-mode="dynamic"
                    horizontal-default-position="end"
                    class="submenu-region"
                    dir="${(x) => x.currentDirection}"
                    @loaded="${(x) => x.submenuLoaded()}"
                    ${ref("submenuRegion")}
                    part="submenu-region"
                >
                    <slot name="submenu"></slot>
                </${context.tagFor(AnchoredRegion)}>
            `)}
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/menu-item/index.js
var init_menu_item2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/menu-item/index.js"() {
    init_menu_item_template();
    init_menu_item();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.template.js
var menuTemplate;
var init_menu_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.template.js"() {
    init_esm();
    menuTemplate = (context, definition) => html2`
    <template
        slot="${(x) => x.slot ? x.slot : x.isNestedMenu() ? "submenu" : void 0}"
        role="menu"
        @keydown="${(x, c) => x.handleMenuKeyDown(c.event)}"
        @focusout="${(x, c) => x.handleFocusOut(c.event)}"
    >
        <slot ${slotted("items")}></slot>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.js
var Menu;
var init_menu = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_menu_item2();
    init_foundation_element();
    Menu = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.expandedItem = null;
        this.focusIndex = -1;
        this.isNestedMenu = () => {
          return this.parentElement !== null && isHTMLElement(this.parentElement) && this.parentElement.getAttribute("role") === "menuitem";
        };
        this.handleFocusOut = (e) => {
          if (!this.contains(e.relatedTarget) && this.menuItems !== void 0) {
            this.collapseExpandedItem();
            const focusIndex = this.menuItems.findIndex(this.isFocusableElement);
            this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            this.menuItems[focusIndex].setAttribute("tabindex", "0");
            this.focusIndex = focusIndex;
          }
        };
        this.handleItemFocus = (e) => {
          const targetItem = e.target;
          if (this.menuItems !== void 0 && targetItem !== this.menuItems[this.focusIndex]) {
            this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            this.focusIndex = this.menuItems.indexOf(targetItem);
            targetItem.setAttribute("tabindex", "0");
          }
        };
        this.handleExpandedChanged = (e) => {
          if (e.defaultPrevented || e.target === null || this.menuItems === void 0 || this.menuItems.indexOf(e.target) < 0) {
            return;
          }
          e.preventDefault();
          const changedItem = e.target;
          if (this.expandedItem !== null && changedItem === this.expandedItem && changedItem.expanded === false) {
            this.expandedItem = null;
            return;
          }
          if (changedItem.expanded) {
            if (this.expandedItem !== null && this.expandedItem !== changedItem) {
              this.expandedItem.expanded = false;
            }
            this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            this.expandedItem = changedItem;
            this.focusIndex = this.menuItems.indexOf(changedItem);
            changedItem.setAttribute("tabindex", "0");
          }
        };
        this.removeItemListeners = () => {
          if (this.menuItems !== void 0) {
            this.menuItems.forEach((item) => {
              item.removeEventListener("expanded-change", this.handleExpandedChanged);
              item.removeEventListener("focus", this.handleItemFocus);
            });
          }
        };
        this.setItems = () => {
          const newItems = this.domChildren();
          this.removeItemListeners();
          this.menuItems = newItems;
          const menuItems = this.menuItems.filter(this.isMenuItemElement);
          if (menuItems.length) {
            this.focusIndex = 0;
          }
          function elementIndent(el) {
            const role = el.getAttribute("role");
            const startSlot = el.querySelector("[slot=start]");
            if (role !== MenuItemRole.menuitem && startSlot === null) {
              return 1;
            } else if (role === MenuItemRole.menuitem && startSlot !== null) {
              return 1;
            } else if (role !== MenuItemRole.menuitem && startSlot !== null) {
              return 2;
            } else {
              return 0;
            }
          }
          const indent = menuItems.reduce((accum, current) => {
            const elementValue = elementIndent(current);
            return accum > elementValue ? accum : elementValue;
          }, 0);
          menuItems.forEach((item, index) => {
            item.setAttribute("tabindex", index === 0 ? "0" : "-1");
            item.addEventListener("expanded-change", this.handleExpandedChanged);
            item.addEventListener("focus", this.handleItemFocus);
            if (item instanceof MenuItem) {
              item.startColumnCount = indent;
            }
          });
        };
        this.changeHandler = (e) => {
          if (this.menuItems === void 0) {
            return;
          }
          const changedMenuItem = e.target;
          const changeItemIndex = this.menuItems.indexOf(changedMenuItem);
          if (changeItemIndex === -1) {
            return;
          }
          if (changedMenuItem.role === "menuitemradio" && changedMenuItem.checked === true) {
            for (let i = changeItemIndex - 1; i >= 0; --i) {
              const item = this.menuItems[i];
              const role = item.getAttribute("role");
              if (role === MenuItemRole.menuitemradio) {
                item.checked = false;
              }
              if (role === "separator") {
                break;
              }
            }
            const maxIndex = this.menuItems.length - 1;
            for (let i = changeItemIndex + 1; i <= maxIndex; ++i) {
              const item = this.menuItems[i];
              const role = item.getAttribute("role");
              if (role === MenuItemRole.menuitemradio) {
                item.checked = false;
              }
              if (role === "separator") {
                break;
              }
            }
          }
        };
        this.isMenuItemElement = (el) => {
          return isHTMLElement(el) && Menu.focusableElementRoles.hasOwnProperty(el.getAttribute("role"));
        };
        this.isFocusableElement = (el) => {
          return this.isMenuItemElement(el);
        };
      }
      itemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected && this.menuItems !== void 0) {
          this.setItems();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        DOM.queueUpdate(() => {
          this.setItems();
        });
        this.addEventListener("change", this.changeHandler);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeItemListeners();
        this.menuItems = void 0;
        this.removeEventListener("change", this.changeHandler);
      }
      /**
       * Focuses the first item in the menu.
       *
       * @public
       */
      focus() {
        this.setFocus(0, 1);
      }
      /**
       * Collapses any expanded menu items.
       *
       * @public
       */
      collapseExpandedItem() {
        if (this.expandedItem !== null) {
          this.expandedItem.expanded = false;
          this.expandedItem = null;
        }
      }
      /**
       * @internal
       */
      handleMenuKeyDown(e) {
        if (e.defaultPrevented || this.menuItems === void 0) {
          return;
        }
        switch (e.key) {
          case keyArrowDown:
            this.setFocus(this.focusIndex + 1, 1);
            return;
          case keyArrowUp:
            this.setFocus(this.focusIndex - 1, -1);
            return;
          case keyEnd:
            this.setFocus(this.menuItems.length - 1, -1);
            return;
          case keyHome:
            this.setFocus(0, 1);
            return;
          default:
            return true;
        }
      }
      /**
       * get an array of valid DOM children
       */
      domChildren() {
        return Array.from(this.children).filter((child) => !child.hasAttribute("hidden"));
      }
      setFocus(focusIndex, adjustment) {
        if (this.menuItems === void 0) {
          return;
        }
        while (focusIndex >= 0 && focusIndex < this.menuItems.length) {
          const child = this.menuItems[focusIndex];
          if (this.isFocusableElement(child)) {
            if (this.focusIndex > -1 && this.menuItems.length >= this.focusIndex - 1) {
              this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
            }
            this.focusIndex = focusIndex;
            child.setAttribute("tabindex", "0");
            child.focus();
            break;
          }
          focusIndex += adjustment;
        }
      }
    };
    Menu.focusableElementRoles = roleForMenuItem;
    __decorate5([
      observable
    ], Menu.prototype, "items", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/menu/index.js
var init_menu2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/menu/index.js"() {
    init_menu_template();
    init_menu();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.template.js
var numberFieldTemplate;
var init_number_field_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.template.js"() {
    init_esm();
    init_start_end();
    numberFieldTemplate = (context, definition) => html2`
    <template class="${(x) => x.readOnly ? "readonly" : ""}">
        <label
            part="label"
            for="control"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <div class="root" part="root">
            ${startSlotTemplate(context, definition)}
            <input
                class="control"
                part="control"
                id="control"
                @input="${(x) => x.handleTextInput()}"
                @change="${(x) => x.handleChange()}"
                @keydown="${(x, c) => x.handleKeyDown(c.event)}"
                @blur="${(x, c) => x.handleBlur()}"
                ?autofocus="${(x) => x.autofocus}"
                ?disabled="${(x) => x.disabled}"
                list="${(x) => x.list}"
                maxlength="${(x) => x.maxlength}"
                minlength="${(x) => x.minlength}"
                placeholder="${(x) => x.placeholder}"
                ?readonly="${(x) => x.readOnly}"
                ?required="${(x) => x.required}"
                size="${(x) => x.size}"
                type="text"
                inputmode="numeric"
                min="${(x) => x.min}"
                max="${(x) => x.max}"
                step="${(x) => x.step}"
                aria-atomic="${(x) => x.ariaAtomic}"
                aria-busy="${(x) => x.ariaBusy}"
                aria-controls="${(x) => x.ariaControls}"
                aria-current="${(x) => x.ariaCurrent}"
                aria-describedby="${(x) => x.ariaDescribedby}"
                aria-details="${(x) => x.ariaDetails}"
                aria-disabled="${(x) => x.ariaDisabled}"
                aria-errormessage="${(x) => x.ariaErrormessage}"
                aria-flowto="${(x) => x.ariaFlowto}"
                aria-haspopup="${(x) => x.ariaHaspopup}"
                aria-hidden="${(x) => x.ariaHidden}"
                aria-invalid="${(x) => x.ariaInvalid}"
                aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
                aria-label="${(x) => x.ariaLabel}"
                aria-labelledby="${(x) => x.ariaLabelledby}"
                aria-live="${(x) => x.ariaLive}"
                aria-owns="${(x) => x.ariaOwns}"
                aria-relevant="${(x) => x.ariaRelevant}"
                aria-roledescription="${(x) => x.ariaRoledescription}"
                ${ref("control")}
            />
            ${when((x) => !x.hideStep && !x.readOnly && !x.disabled, html2`
                    <div class="controls" part="controls">
                        <div class="step-up" part="step-up" @click="${(x) => x.stepUp()}">
                            <slot name="step-up-glyph">
                                ${definition.stepUpGlyph || ""}
                            </slot>
                        </div>
                        <div
                            class="step-down"
                            part="step-down"
                            @click="${(x) => x.stepDown()}"
                        >
                            <slot name="step-down-glyph">
                                ${definition.stepDownGlyph || ""}
                            </slot>
                        </div>
                    </div>
                `)}
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.form-associated.js
var _TextField, FormAssociatedTextField;
var init_text_field_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _TextField = class extends FoundationElement {
    };
    FormAssociatedTextField = class extends FormAssociated(_TextField) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.options.js
var TextFieldType;
var init_text_field_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.options.js"() {
    TextFieldType = {
      /**
       * An email TextField
       */
      email: "email",
      /**
       * A password TextField
       */
      password: "password",
      /**
       * A telephone TextField
       */
      tel: "tel",
      /**
       * A text TextField
       */
      text: "text",
      /**
       * A URL TextField
       */
      url: "url"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.js
var TextField, DelegatesARIATextbox;
var init_text_field = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.js"() {
    init_tslib_es62();
    init_esm();
    init_patterns();
    init_apply_mixins();
    init_text_field_form_associated();
    init_text_field_options();
    TextField = class extends FormAssociatedTextField {
      constructor() {
        super(...arguments);
        this.type = TextFieldType.text;
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
          this.validate();
        }
      }
      autofocusChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.autofocus = this.autofocus;
          this.validate();
        }
      }
      placeholderChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.placeholder = this.placeholder;
        }
      }
      typeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.type = this.type;
          this.validate();
        }
      }
      listChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.setAttribute("list", this.list);
          this.validate();
        }
      }
      maxlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.maxLength = this.maxlength;
          this.validate();
        }
      }
      minlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.minLength = this.minlength;
          this.validate();
        }
      }
      patternChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.pattern = this.pattern;
          this.validate();
        }
      }
      sizeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.size = this.size;
        }
      }
      spellcheckChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.spellcheck = this.spellcheck;
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", this.type);
        this.validate();
        if (this.autofocus) {
          DOM.queueUpdate(() => {
            this.focus();
          });
        }
      }
      /**
       * Selects all the text in the text field
       *
       * @public
       */
      select() {
        this.control.select();
        this.$emit("select");
      }
      /**
       * Handles the internal control's `input` event
       * @internal
       */
      handleTextInput() {
        this.value = this.control.value;
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], TextField.prototype, "readOnly", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], TextField.prototype, "autofocus", void 0);
    __decorate5([
      attr
    ], TextField.prototype, "placeholder", void 0);
    __decorate5([
      attr
    ], TextField.prototype, "type", void 0);
    __decorate5([
      attr
    ], TextField.prototype, "list", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], TextField.prototype, "maxlength", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], TextField.prototype, "minlength", void 0);
    __decorate5([
      attr
    ], TextField.prototype, "pattern", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], TextField.prototype, "size", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], TextField.prototype, "spellcheck", void 0);
    __decorate5([
      observable
    ], TextField.prototype, "defaultSlottedNodes", void 0);
    DelegatesARIATextbox = class {
    };
    applyMixins(DelegatesARIATextbox, ARIAGlobalStatesAndProperties);
    applyMixins(TextField, StartEnd, DelegatesARIATextbox);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.form-associated.js
var _NumberField, FormAssociatedNumberField;
var init_number_field_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _NumberField = class extends FoundationElement {
    };
    FormAssociatedNumberField = class extends FormAssociated(_NumberField) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.js
var NumberField;
var init_number_field = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/number-field/number-field.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_start_end();
    init_apply_mixins();
    init_text_field();
    init_number_field_form_associated();
    NumberField = class extends FormAssociatedNumberField {
      constructor() {
        super(...arguments);
        this.hideStep = false;
        this.step = 1;
        this.isUserInput = false;
      }
      /**
       * Ensures that the max is greater than the min and that the value
       *  is less than the max
       * @param previous - the previous max value
       * @param next - updated max value
       *
       * @internal
       */
      maxChanged(previous, next) {
        var _a2;
        this.max = Math.max(next, (_a2 = this.min) !== null && _a2 !== void 0 ? _a2 : next);
        const min = Math.min(this.min, this.max);
        if (this.min !== void 0 && this.min !== min) {
          this.min = min;
        }
        this.value = this.getValidValue(this.value);
      }
      /**
       * Ensures that the min is less than the max and that the value
       *  is greater than the min
       * @param previous - previous min value
       * @param next - updated min value
       *
       * @internal
       */
      minChanged(previous, next) {
        var _a2;
        this.min = Math.min(next, (_a2 = this.max) !== null && _a2 !== void 0 ? _a2 : next);
        const max = Math.max(this.min, this.max);
        if (this.max !== void 0 && this.max !== max) {
          this.max = max;
        }
        this.value = this.getValidValue(this.value);
      }
      /**
       * The value property, typed as a number.
       *
       * @public
       */
      get valueAsNumber() {
        return parseFloat(super.value);
      }
      set valueAsNumber(next) {
        this.value = next.toString();
      }
      /**
       * Validates that the value is a number between the min and max
       * @param previous - previous stored value
       * @param next - value being updated
       * @param updateControl - should the text field be updated with value, defaults to true
       * @internal
       */
      valueChanged(previous, next) {
        this.value = this.getValidValue(next);
        if (next !== this.value) {
          return;
        }
        if (this.control && !this.isUserInput) {
          this.control.value = this.value;
        }
        super.valueChanged(previous, this.value);
        if (previous !== void 0 && !this.isUserInput) {
          this.$emit("input");
          this.$emit("change");
        }
        this.isUserInput = false;
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      /**
       * Sets the internal value to a valid number between the min and max properties
       * @param value - user input
       *
       * @internal
       */
      getValidValue(value) {
        var _a2, _b2;
        let validValue = parseFloat(parseFloat(value).toPrecision(12));
        if (isNaN(validValue)) {
          validValue = "";
        } else {
          validValue = Math.min(validValue, (_a2 = this.max) !== null && _a2 !== void 0 ? _a2 : validValue);
          validValue = Math.max(validValue, (_b2 = this.min) !== null && _b2 !== void 0 ? _b2 : validValue).toString();
        }
        return validValue;
      }
      /**
       * Increments the value using the step value
       *
       * @public
       */
      stepUp() {
        const value = parseFloat(this.value);
        const stepUpValue = !isNaN(value) ? value + this.step : this.min > 0 ? this.min : this.max < 0 ? this.max : !this.min ? this.step : 0;
        this.value = stepUpValue.toString();
      }
      /**
       * Decrements the value using the step value
       *
       * @public
       */
      stepDown() {
        const value = parseFloat(this.value);
        const stepDownValue = !isNaN(value) ? value - this.step : this.min > 0 ? this.min : this.max < 0 ? this.max : !this.min ? 0 - this.step : 0;
        this.value = stepDownValue.toString();
      }
      /**
       * Sets up the initial state of the number field
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", "number");
        this.validate();
        this.control.value = this.value;
        if (this.autofocus) {
          DOM.queueUpdate(() => {
            this.focus();
          });
        }
      }
      /**
       * Selects all the text in the number field
       *
       * @public
       */
      select() {
        this.control.select();
        this.$emit("select");
      }
      /**
       * Handles the internal control's `input` event
       * @internal
       */
      handleTextInput() {
        this.control.value = this.control.value.replace(/[^0-9\-+e.]/g, "");
        this.isUserInput = true;
        this.value = this.control.value;
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
      /**
       * Handles the internal control's `keydown` event
       * @internal
       */
      handleKeyDown(e) {
        const key = e.key;
        switch (key) {
          case keyArrowUp:
            this.stepUp();
            return false;
          case keyArrowDown:
            this.stepDown();
            return false;
        }
        return true;
      }
      /**
       * Handles populating the input field with a validated value when
       *  leaving the input field.
       * @internal
       */
      handleBlur() {
        this.control.value = this.value;
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], NumberField.prototype, "readOnly", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], NumberField.prototype, "autofocus", void 0);
    __decorate5([
      attr({ attribute: "hide-step", mode: "boolean" })
    ], NumberField.prototype, "hideStep", void 0);
    __decorate5([
      attr
    ], NumberField.prototype, "placeholder", void 0);
    __decorate5([
      attr
    ], NumberField.prototype, "list", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "maxlength", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "minlength", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "size", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "step", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "max", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], NumberField.prototype, "min", void 0);
    __decorate5([
      observable
    ], NumberField.prototype, "defaultSlottedNodes", void 0);
    applyMixins(NumberField, StartEnd, DelegatesARIATextbox);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/number-field/index.js
var init_number_field2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/number-field/index.js"() {
    init_number_field_template();
    init_number_field();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/progress-ring.template.js
var progressSegments, progressRingTemplate;
var init_progress_ring_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/progress-ring.template.js"() {
    init_esm();
    progressSegments = 44;
    progressRingTemplate = (context, definition) => html2`
    <template
        role="progressbar"
        aria-valuenow="${(x) => x.value}"
        aria-valuemin="${(x) => x.min}"
        aria-valuemax="${(x) => x.max}"
        class="${(x) => x.paused ? "paused" : ""}"
    >
        ${when((x) => typeof x.value === "number", html2`
                <svg
                    class="progress"
                    part="progress"
                    viewBox="0 0 16 16"
                    slot="determinate"
                >
                    <circle
                        class="background"
                        part="background"
                        cx="8px"
                        cy="8px"
                        r="7px"
                    ></circle>
                    <circle
                        class="determinate"
                        part="determinate"
                        style="stroke-dasharray: ${(x) => progressSegments * x.percentComplete / 100}px ${progressSegments}px"
                        cx="8px"
                        cy="8px"
                        r="7px"
                    ></circle>
                </svg>
            `)}
        ${when((x) => typeof x.value !== "number", html2`
                <slot name="indeterminate" slot="indeterminate">
                    ${definition.indeterminateIndicator || ""}
                </slot>
            `)}
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/index.js
var init_progress_ring = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/progress-ring/index.js"() {
    init_progress_ring_template();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/progress/base-progress.js
var BaseProgress;
var init_base_progress = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/progress/base-progress.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    BaseProgress = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.percentComplete = 0;
      }
      valueChanged() {
        if (this.$fastController.isConnected) {
          this.updatePercentComplete();
        }
      }
      minChanged() {
        if (this.$fastController.isConnected) {
          this.updatePercentComplete();
        }
      }
      maxChanged() {
        if (this.$fastController.isConnected) {
          this.updatePercentComplete();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.updatePercentComplete();
      }
      updatePercentComplete() {
        const min = typeof this.min === "number" ? this.min : 0;
        const max = typeof this.max === "number" ? this.max : 100;
        const value = typeof this.value === "number" ? this.value : 0;
        const range2 = max - min;
        this.percentComplete = range2 === 0 ? 0 : Math.fround((value - min) / range2 * 100);
      }
    };
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], BaseProgress.prototype, "value", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], BaseProgress.prototype, "min", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], BaseProgress.prototype, "max", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], BaseProgress.prototype, "paused", void 0);
    __decorate5([
      observable
    ], BaseProgress.prototype, "percentComplete", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/progress/progress.template.js
var progressTemplate;
var init_progress_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/progress/progress.template.js"() {
    init_esm();
    progressTemplate = (context, defintion) => html2`
    <template
        role="progressbar"
        aria-valuenow="${(x) => x.value}"
        aria-valuemin="${(x) => x.min}"
        aria-valuemax="${(x) => x.max}"
        class="${(x) => x.paused ? "paused" : ""}"
    >
        ${when((x) => typeof x.value === "number", html2`
                <div class="progress" part="progress" slot="determinate">
                    <div
                        class="determinate"
                        part="determinate"
                        style="width: ${(x) => x.percentComplete}%"
                    ></div>
                </div>
            `)}
        ${when((x) => typeof x.value !== "number", html2`
                <div class="progress" part="progress" slot="indeterminate">
                    <slot class="indeterminate" name="indeterminate">
                        ${defintion.indeterminateIndicator1 || ""}
                        ${defintion.indeterminateIndicator2 || ""}
                    </slot>
                </div>
            `)}
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/progress/index.js
var init_progress = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/progress/index.js"() {
    init_base_progress();
    init_progress_template();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.template.js
var radioGroupTemplate;
var init_radio_group_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.template.js"() {
    init_esm();
    init_dist2();
    radioGroupTemplate = (context, definition) => html2`
    <template
        role="radiogroup"
        aria-disabled="${(x) => x.disabled}"
        aria-readonly="${(x) => x.readOnly}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        @focusout="${(x, c) => x.focusOutHandler(c.event)}"
    >
        <slot name="label"></slot>
        <div
            class="positioning-region ${(x) => x.orientation === Orientation.horizontal ? "horizontal" : "vertical"}"
            part="positioning-region"
        >
            <slot
                ${slotted({
      property: "slottedRadioButtons",
      filter: elements("[role=radio]")
    })}
            ></slot>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.js
var RadioGroup;
var init_radio_group = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/radio-group/radio-group.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_direction();
    init_foundation_element();
    RadioGroup = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.orientation = Orientation.horizontal;
        this.radioChangeHandler = (e) => {
          const changedRadio = e.target;
          if (changedRadio.checked) {
            this.slottedRadioButtons.forEach((radio) => {
              if (radio !== changedRadio) {
                radio.checked = false;
                if (!this.isInsideFoundationToolbar) {
                  radio.setAttribute("tabindex", "-1");
                }
              }
            });
            this.selectedRadio = changedRadio;
            this.value = changedRadio.value;
            changedRadio.setAttribute("tabindex", "0");
            this.focusedRadio = changedRadio;
          }
          e.stopPropagation();
        };
        this.moveToRadioByIndex = (group, index) => {
          const radio = group[index];
          if (!this.isInsideToolbar) {
            radio.setAttribute("tabindex", "0");
            if (radio.readOnly) {
              this.slottedRadioButtons.forEach((nextRadio) => {
                if (nextRadio !== radio) {
                  nextRadio.setAttribute("tabindex", "-1");
                }
              });
            } else {
              radio.checked = true;
              this.selectedRadio = radio;
            }
          }
          this.focusedRadio = radio;
          radio.focus();
        };
        this.moveRightOffGroup = () => {
          var _a2;
          (_a2 = this.nextElementSibling) === null || _a2 === void 0 ? void 0 : _a2.focus();
        };
        this.moveLeftOffGroup = () => {
          var _a2;
          (_a2 = this.previousElementSibling) === null || _a2 === void 0 ? void 0 : _a2.focus();
        };
        this.focusOutHandler = (e) => {
          const group = this.slottedRadioButtons;
          const radio = e.target;
          const index = radio !== null ? group.indexOf(radio) : 0;
          const focusedIndex = this.focusedRadio ? group.indexOf(this.focusedRadio) : -1;
          if (focusedIndex === 0 && index === focusedIndex || focusedIndex === group.length - 1 && focusedIndex === index) {
            if (!this.selectedRadio) {
              this.focusedRadio = group[0];
              this.focusedRadio.setAttribute("tabindex", "0");
              group.forEach((nextRadio) => {
                if (nextRadio !== this.focusedRadio) {
                  nextRadio.setAttribute("tabindex", "-1");
                }
              });
            } else {
              this.focusedRadio = this.selectedRadio;
              if (!this.isInsideFoundationToolbar) {
                this.selectedRadio.setAttribute("tabindex", "0");
                group.forEach((nextRadio) => {
                  if (nextRadio !== this.selectedRadio) {
                    nextRadio.setAttribute("tabindex", "-1");
                  }
                });
              }
            }
          }
          return true;
        };
        this.clickHandler = (e) => {
          const radio = e.target;
          if (radio) {
            const group = this.slottedRadioButtons;
            if (radio.checked || group.indexOf(radio) === 0) {
              radio.setAttribute("tabindex", "0");
              this.selectedRadio = radio;
            } else {
              radio.setAttribute("tabindex", "-1");
              this.selectedRadio = null;
            }
            this.focusedRadio = radio;
          }
          e.preventDefault();
        };
        this.shouldMoveOffGroupToTheRight = (index, group, key) => {
          return index === group.length && this.isInsideToolbar && key === keyArrowRight;
        };
        this.shouldMoveOffGroupToTheLeft = (group, key) => {
          const index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
          return index < 0 && this.isInsideToolbar && key === keyArrowLeft;
        };
        this.checkFocusedRadio = () => {
          if (this.focusedRadio !== null && !this.focusedRadio.readOnly && !this.focusedRadio.checked) {
            this.focusedRadio.checked = true;
            this.focusedRadio.setAttribute("tabindex", "0");
            this.focusedRadio.focus();
            this.selectedRadio = this.focusedRadio;
          }
        };
        this.moveRight = (e) => {
          const group = this.slottedRadioButtons;
          let index = 0;
          index = this.focusedRadio ? group.indexOf(this.focusedRadio) + 1 : 1;
          if (this.shouldMoveOffGroupToTheRight(index, group, e.key)) {
            this.moveRightOffGroup();
            return;
          } else if (index === group.length) {
            index = 0;
          }
          while (index < group.length && group.length > 1) {
            if (!group[index].disabled) {
              this.moveToRadioByIndex(group, index);
              break;
            } else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
              break;
            } else if (index + 1 >= group.length) {
              if (this.isInsideToolbar) {
                break;
              } else {
                index = 0;
              }
            } else {
              index += 1;
            }
          }
        };
        this.moveLeft = (e) => {
          const group = this.slottedRadioButtons;
          let index = 0;
          index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
          index = index < 0 ? group.length - 1 : index;
          if (this.shouldMoveOffGroupToTheLeft(group, e.key)) {
            this.moveLeftOffGroup();
            return;
          }
          while (index >= 0 && group.length > 1) {
            if (!group[index].disabled) {
              this.moveToRadioByIndex(group, index);
              break;
            } else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
              break;
            } else if (index - 1 < 0) {
              index = group.length - 1;
            } else {
              index -= 1;
            }
          }
        };
        this.keydownHandler = (e) => {
          const key = e.key;
          if (key in ArrowKeys && this.isInsideFoundationToolbar) {
            return true;
          }
          switch (key) {
            case keyEnter: {
              this.checkFocusedRadio();
              break;
            }
            case keyArrowRight:
            case keyArrowDown: {
              if (this.direction === Direction.ltr) {
                this.moveRight(e);
              } else {
                this.moveLeft(e);
              }
              break;
            }
            case keyArrowLeft:
            case keyArrowUp: {
              if (this.direction === Direction.ltr) {
                this.moveLeft(e);
              } else {
                this.moveRight(e);
              }
              break;
            }
            default: {
              return true;
            }
          }
        };
      }
      readOnlyChanged() {
        if (this.slottedRadioButtons !== void 0) {
          this.slottedRadioButtons.forEach((radio) => {
            if (this.readOnly) {
              radio.readOnly = true;
            } else {
              radio.readOnly = false;
            }
          });
        }
      }
      disabledChanged() {
        if (this.slottedRadioButtons !== void 0) {
          this.slottedRadioButtons.forEach((radio) => {
            if (this.disabled) {
              radio.disabled = true;
            } else {
              radio.disabled = false;
            }
          });
        }
      }
      nameChanged() {
        if (this.slottedRadioButtons) {
          this.slottedRadioButtons.forEach((radio) => {
            radio.setAttribute("name", this.name);
          });
        }
      }
      valueChanged() {
        if (this.slottedRadioButtons) {
          this.slottedRadioButtons.forEach((radio) => {
            if (radio.value === this.value) {
              radio.checked = true;
              this.selectedRadio = radio;
            }
          });
        }
        this.$emit("change");
      }
      slottedRadioButtonsChanged(oldValue, newValue) {
        if (this.slottedRadioButtons && this.slottedRadioButtons.length > 0) {
          this.setupRadioButtons();
        }
      }
      get parentToolbar() {
        return this.closest('[role="toolbar"]');
      }
      get isInsideToolbar() {
        var _a2;
        return (_a2 = this.parentToolbar) !== null && _a2 !== void 0 ? _a2 : false;
      }
      get isInsideFoundationToolbar() {
        var _a2;
        return !!((_a2 = this.parentToolbar) === null || _a2 === void 0 ? void 0 : _a2["$fastController"]);
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.direction = getDirection(this);
        this.setupRadioButtons();
      }
      disconnectedCallback() {
        this.slottedRadioButtons.forEach((radio) => {
          radio.removeEventListener("change", this.radioChangeHandler);
        });
      }
      setupRadioButtons() {
        const checkedRadios = this.slottedRadioButtons.filter((radio) => {
          return radio.hasAttribute("checked");
        });
        const numberOfCheckedRadios = checkedRadios ? checkedRadios.length : 0;
        if (numberOfCheckedRadios > 1) {
          const lastCheckedRadio = checkedRadios[numberOfCheckedRadios - 1];
          lastCheckedRadio.checked = true;
        }
        let foundMatchingVal = false;
        this.slottedRadioButtons.forEach((radio) => {
          if (this.name !== void 0) {
            radio.setAttribute("name", this.name);
          }
          if (this.disabled) {
            radio.disabled = true;
          }
          if (this.readOnly) {
            radio.readOnly = true;
          }
          if (this.value && this.value === radio.value) {
            this.selectedRadio = radio;
            this.focusedRadio = radio;
            radio.checked = true;
            radio.setAttribute("tabindex", "0");
            foundMatchingVal = true;
          } else {
            if (!this.isInsideFoundationToolbar) {
              radio.setAttribute("tabindex", "-1");
            }
            radio.checked = false;
          }
          radio.addEventListener("change", this.radioChangeHandler);
        });
        if (this.value === void 0 && this.slottedRadioButtons.length > 0) {
          const checkedRadios2 = this.slottedRadioButtons.filter((radio) => {
            return radio.hasAttribute("checked");
          });
          const numberOfCheckedRadios2 = checkedRadios2 !== null ? checkedRadios2.length : 0;
          if (numberOfCheckedRadios2 > 0 && !foundMatchingVal) {
            const lastCheckedRadio = checkedRadios2[numberOfCheckedRadios2 - 1];
            lastCheckedRadio.checked = true;
            this.focusedRadio = lastCheckedRadio;
            lastCheckedRadio.setAttribute("tabindex", "0");
          } else {
            this.slottedRadioButtons[0].setAttribute("tabindex", "0");
            this.focusedRadio = this.slottedRadioButtons[0];
          }
        }
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], RadioGroup.prototype, "readOnly", void 0);
    __decorate5([
      attr({ attribute: "disabled", mode: "boolean" })
    ], RadioGroup.prototype, "disabled", void 0);
    __decorate5([
      attr
    ], RadioGroup.prototype, "name", void 0);
    __decorate5([
      attr
    ], RadioGroup.prototype, "value", void 0);
    __decorate5([
      attr
    ], RadioGroup.prototype, "orientation", void 0);
    __decorate5([
      observable
    ], RadioGroup.prototype, "childItems", void 0);
    __decorate5([
      observable
    ], RadioGroup.prototype, "slottedRadioButtons", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/radio-group/index.js
var init_radio_group2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/radio-group/index.js"() {
    init_radio_group_template();
    init_radio_group();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.template.js
var radioTemplate;
var init_radio_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.template.js"() {
    init_esm();
    radioTemplate = (context, definition) => html2`
    <template
        role="radio"
        class="${(x) => x.checked ? "checked" : ""} ${(x) => x.readOnly ? "readonly" : ""}"
        aria-checked="${(x) => x.checked}"
        aria-required="${(x) => x.required}"
        aria-disabled="${(x) => x.disabled}"
        aria-readonly="${(x) => x.readOnly}"
        @keypress="${(x, c) => x.keypressHandler(c.event)}"
        @click="${(x, c) => x.clickHandler(c.event)}"
    >
        <div part="control" class="control">
            <slot name="checked-indicator">
                ${definition.checkedIndicator || ""}
            </slot>
        </div>
        <label
            part="label"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.form-associated.js
var _Radio, FormAssociatedRadio;
var init_radio_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Radio = class extends FoundationElement {
    };
    FormAssociatedRadio = class extends CheckableFormAssociated(_Radio) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.js
var Radio;
var init_radio = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/radio/radio.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_radio_form_associated();
    Radio = class extends FormAssociatedRadio {
      constructor() {
        super();
        this.initialValue = "on";
        this.keypressHandler = (e) => {
          switch (e.key) {
            case keySpace:
              if (!this.checked && !this.readOnly) {
                this.checked = true;
              }
              return;
          }
          return true;
        };
        this.proxy.setAttribute("type", "radio");
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
      /**
       * @internal
       */
      defaultCheckedChanged() {
        var _a2;
        if (this.$fastController.isConnected && !this.dirtyChecked) {
          if (!this.isInsideRadioGroup()) {
            this.checked = (_a2 = this.defaultChecked) !== null && _a2 !== void 0 ? _a2 : false;
            this.dirtyChecked = false;
          }
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        var _a2, _b2;
        super.connectedCallback();
        this.validate();
        if (((_a2 = this.parentElement) === null || _a2 === void 0 ? void 0 : _a2.getAttribute("role")) !== "radiogroup" && this.getAttribute("tabindex") === null) {
          if (!this.disabled) {
            this.setAttribute("tabindex", "0");
          }
        }
        if (this.checkedAttribute) {
          if (!this.dirtyChecked) {
            if (!this.isInsideRadioGroup()) {
              this.checked = (_b2 = this.defaultChecked) !== null && _b2 !== void 0 ? _b2 : false;
              this.dirtyChecked = false;
            }
          }
        }
      }
      isInsideRadioGroup() {
        const parent = this.closest("[role=radiogroup]");
        return parent !== null;
      }
      /**
       * @internal
       */
      clickHandler(e) {
        if (!this.disabled && !this.readOnly && !this.checked) {
          this.checked = true;
        }
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Radio.prototype, "readOnly", void 0);
    __decorate5([
      observable
    ], Radio.prototype, "name", void 0);
    __decorate5([
      observable
    ], Radio.prototype, "defaultSlottedNodes", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/radio/index.js
var init_radio2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/radio/index.js"() {
    init_radio_template();
    init_radio();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.js
var HorizontalScroll;
var init_horizontal_scroll = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    HorizontalScroll = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.framesPerSecond = 60;
        this.updatingItems = false;
        this.speed = 600;
        this.easing = "ease-in-out";
        this.flippersHiddenFromAT = false;
        this.scrolling = false;
        this.resizeDetector = null;
      }
      /**
       * The calculated duration for a frame.
       *
       * @internal
       */
      get frameTime() {
        return 1e3 / this.framesPerSecond;
      }
      /**
       * Firing scrollstart and scrollend events
       * @internal
       */
      scrollingChanged(prev, next) {
        if (this.scrollContainer) {
          const event = this.scrolling == true ? "scrollstart" : "scrollend";
          this.$emit(event, this.scrollContainer.scrollLeft);
        }
      }
      /**
       * In RTL mode
       * @internal
       */
      get isRtl() {
        return this.scrollItems.length > 1 && this.scrollItems[0].offsetLeft > this.scrollItems[1].offsetLeft;
      }
      connectedCallback() {
        super.connectedCallback();
        this.initializeResizeDetector();
      }
      disconnectedCallback() {
        this.disconnectResizeDetector();
        super.disconnectedCallback();
      }
      /**
       * Updates scroll stops and flippers when scroll items change
       * @param previous - current scroll items
       * @param next - new updated scroll items
       * @public
       */
      scrollItemsChanged(previous, next) {
        if (next && !this.updatingItems) {
          DOM.queueUpdate(() => this.setStops());
        }
      }
      /**
       * destroys the instance's resize observer
       * @internal
       */
      disconnectResizeDetector() {
        if (this.resizeDetector) {
          this.resizeDetector.disconnect();
          this.resizeDetector = null;
        }
      }
      /**
       * initializes the instance's resize observer
       * @internal
       */
      initializeResizeDetector() {
        this.disconnectResizeDetector();
        this.resizeDetector = new window.ResizeObserver(this.resized.bind(this));
        this.resizeDetector.observe(this);
      }
      /**
       * Looks for slots and uses child nodes instead
       * @internal
       */
      updateScrollStops() {
        this.updatingItems = true;
        const updatedItems = this.scrollItems.reduce((scrollItems, scrollItem) => {
          if (scrollItem instanceof HTMLSlotElement) {
            return scrollItems.concat(scrollItem.assignedElements());
          }
          scrollItems.push(scrollItem);
          return scrollItems;
        }, []);
        this.scrollItems = updatedItems;
        this.updatingItems = false;
      }
      /**
       * Finds all of the scroll stops between elements
       * @internal
       */
      setStops() {
        this.updateScrollStops();
        const { scrollContainer: container } = this;
        const { scrollLeft } = container;
        const { width: containerWidth, left: containerLeft } = container.getBoundingClientRect();
        this.width = containerWidth;
        let lastStop = 0;
        let stops = this.scrollItems.map((item, index) => {
          const { left, width } = item.getBoundingClientRect();
          const leftPosition = Math.round(left + scrollLeft - containerLeft);
          const right = Math.round(leftPosition + width);
          if (this.isRtl) {
            return -right;
          }
          lastStop = right;
          return index === 0 ? 0 : leftPosition;
        }).concat(lastStop);
        stops = this.fixScrollMisalign(stops);
        stops.sort((a, b) => Math.abs(a) - Math.abs(b));
        this.scrollStops = stops;
        this.setFlippers();
      }
      /**
       *
       */
      fixScrollMisalign(stops) {
        if (this.isRtl && stops.some((stop) => stop > 0)) {
          stops.sort((a, b) => b - a);
          const offset = stops[0];
          stops = stops.map((stop) => stop - offset);
        }
        return stops;
      }
      /**
       * Sets the controls view if enabled
       * @internal
       */
      setFlippers() {
        var _a2, _b2;
        const position = this.scrollContainer.scrollLeft;
        (_a2 = this.previousFlipperContainer) === null || _a2 === void 0 ? void 0 : _a2.classList.toggle("disabled", position === 0);
        if (this.scrollStops) {
          const lastStop = Math.abs(this.scrollStops[this.scrollStops.length - 1]);
          (_b2 = this.nextFlipperContainer) === null || _b2 === void 0 ? void 0 : _b2.classList.toggle("disabled", Math.abs(position) + this.width >= lastStop);
        }
      }
      /**
       * Function that can scroll an item into view.
       * @param item - An item index, a scroll item or a child of one of the scroll items
       * @param padding - Padding of the viewport where the active item shouldn't be
       * @param rightPadding - Optional right padding. Uses the padding if not defined
       *
       * @public
       */
      scrollInView(item, padding = 0, rightPadding) {
        var _a2;
        if (typeof item !== "number" && item) {
          item = this.scrollItems.findIndex((scrollItem) => scrollItem === item || scrollItem.contains(item));
        }
        if (item !== void 0) {
          rightPadding = rightPadding !== null && rightPadding !== void 0 ? rightPadding : padding;
          const { scrollContainer: container, scrollStops, scrollItems: items } = this;
          const { scrollLeft } = this.scrollContainer;
          const { width: containerWidth } = container.getBoundingClientRect();
          const itemStart = scrollStops[item];
          const { width } = items[item].getBoundingClientRect();
          const itemEnd = itemStart + width;
          const isBefore = scrollLeft + padding > itemStart;
          if (isBefore || scrollLeft + containerWidth - rightPadding < itemEnd) {
            const stops = [...scrollStops].sort((a, b) => isBefore ? b - a : a - b);
            const scrollTo = (_a2 = stops.find((position) => isBefore ? position + padding < itemStart : position + containerWidth - (rightPadding !== null && rightPadding !== void 0 ? rightPadding : 0) > itemEnd)) !== null && _a2 !== void 0 ? _a2 : 0;
            this.scrollToPosition(scrollTo);
          }
        }
      }
      /**
       * Lets the user arrow left and right through the horizontal scroll
       * @param e - Keyboard event
       * @public
       */
      keyupHandler(e) {
        const key = e.key;
        switch (key) {
          case "ArrowLeft":
            this.scrollToPrevious();
            break;
          case "ArrowRight":
            this.scrollToNext();
            break;
        }
      }
      /**
       * Scrolls items to the left
       * @public
       */
      scrollToPrevious() {
        const scrollPosition = this.scrollContainer.scrollLeft;
        const current = this.scrollStops.findIndex((stop, index) => stop >= scrollPosition && (this.isRtl || index === this.scrollStops.length - 1 || this.scrollStops[index + 1] > scrollPosition));
        const right = Math.abs(this.scrollStops[current + 1]);
        let nextIndex = this.scrollStops.findIndex((stop) => Math.abs(stop) + this.width > right);
        if (nextIndex >= current || nextIndex === -1) {
          nextIndex = current > 0 ? current - 1 : 0;
        }
        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);
      }
      /**
       * Scrolls items to the right
       * @public
       */
      scrollToNext() {
        const scrollPosition = this.scrollContainer.scrollLeft;
        const current = this.scrollStops.findIndex((stop) => Math.abs(stop) >= Math.abs(scrollPosition));
        const outOfView = this.scrollStops.findIndex((stop) => Math.abs(scrollPosition) + this.width <= Math.abs(stop));
        let nextIndex = current;
        if (outOfView > current + 2) {
          nextIndex = outOfView - 2;
        } else if (current < this.scrollStops.length - 2) {
          nextIndex = current + 1;
        }
        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);
      }
      /**
       * Handles scrolling with easing
       * @param position - starting position
       * @param newPosition - position to scroll to
       * @public
       */
      scrollToPosition(newPosition, position = this.scrollContainer.scrollLeft) {
        var _a2;
        if (this.scrolling) {
          return;
        }
        this.scrolling = true;
        const seconds = (_a2 = this.duration) !== null && _a2 !== void 0 ? _a2 : `${Math.abs(newPosition - position) / this.speed}s`;
        this.content.style.setProperty("transition-duration", seconds);
        const computedDuration = parseFloat(getComputedStyle(this.content).getPropertyValue("transition-duration"));
        const transitionendHandler = (e) => {
          if (e && e.target !== e.currentTarget) {
            return;
          }
          this.content.style.setProperty("transition-duration", "0s");
          this.content.style.removeProperty("transform");
          this.scrollContainer.style.setProperty("scroll-behavior", "auto");
          this.scrollContainer.scrollLeft = newPosition;
          this.setFlippers();
          this.content.removeEventListener("transitionend", transitionendHandler);
          this.scrolling = false;
        };
        if (computedDuration === 0) {
          transitionendHandler();
          return;
        }
        this.content.addEventListener("transitionend", transitionendHandler);
        const maxScrollValue = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;
        let transitionStop = this.scrollContainer.scrollLeft - Math.min(newPosition, maxScrollValue);
        if (this.isRtl) {
          transitionStop = this.scrollContainer.scrollLeft + Math.min(Math.abs(newPosition), maxScrollValue);
        }
        this.content.style.setProperty("transition-property", "transform");
        this.content.style.setProperty("transition-timing-function", this.easing);
        this.content.style.setProperty("transform", `translateX(${transitionStop}px)`);
      }
      /**
       * Monitors resize event on the horizontal-scroll element
       * @public
       */
      resized() {
        if (this.resizeTimeout) {
          this.resizeTimeout = clearTimeout(this.resizeTimeout);
        }
        this.resizeTimeout = setTimeout(() => {
          this.width = this.scrollContainer.offsetWidth;
          this.setFlippers();
        }, this.frameTime);
      }
      /**
       * Monitors scrolled event on the content container
       * @public
       */
      scrolled() {
        if (this.scrollTimeout) {
          this.scrollTimeout = clearTimeout(this.scrollTimeout);
        }
        this.scrollTimeout = setTimeout(() => {
          this.setFlippers();
        }, this.frameTime);
      }
    };
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], HorizontalScroll.prototype, "speed", void 0);
    __decorate5([
      attr
    ], HorizontalScroll.prototype, "duration", void 0);
    __decorate5([
      attr
    ], HorizontalScroll.prototype, "easing", void 0);
    __decorate5([
      attr({ attribute: "flippers-hidden-from-at", converter: booleanConverter })
    ], HorizontalScroll.prototype, "flippersHiddenFromAT", void 0);
    __decorate5([
      observable
    ], HorizontalScroll.prototype, "scrolling", void 0);
    __decorate5([
      observable
    ], HorizontalScroll.prototype, "scrollItems", void 0);
    __decorate5([
      attr({ attribute: "view" })
    ], HorizontalScroll.prototype, "view", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.template.js
var horizontalScrollTemplate;
var init_horizontal_scroll_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.template.js"() {
    init_esm();
    init_start_end();
    horizontalScrollTemplate = (context, definition) => {
      var _a2, _b2;
      return html2`
    <template
        class="horizontal-scroll"
        @keyup="${(x, c) => x.keyupHandler(c.event)}"
    >
        ${startSlotTemplate(context, definition)}
        <div class="scroll-area" part="scroll-area">
            <div
                class="scroll-view"
                part="scroll-view"
                @scroll="${(x) => x.scrolled()}"
                ${ref("scrollContainer")}
            >
                <div class="content-container" part="content-container" ${ref("content")}>
                    <slot
                        ${slotted({
        property: "scrollItems",
        filter: elements()
      })}
                    ></slot>
                </div>
            </div>
            ${when((x) => x.view !== "mobile", html2`
                    <div
                        class="scroll scroll-prev"
                        part="scroll-prev"
                        ${ref("previousFlipperContainer")}
                    >
                        <div class="scroll-action" part="scroll-action-previous">
                            <slot name="previous-flipper">
                                ${definition.previousFlipper instanceof Function ? definition.previousFlipper(context, definition) : (_a2 = definition.previousFlipper) !== null && _a2 !== void 0 ? _a2 : ""}
                            </slot>
                        </div>
                    </div>
                    <div
                        class="scroll scroll-next"
                        part="scroll-next"
                        ${ref("nextFlipperContainer")}
                    >
                        <div class="scroll-action" part="scroll-action-next">
                            <slot name="next-flipper">
                                ${definition.nextFlipper instanceof Function ? definition.nextFlipper(context, definition) : (_b2 = definition.nextFlipper) !== null && _b2 !== void 0 ? _b2 : ""}
                            </slot>
                        </div>
                    </div>
                `)}
        </div>
        ${endSlotTemplate(context, definition)}
    </template>
`;
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/index.js
var init_horizontal_scroll2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/index.js"() {
    init_horizontal_scroll();
    init_horizontal_scroll_template();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/whitespace-filter.js
function whitespaceFilter(value, index, array) {
  return value.nodeType !== Node.TEXT_NODE ? true : typeof value.nodeValue === "string" && !!value.nodeValue.trim().length;
}
var init_whitespace_filter = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/whitespace-filter.js"() {
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/search/search.template.js
var init_search_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/search/search.template.js"() {
    init_esm();
    init_start_end();
    init_whitespace_filter();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/search/search.form-associated.js
var _Search, FormAssociatedSearch;
var init_search_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/search/search.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Search = class extends FoundationElement {
    };
    FormAssociatedSearch = class extends FormAssociated(_Search) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/search/search.js
var Search, DelegatesARIASearch;
var init_search = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/search/search.js"() {
    init_tslib_es62();
    init_esm();
    init_patterns();
    init_apply_mixins();
    init_search_form_associated();
    Search = class extends FormAssociatedSearch {
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
          this.validate();
        }
      }
      autofocusChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.autofocus = this.autofocus;
          this.validate();
        }
      }
      placeholderChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.placeholder = this.placeholder;
        }
      }
      listChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.setAttribute("list", this.list);
          this.validate();
        }
      }
      maxlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.maxLength = this.maxlength;
          this.validate();
        }
      }
      minlengthChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.minLength = this.minlength;
          this.validate();
        }
      }
      patternChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.pattern = this.pattern;
          this.validate();
        }
      }
      sizeChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.size = this.size;
        }
      }
      spellcheckChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.spellcheck = this.spellcheck;
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.validate();
        if (this.autofocus) {
          DOM.queueUpdate(() => {
            this.focus();
          });
        }
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
      /**
       * Handles the internal control's `input` event
       * @internal
       */
      handleTextInput() {
        this.value = this.control.value;
      }
      /**
       * Handles the control's clear value event
       * @public
       */
      handleClearInput() {
        this.value = "";
        this.control.focus();
        this.handleChange();
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Search.prototype, "readOnly", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], Search.prototype, "autofocus", void 0);
    __decorate5([
      attr
    ], Search.prototype, "placeholder", void 0);
    __decorate5([
      attr
    ], Search.prototype, "list", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Search.prototype, "maxlength", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Search.prototype, "minlength", void 0);
    __decorate5([
      attr
    ], Search.prototype, "pattern", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Search.prototype, "size", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], Search.prototype, "spellcheck", void 0);
    __decorate5([
      observable
    ], Search.prototype, "defaultSlottedNodes", void 0);
    DelegatesARIASearch = class {
    };
    applyMixins(DelegatesARIASearch, ARIAGlobalStatesAndProperties);
    applyMixins(Search, StartEnd, DelegatesARIASearch);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/search/index.js
var init_search2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/search/index.js"() {
    init_search_template();
    init_search();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/select/select.form-associated.js
var _Select, FormAssociatedSelect;
var init_select_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/select/select.form-associated.js"() {
    init_listbox_element();
    init_form_associated();
    _Select = class extends ListboxElement {
    };
    FormAssociatedSelect = class extends FormAssociated(_Select) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("select");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/select/select.js
var Select, DelegatesARIASelect;
var init_select = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/select/select.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_listbox();
    init_start_end();
    init_apply_mixins();
    init_select_form_associated();
    init_select_options();
    Select = class extends FormAssociatedSelect {
      constructor() {
        super(...arguments);
        this.open = false;
        this.forcedPosition = false;
        this.listboxId = uniqueId("listbox-");
        this.maxHeight = 0;
      }
      /**
       * Sets focus and synchronizes ARIA attributes when the open property changes.
       *
       * @param prev - the previous open value
       * @param next - the current open value
       *
       * @internal
       */
      openChanged(prev, next) {
        if (!this.collapsible) {
          return;
        }
        if (this.open) {
          this.ariaControls = this.listboxId;
          this.ariaExpanded = "true";
          this.setPositioning();
          this.focusAndScrollOptionIntoView();
          this.indexWhenOpened = this.selectedIndex;
          DOM.queueUpdate(() => this.focus());
          return;
        }
        this.ariaControls = "";
        this.ariaExpanded = "false";
      }
      /**
       * The component is collapsible when in single-selection mode with no size attribute.
       *
       * @internal
       */
      get collapsible() {
        return !(this.multiple || typeof this.size === "number");
      }
      /**
       * The value property.
       *
       * @public
       */
      get value() {
        Observable.track(this, "value");
        return this._value;
      }
      set value(next) {
        var _a2, _b2, _c, _d, _e, _f, _g;
        const prev = `${this._value}`;
        if ((_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.length) {
          const selectedIndex = this._options.findIndex((el) => el.value === next);
          const prevSelectedValue = (_c = (_b2 = this._options[this.selectedIndex]) === null || _b2 === void 0 ? void 0 : _b2.value) !== null && _c !== void 0 ? _c : null;
          const nextSelectedValue = (_e = (_d = this._options[selectedIndex]) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : null;
          if (selectedIndex === -1 || prevSelectedValue !== nextSelectedValue) {
            next = "";
            this.selectedIndex = selectedIndex;
          }
          next = (_g = (_f = this.firstSelectedOption) === null || _f === void 0 ? void 0 : _f.value) !== null && _g !== void 0 ? _g : next;
        }
        if (prev !== next) {
          this._value = next;
          super.valueChanged(prev, next);
          Observable.notify(this, "value");
          this.updateDisplayValue();
        }
      }
      /**
       * Sets the value and display value to match the first selected option.
       *
       * @param shouldEmit - if true, the input and change events will be emitted
       *
       * @internal
       */
      updateValue(shouldEmit) {
        var _a2, _b2;
        if (this.$fastController.isConnected) {
          this.value = (_b2 = (_a2 = this.firstSelectedOption) === null || _a2 === void 0 ? void 0 : _a2.value) !== null && _b2 !== void 0 ? _b2 : "";
        }
        if (shouldEmit) {
          this.$emit("input");
          this.$emit("change", this, {
            bubbles: true,
            composed: void 0
          });
        }
      }
      /**
       * Updates the proxy value when the selected index changes.
       *
       * @param prev - the previous selected index
       * @param next - the next selected index
       *
       * @internal
       */
      selectedIndexChanged(prev, next) {
        super.selectedIndexChanged(prev, next);
        this.updateValue();
      }
      positionChanged(prev, next) {
        this.positionAttribute = next;
        this.setPositioning();
      }
      /**
       * Calculate and apply listbox positioning based on available viewport space.
       *
       * @public
       */
      setPositioning() {
        const currentBox = this.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const availableBottom = viewportHeight - currentBox.bottom;
        this.position = this.forcedPosition ? this.positionAttribute : currentBox.top > availableBottom ? SelectPosition.above : SelectPosition.below;
        this.positionAttribute = this.forcedPosition ? this.positionAttribute : this.position;
        this.maxHeight = this.position === SelectPosition.above ? ~~currentBox.top : ~~availableBottom;
      }
      /**
       * The value displayed on the button.
       *
       * @public
       */
      get displayValue() {
        var _a2, _b2;
        Observable.track(this, "displayValue");
        return (_b2 = (_a2 = this.firstSelectedOption) === null || _a2 === void 0 ? void 0 : _a2.text) !== null && _b2 !== void 0 ? _b2 : "";
      }
      /**
       * Synchronize the `aria-disabled` property when the `disabled` property changes.
       *
       * @param prev - The previous disabled value
       * @param next - The next disabled value
       *
       * @internal
       */
      disabledChanged(prev, next) {
        if (super.disabledChanged) {
          super.disabledChanged(prev, next);
        }
        this.ariaDisabled = this.disabled ? "true" : "false";
      }
      /**
       * Reset the element to its first selectable option when its parent form is reset.
       *
       * @internal
       */
      formResetCallback() {
        this.setProxyOptions();
        super.setDefaultSelectedOption();
        if (this.selectedIndex === -1) {
          this.selectedIndex = 0;
        }
      }
      /**
       * Handle opening and closing the listbox when the select is clicked.
       *
       * @param e - the mouse event
       * @internal
       */
      clickHandler(e) {
        if (this.disabled) {
          return;
        }
        if (this.open) {
          const captured = e.target.closest(`option,[role=option]`);
          if (captured && captured.disabled) {
            return;
          }
        }
        super.clickHandler(e);
        this.open = this.collapsible && !this.open;
        if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
          this.updateValue(true);
        }
        return true;
      }
      /**
       * Handles focus state when the element or its children lose focus.
       *
       * @param e - The focus event
       * @internal
       */
      focusoutHandler(e) {
        var _a2;
        super.focusoutHandler(e);
        if (!this.open) {
          return true;
        }
        const focusTarget = e.relatedTarget;
        if (this.isSameNode(focusTarget)) {
          this.focus();
          return;
        }
        if (!((_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.includes(focusTarget))) {
          this.open = false;
          if (this.indexWhenOpened !== this.selectedIndex) {
            this.updateValue(true);
          }
        }
      }
      /**
       * Updates the value when an option's value changes.
       *
       * @param source - the source object
       * @param propertyName - the property to evaluate
       *
       * @internal
       * @override
       */
      handleChange(source, propertyName) {
        super.handleChange(source, propertyName);
        if (propertyName === "value") {
          this.updateValue();
        }
      }
      /**
       * Synchronize the form-associated proxy and updates the value property of the element.
       *
       * @param prev - the previous collection of slotted option elements
       * @param next - the next collection of slotted option elements
       *
       * @internal
       */
      slottedOptionsChanged(prev, next) {
        this.options.forEach((o) => {
          const notifier = Observable.getNotifier(o);
          notifier.unsubscribe(this, "value");
        });
        super.slottedOptionsChanged(prev, next);
        this.options.forEach((o) => {
          const notifier = Observable.getNotifier(o);
          notifier.subscribe(this, "value");
        });
        this.setProxyOptions();
        this.updateValue();
      }
      /**
       * Prevents focus when size is set and a scrollbar is clicked.
       *
       * @param e - the mouse event object
       *
       * @override
       * @internal
       */
      mousedownHandler(e) {
        var _a2;
        if (e.offsetX >= 0 && e.offsetX <= ((_a2 = this.listbox) === null || _a2 === void 0 ? void 0 : _a2.scrollWidth)) {
          return super.mousedownHandler(e);
        }
        return this.collapsible;
      }
      /**
       * Sets the multiple property on the proxy element.
       *
       * @param prev - the previous multiple value
       * @param next - the current multiple value
       */
      multipleChanged(prev, next) {
        super.multipleChanged(prev, next);
        if (this.proxy) {
          this.proxy.multiple = next;
        }
      }
      /**
       * Updates the selectedness of each option when the list of selected options changes.
       *
       * @param prev - the previous list of selected options
       * @param next - the current list of selected options
       *
       * @override
       * @internal
       */
      selectedOptionsChanged(prev, next) {
        var _a2;
        super.selectedOptionsChanged(prev, next);
        (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.forEach((o, i) => {
          var _a3;
          const proxyOption = (_a3 = this.proxy) === null || _a3 === void 0 ? void 0 : _a3.options.item(i);
          if (proxyOption) {
            proxyOption.selected = o.selected;
          }
        });
      }
      /**
       * Sets the selected index to match the first option with the selected attribute, or
       * the first selectable option.
       *
       * @override
       * @internal
       */
      setDefaultSelectedOption() {
        var _a2;
        const options = (_a2 = this.options) !== null && _a2 !== void 0 ? _a2 : Array.from(this.children).filter(Listbox.slottedOptionFilter);
        const selectedIndex = options === null || options === void 0 ? void 0 : options.findIndex((el) => el.hasAttribute("selected") || el.selected || el.value === this.value);
        if (selectedIndex !== -1) {
          this.selectedIndex = selectedIndex;
          return;
        }
        this.selectedIndex = 0;
      }
      /**
       * Resets and fills the proxy to match the component's options.
       *
       * @internal
       */
      setProxyOptions() {
        if (this.proxy instanceof HTMLSelectElement && this.options) {
          this.proxy.options.length = 0;
          this.options.forEach((option) => {
            const proxyOption = option.proxy || (option instanceof HTMLOptionElement ? option.cloneNode() : null);
            if (proxyOption) {
              this.proxy.options.add(proxyOption);
            }
          });
        }
      }
      /**
       * Handle keyboard interaction for the select.
       *
       * @param e - the keyboard event
       * @internal
       */
      keydownHandler(e) {
        super.keydownHandler(e);
        const key = e.key || e.key.charCodeAt(0);
        switch (key) {
          case keySpace: {
            e.preventDefault();
            if (this.collapsible && this.typeAheadExpired) {
              this.open = !this.open;
            }
            break;
          }
          case keyHome:
          case keyEnd: {
            e.preventDefault();
            break;
          }
          case keyEnter: {
            e.preventDefault();
            this.open = !this.open;
            break;
          }
          case keyEscape: {
            if (this.collapsible && this.open) {
              e.preventDefault();
              this.open = false;
            }
            break;
          }
          case keyTab: {
            if (this.collapsible && this.open) {
              e.preventDefault();
              this.open = false;
            }
            return true;
          }
        }
        if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
          this.updateValue(true);
          this.indexWhenOpened = this.selectedIndex;
        }
        return !(key === keyArrowDown || key === keyArrowUp);
      }
      connectedCallback() {
        super.connectedCallback();
        this.forcedPosition = !!this.positionAttribute;
        this.addEventListener("contentchange", this.updateDisplayValue);
      }
      disconnectedCallback() {
        this.removeEventListener("contentchange", this.updateDisplayValue);
        super.disconnectedCallback();
      }
      /**
       * Updates the proxy's size property when the size attribute changes.
       *
       * @param prev - the previous size
       * @param next - the current size
       *
       * @override
       * @internal
       */
      sizeChanged(prev, next) {
        super.sizeChanged(prev, next);
        if (this.proxy) {
          this.proxy.size = next;
        }
      }
      /**
       *
       * @internal
       */
      updateDisplayValue() {
        if (this.collapsible) {
          Observable.notify(this, "displayValue");
        }
      }
    };
    __decorate5([
      attr({ attribute: "open", mode: "boolean" })
    ], Select.prototype, "open", void 0);
    __decorate5([
      volatile
    ], Select.prototype, "collapsible", null);
    __decorate5([
      observable
    ], Select.prototype, "control", void 0);
    __decorate5([
      attr({ attribute: "position" })
    ], Select.prototype, "positionAttribute", void 0);
    __decorate5([
      observable
    ], Select.prototype, "position", void 0);
    __decorate5([
      observable
    ], Select.prototype, "maxHeight", void 0);
    DelegatesARIASelect = class {
    };
    __decorate5([
      observable
    ], DelegatesARIASelect.prototype, "ariaControls", void 0);
    applyMixins(DelegatesARIASelect, DelegatesARIAListbox);
    applyMixins(Select, StartEnd, DelegatesARIASelect);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/select/select.template.js
var selectTemplate;
var init_select_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/select/select.template.js"() {
    init_esm();
    init_listbox();
    init_start_end();
    selectTemplate = (context, definition) => html2`
    <template
        class="${(x) => [
      x.collapsible && "collapsible",
      x.collapsible && x.open && "open",
      x.disabled && "disabled",
      x.collapsible && x.position
    ].filter(Boolean).join(" ")}"
        aria-activedescendant="${(x) => x.ariaActiveDescendant}"
        aria-controls="${(x) => x.ariaControls}"
        aria-disabled="${(x) => x.ariaDisabled}"
        aria-expanded="${(x) => x.ariaExpanded}"
        aria-haspopup="${(x) => x.collapsible ? "listbox" : null}"
        aria-multiselectable="${(x) => x.ariaMultiSelectable}"
        ?open="${(x) => x.open}"
        role="combobox"
        tabindex="${(x) => !x.disabled ? "0" : null}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @focusin="${(x, c) => x.focusinHandler(c.event)}"
        @focusout="${(x, c) => x.focusoutHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        @mousedown="${(x, c) => x.mousedownHandler(c.event)}"
    >
        ${when((x) => x.collapsible, html2`
                <div
                    class="control"
                    part="control"
                    ?disabled="${(x) => x.disabled}"
                    ${ref("control")}
                >
                    ${startSlotTemplate(context, definition)}
                    <slot name="button-container">
                        <div class="selected-value" part="selected-value">
                            <slot name="selected-value">${(x) => x.displayValue}</slot>
                        </div>
                        <div aria-hidden="true" class="indicator" part="indicator">
                            <slot name="indicator">
                                ${definition.indicator || ""}
                            </slot>
                        </div>
                    </slot>
                    ${endSlotTemplate(context, definition)}
                </div>
            `)}
        <div
            class="listbox"
            id="${(x) => x.listboxId}"
            part="listbox"
            role="listbox"
            ?disabled="${(x) => x.disabled}"
            ?hidden="${(x) => x.collapsible ? !x.open : false}"
            ${ref("listbox")}
        >
            <slot
                ${slotted({
      filter: Listbox.slottedOptionFilter,
      flatten: true,
      property: "slottedOptions"
    })}
            ></slot>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/select/index.js
var init_select2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/select/index.js"() {
    init_select();
    init_select_options();
    init_select_template();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.template.js
var skeletonTemplate;
var init_skeleton_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.template.js"() {
    init_esm();
    skeletonTemplate = (context, definition) => html2`
    <template
        class="${(x) => x.shape === "circle" ? "circle" : "rect"}"
        pattern="${(x) => x.pattern}"
        ?shimmer="${(x) => x.shimmer}"
    >
        ${when((x) => x.shimmer === true, html2`
                <span class="shimmer"></span>
            `)}
        <object type="image/svg+xml" data="${(x) => x.pattern}" role="presentation">
            <img class="pattern" src="${(x) => x.pattern}" />
        </object>
        <slot></slot>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.js
var Skeleton;
var init_skeleton = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/skeleton/skeleton.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    Skeleton = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.shape = "rect";
      }
    };
    __decorate5([
      attr
    ], Skeleton.prototype, "fill", void 0);
    __decorate5([
      attr
    ], Skeleton.prototype, "shape", void 0);
    __decorate5([
      attr
    ], Skeleton.prototype, "pattern", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], Skeleton.prototype, "shimmer", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/skeleton/index.js
var init_skeleton2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/skeleton/index.js"() {
    init_skeleton_template();
    init_skeleton();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.template.js
var sliderLabelTemplate;
var init_slider_label_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.template.js"() {
    init_esm();
    init_dist2();
    sliderLabelTemplate = (context, definition) => html2`
    <template
        aria-disabled="${(x) => x.disabled}"
        class="${(x) => x.sliderOrientation || Orientation.horizontal}
            ${(x) => x.disabled ? "disabled" : ""}"
    >
        <div ${ref("root")} part="root" class="root" style="${(x) => x.positionStyle}">
            <div class="container">
                ${when((x) => !x.hideMark, html2`
                        <div class="mark"></div>
                    `)}
                <div class="label">
                    <slot></slot>
                </div>
            </div>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider/slider-utilities.js
function convertPixelToPercent(pixelPos, minPosition, maxPosition, direction2) {
  let pct = limit(0, 1, (pixelPos - minPosition) / (maxPosition - minPosition));
  if (direction2 === Direction.rtl) {
    pct = 1 - pct;
  }
  return pct;
}
var init_slider_utilities = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider/slider-utilities.js"() {
    init_dist2();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.js
var defaultConfig, SliderLabel;
var init_slider_label = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider-label/slider-label.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_slider_utilities();
    init_foundation_element();
    defaultConfig = {
      min: 0,
      max: 0,
      direction: Direction.ltr,
      orientation: Orientation.horizontal,
      disabled: false
    };
    SliderLabel = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.hideMark = false;
        this.sliderDirection = Direction.ltr;
        this.getSliderConfiguration = () => {
          if (!this.isSliderConfig(this.parentNode)) {
            this.sliderDirection = defaultConfig.direction || Direction.ltr;
            this.sliderOrientation = defaultConfig.orientation || Orientation.horizontal;
            this.sliderMaxPosition = defaultConfig.max;
            this.sliderMinPosition = defaultConfig.min;
          } else {
            const parentSlider = this.parentNode;
            const { min, max, direction: direction2, orientation, disabled } = parentSlider;
            if (disabled !== void 0) {
              this.disabled = disabled;
            }
            this.sliderDirection = direction2 || Direction.ltr;
            this.sliderOrientation = orientation || Orientation.horizontal;
            this.sliderMaxPosition = max;
            this.sliderMinPosition = min;
          }
        };
        this.positionAsStyle = () => {
          const direction2 = this.sliderDirection ? this.sliderDirection : Direction.ltr;
          const pct = convertPixelToPercent(Number(this.position), Number(this.sliderMinPosition), Number(this.sliderMaxPosition));
          let rightNum = Math.round((1 - pct) * 100);
          let leftNum = Math.round(pct * 100);
          if (Number.isNaN(leftNum) && Number.isNaN(rightNum)) {
            rightNum = 50;
            leftNum = 50;
          }
          if (this.sliderOrientation === Orientation.horizontal) {
            return direction2 === Direction.rtl ? `right: ${leftNum}%; left: ${rightNum}%;` : `left: ${leftNum}%; right: ${rightNum}%;`;
          } else {
            return `top: ${leftNum}%; bottom: ${rightNum}%;`;
          }
        };
      }
      positionChanged() {
        this.positionStyle = this.positionAsStyle();
      }
      /**
       * @internal
       */
      sliderOrientationChanged() {
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.getSliderConfiguration();
        this.positionStyle = this.positionAsStyle();
        this.notifier = Observable.getNotifier(this.parentNode);
        this.notifier.subscribe(this, "orientation");
        this.notifier.subscribe(this, "direction");
        this.notifier.subscribe(this, "max");
        this.notifier.subscribe(this, "min");
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.notifier.unsubscribe(this, "orientation");
        this.notifier.unsubscribe(this, "direction");
        this.notifier.unsubscribe(this, "max");
        this.notifier.unsubscribe(this, "min");
      }
      /**
       * @internal
       */
      handleChange(source, propertyName) {
        switch (propertyName) {
          case "direction":
            this.sliderDirection = source.direction;
            break;
          case "orientation":
            this.sliderOrientation = source.orientation;
            break;
          case "max":
            this.sliderMaxPosition = source.max;
            break;
          case "min":
            this.sliderMinPosition = source.min;
            break;
          default:
            break;
        }
        this.positionStyle = this.positionAsStyle();
      }
      isSliderConfig(node) {
        return node.max !== void 0 && node.min !== void 0;
      }
    };
    __decorate5([
      observable
    ], SliderLabel.prototype, "positionStyle", void 0);
    __decorate5([
      attr
    ], SliderLabel.prototype, "position", void 0);
    __decorate5([
      attr({ attribute: "hide-mark", mode: "boolean" })
    ], SliderLabel.prototype, "hideMark", void 0);
    __decorate5([
      attr({ attribute: "disabled", mode: "boolean" })
    ], SliderLabel.prototype, "disabled", void 0);
    __decorate5([
      observable
    ], SliderLabel.prototype, "sliderOrientation", void 0);
    __decorate5([
      observable
    ], SliderLabel.prototype, "sliderMinPosition", void 0);
    __decorate5([
      observable
    ], SliderLabel.prototype, "sliderMaxPosition", void 0);
    __decorate5([
      observable
    ], SliderLabel.prototype, "sliderDirection", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider-label/index.js
var init_slider_label2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider-label/index.js"() {
    init_slider_label_template();
    init_slider_label();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.template.js
var sliderTemplate;
var init_slider_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.template.js"() {
    init_esm();
    init_dist2();
    sliderTemplate = (context, definition) => html2`
    <template
        role="slider"
        class="${(x) => x.readOnly ? "readonly" : ""}
        ${(x) => x.orientation || Orientation.horizontal}"
        tabindex="${(x) => x.disabled ? null : 0}"
        aria-valuetext="${(x) => x.valueTextFormatter(x.value)}"
        aria-valuenow="${(x) => x.value}"
        aria-valuemin="${(x) => x.min}"
        aria-valuemax="${(x) => x.max}"
        aria-disabled="${(x) => x.disabled ? true : void 0}"
        aria-readonly="${(x) => x.readOnly ? true : void 0}"
        aria-orientation="${(x) => x.orientation}"
        class="${(x) => x.orientation}"
    >
        <div part="positioning-region" class="positioning-region">
            <div ${ref("track")} part="track-container" class="track">
                <slot name="track"></slot>
                <div part="track-start" class="track-start" style="${(x) => x.position}">
                    <slot name="track-start"></slot>
                </div>
            </div>
            <slot></slot>
            <div
                ${ref("thumb")}
                part="thumb-container"
                class="thumb-container"
                style="${(x) => x.position}"
            >
                <slot name="thumb">${definition.thumb || ""}</slot>
            </div>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.form-associated.js
var _Slider, FormAssociatedSlider;
var init_slider_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Slider = class extends FoundationElement {
    };
    FormAssociatedSlider = class extends FormAssociated(_Slider) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.js
var SliderMode, Slider;
var init_slider = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider/slider.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_direction();
    init_slider_utilities();
    init_slider_form_associated();
    SliderMode = {
      singleValue: "single-value"
    };
    Slider = class extends FormAssociatedSlider {
      constructor() {
        super(...arguments);
        this.direction = Direction.ltr;
        this.isDragging = false;
        this.trackWidth = 0;
        this.trackMinWidth = 0;
        this.trackHeight = 0;
        this.trackLeft = 0;
        this.trackMinHeight = 0;
        this.valueTextFormatter = () => null;
        this.min = 0;
        this.max = 10;
        this.step = 1;
        this.orientation = Orientation.horizontal;
        this.mode = SliderMode.singleValue;
        this.keypressHandler = (e) => {
          if (this.readOnly) {
            return;
          }
          if (e.key === keyHome) {
            e.preventDefault();
            this.value = `${this.min}`;
          } else if (e.key === keyEnd) {
            e.preventDefault();
            this.value = `${this.max}`;
          } else if (!e.shiftKey) {
            switch (e.key) {
              case keyArrowRight:
              case keyArrowUp:
                e.preventDefault();
                this.increment();
                break;
              case keyArrowLeft:
              case keyArrowDown:
                e.preventDefault();
                this.decrement();
                break;
            }
          }
        };
        this.setupTrackConstraints = () => {
          const clientRect = this.track.getBoundingClientRect();
          this.trackWidth = this.track.clientWidth;
          this.trackMinWidth = this.track.clientLeft;
          this.trackHeight = clientRect.bottom;
          this.trackMinHeight = clientRect.top;
          this.trackLeft = this.getBoundingClientRect().left;
          if (this.trackWidth === 0) {
            this.trackWidth = 1;
          }
        };
        this.setupListeners = (remove = false) => {
          const eventAction = `${remove ? "remove" : "add"}EventListener`;
          this[eventAction]("keydown", this.keypressHandler);
          this[eventAction]("mousedown", this.handleMouseDown);
          this.thumb[eventAction]("mousedown", this.handleThumbMouseDown, {
            passive: true
          });
          this.thumb[eventAction]("touchstart", this.handleThumbMouseDown, {
            passive: true
          });
          if (remove) {
            this.handleMouseDown(null);
            this.handleThumbMouseDown(null);
          }
        };
        this.initialValue = "";
        this.handleThumbMouseDown = (event) => {
          if (event) {
            if (this.readOnly || this.disabled || event.defaultPrevented) {
              return;
            }
            event.target.focus();
          }
          const eventAction = `${event !== null ? "add" : "remove"}EventListener`;
          window[eventAction]("mouseup", this.handleWindowMouseUp);
          window[eventAction]("mousemove", this.handleMouseMove, { passive: true });
          window[eventAction]("touchmove", this.handleMouseMove, { passive: true });
          window[eventAction]("touchend", this.handleWindowMouseUp);
          this.isDragging = event !== null;
        };
        this.handleMouseMove = (e) => {
          if (this.readOnly || this.disabled || e.defaultPrevented) {
            return;
          }
          const sourceEvent = window.TouchEvent && e instanceof TouchEvent ? e.touches[0] : e;
          const eventValue = this.orientation === Orientation.horizontal ? sourceEvent.pageX - document.documentElement.scrollLeft - this.trackLeft : sourceEvent.pageY - document.documentElement.scrollTop;
          this.value = `${this.calculateNewValue(eventValue)}`;
        };
        this.calculateNewValue = (rawValue) => {
          const newPosition = convertPixelToPercent(rawValue, this.orientation === Orientation.horizontal ? this.trackMinWidth : this.trackMinHeight, this.orientation === Orientation.horizontal ? this.trackWidth : this.trackHeight, this.direction);
          const newValue = (this.max - this.min) * newPosition + this.min;
          return this.convertToConstrainedValue(newValue);
        };
        this.handleWindowMouseUp = (event) => {
          this.stopDragging();
        };
        this.stopDragging = () => {
          this.isDragging = false;
          this.handleMouseDown(null);
          this.handleThumbMouseDown(null);
        };
        this.handleMouseDown = (e) => {
          const eventAction = `${e !== null ? "add" : "remove"}EventListener`;
          if (e === null || !this.disabled && !this.readOnly) {
            window[eventAction]("mouseup", this.handleWindowMouseUp);
            window.document[eventAction]("mouseleave", this.handleWindowMouseUp);
            window[eventAction]("mousemove", this.handleMouseMove);
            if (e) {
              e.preventDefault();
              this.setupTrackConstraints();
              e.target.focus();
              const controlValue = this.orientation === Orientation.horizontal ? e.pageX - document.documentElement.scrollLeft - this.trackLeft : e.pageY - document.documentElement.scrollTop;
              this.value = `${this.calculateNewValue(controlValue)}`;
            }
          }
        };
        this.convertToConstrainedValue = (value) => {
          if (isNaN(value)) {
            value = this.min;
          }
          let constrainedValue = value - this.min;
          const roundedConstrainedValue = Math.round(constrainedValue / this.step);
          const remainderValue = constrainedValue - roundedConstrainedValue * (this.stepMultiplier * this.step) / this.stepMultiplier;
          constrainedValue = remainderValue >= Number(this.step) / 2 ? constrainedValue - remainderValue + Number(this.step) : constrainedValue - remainderValue;
          return constrainedValue + this.min;
        };
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
      /**
       * The value property, typed as a number.
       *
       * @public
       */
      get valueAsNumber() {
        return parseFloat(super.value);
      }
      set valueAsNumber(next) {
        this.value = next.toString();
      }
      /**
       * @internal
       */
      valueChanged(previous, next) {
        super.valueChanged(previous, next);
        if (this.$fastController.isConnected) {
          this.setThumbPositionForOrientation(this.direction);
        }
        this.$emit("change");
      }
      minChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.min = `${this.min}`;
        }
        this.validate();
      }
      maxChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.max = `${this.max}`;
        }
        this.validate();
      }
      stepChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.step = `${this.step}`;
        }
        this.updateStepMultiplier();
        this.validate();
      }
      orientationChanged() {
        if (this.$fastController.isConnected) {
          this.setThumbPositionForOrientation(this.direction);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", "range");
        this.direction = getDirection(this);
        this.updateStepMultiplier();
        this.setupTrackConstraints();
        this.setupListeners();
        this.setupDefaultValue();
        this.setThumbPositionForOrientation(this.direction);
      }
      /**
       * @internal
       */
      disconnectedCallback() {
        this.setupListeners(true);
      }
      /**
       * Increment the value by the step
       *
       * @public
       */
      increment() {
        const newVal = this.direction !== Direction.rtl && this.orientation !== Orientation.vertical ? Number(this.value) + Number(this.step) : Number(this.value) - Number(this.step);
        const incrementedVal = this.convertToConstrainedValue(newVal);
        const incrementedValString = incrementedVal < Number(this.max) ? `${incrementedVal}` : `${this.max}`;
        this.value = incrementedValString;
      }
      /**
       * Decrement the value by the step
       *
       * @public
       */
      decrement() {
        const newVal = this.direction !== Direction.rtl && this.orientation !== Orientation.vertical ? Number(this.value) - Number(this.step) : Number(this.value) + Number(this.step);
        const decrementedVal = this.convertToConstrainedValue(newVal);
        const decrementedValString = decrementedVal > Number(this.min) ? `${decrementedVal}` : `${this.min}`;
        this.value = decrementedValString;
      }
      /**
       * Places the thumb based on the current value
       *
       * @public
       * @param direction - writing mode
       */
      setThumbPositionForOrientation(direction2) {
        const newPct = convertPixelToPercent(Number(this.value), Number(this.min), Number(this.max), direction2);
        const percentage = (1 - newPct) * 100;
        if (this.orientation === Orientation.horizontal) {
          this.position = this.isDragging ? `right: ${percentage}%; transition: none;` : `right: ${percentage}%; transition: all 0.2s ease;`;
        } else {
          this.position = this.isDragging ? `bottom: ${percentage}%; transition: none;` : `bottom: ${percentage}%; transition: all 0.2s ease;`;
        }
      }
      /**
       * Update the step multiplier used to ensure rounding errors from steps that
       * are not whole numbers
       */
      updateStepMultiplier() {
        const stepString = this.step + "";
        const decimalPlacesOfStep = !!(this.step % 1) ? stepString.length - stepString.indexOf(".") - 1 : 0;
        this.stepMultiplier = Math.pow(10, decimalPlacesOfStep);
      }
      get midpoint() {
        return `${this.convertToConstrainedValue((this.max + this.min) / 2)}`;
      }
      setupDefaultValue() {
        if (typeof this.value === "string") {
          if (this.value.length === 0) {
            this.initialValue = this.midpoint;
          } else {
            const value = parseFloat(this.value);
            if (!Number.isNaN(value) && (value < this.min || value > this.max)) {
              this.value = this.midpoint;
            }
          }
        }
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Slider.prototype, "readOnly", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "direction", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "isDragging", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "position", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "trackWidth", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "trackMinWidth", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "trackHeight", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "trackLeft", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "trackMinHeight", void 0);
    __decorate5([
      observable
    ], Slider.prototype, "valueTextFormatter", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Slider.prototype, "min", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Slider.prototype, "max", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], Slider.prototype, "step", void 0);
    __decorate5([
      attr
    ], Slider.prototype, "orientation", void 0);
    __decorate5([
      attr
    ], Slider.prototype, "mode", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/slider/index.js
var init_slider2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/slider/index.js"() {
    init_slider_template();
    init_slider();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.template.js
var switchTemplate;
var init_switch_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.template.js"() {
    init_esm();
    switchTemplate = (context, definition) => html2`
    <template
        role="switch"
        aria-checked="${(x) => x.checked}"
        aria-disabled="${(x) => x.disabled}"
        aria-readonly="${(x) => x.readOnly}"
        tabindex="${(x) => x.disabled ? null : 0}"
        @keypress="${(x, c) => x.keypressHandler(c.event)}"
        @click="${(x, c) => x.clickHandler(c.event)}"
        class="${(x) => x.checked ? "checked" : ""}"
    >
        <label
            part="label"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <div part="switch" class="switch">
            <slot name="switch">${definition.switch || ""}</slot>
        </div>
        <span class="status-message" part="status-message">
            <span class="checked-message" part="checked-message">
                <slot name="checked-message"></slot>
            </span>
            <span class="unchecked-message" part="unchecked-message">
                <slot name="unchecked-message"></slot>
            </span>
        </span>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.form-associated.js
var _Switch, FormAssociatedSwitch;
var init_switch_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _Switch = class extends FoundationElement {
    };
    FormAssociatedSwitch = class extends CheckableFormAssociated(_Switch) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.js
var Switch;
var init_switch = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/switch/switch.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_switch_form_associated();
    Switch = class extends FormAssociatedSwitch {
      constructor() {
        super();
        this.initialValue = "on";
        this.keypressHandler = (e) => {
          if (this.readOnly) {
            return;
          }
          switch (e.key) {
            case keyEnter:
            case keySpace:
              this.checked = !this.checked;
              break;
          }
        };
        this.clickHandler = (e) => {
          if (!this.disabled && !this.readOnly) {
            this.checked = !this.checked;
          }
        };
        this.proxy.setAttribute("type", "checkbox");
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLInputElement) {
          this.proxy.readOnly = this.readOnly;
        }
        this.readOnly ? this.classList.add("readonly") : this.classList.remove("readonly");
      }
      /**
       * @internal
       */
      checkedChanged(prev, next) {
        super.checkedChanged(prev, next);
        this.checked ? this.classList.add("checked") : this.classList.remove("checked");
      }
    };
    __decorate5([
      attr({ attribute: "readonly", mode: "boolean" })
    ], Switch.prototype, "readOnly", void 0);
    __decorate5([
      observable
    ], Switch.prototype, "defaultSlottedNodes", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/switch/index.js
var init_switch2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/switch/index.js"() {
    init_switch_template();
    init_switch();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.template.js
var tabPanelTemplate;
var init_tab_panel_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.template.js"() {
    init_esm();
    tabPanelTemplate = (context, definition) => html2`
    <template slot="tabpanel" role="tabpanel">
        <slot></slot>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.js
var TabPanel;
var init_tab_panel = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/tab-panel.js"() {
    init_foundation_element();
    TabPanel = class extends FoundationElement {
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/index.js
var init_tab_panel2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tab-panel/index.js"() {
    init_tab_panel_template();
    init_tab_panel();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.template.js
var tabTemplate;
var init_tab_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.template.js"() {
    init_esm();
    tabTemplate = (context, definition) => html2`
    <template slot="tab" role="tab" aria-disabled="${(x) => x.disabled}">
        <slot></slot>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.js
var Tab;
var init_tab = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tab/tab.js"() {
    init_tslib_es62();
    init_esm();
    init_foundation_element();
    Tab = class extends FoundationElement {
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], Tab.prototype, "disabled", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tab/index.js
var init_tab2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tab/index.js"() {
    init_tab_template();
    init_tab();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.template.js
var tabsTemplate;
var init_tabs_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.template.js"() {
    init_esm();
    init_start_end();
    tabsTemplate = (context, definition) => html2`
    <template class="${(x) => x.orientation}">
        ${startSlotTemplate(context, definition)}
        <div class="tablist" part="tablist" role="tablist">
            <slot class="tab" name="tab" part="tab" ${slotted("tabs")}></slot>

            ${when((x) => x.showActiveIndicator, html2`
                    <div
                        ${ref("activeIndicatorRef")}
                        class="activeIndicator"
                        part="activeIndicator"
                    ></div>
                `)}
        </div>
        ${endSlotTemplate(context, definition)}
        <div class="tabpanel">
            <slot name="tabpanel" part="tabpanel" ${slotted("tabpanels")}></slot>
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.js
var TabsOrientation, Tabs;
var init_tabs = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tabs/tabs.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_start_end();
    init_apply_mixins();
    init_foundation_element();
    TabsOrientation = {
      vertical: "vertical",
      horizontal: "horizontal"
    };
    Tabs = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.orientation = TabsOrientation.horizontal;
        this.activeindicator = true;
        this.showActiveIndicator = true;
        this.prevActiveTabIndex = 0;
        this.activeTabIndex = 0;
        this.ticking = false;
        this.change = () => {
          this.$emit("change", this.activetab);
        };
        this.isDisabledElement = (el) => {
          return el.getAttribute("aria-disabled") === "true";
        };
        this.isFocusableElement = (el) => {
          return !this.isDisabledElement(el);
        };
        this.setTabs = () => {
          const gridHorizontalProperty = "gridColumn";
          const gridVerticalProperty = "gridRow";
          const gridProperty = this.isHorizontal() ? gridHorizontalProperty : gridVerticalProperty;
          this.activeTabIndex = this.getActiveIndex();
          this.showActiveIndicator = false;
          this.tabs.forEach((tab, index) => {
            if (tab.slot === "tab") {
              const isActiveTab = this.activeTabIndex === index && this.isFocusableElement(tab);
              if (this.activeindicator && this.isFocusableElement(tab)) {
                this.showActiveIndicator = true;
              }
              const tabId = this.tabIds[index];
              const tabpanelId = this.tabpanelIds[index];
              tab.setAttribute("id", tabId);
              tab.setAttribute("aria-selected", isActiveTab ? "true" : "false");
              tab.setAttribute("aria-controls", tabpanelId);
              tab.addEventListener("click", this.handleTabClick);
              tab.addEventListener("keydown", this.handleTabKeyDown);
              tab.setAttribute("tabindex", isActiveTab ? "0" : "-1");
              if (isActiveTab) {
                this.activetab = tab;
              }
            }
            tab.style[gridHorizontalProperty] = "";
            tab.style[gridVerticalProperty] = "";
            tab.style[gridProperty] = `${index + 1}`;
            !this.isHorizontal() ? tab.classList.add("vertical") : tab.classList.remove("vertical");
          });
        };
        this.setTabPanels = () => {
          this.tabpanels.forEach((tabpanel, index) => {
            const tabId = this.tabIds[index];
            const tabpanelId = this.tabpanelIds[index];
            tabpanel.setAttribute("id", tabpanelId);
            tabpanel.setAttribute("aria-labelledby", tabId);
            this.activeTabIndex !== index ? tabpanel.setAttribute("hidden", "") : tabpanel.removeAttribute("hidden");
          });
        };
        this.handleTabClick = (event) => {
          const selectedTab = event.currentTarget;
          if (selectedTab.nodeType === 1 && this.isFocusableElement(selectedTab)) {
            this.prevActiveTabIndex = this.activeTabIndex;
            this.activeTabIndex = this.tabs.indexOf(selectedTab);
            this.setComponent();
          }
        };
        this.handleTabKeyDown = (event) => {
          if (this.isHorizontal()) {
            switch (event.key) {
              case keyArrowLeft:
                event.preventDefault();
                this.adjustBackward(event);
                break;
              case keyArrowRight:
                event.preventDefault();
                this.adjustForward(event);
                break;
            }
          } else {
            switch (event.key) {
              case keyArrowUp:
                event.preventDefault();
                this.adjustBackward(event);
                break;
              case keyArrowDown:
                event.preventDefault();
                this.adjustForward(event);
                break;
            }
          }
          switch (event.key) {
            case keyHome:
              event.preventDefault();
              this.adjust(-this.activeTabIndex);
              break;
            case keyEnd:
              event.preventDefault();
              this.adjust(this.tabs.length - this.activeTabIndex - 1);
              break;
          }
        };
        this.adjustForward = (e) => {
          const group = this.tabs;
          let index = 0;
          index = this.activetab ? group.indexOf(this.activetab) + 1 : 1;
          if (index === group.length) {
            index = 0;
          }
          while (index < group.length && group.length > 1) {
            if (this.isFocusableElement(group[index])) {
              this.moveToTabByIndex(group, index);
              break;
            } else if (this.activetab && index === group.indexOf(this.activetab)) {
              break;
            } else if (index + 1 >= group.length) {
              index = 0;
            } else {
              index += 1;
            }
          }
        };
        this.adjustBackward = (e) => {
          const group = this.tabs;
          let index = 0;
          index = this.activetab ? group.indexOf(this.activetab) - 1 : 0;
          index = index < 0 ? group.length - 1 : index;
          while (index >= 0 && group.length > 1) {
            if (this.isFocusableElement(group[index])) {
              this.moveToTabByIndex(group, index);
              break;
            } else if (index - 1 < 0) {
              index = group.length - 1;
            } else {
              index -= 1;
            }
          }
        };
        this.moveToTabByIndex = (group, index) => {
          const tab = group[index];
          this.activetab = tab;
          this.prevActiveTabIndex = this.activeTabIndex;
          this.activeTabIndex = index;
          tab.focus();
          this.setComponent();
        };
      }
      /**
       * @internal
       */
      orientationChanged() {
        if (this.$fastController.isConnected) {
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      /**
       * @internal
       */
      activeidChanged(oldValue, newValue) {
        if (this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length) {
          this.prevActiveTabIndex = this.tabs.findIndex((item) => item.id === oldValue);
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      /**
       * @internal
       */
      tabsChanged() {
        if (this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length) {
          this.tabIds = this.getTabIds();
          this.tabpanelIds = this.getTabPanelIds();
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      /**
       * @internal
       */
      tabpanelsChanged() {
        if (this.$fastController.isConnected && this.tabpanels.length <= this.tabs.length) {
          this.tabIds = this.getTabIds();
          this.tabpanelIds = this.getTabPanelIds();
          this.setTabs();
          this.setTabPanels();
          this.handleActiveIndicatorPosition();
        }
      }
      getActiveIndex() {
        const id = this.activeid;
        if (id !== void 0) {
          return this.tabIds.indexOf(this.activeid) === -1 ? 0 : this.tabIds.indexOf(this.activeid);
        } else {
          return 0;
        }
      }
      getTabIds() {
        return this.tabs.map((tab) => {
          var _a2;
          return (_a2 = tab.getAttribute("id")) !== null && _a2 !== void 0 ? _a2 : `tab-${uniqueId()}`;
        });
      }
      getTabPanelIds() {
        return this.tabpanels.map((tabPanel) => {
          var _a2;
          return (_a2 = tabPanel.getAttribute("id")) !== null && _a2 !== void 0 ? _a2 : `panel-${uniqueId()}`;
        });
      }
      setComponent() {
        if (this.activeTabIndex !== this.prevActiveTabIndex) {
          this.activeid = this.tabIds[this.activeTabIndex];
          this.focusTab();
          this.change();
        }
      }
      isHorizontal() {
        return this.orientation === TabsOrientation.horizontal;
      }
      handleActiveIndicatorPosition() {
        if (this.showActiveIndicator && this.activeindicator && this.activeTabIndex !== this.prevActiveTabIndex) {
          if (this.ticking) {
            this.ticking = false;
          } else {
            this.ticking = true;
            this.animateActiveIndicator();
          }
        }
      }
      animateActiveIndicator() {
        this.ticking = true;
        const gridProperty = this.isHorizontal() ? "gridColumn" : "gridRow";
        const translateProperty = this.isHorizontal() ? "translateX" : "translateY";
        const offsetProperty = this.isHorizontal() ? "offsetLeft" : "offsetTop";
        const prev = this.activeIndicatorRef[offsetProperty];
        this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
        const next = this.activeIndicatorRef[offsetProperty];
        this.activeIndicatorRef.style[gridProperty] = `${this.prevActiveTabIndex + 1}`;
        const dif = next - prev;
        this.activeIndicatorRef.style.transform = `${translateProperty}(${dif}px)`;
        this.activeIndicatorRef.classList.add("activeIndicatorTransition");
        this.activeIndicatorRef.addEventListener("transitionend", () => {
          this.ticking = false;
          this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
          this.activeIndicatorRef.style.transform = `${translateProperty}(0px)`;
          this.activeIndicatorRef.classList.remove("activeIndicatorTransition");
        });
      }
      /**
       * The adjust method for FASTTabs
       * @public
       * @remarks
       * This method allows the active index to be adjusted by numerical increments
       */
      adjust(adjustment) {
        this.prevActiveTabIndex = this.activeTabIndex;
        this.activeTabIndex = wrapInBounds(0, this.tabs.length - 1, this.activeTabIndex + adjustment);
        this.setComponent();
      }
      focusTab() {
        this.tabs[this.activeTabIndex].focus();
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.tabIds = this.getTabIds();
        this.tabpanelIds = this.getTabPanelIds();
        this.activeTabIndex = this.getActiveIndex();
      }
    };
    __decorate5([
      attr
    ], Tabs.prototype, "orientation", void 0);
    __decorate5([
      attr
    ], Tabs.prototype, "activeid", void 0);
    __decorate5([
      observable
    ], Tabs.prototype, "tabs", void 0);
    __decorate5([
      observable
    ], Tabs.prototype, "tabpanels", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], Tabs.prototype, "activeindicator", void 0);
    __decorate5([
      observable
    ], Tabs.prototype, "activeIndicatorRef", void 0);
    __decorate5([
      observable
    ], Tabs.prototype, "showActiveIndicator", void 0);
    applyMixins(Tabs, StartEnd);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tabs/index.js
var init_tabs2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tabs/index.js"() {
    init_tabs_template();
    init_tabs();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.form-associated.js
var _TextArea, FormAssociatedTextArea;
var init_text_area_form_associated = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.form-associated.js"() {
    init_form_associated();
    init_foundation_element();
    _TextArea = class extends FoundationElement {
    };
    FormAssociatedTextArea = class extends FormAssociated(_TextArea) {
      constructor() {
        super(...arguments);
        this.proxy = document.createElement("textarea");
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.options.js
var TextAreaResize;
var init_text_area_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.options.js"() {
    TextAreaResize = {
      /**
       * No resize.
       */
      none: "none",
      /**
       * Resize vertically and horizontally.
       */
      both: "both",
      /**
       * Resize horizontally.
       */
      horizontal: "horizontal",
      /**
       * Resize vertically.
       */
      vertical: "vertical"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.js
var TextArea;
var init_text_area = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.js"() {
    init_tslib_es62();
    init_esm();
    init_text_field();
    init_apply_mixins();
    init_text_area_form_associated();
    init_text_area_options();
    TextArea = class extends FormAssociatedTextArea {
      constructor() {
        super(...arguments);
        this.resize = TextAreaResize.none;
        this.cols = 20;
        this.handleTextInput = () => {
          this.value = this.control.value;
        };
      }
      readOnlyChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.readOnly = this.readOnly;
        }
      }
      autofocusChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.autofocus = this.autofocus;
        }
      }
      listChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.setAttribute("list", this.list);
        }
      }
      maxlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.maxLength = this.maxlength;
        }
      }
      minlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.minLength = this.minlength;
        }
      }
      spellcheckChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
          this.proxy.spellcheck = this.spellcheck;
        }
      }
      /**
       * Selects all the text in the text area
       *
       * @public
       */
      select() {
        this.control.select();
        this.$emit("select");
      }
      /**
       * Change event handler for inner control.
       * @remarks
       * "Change" events are not `composable` so they will not
       * permeate the shadow DOM boundary. This fn effectively proxies
       * the change event, emitting a `change` event whenever the internal
       * control emits a `change` event
       * @internal
       */
      handleChange() {
        this.$emit("change");
      }
      /** {@inheritDoc (FormAssociated:interface).validate} */
      validate() {
        super.validate(this.control);
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], TextArea.prototype, "readOnly", void 0);
    __decorate5([
      attr
    ], TextArea.prototype, "resize", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], TextArea.prototype, "autofocus", void 0);
    __decorate5([
      attr({ attribute: "form" })
    ], TextArea.prototype, "formId", void 0);
    __decorate5([
      attr
    ], TextArea.prototype, "list", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], TextArea.prototype, "maxlength", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter })
    ], TextArea.prototype, "minlength", void 0);
    __decorate5([
      attr
    ], TextArea.prototype, "name", void 0);
    __decorate5([
      attr
    ], TextArea.prototype, "placeholder", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter, mode: "fromView" })
    ], TextArea.prototype, "cols", void 0);
    __decorate5([
      attr({ converter: nullableNumberConverter, mode: "fromView" })
    ], TextArea.prototype, "rows", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], TextArea.prototype, "spellcheck", void 0);
    __decorate5([
      observable
    ], TextArea.prototype, "defaultSlottedNodes", void 0);
    applyMixins(TextArea, DelegatesARIATextbox);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.template.js
var textAreaTemplate;
var init_text_area_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-area/text-area.template.js"() {
    init_esm();
    init_text_area();
    textAreaTemplate = (context, definition) => html2`
    <template
        class="
            ${(x) => x.readOnly ? "readonly" : ""}
            ${(x) => x.resize !== TextAreaResize.none ? `resize-${x.resize}` : ""}"
    >
        <label
            part="label"
            for="control"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <textarea
            part="control"
            class="control"
            id="control"
            ?autofocus="${(x) => x.autofocus}"
            cols="${(x) => x.cols}"
            ?disabled="${(x) => x.disabled}"
            form="${(x) => x.form}"
            list="${(x) => x.list}"
            maxlength="${(x) => x.maxlength}"
            minlength="${(x) => x.minlength}"
            name="${(x) => x.name}"
            placeholder="${(x) => x.placeholder}"
            ?readonly="${(x) => x.readOnly}"
            ?required="${(x) => x.required}"
            rows="${(x) => x.rows}"
            ?spellcheck="${(x) => x.spellcheck}"
            :value="${(x) => x.value}"
            aria-atomic="${(x) => x.ariaAtomic}"
            aria-busy="${(x) => x.ariaBusy}"
            aria-controls="${(x) => x.ariaControls}"
            aria-current="${(x) => x.ariaCurrent}"
            aria-describedby="${(x) => x.ariaDescribedby}"
            aria-details="${(x) => x.ariaDetails}"
            aria-disabled="${(x) => x.ariaDisabled}"
            aria-errormessage="${(x) => x.ariaErrormessage}"
            aria-flowto="${(x) => x.ariaFlowto}"
            aria-haspopup="${(x) => x.ariaHaspopup}"
            aria-hidden="${(x) => x.ariaHidden}"
            aria-invalid="${(x) => x.ariaInvalid}"
            aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
            aria-label="${(x) => x.ariaLabel}"
            aria-labelledby="${(x) => x.ariaLabelledby}"
            aria-live="${(x) => x.ariaLive}"
            aria-owns="${(x) => x.ariaOwns}"
            aria-relevant="${(x) => x.ariaRelevant}"
            aria-roledescription="${(x) => x.ariaRoledescription}"
            @input="${(x, c) => x.handleTextInput()}"
            @change="${(x) => x.handleChange()}"
            ${ref("control")}
        ></textarea>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-area/index.js
var init_text_area2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-area/index.js"() {
    init_text_area_template();
    init_text_area();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.template.js
var textFieldTemplate;
var init_text_field_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-field/text-field.template.js"() {
    init_esm();
    init_start_end();
    init_whitespace_filter();
    textFieldTemplate = (context, definition) => html2`
    <template
        class="
            ${(x) => x.readOnly ? "readonly" : ""}
        "
    >
        <label
            part="label"
            for="control"
            class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot
                ${slotted({ property: "defaultSlottedNodes", filter: whitespaceFilter })}
            ></slot>
        </label>
        <div class="root" part="root">
            ${startSlotTemplate(context, definition)}
            <input
                class="control"
                part="control"
                id="control"
                @input="${(x) => x.handleTextInput()}"
                @change="${(x) => x.handleChange()}"
                ?autofocus="${(x) => x.autofocus}"
                ?disabled="${(x) => x.disabled}"
                list="${(x) => x.list}"
                maxlength="${(x) => x.maxlength}"
                minlength="${(x) => x.minlength}"
                pattern="${(x) => x.pattern}"
                placeholder="${(x) => x.placeholder}"
                ?readonly="${(x) => x.readOnly}"
                ?required="${(x) => x.required}"
                size="${(x) => x.size}"
                ?spellcheck="${(x) => x.spellcheck}"
                :value="${(x) => x.value}"
                type="${(x) => x.type}"
                aria-atomic="${(x) => x.ariaAtomic}"
                aria-busy="${(x) => x.ariaBusy}"
                aria-controls="${(x) => x.ariaControls}"
                aria-current="${(x) => x.ariaCurrent}"
                aria-describedby="${(x) => x.ariaDescribedby}"
                aria-details="${(x) => x.ariaDetails}"
                aria-disabled="${(x) => x.ariaDisabled}"
                aria-errormessage="${(x) => x.ariaErrormessage}"
                aria-flowto="${(x) => x.ariaFlowto}"
                aria-haspopup="${(x) => x.ariaHaspopup}"
                aria-hidden="${(x) => x.ariaHidden}"
                aria-invalid="${(x) => x.ariaInvalid}"
                aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
                aria-label="${(x) => x.ariaLabel}"
                aria-labelledby="${(x) => x.ariaLabelledby}"
                aria-live="${(x) => x.ariaLive}"
                aria-owns="${(x) => x.ariaOwns}"
                aria-relevant="${(x) => x.ariaRelevant}"
                aria-roledescription="${(x) => x.ariaRoledescription}"
                ${ref("control")}
            />
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/text-field/index.js
var init_text_field2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/text-field/index.js"() {
    init_text_field_template();
    init_text_field();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.template.js
var toolbarTemplate;
var init_toolbar_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.template.js"() {
    init_esm();
    init_start_end();
    toolbarTemplate = (context, definition) => html2`
    <template
        aria-label="${(x) => x.ariaLabel}"
        aria-labelledby="${(x) => x.ariaLabelledby}"
        aria-orientation="${(x) => x.orientation}"
        orientation="${(x) => x.orientation}"
        role="toolbar"
        @click="${(x, c) => x.clickHandler(c.event)}"
        @focusin="${(x, c) => x.focusinHandler(c.event)}"
        @keydown="${(x, c) => x.keydownHandler(c.event)}"
        ${children({
      property: "childItems",
      attributeFilter: ["disabled", "hidden"],
      filter: elements(),
      subtree: true
    })}
    >
        <slot name="label"></slot>
        <div class="positioning-region" part="positioning-region">
            ${startSlotTemplate(context, definition)}
            <slot
                ${slotted({
      filter: elements(),
      property: "slottedItems"
    })}
            ></slot>
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.js
var ToolbarArrowKeyMap, Toolbar, DelegatesARIAToolbar;
var init_toolbar = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/toolbar/toolbar.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_index_esm();
    init_foundation_element();
    init_aria_global();
    init_start_end();
    init_apply_mixins();
    init_direction();
    ToolbarArrowKeyMap = Object.freeze({
      [ArrowKeys.ArrowUp]: {
        [Orientation.vertical]: -1
      },
      [ArrowKeys.ArrowDown]: {
        [Orientation.vertical]: 1
      },
      [ArrowKeys.ArrowLeft]: {
        [Orientation.horizontal]: {
          [Direction.ltr]: -1,
          [Direction.rtl]: 1
        }
      },
      [ArrowKeys.ArrowRight]: {
        [Orientation.horizontal]: {
          [Direction.ltr]: 1,
          [Direction.rtl]: -1
        }
      }
    });
    Toolbar = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this._activeIndex = 0;
        this.direction = Direction.ltr;
        this.orientation = Orientation.horizontal;
      }
      /**
       * The index of the currently focused element, clamped between 0 and the last element.
       *
       * @internal
       */
      get activeIndex() {
        Observable.track(this, "activeIndex");
        return this._activeIndex;
      }
      set activeIndex(value) {
        if (this.$fastController.isConnected) {
          this._activeIndex = limit(0, this.focusableElements.length - 1, value);
          Observable.notify(this, "activeIndex");
        }
      }
      slottedItemsChanged() {
        if (this.$fastController.isConnected) {
          this.reduceFocusableElements();
        }
      }
      /**
       * Set the activeIndex when a focusable element in the toolbar is clicked.
       *
       * @internal
       */
      clickHandler(e) {
        var _a2;
        const activeIndex = (_a2 = this.focusableElements) === null || _a2 === void 0 ? void 0 : _a2.indexOf(e.target);
        if (activeIndex > -1 && this.activeIndex !== activeIndex) {
          this.setFocusedElement(activeIndex);
        }
        return true;
      }
      childItemsChanged(prev, next) {
        if (this.$fastController.isConnected) {
          this.reduceFocusableElements();
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        this.direction = getDirection(this);
      }
      /**
       * When the toolbar receives focus, set the currently active element as focused.
       *
       * @internal
       */
      focusinHandler(e) {
        const relatedTarget = e.relatedTarget;
        if (!relatedTarget || this.contains(relatedTarget)) {
          return;
        }
        this.setFocusedElement();
      }
      /**
       * Determines a value that can be used to iterate a list with the arrow keys.
       *
       * @param this - An element with an orientation and direction
       * @param key - The event key value
       * @internal
       */
      getDirectionalIncrementer(key) {
        var _a2, _b2, _c, _d, _e;
        return (_e = (_c = (_b2 = (_a2 = ToolbarArrowKeyMap[key]) === null || _a2 === void 0 ? void 0 : _a2[this.orientation]) === null || _b2 === void 0 ? void 0 : _b2[this.direction]) !== null && _c !== void 0 ? _c : (_d = ToolbarArrowKeyMap[key]) === null || _d === void 0 ? void 0 : _d[this.orientation]) !== null && _e !== void 0 ? _e : 0;
      }
      /**
       * Handle keyboard events for the toolbar.
       *
       * @internal
       */
      keydownHandler(e) {
        const key = e.key;
        if (!(key in ArrowKeys) || e.defaultPrevented || e.shiftKey) {
          return true;
        }
        const incrementer = this.getDirectionalIncrementer(key);
        if (!incrementer) {
          return !e.target.closest("[role=radiogroup]");
        }
        const nextIndex = this.activeIndex + incrementer;
        if (this.focusableElements[nextIndex]) {
          e.preventDefault();
        }
        this.setFocusedElement(nextIndex);
        return true;
      }
      /**
       * get all the slotted elements
       * @internal
       */
      get allSlottedItems() {
        return [
          ...this.start.assignedElements(),
          ...this.slottedItems,
          ...this.end.assignedElements()
        ];
      }
      /**
       * Prepare the slotted elements which can be focusable.
       *
       * @internal
       */
      reduceFocusableElements() {
        var _a2;
        const previousFocusedElement = (_a2 = this.focusableElements) === null || _a2 === void 0 ? void 0 : _a2[this.activeIndex];
        this.focusableElements = this.allSlottedItems.reduce(Toolbar.reduceFocusableItems, []);
        const adjustedActiveIndex = this.focusableElements.indexOf(previousFocusedElement);
        this.activeIndex = Math.max(0, adjustedActiveIndex);
        this.setFocusableElements();
      }
      /**
       * Set the activeIndex and focus the corresponding control.
       *
       * @param activeIndex - The new index to set
       * @internal
       */
      setFocusedElement(activeIndex = this.activeIndex) {
        var _a2;
        this.activeIndex = activeIndex;
        this.setFocusableElements();
        (_a2 = this.focusableElements[this.activeIndex]) === null || _a2 === void 0 ? void 0 : _a2.focus();
      }
      /**
       * Reduce a collection to only its focusable elements.
       *
       * @param elements - Collection of elements to reduce
       * @param element - The current element
       *
       * @internal
       */
      static reduceFocusableItems(elements2, element) {
        var _a2, _b2, _c, _d;
        const isRoleRadio = element.getAttribute("role") === "radio";
        const isFocusableFastElement = (_b2 = (_a2 = element.$fastController) === null || _a2 === void 0 ? void 0 : _a2.definition.shadowOptions) === null || _b2 === void 0 ? void 0 : _b2.delegatesFocus;
        const hasFocusableShadow = Array.from((_d = (_c = element.shadowRoot) === null || _c === void 0 ? void 0 : _c.querySelectorAll("*")) !== null && _d !== void 0 ? _d : []).some((x) => isFocusable(x));
        if (!element.hasAttribute("disabled") && !element.hasAttribute("hidden") && (isFocusable(element) || isRoleRadio || isFocusableFastElement || hasFocusableShadow)) {
          elements2.push(element);
          return elements2;
        }
        if (element.childElementCount) {
          return elements2.concat(Array.from(element.children).reduce(Toolbar.reduceFocusableItems, []));
        }
        return elements2;
      }
      /**
       * @internal
       */
      setFocusableElements() {
        if (this.$fastController.isConnected && this.focusableElements.length > 0) {
          this.focusableElements.forEach((element, index) => {
            element.tabIndex = this.activeIndex === index ? 0 : -1;
          });
        }
      }
    };
    __decorate5([
      observable
    ], Toolbar.prototype, "direction", void 0);
    __decorate5([
      attr
    ], Toolbar.prototype, "orientation", void 0);
    __decorate5([
      observable
    ], Toolbar.prototype, "slottedItems", void 0);
    __decorate5([
      observable
    ], Toolbar.prototype, "slottedLabel", void 0);
    __decorate5([
      observable
    ], Toolbar.prototype, "childItems", void 0);
    DelegatesARIAToolbar = class {
    };
    __decorate5([
      attr({ attribute: "aria-labelledby" })
    ], DelegatesARIAToolbar.prototype, "ariaLabelledby", void 0);
    __decorate5([
      attr({ attribute: "aria-label" })
    ], DelegatesARIAToolbar.prototype, "ariaLabel", void 0);
    applyMixins(DelegatesARIAToolbar, ARIAGlobalStatesAndProperties);
    applyMixins(Toolbar, StartEnd, DelegatesARIAToolbar);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/toolbar/index.js
var init_toolbar2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/toolbar/index.js"() {
    init_toolbar_template();
    init_toolbar();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.template.js
var tooltipTemplate;
var init_tooltip_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.template.js"() {
    init_esm();
    init_anchored_region();
    tooltipTemplate = (context, definition) => {
      return html2`
        ${when((x) => x.tooltipVisible, html2`
            <${context.tagFor(AnchoredRegion)}
                fixed-placement="true"
                auto-update-mode="${(x) => x.autoUpdateMode}"
                vertical-positioning-mode="${(x) => x.verticalPositioningMode}"
                vertical-default-position="${(x) => x.verticalDefaultPosition}"
                vertical-inset="${(x) => x.verticalInset}"
                vertical-scaling="${(x) => x.verticalScaling}"
                horizontal-positioning-mode="${(x) => x.horizontalPositioningMode}"
                horizontal-default-position="${(x) => x.horizontalDefaultPosition}"
                horizontal-scaling="${(x) => x.horizontalScaling}"
                horizontal-inset="${(x) => x.horizontalInset}"
                vertical-viewport-lock="${(x) => x.horizontalViewportLock}"
                horizontal-viewport-lock="${(x) => x.verticalViewportLock}"
                dir="${(x) => x.currentDirection}"
                ${ref("region")}
            >
                <div class="tooltip" part="tooltip" role="tooltip">
                    <slot></slot>
                </div>
            </${context.tagFor(AnchoredRegion)}>
        `)}
    `;
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.options.js
var TooltipPosition;
var init_tooltip_options = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.options.js"() {
    TooltipPosition = {
      /**
       * The tooltip is positioned above the element
       */
      top: "top",
      /**
       * The tooltip is positioned to the right of the element
       */
      right: "right",
      /**
       * The tooltip is positioned below the element
       */
      bottom: "bottom",
      /**
       * The tooltip is positioned to the left of the element
       */
      left: "left",
      /**
       * The tooltip is positioned before the element
       */
      start: "start",
      /**
       * The tooltip is positioned after the element
       */
      end: "end",
      /**
       * The tooltip is positioned above the element and to the left
       */
      topLeft: "top-left",
      /**
       * The tooltip is positioned above the element and to the right
       */
      topRight: "top-right",
      /**
       * The tooltip is positioned below the element and to the left
       */
      bottomLeft: "bottom-left",
      /**
       * The tooltip is positioned below the element and to the right
       */
      bottomRight: "bottom-right",
      /**
       * The tooltip is positioned above the element and to the left
       */
      topStart: "top-start",
      /**
       * The tooltip is positioned above the element and to the right
       */
      topEnd: "top-end",
      /**
       * The tooltip is positioned below the element and to the left
       */
      bottomStart: "bottom-start",
      /**
       * The tooltip is positioned below the element and to the right
       */
      bottomEnd: "bottom-end"
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.js
var Tooltip;
var init_tooltip = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tooltip/tooltip.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_direction();
    init_foundation_element();
    init_tooltip_options();
    Tooltip = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.anchor = "";
        this.delay = 300;
        this.autoUpdateMode = "anchor";
        this.anchorElement = null;
        this.viewportElement = null;
        this.verticalPositioningMode = "dynamic";
        this.horizontalPositioningMode = "dynamic";
        this.horizontalInset = "false";
        this.verticalInset = "false";
        this.horizontalScaling = "content";
        this.verticalScaling = "content";
        this.verticalDefaultPosition = void 0;
        this.horizontalDefaultPosition = void 0;
        this.tooltipVisible = false;
        this.currentDirection = Direction.ltr;
        this.showDelayTimer = null;
        this.hideDelayTimer = null;
        this.isAnchorHoveredFocused = false;
        this.isRegionHovered = false;
        this.handlePositionChange = (ev) => {
          this.classList.toggle("top", this.region.verticalPosition === "start");
          this.classList.toggle("bottom", this.region.verticalPosition === "end");
          this.classList.toggle("inset-top", this.region.verticalPosition === "insetStart");
          this.classList.toggle("inset-bottom", this.region.verticalPosition === "insetEnd");
          this.classList.toggle("center-vertical", this.region.verticalPosition === "center");
          this.classList.toggle("left", this.region.horizontalPosition === "start");
          this.classList.toggle("right", this.region.horizontalPosition === "end");
          this.classList.toggle("inset-left", this.region.horizontalPosition === "insetStart");
          this.classList.toggle("inset-right", this.region.horizontalPosition === "insetEnd");
          this.classList.toggle("center-horizontal", this.region.horizontalPosition === "center");
        };
        this.handleRegionMouseOver = (ev) => {
          this.isRegionHovered = true;
        };
        this.handleRegionMouseOut = (ev) => {
          this.isRegionHovered = false;
          this.startHideDelayTimer();
        };
        this.handleAnchorMouseOver = (ev) => {
          if (this.tooltipVisible) {
            this.isAnchorHoveredFocused = true;
            return;
          }
          this.startShowDelayTimer();
        };
        this.handleAnchorMouseOut = (ev) => {
          this.isAnchorHoveredFocused = false;
          this.clearShowDelayTimer();
          this.startHideDelayTimer();
        };
        this.handleAnchorFocusIn = (ev) => {
          this.startShowDelayTimer();
        };
        this.handleAnchorFocusOut = (ev) => {
          this.isAnchorHoveredFocused = false;
          this.clearShowDelayTimer();
          this.startHideDelayTimer();
        };
        this.startHideDelayTimer = () => {
          this.clearHideDelayTimer();
          if (!this.tooltipVisible) {
            return;
          }
          this.hideDelayTimer = window.setTimeout(() => {
            this.updateTooltipVisibility();
          }, 60);
        };
        this.clearHideDelayTimer = () => {
          if (this.hideDelayTimer !== null) {
            clearTimeout(this.hideDelayTimer);
            this.hideDelayTimer = null;
          }
        };
        this.startShowDelayTimer = () => {
          if (this.isAnchorHoveredFocused) {
            return;
          }
          if (this.delay > 1) {
            if (this.showDelayTimer === null)
              this.showDelayTimer = window.setTimeout(() => {
                this.startHover();
              }, this.delay);
            return;
          }
          this.startHover();
        };
        this.startHover = () => {
          this.isAnchorHoveredFocused = true;
          this.updateTooltipVisibility();
        };
        this.clearShowDelayTimer = () => {
          if (this.showDelayTimer !== null) {
            clearTimeout(this.showDelayTimer);
            this.showDelayTimer = null;
          }
        };
        this.getAnchor = () => {
          const rootNode = this.getRootNode();
          if (rootNode instanceof ShadowRoot) {
            return rootNode.getElementById(this.anchor);
          }
          return document.getElementById(this.anchor);
        };
        this.handleDocumentKeydown = (e) => {
          if (!e.defaultPrevented && this.tooltipVisible) {
            switch (e.key) {
              case keyEscape:
                this.isAnchorHoveredFocused = false;
                this.updateTooltipVisibility();
                this.$emit("dismiss");
                break;
            }
          }
        };
        this.updateTooltipVisibility = () => {
          if (this.visible === false) {
            this.hideTooltip();
          } else if (this.visible === true) {
            this.showTooltip();
            return;
          } else {
            if (this.isAnchorHoveredFocused || this.isRegionHovered) {
              this.showTooltip();
              return;
            }
            this.hideTooltip();
          }
        };
        this.showTooltip = () => {
          if (this.tooltipVisible) {
            return;
          }
          this.currentDirection = getDirection(this);
          this.tooltipVisible = true;
          document.addEventListener("keydown", this.handleDocumentKeydown);
          DOM.queueUpdate(this.setRegionProps);
        };
        this.hideTooltip = () => {
          if (!this.tooltipVisible) {
            return;
          }
          this.clearHideDelayTimer();
          if (this.region !== null && this.region !== void 0) {
            this.region.removeEventListener("positionchange", this.handlePositionChange);
            this.region.viewportElement = null;
            this.region.anchorElement = null;
            this.region.removeEventListener("mouseover", this.handleRegionMouseOver);
            this.region.removeEventListener("mouseout", this.handleRegionMouseOut);
          }
          document.removeEventListener("keydown", this.handleDocumentKeydown);
          this.tooltipVisible = false;
        };
        this.setRegionProps = () => {
          if (!this.tooltipVisible) {
            return;
          }
          this.region.viewportElement = this.viewportElement;
          this.region.anchorElement = this.anchorElement;
          this.region.addEventListener("positionchange", this.handlePositionChange);
          this.region.addEventListener("mouseover", this.handleRegionMouseOver, {
            passive: true
          });
          this.region.addEventListener("mouseout", this.handleRegionMouseOut, {
            passive: true
          });
        };
      }
      visibleChanged() {
        if (this.$fastController.isConnected) {
          this.updateTooltipVisibility();
          this.updateLayout();
        }
      }
      anchorChanged() {
        if (this.$fastController.isConnected) {
          this.anchorElement = this.getAnchor();
        }
      }
      positionChanged() {
        if (this.$fastController.isConnected) {
          this.updateLayout();
        }
      }
      anchorElementChanged(oldValue) {
        if (this.$fastController.isConnected) {
          if (oldValue !== null && oldValue !== void 0) {
            oldValue.removeEventListener("mouseover", this.handleAnchorMouseOver);
            oldValue.removeEventListener("mouseout", this.handleAnchorMouseOut);
            oldValue.removeEventListener("focusin", this.handleAnchorFocusIn);
            oldValue.removeEventListener("focusout", this.handleAnchorFocusOut);
          }
          if (this.anchorElement !== null && this.anchorElement !== void 0) {
            this.anchorElement.addEventListener("mouseover", this.handleAnchorMouseOver, { passive: true });
            this.anchorElement.addEventListener("mouseout", this.handleAnchorMouseOut, { passive: true });
            this.anchorElement.addEventListener("focusin", this.handleAnchorFocusIn, {
              passive: true
            });
            this.anchorElement.addEventListener("focusout", this.handleAnchorFocusOut, { passive: true });
            const anchorId = this.anchorElement.id;
            if (this.anchorElement.parentElement !== null) {
              this.anchorElement.parentElement.querySelectorAll(":hover").forEach((element) => {
                if (element.id === anchorId) {
                  this.startShowDelayTimer();
                }
              });
            }
          }
          if (this.region !== null && this.region !== void 0 && this.tooltipVisible) {
            this.region.anchorElement = this.anchorElement;
          }
          this.updateLayout();
        }
      }
      viewportElementChanged() {
        if (this.region !== null && this.region !== void 0) {
          this.region.viewportElement = this.viewportElement;
        }
        this.updateLayout();
      }
      connectedCallback() {
        super.connectedCallback();
        this.anchorElement = this.getAnchor();
        this.updateTooltipVisibility();
      }
      disconnectedCallback() {
        this.hideTooltip();
        this.clearShowDelayTimer();
        this.clearHideDelayTimer();
        super.disconnectedCallback();
      }
      /**
       * updated the properties being passed to the anchored region
       */
      updateLayout() {
        this.verticalPositioningMode = "locktodefault";
        this.horizontalPositioningMode = "locktodefault";
        switch (this.position) {
          case TooltipPosition.top:
          case TooltipPosition.bottom:
            this.verticalDefaultPosition = this.position;
            this.horizontalDefaultPosition = "center";
            break;
          case TooltipPosition.right:
          case TooltipPosition.left:
          case TooltipPosition.start:
          case TooltipPosition.end:
            this.verticalDefaultPosition = "center";
            this.horizontalDefaultPosition = this.position;
            break;
          case TooltipPosition.topLeft:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "left";
            break;
          case TooltipPosition.topRight:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "right";
            break;
          case TooltipPosition.bottomLeft:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "left";
            break;
          case TooltipPosition.bottomRight:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "right";
            break;
          case TooltipPosition.topStart:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "start";
            break;
          case TooltipPosition.topEnd:
            this.verticalDefaultPosition = "top";
            this.horizontalDefaultPosition = "end";
            break;
          case TooltipPosition.bottomStart:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "start";
            break;
          case TooltipPosition.bottomEnd:
            this.verticalDefaultPosition = "bottom";
            this.horizontalDefaultPosition = "end";
            break;
          default:
            this.verticalPositioningMode = "dynamic";
            this.horizontalPositioningMode = "dynamic";
            this.verticalDefaultPosition = void 0;
            this.horizontalDefaultPosition = "center";
            break;
        }
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], Tooltip.prototype, "visible", void 0);
    __decorate5([
      attr
    ], Tooltip.prototype, "anchor", void 0);
    __decorate5([
      attr
    ], Tooltip.prototype, "delay", void 0);
    __decorate5([
      attr
    ], Tooltip.prototype, "position", void 0);
    __decorate5([
      attr({ attribute: "auto-update-mode" })
    ], Tooltip.prototype, "autoUpdateMode", void 0);
    __decorate5([
      attr({ attribute: "horizontal-viewport-lock" })
    ], Tooltip.prototype, "horizontalViewportLock", void 0);
    __decorate5([
      attr({ attribute: "vertical-viewport-lock" })
    ], Tooltip.prototype, "verticalViewportLock", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "anchorElement", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "viewportElement", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "verticalPositioningMode", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "horizontalPositioningMode", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "horizontalInset", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "verticalInset", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "horizontalScaling", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "verticalScaling", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "verticalDefaultPosition", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "horizontalDefaultPosition", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "tooltipVisible", void 0);
    __decorate5([
      observable
    ], Tooltip.prototype, "currentDirection", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tooltip/index.js
var init_tooltip2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tooltip/index.js"() {
    init_tooltip_template();
    init_tooltip();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.template.js
var treeItemTemplate;
var init_tree_item_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.template.js"() {
    init_esm();
    init_start_end();
    treeItemTemplate = (context, definition) => html2`
    <template
        role="treeitem"
        slot="${(x) => x.isNestedItem() ? "item" : void 0}"
        tabindex="-1"
        class="${(x) => x.expanded ? "expanded" : ""} ${(x) => x.selected ? "selected" : ""} ${(x) => x.nested ? "nested" : ""}
            ${(x) => x.disabled ? "disabled" : ""}"
        aria-expanded="${(x) => x.childItems && x.childItemLength() > 0 ? x.expanded : void 0}"
        aria-selected="${(x) => x.selected}"
        aria-disabled="${(x) => x.disabled}"
        @focusin="${(x, c) => x.handleFocus(c.event)}"
        @focusout="${(x, c) => x.handleBlur(c.event)}"
        ${children({
      property: "childItems",
      filter: elements()
    })}
    >
        <div class="positioning-region" part="positioning-region">
            <div class="content-region" part="content-region">
                ${when((x) => x.childItems && x.childItemLength() > 0, html2`
                        <div
                            aria-hidden="true"
                            class="expand-collapse-button"
                            part="expand-collapse-button"
                            @click="${(x, c) => x.handleExpandCollapseButtonClick(c.event)}"
                            ${ref("expandCollapseButton")}
                        >
                            <slot name="expand-collapse-glyph">
                                ${definition.expandCollapseGlyph || ""}
                            </slot>
                        </div>
                    `)}
                ${startSlotTemplate(context, definition)}
                <slot></slot>
                ${endSlotTemplate(context, definition)}
            </div>
        </div>
        ${when((x) => x.childItems && x.childItemLength() > 0 && (x.expanded || x.renderCollapsedChildren), html2`
                <div role="group" class="items" part="items">
                    <slot name="item" ${slotted("items")}></slot>
                </div>
            `)}
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.js
function isTreeItemElement(el) {
  return isHTMLElement(el) && el.getAttribute("role") === "treeitem";
}
var TreeItem;
var init_tree_item = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tree-item/tree-item.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_start_end();
    init_apply_mixins();
    init_foundation_element();
    TreeItem = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.expanded = false;
        this.focusable = false;
        this.isNestedItem = () => {
          return isTreeItemElement(this.parentElement);
        };
        this.handleExpandCollapseButtonClick = (e) => {
          if (!this.disabled && !e.defaultPrevented) {
            this.expanded = !this.expanded;
          }
        };
        this.handleFocus = (e) => {
          this.setAttribute("tabindex", "0");
        };
        this.handleBlur = (e) => {
          this.setAttribute("tabindex", "-1");
        };
      }
      expandedChanged() {
        if (this.$fastController.isConnected) {
          this.$emit("expanded-change", this);
        }
      }
      selectedChanged() {
        if (this.$fastController.isConnected) {
          this.$emit("selected-change", this);
        }
      }
      itemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
          this.items.forEach((node) => {
            if (isTreeItemElement(node)) {
              node.nested = true;
            }
          });
        }
      }
      /**
       * Places document focus on a tree item
       *
       * @public
       * @param el - the element to focus
       */
      static focusItem(el) {
        el.focusable = true;
        el.focus();
      }
      /**
       * Gets number of children
       *
       * @internal
       */
      childItemLength() {
        const treeChildren = this.childItems.filter((item) => {
          return isTreeItemElement(item);
        });
        return treeChildren ? treeChildren.length : 0;
      }
    };
    __decorate5([
      attr({ mode: "boolean" })
    ], TreeItem.prototype, "expanded", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], TreeItem.prototype, "selected", void 0);
    __decorate5([
      attr({ mode: "boolean" })
    ], TreeItem.prototype, "disabled", void 0);
    __decorate5([
      observable
    ], TreeItem.prototype, "focusable", void 0);
    __decorate5([
      observable
    ], TreeItem.prototype, "childItems", void 0);
    __decorate5([
      observable
    ], TreeItem.prototype, "items", void 0);
    __decorate5([
      observable
    ], TreeItem.prototype, "nested", void 0);
    __decorate5([
      observable
    ], TreeItem.prototype, "renderCollapsedChildren", void 0);
    applyMixins(TreeItem, StartEnd);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tree-item/index.js
var init_tree_item2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tree-item/index.js"() {
    init_tree_item_template();
    init_tree_item();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.template.js
var treeViewTemplate;
var init_tree_view_template = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.template.js"() {
    init_esm();
    treeViewTemplate = (context, definition) => html2`
    <template
        role="tree"
        ${ref("treeView")}
        @keydown="${(x, c) => x.handleKeyDown(c.event)}"
        @focusin="${(x, c) => x.handleFocus(c.event)}"
        @focusout="${(x, c) => x.handleBlur(c.event)}"
        @click="${(x, c) => x.handleClick(c.event)}"
        @selected-change="${(x, c) => x.handleSelectedChange(c.event)}"
    >
        <slot ${slotted("slottedTreeItems")}></slot>
    </template>
`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.js
var TreeView;
var init_tree_view = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.js"() {
    init_tslib_es62();
    init_esm();
    init_dist2();
    init_tree_item();
    init_foundation_element();
    TreeView = class extends FoundationElement {
      constructor() {
        super(...arguments);
        this.currentFocused = null;
        this.handleFocus = (e) => {
          if (this.slottedTreeItems.length < 1) {
            return;
          }
          if (e.target === this) {
            if (this.currentFocused === null) {
              this.currentFocused = this.getValidFocusableItem();
            }
            if (this.currentFocused !== null) {
              TreeItem.focusItem(this.currentFocused);
            }
            return;
          }
          if (this.contains(e.target)) {
            this.setAttribute("tabindex", "-1");
            this.currentFocused = e.target;
          }
        };
        this.handleBlur = (e) => {
          if (e.target instanceof HTMLElement && (e.relatedTarget === null || !this.contains(e.relatedTarget))) {
            this.setAttribute("tabindex", "0");
          }
        };
        this.handleKeyDown = (e) => {
          if (e.defaultPrevented) {
            return;
          }
          if (this.slottedTreeItems.length < 1) {
            return true;
          }
          const treeItems = this.getVisibleNodes();
          switch (e.key) {
            case keyHome:
              if (treeItems.length) {
                TreeItem.focusItem(treeItems[0]);
              }
              return;
            case keyEnd:
              if (treeItems.length) {
                TreeItem.focusItem(treeItems[treeItems.length - 1]);
              }
              return;
            case keyArrowLeft:
              if (e.target && this.isFocusableElement(e.target)) {
                const item = e.target;
                if (item instanceof TreeItem && item.childItemLength() > 0 && item.expanded) {
                  item.expanded = false;
                } else if (item instanceof TreeItem && item.parentElement instanceof TreeItem) {
                  TreeItem.focusItem(item.parentElement);
                }
              }
              return false;
            case keyArrowRight:
              if (e.target && this.isFocusableElement(e.target)) {
                const item = e.target;
                if (item instanceof TreeItem && item.childItemLength() > 0 && !item.expanded) {
                  item.expanded = true;
                } else if (item instanceof TreeItem && item.childItemLength() > 0) {
                  this.focusNextNode(1, e.target);
                }
              }
              return;
            case keyArrowDown:
              if (e.target && this.isFocusableElement(e.target)) {
                this.focusNextNode(1, e.target);
              }
              return;
            case keyArrowUp:
              if (e.target && this.isFocusableElement(e.target)) {
                this.focusNextNode(-1, e.target);
              }
              return;
            case keyEnter:
              this.handleClick(e);
              return;
          }
          return true;
        };
        this.handleSelectedChange = (e) => {
          if (e.defaultPrevented) {
            return;
          }
          if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {
            return true;
          }
          const item = e.target;
          if (item.selected) {
            if (this.currentSelected && this.currentSelected !== item) {
              this.currentSelected.selected = false;
            }
            this.currentSelected = item;
          } else if (!item.selected && this.currentSelected === item) {
            this.currentSelected = null;
          }
          return;
        };
        this.setItems = () => {
          const selectedItem = this.treeView.querySelector("[aria-selected='true']");
          this.currentSelected = selectedItem;
          if (this.currentFocused === null || !this.contains(this.currentFocused)) {
            this.currentFocused = this.getValidFocusableItem();
          }
          this.nested = this.checkForNestedItems();
          const treeItems = this.getVisibleNodes();
          treeItems.forEach((node) => {
            if (isTreeItemElement(node)) {
              node.nested = this.nested;
            }
          });
        };
        this.isFocusableElement = (el) => {
          return isTreeItemElement(el);
        };
        this.isSelectedElement = (el) => {
          return el.selected;
        };
      }
      slottedTreeItemsChanged() {
        if (this.$fastController.isConnected) {
          this.setItems();
        }
      }
      connectedCallback() {
        super.connectedCallback();
        this.setAttribute("tabindex", "0");
        DOM.queueUpdate(() => {
          this.setItems();
        });
      }
      /**
       * Handles click events bubbling up
       *
       *  @internal
       */
      handleClick(e) {
        if (e.defaultPrevented) {
          return;
        }
        if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {
          return true;
        }
        const item = e.target;
        if (!item.disabled) {
          item.selected = !item.selected;
        }
        return;
      }
      /**
       * Move focus to a tree item based on its offset from the provided item
       */
      focusNextNode(delta, item) {
        const visibleNodes = this.getVisibleNodes();
        if (!visibleNodes) {
          return;
        }
        const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];
        if (isHTMLElement(focusItem)) {
          TreeItem.focusItem(focusItem);
        }
      }
      /**
       * checks if there are any nested tree items
       */
      getValidFocusableItem() {
        const treeItems = this.getVisibleNodes();
        let focusIndex = treeItems.findIndex(this.isSelectedElement);
        if (focusIndex === -1) {
          focusIndex = treeItems.findIndex(this.isFocusableElement);
        }
        if (focusIndex !== -1) {
          return treeItems[focusIndex];
        }
        return null;
      }
      /**
       * checks if there are any nested tree items
       */
      checkForNestedItems() {
        return this.slottedTreeItems.some((node) => {
          return isTreeItemElement(node) && node.querySelector("[role='treeitem']");
        });
      }
      getVisibleNodes() {
        return getDisplayedNodes(this, "[role='treeitem']") || [];
      }
    };
    __decorate5([
      attr({ attribute: "render-collapsed-nodes" })
    ], TreeView.prototype, "renderCollapsedNodes", void 0);
    __decorate5([
      observable
    ], TreeView.prototype, "currentSelected", void 0);
    __decorate5([
      observable
    ], TreeView.prototype, "slottedTreeItems", void 0);
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/tree-view/index.js
var init_tree_view2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/tree-view/index.js"() {
    init_tree_view_template();
    init_tree_view();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/match-media-stylesheet-behavior.js
var MatchMediaBehavior, MatchMediaStyleSheetBehavior, forcedColorsStylesheetBehavior, darkModeStylesheetBehavior, lightModeStylesheetBehavior;
var init_match_media_stylesheet_behavior = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/match-media-stylesheet-behavior.js"() {
    MatchMediaBehavior = class {
      /**
       *
       * @param query - The media query to operate from.
       */
      constructor(query) {
        this.listenerCache = /* @__PURE__ */ new WeakMap();
        this.query = query;
      }
      /**
       * Binds the behavior to the element.
       * @param source - The element for which the behavior is bound.
       */
      bind(source) {
        const { query } = this;
        const listener = this.constructListener(source);
        listener.bind(query)();
        query.addListener(listener);
        this.listenerCache.set(source, listener);
      }
      /**
       * Unbinds the behavior from the element.
       * @param source - The element for which the behavior is unbinding.
       */
      unbind(source) {
        const listener = this.listenerCache.get(source);
        if (listener) {
          this.query.removeListener(listener);
          this.listenerCache.delete(source);
        }
      }
    };
    MatchMediaStyleSheetBehavior = class extends MatchMediaBehavior {
      /**
       * Constructs a {@link MatchMediaStyleSheetBehavior} instance.
       * @param query - The media query to operate from.
       * @param styles - The styles to coordinate with the query.
       */
      constructor(query, styles22) {
        super(query);
        this.styles = styles22;
      }
      /**
       * Defines a function to construct {@link MatchMediaStyleSheetBehavior | MatchMediaStyleSheetBehaviors} for
       * a provided query.
       * @param query - The media query to operate from.
       *
       * @public
       * @example
       *
       * ```ts
       * import { css } from "@microsoft/fast-element";
       * import { MatchMediaStyleSheetBehavior } from "@microsoft/fast-foundation";
       *
       * const landscapeBehavior = MatchMediaStyleSheetBehavior.with(
       *   window.matchMedia("(orientation: landscape)")
       * );
       * const styles = css`
       *   :host {
       *     width: 200px;
       *     height: 400px;
       *   }
       * `
       * .withBehaviors(landscapeBehavior(css`
       *   :host {
       *     width: 400px;
       *     height: 200px;
       *   }
       * `))
       * ```
       */
      static with(query) {
        return (styles22) => {
          return new MatchMediaStyleSheetBehavior(query, styles22);
        };
      }
      /**
       * Constructs a match-media listener for a provided element.
       * @param source - the element for which to attach or detach styles.
       * @internal
       */
      constructListener(source) {
        let attached = false;
        const styles22 = this.styles;
        return function listener() {
          const { matches: matches2 } = this;
          if (matches2 && !attached) {
            source.$fastController.addStyles(styles22);
            attached = matches2;
          } else if (!matches2 && attached) {
            source.$fastController.removeStyles(styles22);
            attached = matches2;
          }
        };
      }
      /**
       * Unbinds the behavior from the element.
       * @param source - The element for which the behavior is unbinding.
       * @internal
       */
      unbind(source) {
        super.unbind(source);
        source.$fastController.removeStyles(this.styles);
      }
    };
    forcedColorsStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(forced-colors)"));
    darkModeStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: dark)"));
    lightModeStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: light)"));
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/property-stylesheet-behavior.js
var PropertyStyleSheetBehavior;
var init_property_stylesheet_behavior = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/property-stylesheet-behavior.js"() {
    init_esm();
    PropertyStyleSheetBehavior = class {
      /**
       * Constructs a {@link PropertyStyleSheetBehavior} instance.
       * @param propertyName - The property name to operate from.
       * @param value - The property value to operate from.
       * @param styles - The styles to coordinate with the property.
       */
      constructor(propertyName, value, styles22) {
        this.propertyName = propertyName;
        this.value = value;
        this.styles = styles22;
      }
      /**
       * Binds the behavior to the element.
       * @param elementInstance - The element for which the property is applied.
       */
      bind(elementInstance) {
        Observable.getNotifier(elementInstance).subscribe(this, this.propertyName);
        this.handleChange(elementInstance, this.propertyName);
      }
      /**
       * Unbinds the behavior from the element.
       * @param source - The element for which the behavior is unbinding.
       * @internal
       */
      unbind(source) {
        Observable.getNotifier(source).unsubscribe(this, this.propertyName);
        source.$fastController.removeStyles(this.styles);
      }
      /**
       * Change event for the provided element.
       * @param source - the element for which to attach or detach styles.
       * @param key - the key to lookup to know if the element already has the styles
       * @internal
       */
      handleChange(source, key) {
        if (source[key] === this.value) {
          source.$fastController.addStyles(this.styles);
        } else {
          source.$fastController.removeStyles(this.styles);
        }
      }
    };
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/disabled.js
var disabledCursor;
var init_disabled = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/disabled.js"() {
    disabledCursor = "not-allowed";
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/display.js
function display(displayValue) {
  return `${hidden}:host{display:${displayValue}}`;
}
var hidden;
var init_display = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/display.js"() {
    hidden = `:host([hidden]){display:none}`;
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/focus.js
var focusVisible;
var init_focus = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/focus.js"() {
    init_dist2();
    focusVisible = canUseFocusVisible() ? "focus-visible" : "focus";
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/index.js
var init_style = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/style/index.js"() {
    init_disabled();
    init_display();
    init_focus();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/utilities/index.js
var init_utilities = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/utilities/index.js"() {
    init_apply_mixins();
    init_composed_parent();
    init_composed_contains();
    init_match_media_stylesheet_behavior();
    init_property_stylesheet_behavior();
    init_style();
    init_direction();
    init_whitespace_filter();
  }
});

// node_modules/@microsoft/fast-foundation/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/@microsoft/fast-foundation/dist/esm/index.js"() {
    init_accordion_item2();
    init_accordion2();
    init_anchor2();
    init_anchored_region2();
    init_avatar2();
    init_badge2();
    init_breadcrumb_item2();
    init_breadcrumb2();
    init_button2();
    init_calendar2();
    init_card2();
    init_checkbox2();
    init_combobox2();
    init_data_grid2();
    init_design_system2();
    init_design_token();
    init_interfaces();
    init_di2();
    init_dialog2();
    init_reflect_attributes();
    init_disclosure2();
    init_divider2();
    init_flipper2();
    init_form_associated2();
    init_foundation_element2();
    init_listbox_option2();
    init_listbox2();
    init_picker2();
    init_menu_item2();
    init_menu2();
    init_number_field2();
    init_patterns();
    init_progress_ring();
    init_progress();
    init_radio_group2();
    init_radio2();
    init_horizontal_scroll2();
    init_search2();
    init_select2();
    init_skeleton2();
    init_slider_label2();
    init_slider2();
    init_switch2();
    init_tab_panel2();
    init_tab2();
    init_tabs2();
    init_text_area2();
    init_text_field2();
    init_toolbar2();
    init_tooltip2();
    init_tree_item2();
    init_tree_view2();
    init_utilities();
  }
});

// node_modules/@microsoft/fast-colors/dist/math-utilities.js
function clamp(i, min, max) {
  if (isNaN(i) || i <= min) {
    return min;
  } else if (i >= max) {
    return max;
  }
  return i;
}
function normalize(i, min, max) {
  if (isNaN(i) || i <= min) {
    return 0;
  } else if (i >= max) {
    return 1;
  }
  return i / (max - min);
}
function denormalize(i, min, max) {
  if (isNaN(i)) {
    return min;
  }
  return min + i * (max - min);
}
function degreesToRadians(i) {
  return i * (Math.PI / 180);
}
function radiansToDegrees(i) {
  return i * (180 / Math.PI);
}
function getHexStringForByte(i) {
  const s = Math.round(clamp(i, 0, 255)).toString(16);
  if (s.length === 1) {
    return "0" + s;
  }
  return s;
}
function lerp(i, min, max) {
  if (isNaN(i) || i <= 0) {
    return min;
  } else if (i >= 1) {
    return max;
  }
  return min + i * (max - min);
}
function lerpAnglesInDegrees(i, min, max) {
  if (i <= 0) {
    return min % 360;
  } else if (i >= 1) {
    return max % 360;
  }
  const a = (min - max + 360) % 360;
  const b = (max - min + 360) % 360;
  if (a <= b) {
    return (min - a * i + 360) % 360;
  }
  return (min + a * i + 360) % 360;
}
function roundToPrecisionSmall(i, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(i * factor) / factor;
}
var TwoPI;
var init_math_utilities = __esm({
  "node_modules/@microsoft/fast-colors/dist/math-utilities.js"() {
    TwoPI = Math.PI * 2;
  }
});

// node_modules/@microsoft/fast-colors/dist/color-hsl.js
var ColorHSL;
var init_color_hsl = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-hsl.js"() {
    init_math_utilities();
    ColorHSL = class {
      constructor(hue, sat, lum) {
        this.h = hue;
        this.s = sat;
        this.l = lum;
      }
      /**
       * Construct a {@link ColorHSL} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.h) && !isNaN(data.s) && !isNaN(data.l)) {
          return new ColorHSL(data.h, data.s, data.l);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.h === rhs.h && this.s === rhs.s && this.l === rhs.l;
      }
      /**
       * Returns a new {@link ColorHSL} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorHSL(roundToPrecisionSmall(this.h, precision), roundToPrecisionSmall(this.s, precision), roundToPrecisionSmall(this.l, precision));
      }
      /**
       * Returns the {@link ColorHSL} formatted as an object.
       */
      toObject() {
        return { h: this.h, s: this.s, l: this.l };
      }
    };
  }
});

// node_modules/@microsoft/fast-colors/dist/color-hsv.js
var ColorHSV;
var init_color_hsv = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-hsv.js"() {
    init_math_utilities();
    ColorHSV = class {
      constructor(hue, sat, val) {
        this.h = hue;
        this.s = sat;
        this.v = val;
      }
      /**
       * Construct a {@link ColorHSV} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.h) && !isNaN(data.s) && !isNaN(data.v)) {
          return new ColorHSV(data.h, data.s, data.v);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.h === rhs.h && this.s === rhs.s && this.v === rhs.v;
      }
      /**
       * Returns a new {@link ColorHSV} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorHSV(roundToPrecisionSmall(this.h, precision), roundToPrecisionSmall(this.s, precision), roundToPrecisionSmall(this.v, precision));
      }
      /**
       * Returns the {@link ColorHSV} formatted as an object.
       */
      toObject() {
        return { h: this.h, s: this.s, v: this.v };
      }
    };
  }
});

// node_modules/@microsoft/fast-colors/dist/color-lab.js
var ColorLAB;
var init_color_lab = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-lab.js"() {
    init_math_utilities();
    ColorLAB = class {
      constructor(l, a, b) {
        this.l = l;
        this.a = a;
        this.b = b;
      }
      /**
       * Construct a {@link ColorLAB} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.l) && !isNaN(data.a) && !isNaN(data.b)) {
          return new ColorLAB(data.l, data.a, data.b);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.l === rhs.l && this.a === rhs.a && this.b === rhs.b;
      }
      /**
       * Returns a new {@link ColorLAB} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorLAB(roundToPrecisionSmall(this.l, precision), roundToPrecisionSmall(this.a, precision), roundToPrecisionSmall(this.b, precision));
      }
      /**
       * Returns the {@link ColorLAB} formatted as an object.
       */
      toObject() {
        return { l: this.l, a: this.a, b: this.b };
      }
    };
    ColorLAB.epsilon = 216 / 24389;
    ColorLAB.kappa = 24389 / 27;
  }
});

// node_modules/@microsoft/fast-colors/dist/color-lch.js
var ColorLCH;
var init_color_lch = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-lch.js"() {
    init_math_utilities();
    ColorLCH = class {
      constructor(l, c, h) {
        this.l = l;
        this.c = c;
        this.h = h;
      }
      /**
       * Construct a {@link ColorLCH} from a config object.
       * @param data - the config object
       */
      static fromObject(data) {
        if (data && !isNaN(data.l) && !isNaN(data.c) && !isNaN(data.h)) {
          return new ColorLCH(data.l, data.c, data.h);
        }
        return null;
      }
      /**
       * Determines if one color is equal to another.
       * @param rhs - the color to compare
       */
      equalValue(rhs) {
        return this.l === rhs.l && this.c === rhs.c && this.h === rhs.h;
      }
      /**
       * Returns a new {@link ColorLCH} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorLCH(roundToPrecisionSmall(this.l, precision), roundToPrecisionSmall(this.c, precision), roundToPrecisionSmall(this.h, precision));
      }
      /**
       * Converts the {@link ColorLCH} to a config object.
       */
      toObject() {
        return { l: this.l, c: this.c, h: this.h };
      }
    };
  }
});

// node_modules/@microsoft/fast-colors/dist/color-rgba-64.js
var ColorRGBA64;
var init_color_rgba_64 = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-rgba-64.js"() {
    init_math_utilities();
    ColorRGBA64 = class {
      /**
       *
       * @param red - the red value
       * @param green - the green value
       * @param blue - the blue value
       * @param alpha - the alpha value
       */
      constructor(red, green, blue, alpha) {
        this.r = red;
        this.g = green;
        this.b = blue;
        this.a = typeof alpha === "number" && !isNaN(alpha) ? alpha : 1;
      }
      /**
       * Construct a {@link ColorRGBA64} from a {@link ColorRGBA64Config}
       * @param data - the config object
       */
      static fromObject(data) {
        return data && !isNaN(data.r) && !isNaN(data.g) && !isNaN(data.b) ? new ColorRGBA64(data.r, data.g, data.b, data.a) : null;
      }
      /**
       * Determines if one color is equal to another.
       * @param rhs - the color to compare
       */
      equalValue(rhs) {
        return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
      }
      /**
       * Returns the color formatted as a string; #RRGGBB
       */
      toStringHexRGB() {
        return "#" + [this.r, this.g, this.b].map(this.formatHexValue).join("");
      }
      /**
       * Returns the color formatted as a string; #RRGGBBAA
       */
      toStringHexRGBA() {
        return this.toStringHexRGB() + this.formatHexValue(this.a);
      }
      /**
       * Returns the color formatted as a string; #AARRGGBB
       */
      toStringHexARGB() {
        return "#" + [this.a, this.r, this.g, this.b].map(this.formatHexValue).join("");
      }
      /**
       * Returns the color formatted as a string; "rgb(0xRR, 0xGG, 0xBB)"
       */
      toStringWebRGB() {
        return `rgb(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))})`;
      }
      /**
       * Returns the color formatted as a string; "rgba(0xRR, 0xGG, 0xBB, a)"
       * @remarks
       * Note that this follows the convention of putting alpha in the range [0.0,1.0] while the other three channels are [0,255]
       */
      toStringWebRGBA() {
        return `rgba(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))},${clamp(this.a, 0, 1)})`;
      }
      /**
       * Returns a new {@link ColorRGBA64} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorRGBA64(roundToPrecisionSmall(this.r, precision), roundToPrecisionSmall(this.g, precision), roundToPrecisionSmall(this.b, precision), roundToPrecisionSmall(this.a, precision));
      }
      /**
       * Returns a new {@link ColorRGBA64} with channel values clamped between 0 and 1.
       */
      clamp() {
        return new ColorRGBA64(clamp(this.r, 0, 1), clamp(this.g, 0, 1), clamp(this.b, 0, 1), clamp(this.a, 0, 1));
      }
      /**
       * Converts the {@link ColorRGBA64} to a {@link ColorRGBA64Config}.
       */
      toObject() {
        return { r: this.r, g: this.g, b: this.b, a: this.a };
      }
      formatHexValue(value) {
        return getHexStringForByte(denormalize(value, 0, 255));
      }
    };
  }
});

// node_modules/@microsoft/fast-colors/dist/color-xyz.js
var ColorXYZ;
var init_color_xyz = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-xyz.js"() {
    init_math_utilities();
    ColorXYZ = class {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      /**
       * Construct a {@link ColorXYZ} from a config object.
       */
      static fromObject(data) {
        if (data && !isNaN(data.x) && !isNaN(data.y) && !isNaN(data.z)) {
          return new ColorXYZ(data.x, data.y, data.z);
        }
        return null;
      }
      /**
       * Determines if a color is equal to another
       * @param rhs - the value to compare
       */
      equalValue(rhs) {
        return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
      }
      /**
       * Returns a new {@link ColorXYZ} rounded to the provided precision
       * @param precision - the precision to round to
       */
      roundToPrecision(precision) {
        return new ColorXYZ(roundToPrecisionSmall(this.x, precision), roundToPrecisionSmall(this.y, precision), roundToPrecisionSmall(this.z, precision));
      }
      /**
       * Returns the {@link ColorXYZ} formatted as an object.
       */
      toObject() {
        return { x: this.x, y: this.y, z: this.z };
      }
    };
    ColorXYZ.whitePoint = new ColorXYZ(0.95047, 1, 1.08883);
  }
});

// node_modules/@microsoft/fast-colors/dist/color-converters.js
function rgbToLinearLuminance(rgb) {
  return rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;
}
function rgbToRelativeLuminance(rgb) {
  function luminanceHelper(i) {
    if (i <= 0.03928) {
      return i / 12.92;
    }
    return Math.pow((i + 0.055) / 1.055, 2.4);
  }
  return rgbToLinearLuminance(new ColorRGBA64(luminanceHelper(rgb.r), luminanceHelper(rgb.g), luminanceHelper(rgb.b), 1));
}
function contrastRatio(a, b) {
  const luminanceA = rgbToRelativeLuminance(a);
  const luminanceB = rgbToRelativeLuminance(b);
  return luminanceA > luminanceB ? calculateContrastRatio(luminanceA, luminanceB) : calculateContrastRatio(luminanceB, luminanceA);
}
function calcChannelOverlay(match, background, overlay) {
  if (overlay - background === 0) {
    return 0;
  } else {
    return (match - background) / (overlay - background);
  }
}
function calcRgbOverlay(rgbMatch, rgbBackground, rgbOverlay) {
  const rChannel = calcChannelOverlay(rgbMatch.r, rgbBackground.r, rgbOverlay.r);
  const gChannel = calcChannelOverlay(rgbMatch.g, rgbBackground.g, rgbOverlay.g);
  const bChannel = calcChannelOverlay(rgbMatch.b, rgbBackground.b, rgbOverlay.b);
  return (rChannel + gChannel + bChannel) / 3;
}
function calculateOverlayColor(rgbMatch, rgbBackground, rgbOverlay = null) {
  let alpha = 0;
  let overlay = rgbOverlay;
  if (overlay !== null) {
    alpha = calcRgbOverlay(rgbMatch, rgbBackground, overlay);
  } else {
    overlay = new ColorRGBA64(0, 0, 0, 1);
    alpha = calcRgbOverlay(rgbMatch, rgbBackground, overlay);
    if (alpha <= 0) {
      overlay = new ColorRGBA64(1, 1, 1, 1);
      alpha = calcRgbOverlay(rgbMatch, rgbBackground, overlay);
    }
  }
  alpha = Math.round(alpha * 1e3) / 1e3;
  return new ColorRGBA64(overlay.r, overlay.g, overlay.b, alpha);
}
function rgbToHSL(rgb) {
  const max = Math.max(rgb.r, rgb.g, rgb.b);
  const min = Math.min(rgb.r, rgb.g, rgb.b);
  const delta = max - min;
  let hue = 0;
  if (delta !== 0) {
    if (max === rgb.r) {
      hue = 60 * ((rgb.g - rgb.b) / delta % 6);
    } else if (max === rgb.g) {
      hue = 60 * ((rgb.b - rgb.r) / delta + 2);
    } else {
      hue = 60 * ((rgb.r - rgb.g) / delta + 4);
    }
  }
  if (hue < 0) {
    hue += 360;
  }
  const lum = (max + min) / 2;
  let sat = 0;
  if (delta !== 0) {
    sat = delta / (1 - Math.abs(2 * lum - 1));
  }
  return new ColorHSL(hue, sat, lum);
}
function hslToRGB(hsl, alpha = 1) {
  const c = (1 - Math.abs(2 * hsl.l - 1)) * hsl.s;
  const x = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));
  const m = hsl.l - c / 2;
  let r = 0;
  let g = 0;
  let b = 0;
  if (hsl.h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (hsl.h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (hsl.h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (hsl.h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (hsl.h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (hsl.h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  return new ColorRGBA64(r + m, g + m, b + m, alpha);
}
function rgbToHSV(rgb) {
  const max = Math.max(rgb.r, rgb.g, rgb.b);
  const min = Math.min(rgb.r, rgb.g, rgb.b);
  const delta = max - min;
  let hue = 0;
  if (delta !== 0) {
    if (max === rgb.r) {
      hue = 60 * ((rgb.g - rgb.b) / delta % 6);
    } else if (max === rgb.g) {
      hue = 60 * ((rgb.b - rgb.r) / delta + 2);
    } else {
      hue = 60 * ((rgb.r - rgb.g) / delta + 4);
    }
  }
  if (hue < 0) {
    hue += 360;
  }
  let sat = 0;
  if (max !== 0) {
    sat = delta / max;
  }
  return new ColorHSV(hue, sat, max);
}
function hsvToRGB(hsv, alpha = 1) {
  const c = hsv.s * hsv.v;
  const x = c * (1 - Math.abs(hsv.h / 60 % 2 - 1));
  const m = hsv.v - c;
  let r = 0;
  let g = 0;
  let b = 0;
  if (hsv.h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (hsv.h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (hsv.h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (hsv.h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (hsv.h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (hsv.h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  return new ColorRGBA64(r + m, g + m, b + m, alpha);
}
function lchToLAB(lch) {
  let a = 0;
  let b = 0;
  if (lch.h !== 0) {
    a = Math.cos(degreesToRadians(lch.h)) * lch.c;
    b = Math.sin(degreesToRadians(lch.h)) * lch.c;
  }
  return new ColorLAB(lch.l, a, b);
}
function labToLCH(lab) {
  let h = 0;
  if (Math.abs(lab.b) > 1e-3 || Math.abs(lab.a) > 1e-3) {
    h = radiansToDegrees(Math.atan2(lab.b, lab.a));
  }
  if (h < 0) {
    h += 360;
  }
  const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
  return new ColorLCH(lab.l, c, h);
}
function labToXYZ(lab) {
  const fy = (lab.l + 16) / 116;
  const fx = fy + lab.a / 500;
  const fz = fy - lab.b / 200;
  const xcubed = Math.pow(fx, 3);
  const ycubed = Math.pow(fy, 3);
  const zcubed = Math.pow(fz, 3);
  let x = 0;
  if (xcubed > ColorLAB.epsilon) {
    x = xcubed;
  } else {
    x = (116 * fx - 16) / ColorLAB.kappa;
  }
  let y = 0;
  if (lab.l > ColorLAB.epsilon * ColorLAB.kappa) {
    y = ycubed;
  } else {
    y = lab.l / ColorLAB.kappa;
  }
  let z = 0;
  if (zcubed > ColorLAB.epsilon) {
    z = zcubed;
  } else {
    z = (116 * fz - 16) / ColorLAB.kappa;
  }
  x = ColorXYZ.whitePoint.x * x;
  y = ColorXYZ.whitePoint.y * y;
  z = ColorXYZ.whitePoint.z * z;
  return new ColorXYZ(x, y, z);
}
function xyzToLAB(xyz) {
  function xyzToLABHelper(i) {
    if (i > ColorLAB.epsilon) {
      return Math.pow(i, 1 / 3);
    }
    return (ColorLAB.kappa * i + 16) / 116;
  }
  const x = xyzToLABHelper(xyz.x / ColorXYZ.whitePoint.x);
  const y = xyzToLABHelper(xyz.y / ColorXYZ.whitePoint.y);
  const z = xyzToLABHelper(xyz.z / ColorXYZ.whitePoint.z);
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return new ColorLAB(l, a, b);
}
function rgbToXYZ(rgb) {
  function rgbToXYZHelper(i) {
    if (i <= 0.04045) {
      return i / 12.92;
    }
    return Math.pow((i + 0.055) / 1.055, 2.4);
  }
  const r = rgbToXYZHelper(rgb.r);
  const g = rgbToXYZHelper(rgb.g);
  const b = rgbToXYZHelper(rgb.b);
  const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
  const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
  const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
  return new ColorXYZ(x, y, z);
}
function xyzToRGB(xyz, alpha = 1) {
  function xyzToRGBHelper(i) {
    if (i <= 31308e-7) {
      return i * 12.92;
    }
    return 1.055 * Math.pow(i, 1 / 2.4) - 0.055;
  }
  const r = xyzToRGBHelper(xyz.x * 3.2404542 - xyz.y * 1.5371385 - xyz.z * 0.4985314);
  const g = xyzToRGBHelper(xyz.x * -0.969266 + xyz.y * 1.8760108 + xyz.z * 0.041556);
  const b = xyzToRGBHelper(xyz.x * 0.0556434 - xyz.y * 0.2040259 + xyz.z * 1.0572252);
  return new ColorRGBA64(r, g, b, alpha);
}
function rgbToLAB(rgb) {
  return xyzToLAB(rgbToXYZ(rgb));
}
function labToRGB(lab, alpha = 1) {
  return xyzToRGB(labToXYZ(lab), alpha);
}
function rgbToLCH(rgb) {
  return labToLCH(rgbToLAB(rgb));
}
function lchToRGB(lch, alpha = 1) {
  return labToRGB(lchToLAB(lch), alpha);
}
var calculateContrastRatio;
var init_color_converters = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-converters.js"() {
    init_color_hsl();
    init_color_hsv();
    init_color_lab();
    init_color_lch();
    init_color_rgba_64();
    init_color_xyz();
    init_math_utilities();
    calculateContrastRatio = (a, b) => (a + 0.05) / (b + 0.05);
  }
});

// node_modules/@microsoft/fast-colors/dist/color-blending.js
function saturateViaLCH(input, saturation, saturationConstant = 18) {
  const lch = rgbToLCH(input);
  let sat = lch.c + saturation * saturationConstant;
  if (sat < 0) {
    sat = 0;
  }
  return lchToRGB(new ColorLCH(lch.l, sat, lch.h));
}
function blendMultiplyChannel(bottom, top) {
  return bottom * top;
}
function blendMultiply(bottom, top) {
  return new ColorRGBA64(blendMultiplyChannel(bottom.r, top.r), blendMultiplyChannel(bottom.g, top.g), blendMultiplyChannel(bottom.b, top.b), 1);
}
function blendOverlayChannel(bottom, top) {
  if (bottom < 0.5) {
    return clamp(2 * top * bottom, 0, 1);
  }
  return clamp(1 - 2 * (1 - top) * (1 - bottom), 0, 1);
}
function blendOverlay(bottom, top) {
  return new ColorRGBA64(blendOverlayChannel(bottom.r, top.r), blendOverlayChannel(bottom.g, top.g), blendOverlayChannel(bottom.b, top.b), 1);
}
function computeAlphaBlend(bottom, top) {
  if (top.a >= 1) {
    return top;
  } else if (top.a <= 0) {
    return new ColorRGBA64(bottom.r, bottom.g, bottom.b, 1);
  }
  const r = top.a * top.r + (1 - top.a) * bottom.r;
  const g = top.a * top.g + (1 - top.a) * bottom.g;
  const b = top.a * top.b + (1 - top.a) * bottom.b;
  return new ColorRGBA64(r, g, b, 1);
}
var ColorBlendMode;
var init_color_blending = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-blending.js"() {
    init_color_converters();
    init_color_hsl();
    init_color_lab();
    init_color_lch();
    init_color_rgba_64();
    init_math_utilities();
    (function(ColorBlendMode2) {
      ColorBlendMode2[ColorBlendMode2["Burn"] = 0] = "Burn";
      ColorBlendMode2[ColorBlendMode2["Color"] = 1] = "Color";
      ColorBlendMode2[ColorBlendMode2["Darken"] = 2] = "Darken";
      ColorBlendMode2[ColorBlendMode2["Dodge"] = 3] = "Dodge";
      ColorBlendMode2[ColorBlendMode2["Lighten"] = 4] = "Lighten";
      ColorBlendMode2[ColorBlendMode2["Multiply"] = 5] = "Multiply";
      ColorBlendMode2[ColorBlendMode2["Overlay"] = 6] = "Overlay";
      ColorBlendMode2[ColorBlendMode2["Screen"] = 7] = "Screen";
    })(ColorBlendMode || (ColorBlendMode = {}));
  }
});

// node_modules/@microsoft/fast-colors/dist/color-interpolation.js
function interpolateRGB(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorRGBA64(lerp(position, left.r, right.r), lerp(position, left.g, right.g), lerp(position, left.b, right.b), lerp(position, left.a, right.a));
}
function interpolateHSL(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorHSL(lerpAnglesInDegrees(position, left.h, right.h), lerp(position, left.s, right.s), lerp(position, left.l, right.l));
}
function interpolateHSV(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorHSV(lerpAnglesInDegrees(position, left.h, right.h), lerp(position, left.s, right.s), lerp(position, left.v, right.v));
}
function interpolateXYZ(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorXYZ(lerp(position, left.x, right.x), lerp(position, left.y, right.y), lerp(position, left.z, right.z));
}
function interpolateLAB(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorLAB(lerp(position, left.l, right.l), lerp(position, left.a, right.a), lerp(position, left.b, right.b));
}
function interpolateLCH(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorLCH(lerp(position, left.l, right.l), lerp(position, left.c, right.c), lerpAnglesInDegrees(position, left.h, right.h));
}
function interpolateByColorSpace(position, space, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  switch (space) {
    case ColorInterpolationSpace.HSL:
      return hslToRGB(interpolateHSL(position, rgbToHSL(left), rgbToHSL(right)));
    case ColorInterpolationSpace.HSV:
      return hsvToRGB(interpolateHSV(position, rgbToHSV(left), rgbToHSV(right)));
    case ColorInterpolationSpace.XYZ:
      return xyzToRGB(interpolateXYZ(position, rgbToXYZ(left), rgbToXYZ(right)));
    case ColorInterpolationSpace.LAB:
      return labToRGB(interpolateLAB(position, rgbToLAB(left), rgbToLAB(right)));
    case ColorInterpolationSpace.LCH:
      return lchToRGB(interpolateLCH(position, rgbToLCH(left), rgbToLCH(right)));
    default:
      return interpolateRGB(position, left, right);
  }
}
var ColorInterpolationSpace;
var init_color_interpolation = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-interpolation.js"() {
    init_color_converters();
    init_color_hsl();
    init_color_hsv();
    init_color_lab();
    init_color_lch();
    init_color_rgba_64();
    init_color_xyz();
    init_math_utilities();
    (function(ColorInterpolationSpace2) {
      ColorInterpolationSpace2[ColorInterpolationSpace2["RGB"] = 0] = "RGB";
      ColorInterpolationSpace2[ColorInterpolationSpace2["HSL"] = 1] = "HSL";
      ColorInterpolationSpace2[ColorInterpolationSpace2["HSV"] = 2] = "HSV";
      ColorInterpolationSpace2[ColorInterpolationSpace2["XYZ"] = 3] = "XYZ";
      ColorInterpolationSpace2[ColorInterpolationSpace2["LAB"] = 4] = "LAB";
      ColorInterpolationSpace2[ColorInterpolationSpace2["LCH"] = 5] = "LCH";
    })(ColorInterpolationSpace || (ColorInterpolationSpace = {}));
  }
});

// node_modules/@microsoft/fast-colors/dist/color-scale.js
var ColorScale;
var init_color_scale = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-scale.js"() {
    init_color_converters();
    init_color_interpolation();
    ColorScale = class {
      constructor(stops) {
        if (stops == null || stops.length === 0) {
          throw new Error("The stops argument must be non-empty");
        } else {
          this.stops = this.sortColorScaleStops(stops);
        }
      }
      static createBalancedColorScale(colors) {
        if (colors == null || colors.length === 0) {
          throw new Error("The colors argument must be non-empty");
        }
        const stops = new Array(colors.length);
        for (let i = 0; i < colors.length; i++) {
          if (i === 0) {
            stops[i] = { color: colors[i], position: 0 };
          } else if (i === colors.length - 1) {
            stops[i] = { color: colors[i], position: 1 };
          } else {
            stops[i] = {
              color: colors[i],
              position: i * (1 / (colors.length - 1))
            };
          }
        }
        return new ColorScale(stops);
      }
      getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {
        if (this.stops.length === 1) {
          return this.stops[0].color;
        } else if (position <= 0) {
          return this.stops[0].color;
        } else if (position >= 1) {
          return this.stops[this.stops.length - 1].color;
        }
        let lowerIndex = 0;
        for (let i = 0; i < this.stops.length; i++) {
          if (this.stops[i].position <= position) {
            lowerIndex = i;
          }
        }
        let upperIndex = lowerIndex + 1;
        if (upperIndex >= this.stops.length) {
          upperIndex = this.stops.length - 1;
        }
        const scalePosition = (position - this.stops[lowerIndex].position) * (1 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));
        return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);
      }
      trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {
        if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {
          throw new Error("Invalid bounds");
        }
        if (lowerBound === upperBound) {
          return new ColorScale([
            { color: this.getColor(lowerBound, interpolationMode), position: 0 }
          ]);
        }
        const containedStops = [];
        for (let i = 0; i < this.stops.length; i++) {
          if (this.stops[i].position >= lowerBound && this.stops[i].position <= upperBound) {
            containedStops.push(this.stops[i]);
          }
        }
        if (containedStops.length === 0) {
          return new ColorScale([
            { color: this.getColor(lowerBound), position: lowerBound },
            { color: this.getColor(upperBound), position: upperBound }
          ]);
        }
        if (containedStops[0].position !== lowerBound) {
          containedStops.unshift({
            color: this.getColor(lowerBound),
            position: lowerBound
          });
        }
        if (containedStops[containedStops.length - 1].position !== upperBound) {
          containedStops.push({
            color: this.getColor(upperBound),
            position: upperBound
          });
        }
        const range2 = upperBound - lowerBound;
        const finalStops = new Array(containedStops.length);
        for (let i = 0; i < containedStops.length; i++) {
          finalStops[i] = {
            color: containedStops[i].color,
            position: (containedStops[i].position - lowerBound) / range2
          };
        }
        return new ColorScale(finalStops);
      }
      findNextColor(position, contrast2, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 5e-3, maxSearchIterations = 32) {
        if (isNaN(position) || position <= 0) {
          position = 0;
        } else if (position >= 1) {
          position = 1;
        }
        const startingColor = this.getColor(position, interpolationMode);
        const finalPosition = searchDown ? 0 : 1;
        const finalColor = this.getColor(finalPosition, interpolationMode);
        const finalContrast = contrastRatio(startingColor, finalColor);
        if (finalContrast <= contrast2) {
          return finalPosition;
        }
        let testRangeMin = searchDown ? 0 : position;
        let testRangeMax = searchDown ? position : 0;
        let mid = finalPosition;
        let iterations = 0;
        while (iterations <= maxSearchIterations) {
          mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;
          const midColor = this.getColor(mid, interpolationMode);
          const midContrast = contrastRatio(startingColor, midColor);
          if (Math.abs(midContrast - contrast2) <= contrastErrorMargin) {
            return mid;
          } else if (midContrast > contrast2) {
            if (searchDown) {
              testRangeMin = mid;
            } else {
              testRangeMax = mid;
            }
          } else {
            if (searchDown) {
              testRangeMax = mid;
            } else {
              testRangeMin = mid;
            }
          }
          iterations++;
        }
        return mid;
      }
      clone() {
        const newStops = new Array(this.stops.length);
        for (let i = 0; i < newStops.length; i++) {
          newStops[i] = {
            color: this.stops[i].color,
            position: this.stops[i].position
          };
        }
        return new ColorScale(newStops);
      }
      sortColorScaleStops(stops) {
        return stops.sort((a, b) => {
          const A = a.position;
          const B = b.position;
          if (A < B) {
            return -1;
          } else if (A > B) {
            return 1;
          } else {
            return 0;
          }
        });
      }
    };
  }
});

// node_modules/@microsoft/fast-colors/dist/named-colors.js
var init_named_colors = __esm({
  "node_modules/@microsoft/fast-colors/dist/named-colors.js"() {
  }
});

// node_modules/@microsoft/fast-colors/dist/parse-color.js
function parseColorHexRGB(raw) {
  const result = hexRGBRegex.exec(raw);
  if (result === null) {
    return null;
  }
  let digits = result[1];
  if (digits.length === 3) {
    const r = digits.charAt(0);
    const g = digits.charAt(1);
    const b = digits.charAt(2);
    digits = r.concat(r, g, g, b, b);
  }
  const rawInt = parseInt(digits, 16);
  if (isNaN(rawInt)) {
    return null;
  }
  return new ColorRGBA64(normalize((rawInt & 16711680) >>> 16, 0, 255), normalize((rawInt & 65280) >>> 8, 0, 255), normalize(rawInt & 255, 0, 255), 1);
}
var hexRGBRegex;
var init_parse_color = __esm({
  "node_modules/@microsoft/fast-colors/dist/parse-color.js"() {
    init_color_rgba_64();
    init_math_utilities();
    init_named_colors();
    hexRGBRegex = /^#((?:[0-9a-f]{6}|[0-9a-f]{3}))$/i;
  }
});

// node_modules/@microsoft/fast-colors/dist/color-palette.js
var ColorPalette, defaultCenteredRescaleConfig;
var init_color_palette = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-palette.js"() {
    init_color_blending();
    init_color_converters();
    init_color_interpolation();
    init_color_rgba_64();
    init_color_scale();
    init_parse_color();
    ColorPalette = class {
      constructor(config) {
        this.config = Object.assign({}, ColorPalette.defaultPaletteConfig, config);
        this.palette = [];
        this.updatePaletteColors();
      }
      updatePaletteGenerationValues(newConfig) {
        let changed = false;
        for (const key in newConfig) {
          if (this.config[key]) {
            if (this.config[key].equalValue) {
              if (!this.config[key].equalValue(newConfig[key])) {
                this.config[key] = newConfig[key];
                changed = true;
              }
            } else {
              if (newConfig[key] !== this.config[key]) {
                this.config[key] = newConfig[key];
                changed = true;
              }
            }
          }
        }
        if (changed) {
          this.updatePaletteColors();
        }
        return changed;
      }
      updatePaletteColors() {
        const scale = this.generatePaletteColorScale();
        for (let i = 0; i < this.config.steps; i++) {
          this.palette[i] = scale.getColor(i / (this.config.steps - 1), this.config.interpolationMode);
        }
      }
      generatePaletteColorScale() {
        const baseColorHSL = rgbToHSL(this.config.baseColor);
        const baseScale = new ColorScale([
          { position: 0, color: this.config.scaleColorLight },
          { position: 0.5, color: this.config.baseColor },
          { position: 1, color: this.config.scaleColorDark }
        ]);
        const trimmedScale = baseScale.trim(this.config.clipLight, 1 - this.config.clipDark);
        const trimmedLight = trimmedScale.getColor(0);
        const trimmedDark = trimmedScale.getColor(1);
        let adjustedLight = trimmedLight;
        let adjustedDark = trimmedDark;
        if (baseColorHSL.s >= this.config.saturationAdjustmentCutoff) {
          adjustedLight = saturateViaLCH(adjustedLight, this.config.saturationLight);
          adjustedDark = saturateViaLCH(adjustedDark, this.config.saturationDark);
        }
        if (this.config.multiplyLight !== 0) {
          const multiply = blendMultiply(this.config.baseColor, adjustedLight);
          adjustedLight = interpolateByColorSpace(this.config.multiplyLight, this.config.interpolationMode, adjustedLight, multiply);
        }
        if (this.config.multiplyDark !== 0) {
          const multiply = blendMultiply(this.config.baseColor, adjustedDark);
          adjustedDark = interpolateByColorSpace(this.config.multiplyDark, this.config.interpolationMode, adjustedDark, multiply);
        }
        if (this.config.overlayLight !== 0) {
          const overlay = blendOverlay(this.config.baseColor, adjustedLight);
          adjustedLight = interpolateByColorSpace(this.config.overlayLight, this.config.interpolationMode, adjustedLight, overlay);
        }
        if (this.config.overlayDark !== 0) {
          const overlay = blendOverlay(this.config.baseColor, adjustedDark);
          adjustedDark = interpolateByColorSpace(this.config.overlayDark, this.config.interpolationMode, adjustedDark, overlay);
        }
        if (this.config.baseScalePosition) {
          if (this.config.baseScalePosition <= 0) {
            return new ColorScale([
              { position: 0, color: this.config.baseColor },
              { position: 1, color: adjustedDark.clamp() }
            ]);
          } else if (this.config.baseScalePosition >= 1) {
            return new ColorScale([
              { position: 0, color: adjustedLight.clamp() },
              { position: 1, color: this.config.baseColor }
            ]);
          }
          return new ColorScale([
            { position: 0, color: adjustedLight.clamp() },
            {
              position: this.config.baseScalePosition,
              color: this.config.baseColor
            },
            { position: 1, color: adjustedDark.clamp() }
          ]);
        }
        return new ColorScale([
          { position: 0, color: adjustedLight.clamp() },
          { position: 0.5, color: this.config.baseColor },
          { position: 1, color: adjustedDark.clamp() }
        ]);
      }
    };
    ColorPalette.defaultPaletteConfig = {
      baseColor: parseColorHexRGB("#808080"),
      steps: 11,
      interpolationMode: ColorInterpolationSpace.RGB,
      scaleColorLight: new ColorRGBA64(1, 1, 1, 1),
      scaleColorDark: new ColorRGBA64(0, 0, 0, 1),
      clipLight: 0.185,
      clipDark: 0.16,
      saturationAdjustmentCutoff: 0.05,
      saturationLight: 0.35,
      saturationDark: 1.25,
      overlayLight: 0,
      overlayDark: 0.25,
      multiplyLight: 0,
      multiplyDark: 0,
      baseScalePosition: 0.5
    };
    ColorPalette.greyscalePaletteConfig = {
      baseColor: parseColorHexRGB("#808080"),
      steps: 11,
      interpolationMode: ColorInterpolationSpace.RGB,
      scaleColorLight: new ColorRGBA64(1, 1, 1, 1),
      scaleColorDark: new ColorRGBA64(0, 0, 0, 1),
      clipLight: 0,
      clipDark: 0,
      saturationAdjustmentCutoff: 0,
      saturationLight: 0,
      saturationDark: 0,
      overlayLight: 0,
      overlayDark: 0,
      multiplyLight: 0,
      multiplyDark: 0,
      baseScalePosition: 0.5
    };
    defaultCenteredRescaleConfig = {
      targetSize: 63,
      spacing: 4,
      scaleColorLight: ColorPalette.defaultPaletteConfig.scaleColorLight,
      scaleColorDark: ColorPalette.defaultPaletteConfig.scaleColorDark
    };
  }
});

// node_modules/@microsoft/fast-colors/dist/histogram.js
var init_histogram = __esm({
  "node_modules/@microsoft/fast-colors/dist/histogram.js"() {
  }
});

// node_modules/@microsoft/fast-colors/dist/pixel-box.js
var init_pixel_box = __esm({
  "node_modules/@microsoft/fast-colors/dist/pixel-box.js"() {
    init_color_rgba_64();
  }
});

// node_modules/@microsoft/fast-colors/dist/color-quantization.js
var init_color_quantization = __esm({
  "node_modules/@microsoft/fast-colors/dist/color-quantization.js"() {
    init_histogram();
    init_pixel_box();
  }
});

// node_modules/@microsoft/fast-colors/dist/component-state-color-palette.js
var ComponentStateColorPalette;
var init_component_state_color_palette = __esm({
  "node_modules/@microsoft/fast-colors/dist/component-state-color-palette.js"() {
    init_color_rgba_64();
    init_color_palette();
    init_color_converters();
    init_color_scale();
    init_color_hsl();
    init_color_interpolation();
    init_parse_color();
    ComponentStateColorPalette = class {
      constructor(config) {
        this.palette = [];
        this.config = Object.assign({}, ComponentStateColorPalette.defaultPaletteConfig, config);
        this.regenPalettes();
      }
      regenPalettes() {
        let steps = this.config.steps;
        if (isNaN(steps) || steps < 3) {
          steps = 3;
        }
        const darkLum = 0.14;
        const darkestLum = 0.06;
        const darkLumColor = new ColorRGBA64(darkLum, darkLum, darkLum, 1);
        const stepsForLuminanceRamp = 94;
        const r = new ColorPalette(Object.assign(Object.assign({}, ColorPalette.greyscalePaletteConfig), { baseColor: darkLumColor, baseScalePosition: (1 - darkLum) * 100 / stepsForLuminanceRamp, steps }));
        const referencePalette = r.palette;
        const baseColorLum1 = rgbToLinearLuminance(this.config.baseColor);
        const baseColorLum2 = rgbToHSL(this.config.baseColor).l;
        const baseColorLum = (baseColorLum1 + baseColorLum2) / 2;
        const baseColorRefIndex = this.matchRelativeLuminanceIndex(baseColorLum, referencePalette);
        const baseColorPercent = baseColorRefIndex / (steps - 1);
        const darkRefIndex = this.matchRelativeLuminanceIndex(darkLum, referencePalette);
        const darkPercent = darkRefIndex / (steps - 1);
        const baseColorHSL = rgbToHSL(this.config.baseColor);
        const darkBaseColor = hslToRGB(ColorHSL.fromObject({
          h: baseColorHSL.h,
          s: baseColorHSL.s,
          l: darkLum
        }));
        const darkestBaseColor = hslToRGB(ColorHSL.fromObject({
          h: baseColorHSL.h,
          s: baseColorHSL.s,
          l: darkestLum
        }));
        const fullColorScaleStops = new Array(5);
        fullColorScaleStops[0] = {
          position: 0,
          color: new ColorRGBA64(1, 1, 1, 1)
        };
        fullColorScaleStops[1] = {
          position: baseColorPercent,
          color: this.config.baseColor
        };
        fullColorScaleStops[2] = {
          position: darkPercent,
          color: darkBaseColor
        };
        fullColorScaleStops[3] = {
          position: 0.99,
          color: darkestBaseColor
        };
        fullColorScaleStops[4] = {
          position: 1,
          color: new ColorRGBA64(0, 0, 0, 1)
        };
        const scale = new ColorScale(fullColorScaleStops);
        this.palette = new Array(steps);
        for (let i = 0; i < steps; i++) {
          const c = scale.getColor(i / (steps - 1), ColorInterpolationSpace.RGB);
          this.palette[i] = c;
        }
      }
      matchRelativeLuminanceIndex(input, reference) {
        let bestFitValue = Number.MAX_VALUE;
        let bestFitIndex = 0;
        let i = 0;
        const referenceLength = reference.length;
        for (; i < referenceLength; i++) {
          const fitValue = Math.abs(rgbToLinearLuminance(reference[i]) - input);
          if (fitValue < bestFitValue) {
            bestFitValue = fitValue;
            bestFitIndex = i;
          }
        }
        return bestFitIndex;
      }
    };
    ComponentStateColorPalette.defaultPaletteConfig = {
      baseColor: parseColorHexRGB("#808080"),
      steps: 94
    };
  }
});

// node_modules/@microsoft/fast-colors/dist/palette-extractor.js
var init_palette_extractor = __esm({
  "node_modules/@microsoft/fast-colors/dist/palette-extractor.js"() {
    init_color_converters();
  }
});

// node_modules/@microsoft/fast-colors/dist/pixel-blob.js
var init_pixel_blob = __esm({
  "node_modules/@microsoft/fast-colors/dist/pixel-blob.js"() {
    init_color_rgba_64();
  }
});

// node_modules/@microsoft/fast-colors/dist/index.js
var init_dist3 = __esm({
  "node_modules/@microsoft/fast-colors/dist/index.js"() {
    init_color_blending();
    init_color_converters();
    init_color_hsl();
    init_color_hsv();
    init_color_interpolation();
    init_color_lab();
    init_color_lch();
    init_color_palette();
    init_color_quantization();
    init_color_rgba_64();
    init_color_scale();
    init_color_xyz();
    init_component_state_color_palette();
    init_histogram();
    init_math_utilities();
    init_palette_extractor();
    init_parse_color();
    init_pixel_blob();
    init_pixel_box();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/utilities/relative-luminance.js
function contrast(a, b) {
  const L1 = a.relativeLuminance > b.relativeLuminance ? a : b;
  const L2 = a.relativeLuminance > b.relativeLuminance ? b : a;
  return (L1.relativeLuminance + 0.05) / (L2.relativeLuminance + 0.05);
}
var init_relative_luminance = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/utilities/relative-luminance.js"() {
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/swatch.js
function isSwatchRGB(value) {
  const test = {
    r: 0,
    g: 0,
    b: 0,
    toColorString: () => "",
    contrast: () => 0,
    relativeLuminance: 0
  };
  for (const key in test) {
    if (typeof test[key] !== typeof value[key]) {
      return false;
    }
  }
  return true;
}
var SwatchRGB, SwatchRGBImpl;
var init_swatch = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/swatch.js"() {
    init_dist3();
    init_relative_luminance();
    SwatchRGB = Object.freeze({
      create(r, g, b) {
        return new SwatchRGBImpl(r, g, b);
      },
      from(obj) {
        return new SwatchRGBImpl(obj.r, obj.g, obj.b);
      }
    });
    SwatchRGBImpl = class extends ColorRGBA64 {
      /**
       *
       * @param red - Red channel expressed as a number between 0 and 1
       * @param green - Green channel expressed as a number between 0 and 1
       * @param blue - Blue channel expressed as a number between 0 and 1
       */
      constructor(red, green, blue) {
        super(red, green, blue, 1);
        this.toColorString = this.toStringHexRGB;
        this.contrast = contrast.bind(null, this);
        this.createCSS = this.toColorString;
        this.relativeLuminance = rgbToRelativeLuminance(this);
      }
      static fromObject(obj) {
        return new SwatchRGBImpl(obj.r, obj.g, obj.b);
      }
    };
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/utilities/binary-search.js
function binarySearch(valuesToSearch, searchCondition, startIndex = 0, endIndex = valuesToSearch.length - 1) {
  if (endIndex === startIndex) {
    return valuesToSearch[startIndex];
  }
  const middleIndex = Math.floor((endIndex - startIndex) / 2) + startIndex;
  return searchCondition(valuesToSearch[middleIndex]) ? binarySearch(valuesToSearch, searchCondition, startIndex, middleIndex) : binarySearch(
    valuesToSearch,
    searchCondition,
    middleIndex + 1,
    // exclude this index because it failed the search condition
    endIndex
  );
}
var init_binary_search = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/utilities/binary-search.js"() {
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/utilities/is-dark.js
function isDark(color) {
  return color.relativeLuminance <= target;
}
var target;
var init_is_dark = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/utilities/is-dark.js"() {
    target = (-0.1 + Math.sqrt(0.21)) / 2;
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/utilities/direction-by-is-dark.js
function directionByIsDark(color) {
  return isDark(color) ? -1 : 1;
}
var init_direction_by_is_dark = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/utilities/direction-by-is-dark.js"() {
    init_is_dark();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/palette.js
function create2(rOrSource, g, b) {
  if (typeof rOrSource === "number") {
    return PaletteRGB.from(SwatchRGB.create(rOrSource, g, b));
  } else {
    return PaletteRGB.from(rOrSource);
  }
}
function from(source, options) {
  return isSwatchRGB(source) ? PaletteRGBImpl.from(source, options) : PaletteRGBImpl.from(SwatchRGB.create(source.r, source.g, source.b), options);
}
var defaultPaletteRGBOptions, PaletteRGB, PaletteRGBImpl;
var init_palette = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/palette.js"() {
    init_dist3();
    init_swatch();
    init_binary_search();
    init_direction_by_is_dark();
    init_relative_luminance();
    defaultPaletteRGBOptions = {
      stepContrast: 1.03,
      stepContrastRamp: 0.03,
      preserveSource: false
    };
    PaletteRGB = Object.freeze({
      create: create2,
      from
    });
    PaletteRGBImpl = class {
      /**
       *
       * @param source - The source color for the palette
       * @param swatches - All swatches in the palette
       */
      constructor(source, swatches) {
        this.closestIndexCache = /* @__PURE__ */ new Map();
        this.source = source;
        this.swatches = swatches;
        this.reversedSwatches = Object.freeze([...this.swatches].reverse());
        this.lastIndex = this.swatches.length - 1;
      }
      /**
       * {@inheritdoc Palette.colorContrast}
       */
      colorContrast(reference, contrastTarget, initialSearchIndex, direction2) {
        if (initialSearchIndex === void 0) {
          initialSearchIndex = this.closestIndexOf(reference);
        }
        let source = this.swatches;
        const endSearchIndex = this.lastIndex;
        let startSearchIndex = initialSearchIndex;
        if (direction2 === void 0) {
          direction2 = directionByIsDark(reference);
        }
        const condition = (value) => contrast(reference, value) >= contrastTarget;
        if (direction2 === -1) {
          source = this.reversedSwatches;
          startSearchIndex = endSearchIndex - startSearchIndex;
        }
        return binarySearch(source, condition, startSearchIndex, endSearchIndex);
      }
      /**
       * {@inheritdoc Palette.get}
       */
      get(index) {
        return this.swatches[index] || this.swatches[clamp(index, 0, this.lastIndex)];
      }
      /**
       * {@inheritdoc Palette.closestIndexOf}
       */
      closestIndexOf(reference) {
        if (this.closestIndexCache.has(reference.relativeLuminance)) {
          return this.closestIndexCache.get(reference.relativeLuminance);
        }
        let index = this.swatches.indexOf(reference);
        if (index !== -1) {
          this.closestIndexCache.set(reference.relativeLuminance, index);
          return index;
        }
        const closest = this.swatches.reduce((previous, next) => Math.abs(next.relativeLuminance - reference.relativeLuminance) < Math.abs(previous.relativeLuminance - reference.relativeLuminance) ? next : previous);
        index = this.swatches.indexOf(closest);
        this.closestIndexCache.set(reference.relativeLuminance, index);
        return index;
      }
      /**
       * Bump the saturation if it falls below the reference color saturation.
       * @param reference Color with target saturation
       * @param color Color to check and bump if below target saturation
       * @returns Original or adjusted color
       */
      static saturationBump(reference, color) {
        const hslReference = rgbToHSL(reference);
        const saturationTarget = hslReference.s;
        const hslColor = rgbToHSL(color);
        if (hslColor.s < saturationTarget) {
          const hslNew = new ColorHSL(hslColor.h, saturationTarget, hslColor.l);
          return hslToRGB(hslNew);
        }
        return color;
      }
      /**
       * Scales input from 0 to 100 to 0 to 0.5.
       * @param l Input number, 0 to 100
       * @returns Output number, 0 to 0.5
       */
      static ramp(l) {
        const inputval = l / 100;
        if (inputval > 0.5)
          return (inputval - 0.5) / 0.5;
        return 2 * inputval;
      }
      /**
       * Create a palette following the desired curve and many steps to build a smaller palette from.
       * @param source The source swatch to create a palette from
       * @returns The palette
       */
      static createHighResolutionPalette(source) {
        const swatches = [];
        const labSource = rgbToLAB(ColorRGBA64.fromObject(source).roundToPrecision(4));
        const lab0 = labToRGB(new ColorLAB(0, labSource.a, labSource.b)).clamp().roundToPrecision(4);
        const lab50 = labToRGB(new ColorLAB(50, labSource.a, labSource.b)).clamp().roundToPrecision(4);
        const lab100 = labToRGB(new ColorLAB(100, labSource.a, labSource.b)).clamp().roundToPrecision(4);
        const rgbMin = new ColorRGBA64(0, 0, 0);
        const rgbMax = new ColorRGBA64(1, 1, 1);
        const lAbove = lab100.equalValue(rgbMax) ? 0 : 14;
        const lBelow = lab0.equalValue(rgbMin) ? 0 : 14;
        for (let l = 100 + lAbove; l >= 0 - lBelow; l -= 0.5) {
          let rgb;
          if (l < 0) {
            const percentFromRgbMinToLab0 = l / lBelow + 1;
            rgb = interpolateRGB(percentFromRgbMinToLab0, rgbMin, lab0);
          } else if (l <= 50) {
            rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab0, lab50);
          } else if (l <= 100) {
            rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab50, lab100);
          } else {
            const percentFromLab100ToRgbMax = (l - 100) / lAbove;
            rgb = interpolateRGB(percentFromLab100ToRgbMax, lab100, rgbMax);
          }
          rgb = PaletteRGBImpl.saturationBump(lab50, rgb).roundToPrecision(4);
          swatches.push(SwatchRGB.from(rgb));
        }
        return new PaletteRGBImpl(source, swatches);
      }
      /**
       * Adjust one end of the contrast-based palette so it doesn't abruptly fall to black (or white).
       * @param swatchContrast Function to get the target contrast for the next swatch
       * @param referencePalette The high resolution palette
       * @param targetPalette The contrast-based palette to adjust
       * @param direction The end to adjust
       */
      static adjustEnd(swatchContrast, referencePalette, targetPalette, direction2) {
        const refSwatches = direction2 === -1 ? referencePalette.swatches : referencePalette.reversedSwatches;
        const refIndex = (swatch) => {
          const index = referencePalette.closestIndexOf(swatch);
          return direction2 === 1 ? referencePalette.lastIndex - index : index;
        };
        if (direction2 === 1) {
          targetPalette.reverse();
        }
        const targetContrast = swatchContrast(targetPalette[targetPalette.length - 2]);
        const actualContrast = roundToPrecisionSmall(contrast(targetPalette[targetPalette.length - 1], targetPalette[targetPalette.length - 2]), 2);
        if (actualContrast < targetContrast) {
          targetPalette.pop();
          const safeSecondSwatch = referencePalette.colorContrast(refSwatches[referencePalette.lastIndex], targetContrast, void 0, direction2);
          const safeSecondRefIndex = refIndex(safeSecondSwatch);
          const targetSwatchCurrentRefIndex = refIndex(targetPalette[targetPalette.length - 2]);
          const swatchesToSpace = safeSecondRefIndex - targetSwatchCurrentRefIndex;
          let space = 1;
          for (let i = targetPalette.length - swatchesToSpace - 1; i < targetPalette.length; i++) {
            const currentRefIndex = refIndex(targetPalette[i]);
            const nextRefIndex = i === targetPalette.length - 1 ? referencePalette.lastIndex : currentRefIndex + space;
            targetPalette[i] = refSwatches[nextRefIndex];
            space++;
          }
        }
        if (direction2 === 1) {
          targetPalette.reverse();
        }
      }
      /**
       * Generate a palette with consistent minimum contrast between swatches.
       * @param source The source color
       * @param options Palette generation options
       * @returns A palette meeting the requested contrast between swatches.
       */
      static createColorPaletteByContrast(source, options) {
        const referencePalette = PaletteRGBImpl.createHighResolutionPalette(source);
        const nextContrast = (swatch) => {
          const c = options.stepContrast + options.stepContrast * (1 - swatch.relativeLuminance) * options.stepContrastRamp;
          return roundToPrecisionSmall(c, 2);
        };
        const swatches = [];
        let ref2 = options.preserveSource ? source : referencePalette.swatches[0];
        swatches.push(ref2);
        do {
          const targetContrast = nextContrast(ref2);
          ref2 = referencePalette.colorContrast(ref2, targetContrast, void 0, 1);
          swatches.push(ref2);
        } while (ref2.relativeLuminance > 0);
        if (options.preserveSource) {
          ref2 = source;
          do {
            const targetContrast = nextContrast(ref2);
            ref2 = referencePalette.colorContrast(ref2, targetContrast, void 0, -1);
            swatches.unshift(ref2);
          } while (ref2.relativeLuminance < 1);
        }
        this.adjustEnd(nextContrast, referencePalette, swatches, -1);
        if (options.preserveSource) {
          this.adjustEnd(nextContrast, referencePalette, swatches, 1);
        }
        return swatches;
      }
      /**
       * Create a color palette from a provided swatch
       * @param source - The source swatch to create a palette from
       * @returns
       */
      static from(source, options) {
        const opts = options === void 0 || null ? defaultPaletteRGBOptions : Object.assign(Object.assign({}, defaultPaletteRGBOptions), options);
        return new PaletteRGBImpl(source, Object.freeze(PaletteRGBImpl.createColorPaletteByContrast(source, opts)));
      }
    };
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/utilities/color-constants.js
var white, black, middleGrey, base, accentBase;
var init_color_constants = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/utilities/color-constants.js"() {
    init_dist3();
    init_swatch();
    white = SwatchRGB.create(1, 1, 1);
    black = SwatchRGB.create(0, 0, 0);
    middleGrey = SwatchRGB.create(0.5, 0.5, 0.5);
    base = parseColorHexRGB("#0078D4");
    accentBase = SwatchRGB.create(base.r, base.g, base.b);
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/foreground-on-accent.js
function foregroundOnAccentSet(restFill, hoverFill, activeFill, focusFill, contrastTarget) {
  const defaultRule = (fill) => fill.contrast(white) >= contrastTarget ? white : black;
  const restForeground = defaultRule(restFill);
  const hoverForeground = defaultRule(hoverFill);
  const activeForeground = restForeground.relativeLuminance === hoverForeground.relativeLuminance ? restForeground : defaultRule(activeFill);
  const focusForeground = defaultRule(focusFill);
  return {
    rest: restForeground,
    hover: hoverForeground,
    active: activeForeground,
    focus: focusForeground
  };
}
var init_foreground_on_accent = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/foreground-on-accent.js"() {
    init_color_constants();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/gradient-swatch.js
var GradientSwatchRGB;
var init_gradient_swatch = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/gradient-swatch.js"() {
    init_dist3();
    init_relative_luminance();
    GradientSwatchRGB = class {
      /**
       *
       * @param red Red channel expressed as a number between 0 and 1
       * @param green Green channel expressed as a number between 0 and 1
       * @param blue Blue channel expressed as a number between 0 and 1
       */
      constructor(red, green, blue, cssGradient) {
        this.toColorString = () => this.cssGradient;
        this.contrast = contrast.bind(null, this);
        this.createCSS = this.toColorString;
        this.color = new ColorRGBA64(red, green, blue);
        this.cssGradient = cssGradient;
        this.relativeLuminance = rgbToRelativeLuminance(this.color);
        this.r = red;
        this.g = green;
        this.b = blue;
      }
      /**
       * Creates a GradientSwatch from a base color and gradient definition
       * @param obj The base color object, used for relative luminance
       * @param cssGradient The actual gradient to be rendered
       * @returns New GradientSwatch object
       */
      static fromObject(obj, cssGradient) {
        return new GradientSwatchRGB(obj.r, obj.g, obj.b, cssGradient);
      }
    };
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/gradient-shadow-stroke.js
function gradientShadowStroke(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, shadowDelta, direction2, shadowPercentage = 10, blendWithReference = false) {
  const referenceIndex = palette.closestIndexOf(reference);
  if (direction2 === void 0) {
    direction2 = directionByIsDark(reference);
  }
  function overlayHelper(color) {
    if (blendWithReference) {
      const refIndex = palette.closestIndexOf(reference);
      const refSwatch = palette.get(refIndex);
      const overlaySolid = color.relativeLuminance < reference.relativeLuminance ? black2 : white2;
      const overlayColor = calculateOverlayColor(parseColorHexRGB(color.toColorString()), parseColorHexRGB(refSwatch.toColorString()), overlaySolid).roundToPrecision(2);
      const blend = computeAlphaBlend(parseColorHexRGB(reference.toColorString()), overlayColor);
      return SwatchRGB.from(blend);
    } else {
      return color;
    }
  }
  const restIndex = referenceIndex + direction2 * restDelta;
  const hoverIndex = restIndex + direction2 * (hoverDelta - restDelta);
  const activeIndex = restIndex + direction2 * (activeDelta - restDelta);
  const focusIndex = restIndex + direction2 * (focusDelta - restDelta);
  const startPosition = direction2 === -1 ? 0 : 100 - shadowPercentage;
  const endPosition = direction2 === -1 ? shadowPercentage : 100;
  function gradientHelper(index, applyShadow) {
    const color = palette.get(index);
    if (applyShadow) {
      const shadowColor = palette.get(index + direction2 * shadowDelta);
      const startColor = direction2 === -1 ? shadowColor : color;
      const endColor = direction2 === -1 ? color : shadowColor;
      const g = `linear-gradient(${overlayHelper(startColor).toColorString()} ${startPosition}%, ${overlayHelper(endColor).toColorString()} ${endPosition}%)`;
      return GradientSwatchRGB.fromObject(startColor, g);
    } else {
      return overlayHelper(color);
    }
  }
  return {
    rest: gradientHelper(restIndex, true),
    hover: gradientHelper(hoverIndex, true),
    active: gradientHelper(activeIndex, false),
    focus: gradientHelper(focusIndex, true)
  };
}
var black2, white2;
var init_gradient_shadow_stroke = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/gradient-shadow-stroke.js"() {
    init_dist3();
    init_swatch();
    init_direction_by_is_dark();
    init_gradient_swatch();
    black2 = new ColorRGBA64(0, 0, 0);
    white2 = new ColorRGBA64(1, 1, 1);
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/underline-stroke.js
function underlineStroke(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, shadowDelta, width) {
  const referenceIndex = palette.closestIndexOf(reference);
  const direction2 = directionByIsDark(reference);
  const restIndex = referenceIndex + direction2 * restDelta;
  const hoverIndex = restIndex + direction2 * (hoverDelta - restDelta);
  const activeIndex = restIndex + direction2 * (activeDelta - restDelta);
  const focusIndex = restIndex + direction2 * (focusDelta - restDelta);
  const midPosition = `calc(100% - ${width})`;
  function gradientHelper(index, applyShadow) {
    const color = palette.get(index);
    if (applyShadow) {
      const underlineColor = palette.get(index + direction2 * shadowDelta);
      const g = `linear-gradient(${color.toColorString()} ${midPosition}, ${underlineColor.toColorString()} ${midPosition}, ${underlineColor.toColorString()})`;
      return GradientSwatchRGB.fromObject(color, g);
    } else {
      return color;
    }
  }
  return {
    rest: gradientHelper(restIndex, true),
    hover: gradientHelper(hoverIndex, true),
    active: gradientHelper(activeIndex, false),
    focus: gradientHelper(focusIndex, true)
  };
}
var init_underline_stroke = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/underline-stroke.js"() {
    init_direction_by_is_dark();
    init_gradient_swatch();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/contrast-swatch.js
function contrastSwatch(palette, reference, contrast2) {
  return palette.colorContrast(reference, contrast2);
}
var init_contrast_swatch = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/contrast-swatch.js"() {
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/contrast-and-delta-swatch-set.js
function contrastAndDeltaSwatchSet(palette, reference, baseContrast, restDelta, hoverDelta, activeDelta, focusDelta, direction2) {
  if (direction2 === null || direction2 === void 0) {
    direction2 = directionByIsDark(reference);
  }
  const baseIndex = palette.closestIndexOf(palette.colorContrast(reference, baseContrast));
  return {
    rest: palette.get(baseIndex + direction2 * restDelta),
    hover: palette.get(baseIndex + direction2 * hoverDelta),
    active: palette.get(baseIndex + direction2 * activeDelta),
    focus: palette.get(baseIndex + direction2 * focusDelta)
  };
}
function contrastAndDeltaSwatchSetByLuminance(palette, reference, lightBaseContrast, lightRestDelta, lightHoverDelta, lightActiveDelta, lightFocusDelta, lightDirection = void 0, darkBaseContrast, darkRestDelta, darkHoverDelta, darkActiveDelta, darkFocusDelta, darkDirection = void 0) {
  if (isDark(reference)) {
    return contrastAndDeltaSwatchSet(palette, reference, darkBaseContrast, darkRestDelta, darkHoverDelta, darkActiveDelta, darkFocusDelta, darkDirection);
  } else {
    return contrastAndDeltaSwatchSet(palette, reference, lightBaseContrast, lightRestDelta, lightHoverDelta, lightActiveDelta, lightFocusDelta, lightDirection);
  }
}
var init_contrast_and_delta_swatch_set = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/contrast-and-delta-swatch-set.js"() {
    init_direction_by_is_dark();
    init_is_dark();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/delta-swatch.js
function deltaSwatch(palette, reference, delta) {
  return palette.get(palette.closestIndexOf(reference) + directionByIsDark(reference) * delta);
}
var init_delta_swatch = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/delta-swatch.js"() {
    init_direction_by_is_dark();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/delta-swatch-set.js
function deltaSwatchSet(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, direction2) {
  const referenceIndex = palette.closestIndexOf(reference);
  if (direction2 === null || direction2 === void 0) {
    direction2 = directionByIsDark(reference);
  }
  return {
    rest: palette.get(referenceIndex + direction2 * restDelta),
    hover: palette.get(referenceIndex + direction2 * hoverDelta),
    active: palette.get(referenceIndex + direction2 * activeDelta),
    focus: palette.get(referenceIndex + direction2 * focusDelta)
  };
}
function deltaSwatchSetByLuminance(palette, reference, lightRestDelta, lightHoverDelta, lightActiveDelta, lightFocusDelta, lightDirection = void 0, darkRestDelta, darkHoverDelta, darkActiveDelta, darkFocusDelta, darkDirection = void 0) {
  if (isDark(reference)) {
    return deltaSwatchSet(palette, reference, darkRestDelta, darkHoverDelta, darkActiveDelta, darkFocusDelta, darkDirection);
  } else {
    return deltaSwatchSet(palette, reference, lightRestDelta, lightHoverDelta, lightActiveDelta, lightFocusDelta, lightDirection);
  }
}
var init_delta_swatch_set = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/delta-swatch-set.js"() {
    init_direction_by_is_dark();
    init_is_dark();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/focus-stroke.js
function focusStrokeOuter(palette, reference) {
  return isDark(reference) ? white : black;
}
function focusStrokeInner(palette, reference, focusColor) {
  return isDark(reference) ? black : white;
}
var init_focus_stroke = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/focus-stroke.js"() {
    init_color_constants();
    init_is_dark();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/utilities/base-layer-luminance.js
function baseLayerLuminanceSwatch(luminance) {
  return SwatchRGB.create(luminance, luminance, luminance);
}
var StandardLuminance;
var init_base_layer_luminance = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/utilities/base-layer-luminance.js"() {
    init_swatch();
    (function(StandardLuminance2) {
      StandardLuminance2[StandardLuminance2["LightMode"] = 0.98] = "LightMode";
      StandardLuminance2[StandardLuminance2["DarkMode"] = 0.15] = "DarkMode";
    })(StandardLuminance || (StandardLuminance = {}));
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-1.js
function neutralLayer1Index(palette, baseLayerLuminance2) {
  return palette.closestIndexOf(baseLayerLuminanceSwatch(baseLayerLuminance2));
}
function neutralLayer1(palette, baseLayerLuminance2) {
  return palette.get(neutralLayer1Index(palette, baseLayerLuminance2));
}
var init_neutral_layer_1 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-1.js"() {
    init_base_layer_luminance();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-floating.js
function neutralLayerFloating(palette, baseLayerLuminance2, layerDelta) {
  return palette.get(neutralLayer1Index(palette, baseLayerLuminance2) + layerDelta);
}
var init_neutral_layer_floating = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-floating.js"() {
    init_neutral_layer_1();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-2.js
function neutralLayer2(palette, baseLayerLuminance2, layerDelta) {
  return palette.get(neutralLayer1Index(palette, baseLayerLuminance2) + layerDelta * -1);
}
var init_neutral_layer_2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-2.js"() {
    init_neutral_layer_1();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-3.js
function neutralLayer3(palette, baseLayerLuminance2, layerDelta) {
  return palette.get(neutralLayer1Index(palette, baseLayerLuminance2) + layerDelta * -1 * 2);
}
var init_neutral_layer_3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-3.js"() {
    init_neutral_layer_1();
  }
});

// node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-4.js
function neutralLayer4(palette, baseLayerLuminance2, layerDelta) {
  return palette.get(neutralLayer1Index(palette, baseLayerLuminance2) + layerDelta * -1 * 3);
}
var init_neutral_layer_4 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/color/recipes/neutral-layer-4.js"() {
    init_neutral_layer_1();
  }
});

// node_modules/@fluentui/web-components/dist/esm/utilities/type-ramp.js
var StandardFontWeight;
var init_type_ramp = __esm({
  "node_modules/@fluentui/web-components/dist/esm/utilities/type-ramp.js"() {
    StandardFontWeight = {
      Thin: 100,
      ExtraLight: 200,
      Light: 300,
      Normal: 400,
      Medium: 500,
      SemiBold: 600,
      Bold: 700,
      ExtraBold: 800,
      Black: 900
    };
  }
});

// node_modules/@fluentui/web-components/dist/esm/design-tokens.js
function createNonCss(name) {
  return DesignToken.create({ name, cssCustomPropertyName: null });
}
function fontVariations(sizeToken) {
  return (element) => {
    const size = sizeToken.getValueFor(element);
    const weight = fontWeight.getValueFor(element);
    if (size.endsWith("px")) {
      const px = Number.parseFloat(size.replace("px", ""));
      if (px <= 12) {
        return `"wght" ${weight}, "opsz" 8`;
      } else if (px > 24) {
        return `"wght" ${weight}, "opsz" 36`;
      }
    }
    return `"wght" ${weight}, "opsz" 10.5`;
  };
}
function neutralFillInverse(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const direction2 = directionByIsDark(reference);
  const accessibleIndex = palette.closestIndexOf(palette.colorContrast(reference, 14));
  const accessibleIndex2 = accessibleIndex + direction2 * Math.abs(restDelta - hoverDelta);
  const indexOneIsRest = direction2 === 1 ? restDelta < hoverDelta : direction2 * restDelta > direction2 * hoverDelta;
  let restIndex;
  let hoverIndex;
  if (indexOneIsRest) {
    restIndex = accessibleIndex;
    hoverIndex = accessibleIndex2;
  } else {
    restIndex = accessibleIndex2;
    hoverIndex = accessibleIndex;
  }
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(restIndex + direction2 * activeDelta),
    focus: palette.get(restIndex + direction2 * focusDelta)
  };
}
var create3, direction, disabledOpacity, baseHeightMultiplier, baseHorizontalSpacingMultiplier, density, designUnit, controlCornerRadius, layerCornerRadius, strokeWidth, focusStrokeWidth, bodyFont, fontWeight, typeRampBaseFontSize, typeRampBaseLineHeight, typeRampBaseFontVariations, typeRampMinus1FontSize, typeRampMinus1LineHeight, typeRampMinus1FontVariations, typeRampMinus2FontSize, typeRampMinus2LineHeight, typeRampMinus2FontVariations, typeRampPlus1FontSize, typeRampPlus1LineHeight, typeRampPlus1FontVariations, typeRampPlus2FontSize, typeRampPlus2LineHeight, typeRampPlus2FontVariations, typeRampPlus3FontSize, typeRampPlus3LineHeight, typeRampPlus3FontVariations, typeRampPlus4FontSize, typeRampPlus4LineHeight, typeRampPlus4FontVariations, typeRampPlus5FontSize, typeRampPlus5LineHeight, typeRampPlus5FontVariations, typeRampPlus6FontSize, typeRampPlus6LineHeight, typeRampPlus6FontVariations, baseLayerLuminance, accentFillRestDelta, accentFillHoverDelta, accentFillActiveDelta, accentFillFocusDelta, accentForegroundRestDelta, accentForegroundHoverDelta, accentForegroundActiveDelta, accentForegroundFocusDelta, neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta, neutralFillFocusDelta, neutralFillInputRestDelta, neutralFillInputHoverDelta, neutralFillInputActiveDelta, neutralFillInputFocusDelta, neutralFillInputAltRestDelta, neutralFillInputAltHoverDelta, neutralFillInputAltActiveDelta, neutralFillInputAltFocusDelta, neutralFillLayerRestDelta, neutralFillLayerHoverDelta, neutralFillLayerActiveDelta, neutralFillLayerAltRestDelta, neutralFillSecondaryRestDelta, neutralFillSecondaryHoverDelta, neutralFillSecondaryActiveDelta, neutralFillSecondaryFocusDelta, neutralFillStealthRestDelta, neutralFillStealthHoverDelta, neutralFillStealthActiveDelta, neutralFillStealthFocusDelta, neutralFillStrongRestDelta, neutralFillStrongHoverDelta, neutralFillStrongActiveDelta, neutralFillStrongFocusDelta, neutralStrokeRestDelta, neutralStrokeHoverDelta, neutralStrokeActiveDelta, neutralStrokeFocusDelta, neutralStrokeControlRestDelta, neutralStrokeControlHoverDelta, neutralStrokeControlActiveDelta, neutralStrokeControlFocusDelta, neutralStrokeDividerRestDelta, neutralStrokeLayerRestDelta, neutralStrokeLayerHoverDelta, neutralStrokeLayerActiveDelta, neutralStrokeStrongHoverDelta, neutralStrokeStrongActiveDelta, neutralStrokeStrongFocusDelta, neutralBaseColor, neutralPalette, accentBaseColor, accentPalette, neutralLayerCardContainerRecipe, neutralLayerCardContainer, neutralLayerFloatingRecipe, neutralLayerFloating2, neutralLayer1Recipe, neutralLayer12, neutralLayer2Recipe, neutralLayer22, neutralLayer3Recipe, neutralLayer32, neutralLayer4Recipe, neutralLayer42, fillColor, ContrastTarget, accentFillRecipe, accentFillRest, accentFillHover, accentFillActive, accentFillFocus, foregroundOnAccentRecipe, foregroundOnAccentRest, foregroundOnAccentHover, foregroundOnAccentActive, foregroundOnAccentFocus, accentForegroundRecipe, accentForegroundRest, accentForegroundHover, accentForegroundActive, accentForegroundFocus, accentStrokeControlRecipe, accentStrokeControlRest, accentStrokeControlHover, accentStrokeControlActive, accentStrokeControlFocus, neutralFillRecipe, neutralFillRest, neutralFillHover, neutralFillActive, neutralFillFocus, neutralFillInputRecipe, neutralFillInputRest, neutralFillInputHover, neutralFillInputActive, neutralFillInputFocus, neutralFillInputAltRecipe, neutralFillInputAltRest, neutralFillInputAltHover, neutralFillInputAltActive, neutralFillInputAltFocus, neutralFillLayerRecipe, neutralFillLayerRest, neutralFillLayerHover, neutralFillLayerActive, neutralFillLayerAltRecipe, neutralFillLayerAltRest, neutralFillSecondaryRecipe, neutralFillSecondaryRest, neutralFillSecondaryHover, neutralFillSecondaryActive, neutralFillSecondaryFocus, neutralFillStealthRecipe, neutralFillStealthRest, neutralFillStealthHover, neutralFillStealthActive, neutralFillStealthFocus, neutralFillStrongRecipe, neutralFillStrongRest, neutralFillStrongHover, neutralFillStrongActive, neutralFillStrongFocus, neutralForegroundRecipe, neutralForegroundRest, neutralForegroundHover, neutralForegroundActive, neutralForegroundFocus, neutralForegroundHintRecipe, neutralForegroundHint, neutralStrokeRecipe, neutralStrokeRest, neutralStrokeHover, neutralStrokeActive, neutralStrokeFocus, neutralStrokeControlRecipe, neutralStrokeControlRest, neutralStrokeControlHover, neutralStrokeControlActive, neutralStrokeControlFocus, neutralStrokeDividerRecipe, neutralStrokeDividerRest, neutralStrokeInputRecipe, neutralStrokeInputRest, neutralStrokeInputHover, neutralStrokeInputActive, neutralStrokeInputFocus, neutralStrokeLayerRecipe, neutralStrokeLayerRest, neutralStrokeLayerHover, neutralStrokeLayerActive, neutralStrokeStrongRecipe, neutralStrokeStrongRest, neutralStrokeStrongHover, neutralStrokeStrongActive, neutralStrokeStrongFocus, focusStrokeOuterRecipe, focusStrokeOuter2, focusStrokeInnerRecipe, focusStrokeInner2, foregroundOnAccentLargeRecipe, foregroundOnAccentRestLarge, foregroundOnAccentHoverLarge, foregroundOnAccentActiveLarge, foregroundOnAccentFocusLarge, neutralFillInverseRestDelta, neutralFillInverseHoverDelta, neutralFillInverseActiveDelta, neutralFillInverseFocusDelta, neutralFillInverseRecipe, neutralFillInverseRest, neutralFillInverseHover, neutralFillInverseActive, neutralFillInverseFocus;
var init_design_tokens = __esm({
  "node_modules/@fluentui/web-components/dist/esm/design-tokens.js"() {
    init_esm2();
    init_dist2();
    init_palette();
    init_foreground_on_accent();
    init_gradient_shadow_stroke();
    init_underline_stroke();
    init_contrast_swatch();
    init_contrast_and_delta_swatch_set();
    init_delta_swatch();
    init_delta_swatch_set();
    init_focus_stroke();
    init_neutral_layer_floating();
    init_neutral_layer_1();
    init_neutral_layer_2();
    init_neutral_layer_3();
    init_neutral_layer_4();
    init_color_constants();
    init_base_layer_luminance();
    init_direction_by_is_dark();
    init_type_ramp();
    ({ create: create3 } = DesignToken);
    direction = create3("direction").withDefault(Direction.ltr);
    disabledOpacity = create3("disabled-opacity").withDefault(0.3);
    baseHeightMultiplier = create3("base-height-multiplier").withDefault(8);
    baseHorizontalSpacingMultiplier = create3("base-horizontal-spacing-multiplier").withDefault(3);
    density = create3("density").withDefault(0);
    designUnit = create3("design-unit").withDefault(4);
    controlCornerRadius = create3("control-corner-radius").withDefault(4);
    layerCornerRadius = create3("layer-corner-radius").withDefault(8);
    strokeWidth = create3("stroke-width").withDefault(1);
    focusStrokeWidth = create3("focus-stroke-width").withDefault(2);
    bodyFont = create3("body-font").withDefault('"Segoe UI Variable", "Segoe UI", sans-serif');
    fontWeight = create3("font-weight").withDefault(StandardFontWeight.Normal);
    typeRampBaseFontSize = create3("type-ramp-base-font-size").withDefault("14px");
    typeRampBaseLineHeight = create3("type-ramp-base-line-height").withDefault("20px");
    typeRampBaseFontVariations = create3("type-ramp-base-font-variations").withDefault(fontVariations(typeRampBaseFontSize));
    typeRampMinus1FontSize = create3("type-ramp-minus-1-font-size").withDefault("12px");
    typeRampMinus1LineHeight = create3("type-ramp-minus-1-line-height").withDefault("16px");
    typeRampMinus1FontVariations = create3("type-ramp-minus-1-font-variations").withDefault(fontVariations(typeRampMinus1FontSize));
    typeRampMinus2FontSize = create3("type-ramp-minus-2-font-size").withDefault("10px");
    typeRampMinus2LineHeight = create3("type-ramp-minus-2-line-height").withDefault("14px");
    typeRampMinus2FontVariations = create3("type-ramp-minus-2-font-variations").withDefault(fontVariations(typeRampMinus2FontSize));
    typeRampPlus1FontSize = create3("type-ramp-plus-1-font-size").withDefault("16px");
    typeRampPlus1LineHeight = create3("type-ramp-plus-1-line-height").withDefault("22px");
    typeRampPlus1FontVariations = create3("type-ramp-plus-1-font-variations").withDefault(fontVariations(typeRampPlus1FontSize));
    typeRampPlus2FontSize = create3("type-ramp-plus-2-font-size").withDefault("20px");
    typeRampPlus2LineHeight = create3("type-ramp-plus-2-line-height").withDefault("26px");
    typeRampPlus2FontVariations = create3("type-ramp-plus-2-font-variations").withDefault(fontVariations(typeRampPlus2FontSize));
    typeRampPlus3FontSize = create3("type-ramp-plus-3-font-size").withDefault("24px");
    typeRampPlus3LineHeight = create3("type-ramp-plus-3-line-height").withDefault("32px");
    typeRampPlus3FontVariations = create3("type-ramp-plus-3-font-variations").withDefault(fontVariations(typeRampPlus3FontSize));
    typeRampPlus4FontSize = create3("type-ramp-plus-4-font-size").withDefault("28px");
    typeRampPlus4LineHeight = create3("type-ramp-plus-4-line-height").withDefault("36px");
    typeRampPlus4FontVariations = create3("type-ramp-plus-4-font-variations").withDefault(fontVariations(typeRampPlus4FontSize));
    typeRampPlus5FontSize = create3("type-ramp-plus-5-font-size").withDefault("32px");
    typeRampPlus5LineHeight = create3("type-ramp-plus-5-line-height").withDefault("40px");
    typeRampPlus5FontVariations = create3("type-ramp-plus-5-font-variations").withDefault(fontVariations(typeRampPlus5FontSize));
    typeRampPlus6FontSize = create3("type-ramp-plus-6-font-size").withDefault("40px");
    typeRampPlus6LineHeight = create3("type-ramp-plus-6-line-height").withDefault("52px");
    typeRampPlus6FontVariations = create3("type-ramp-plus-6-font-variations").withDefault(fontVariations(typeRampPlus6FontSize));
    baseLayerLuminance = create3("base-layer-luminance").withDefault(StandardLuminance.LightMode);
    accentFillRestDelta = createNonCss("accent-fill-rest-delta").withDefault(0);
    accentFillHoverDelta = createNonCss("accent-fill-hover-delta").withDefault(-2);
    accentFillActiveDelta = createNonCss("accent-fill-active-delta").withDefault(-5);
    accentFillFocusDelta = createNonCss("accent-fill-focus-delta").withDefault(0);
    accentForegroundRestDelta = createNonCss("accent-foreground-rest-delta").withDefault(0);
    accentForegroundHoverDelta = createNonCss("accent-foreground-hover-delta").withDefault(3);
    accentForegroundActiveDelta = createNonCss("accent-foreground-active-delta").withDefault(-8);
    accentForegroundFocusDelta = createNonCss("accent-foreground-focus-delta").withDefault(0);
    neutralFillRestDelta = createNonCss("neutral-fill-rest-delta").withDefault(-1);
    neutralFillHoverDelta = createNonCss("neutral-fill-hover-delta").withDefault(1);
    neutralFillActiveDelta = createNonCss("neutral-fill-active-delta").withDefault(0);
    neutralFillFocusDelta = createNonCss("neutral-fill-focus-delta").withDefault(0);
    neutralFillInputRestDelta = createNonCss("neutral-fill-input-rest-delta").withDefault(-1);
    neutralFillInputHoverDelta = createNonCss("neutral-fill-input-hover-delta").withDefault(1);
    neutralFillInputActiveDelta = createNonCss("neutral-fill-input-active-delta").withDefault(0);
    neutralFillInputFocusDelta = createNonCss("neutral-fill-input-focus-delta").withDefault(-2);
    neutralFillInputAltRestDelta = createNonCss("neutral-fill-input-alt-rest-delta").withDefault(2);
    neutralFillInputAltHoverDelta = createNonCss("neutral-fill-input-alt-hover-delta").withDefault(4);
    neutralFillInputAltActiveDelta = createNonCss("neutral-fill-input-alt-active-delta").withDefault(6);
    neutralFillInputAltFocusDelta = createNonCss("neutral-fill-input-alt-focus-delta").withDefault(2);
    neutralFillLayerRestDelta = createNonCss("neutral-fill-layer-rest-delta").withDefault(-2);
    neutralFillLayerHoverDelta = createNonCss("neutral-fill-layer-hover-delta").withDefault(-3);
    neutralFillLayerActiveDelta = createNonCss("neutral-fill-layer-active-delta").withDefault(-3);
    neutralFillLayerAltRestDelta = createNonCss("neutral-fill-layer-alt-rest-delta").withDefault(-1);
    neutralFillSecondaryRestDelta = createNonCss("neutral-fill-secondary-rest-delta").withDefault(3);
    neutralFillSecondaryHoverDelta = createNonCss("neutral-fill-secondary-hover-delta").withDefault(2);
    neutralFillSecondaryActiveDelta = createNonCss("neutral-fill-secondary-active-delta").withDefault(1);
    neutralFillSecondaryFocusDelta = createNonCss("neutral-fill-secondary-focus-delta").withDefault(3);
    neutralFillStealthRestDelta = createNonCss("neutral-fill-stealth-rest-delta").withDefault(0);
    neutralFillStealthHoverDelta = createNonCss("neutral-fill-stealth-hover-delta").withDefault(3);
    neutralFillStealthActiveDelta = createNonCss("neutral-fill-stealth-active-delta").withDefault(2);
    neutralFillStealthFocusDelta = createNonCss("neutral-fill-stealth-focus-delta").withDefault(0);
    neutralFillStrongRestDelta = createNonCss("neutral-fill-strong-rest-delta").withDefault(0);
    neutralFillStrongHoverDelta = createNonCss("neutral-fill-strong-hover-delta").withDefault(8);
    neutralFillStrongActiveDelta = createNonCss("neutral-fill-strong-active-delta").withDefault(-5);
    neutralFillStrongFocusDelta = createNonCss("neutral-fill-strong-focus-delta").withDefault(0);
    neutralStrokeRestDelta = createNonCss("neutral-stroke-rest-delta").withDefault(8);
    neutralStrokeHoverDelta = createNonCss("neutral-stroke-hover-delta").withDefault(12);
    neutralStrokeActiveDelta = createNonCss("neutral-stroke-active-delta").withDefault(6);
    neutralStrokeFocusDelta = createNonCss("neutral-stroke-focus-delta").withDefault(8);
    neutralStrokeControlRestDelta = createNonCss("neutral-stroke-control-rest-delta").withDefault(3);
    neutralStrokeControlHoverDelta = createNonCss("neutral-stroke-control-hover-delta").withDefault(5);
    neutralStrokeControlActiveDelta = createNonCss("neutral-stroke-control-active-delta").withDefault(5);
    neutralStrokeControlFocusDelta = createNonCss("neutral-stroke-control-focus-delta").withDefault(5);
    neutralStrokeDividerRestDelta = createNonCss("neutral-stroke-divider-rest-delta").withDefault(4);
    neutralStrokeLayerRestDelta = createNonCss("neutral-stroke-layer-rest-delta").withDefault(3);
    neutralStrokeLayerHoverDelta = createNonCss("neutral-stroke-layer-hover-delta").withDefault(3);
    neutralStrokeLayerActiveDelta = createNonCss("neutral-stroke-layer-active-delta").withDefault(3);
    neutralStrokeStrongHoverDelta = createNonCss("neutral-stroke-strong-hover-delta").withDefault(0);
    neutralStrokeStrongActiveDelta = createNonCss("neutral-stroke-strong-active-delta").withDefault(0);
    neutralStrokeStrongFocusDelta = createNonCss("neutral-stroke-strong-focus-delta").withDefault(0);
    neutralBaseColor = create3("neutral-base-color").withDefault(middleGrey);
    neutralPalette = createNonCss("neutral-palette").withDefault((element) => PaletteRGB.from(neutralBaseColor.getValueFor(element)));
    accentBaseColor = create3("accent-base-color").withDefault(accentBase);
    accentPalette = createNonCss("accent-palette").withDefault((element) => PaletteRGB.from(accentBaseColor.getValueFor(element)));
    neutralLayerCardContainerRecipe = createNonCss("neutral-layer-card-container-recipe").withDefault({
      evaluate: (element) => neutralLayer2(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralLayerCardContainer = create3("neutral-layer-card-container").withDefault((element) => neutralLayerCardContainerRecipe.getValueFor(element).evaluate(element));
    neutralLayerFloatingRecipe = createNonCss("neutral-layer-floating-recipe").withDefault({
      evaluate: (element) => neutralLayerFloating(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralLayerFloating2 = create3("neutral-layer-floating").withDefault((element) => neutralLayerFloatingRecipe.getValueFor(element).evaluate(element));
    neutralLayer1Recipe = createNonCss("neutral-layer-1-recipe").withDefault({
      evaluate: (element) => neutralLayer1(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element))
    });
    neutralLayer12 = create3("neutral-layer-1").withDefault((element) => neutralLayer1Recipe.getValueFor(element).evaluate(element));
    neutralLayer2Recipe = createNonCss("neutral-layer-2-recipe").withDefault({
      evaluate: (element) => neutralLayer2(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralLayer22 = create3("neutral-layer-2").withDefault((element) => neutralLayer2Recipe.getValueFor(element).evaluate(element));
    neutralLayer3Recipe = createNonCss("neutral-layer-3-recipe").withDefault({
      evaluate: (element) => neutralLayer3(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralLayer32 = create3("neutral-layer-3").withDefault((element) => neutralLayer3Recipe.getValueFor(element).evaluate(element));
    neutralLayer4Recipe = createNonCss("neutral-layer-4-recipe").withDefault({
      evaluate: (element) => neutralLayer4(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
    });
    neutralLayer42 = create3("neutral-layer-4").withDefault((element) => neutralLayer4Recipe.getValueFor(element).evaluate(element));
    fillColor = create3("fill-color").withDefault((element) => neutralLayer12.getValueFor(element));
    (function(ContrastTarget2) {
      ContrastTarget2[ContrastTarget2["normal"] = 4.5] = "normal";
      ContrastTarget2[ContrastTarget2["large"] = 3] = "large";
    })(ContrastTarget || (ContrastTarget = {}));
    accentFillRecipe = createNonCss("accent-fill-recipe").withDefault({
      evaluate: (element, reference) => contrastAndDeltaSwatchSetByLuminance(accentPalette.getValueFor(element), reference || fillColor.getValueFor(element), 5, accentFillRestDelta.getValueFor(element), accentFillHoverDelta.getValueFor(element), accentFillActiveDelta.getValueFor(element), accentFillFocusDelta.getValueFor(element), void 0, 8, accentFillRestDelta.getValueFor(element), accentFillHoverDelta.getValueFor(element), accentFillActiveDelta.getValueFor(element), accentFillFocusDelta.getValueFor(element), void 0)
    });
    accentFillRest = create3("accent-fill-rest").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).rest;
    });
    accentFillHover = create3("accent-fill-hover").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).hover;
    });
    accentFillActive = create3("accent-fill-active").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).active;
    });
    accentFillFocus = create3("accent-fill-focus").withDefault((element) => {
      return accentFillRecipe.getValueFor(element).evaluate(element).focus;
    });
    foregroundOnAccentRecipe = createNonCss("foreground-on-accent-recipe").withDefault({
      evaluate: (element) => foregroundOnAccentSet(accentFillRest.getValueFor(element), accentFillHover.getValueFor(element), accentFillActive.getValueFor(element), accentFillFocus.getValueFor(element), ContrastTarget.normal)
    });
    foregroundOnAccentRest = create3("foreground-on-accent-rest").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element).rest);
    foregroundOnAccentHover = create3("foreground-on-accent-hover").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element).hover);
    foregroundOnAccentActive = create3("foreground-on-accent-active").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element).active);
    foregroundOnAccentFocus = create3("foreground-on-accent-focus").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element).focus);
    accentForegroundRecipe = createNonCss("accent-foreground-recipe").withDefault({
      evaluate: (element, reference) => contrastAndDeltaSwatchSet(accentPalette.getValueFor(element), reference || fillColor.getValueFor(element), 9.5, accentForegroundRestDelta.getValueFor(element), accentForegroundHoverDelta.getValueFor(element), accentForegroundActiveDelta.getValueFor(element), accentForegroundFocusDelta.getValueFor(element))
    });
    accentForegroundRest = create3("accent-foreground-rest").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).rest);
    accentForegroundHover = create3("accent-foreground-hover").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).hover);
    accentForegroundActive = create3("accent-foreground-active").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).active);
    accentForegroundFocus = create3("accent-foreground-focus").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).focus);
    accentStrokeControlRecipe = createNonCss("accent-stroke-control-recipe").withDefault({
      evaluate: (element, reference) => {
        return gradientShadowStroke(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), -3, -3, -3, -3, 10, 1, void 0, true);
      }
    });
    accentStrokeControlRest = create3("accent-stroke-control-rest").withDefault((element) => accentStrokeControlRecipe.getValueFor(element).evaluate(element, accentFillRest.getValueFor(element)).rest);
    accentStrokeControlHover = create3("accent-stroke-control-hover").withDefault((element) => accentStrokeControlRecipe.getValueFor(element).evaluate(element, accentFillHover.getValueFor(element)).hover);
    accentStrokeControlActive = create3("accent-stroke-control-active").withDefault((element) => accentStrokeControlRecipe.getValueFor(element).evaluate(element, accentFillActive.getValueFor(element)).active);
    accentStrokeControlFocus = create3("accent-stroke-control-focus").withDefault((element) => accentStrokeControlRecipe.getValueFor(element).evaluate(element, accentFillFocus.getValueFor(element)).focus);
    neutralFillRecipe = createNonCss("neutral-fill-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatchSetByLuminance(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element), neutralFillFocusDelta.getValueFor(element), void 0, 2, 3, 1, 2, void 0)
    });
    neutralFillRest = create3("neutral-fill-rest").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillHover = create3("neutral-fill-hover").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillActive = create3("neutral-fill-active").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).active);
    neutralFillFocus = create3("neutral-fill-focus").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillInputRecipe = createNonCss("neutral-fill-input-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatchSetByLuminance(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillInputRestDelta.getValueFor(element), neutralFillInputHoverDelta.getValueFor(element), neutralFillInputActiveDelta.getValueFor(element), neutralFillInputFocusDelta.getValueFor(element), void 0, 2, 3, 1, 0, void 0)
    });
    neutralFillInputRest = create3("neutral-fill-input-rest").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillInputHover = create3("neutral-fill-input-hover").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillInputActive = create3("neutral-fill-input-active").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).active);
    neutralFillInputFocus = create3("neutral-fill-input-focus").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillInputAltRecipe = createNonCss("neutral-fill-input-alt-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatchSetByLuminance(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillInputAltRestDelta.getValueFor(element), neutralFillInputAltHoverDelta.getValueFor(element), neutralFillInputAltActiveDelta.getValueFor(element), neutralFillInputAltFocusDelta.getValueFor(element), 1, neutralFillInputAltRestDelta.getValueFor(element), neutralFillInputAltRestDelta.getValueFor(element) - neutralFillInputAltHoverDelta.getValueFor(element), neutralFillInputAltRestDelta.getValueFor(element) - neutralFillInputAltActiveDelta.getValueFor(element), neutralFillInputAltFocusDelta.getValueFor(element), 1)
    });
    neutralFillInputAltRest = create3("neutral-fill-input-alt-rest").withDefault((element) => neutralFillInputAltRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillInputAltHover = create3("neutral-fill-input-alt-hover").withDefault((element) => neutralFillInputAltRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillInputAltActive = create3("neutral-fill-input-alt-active").withDefault((element) => neutralFillInputAltRecipe.getValueFor(element).evaluate(element).active);
    neutralFillInputAltFocus = create3("neutral-fill-input-alt-focus").withDefault((element) => neutralFillInputAltRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillLayerRecipe = createNonCss("neutral-fill-layer-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), neutralFillLayerHoverDelta.getValueFor(element), neutralFillLayerActiveDelta.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), 1)
    });
    neutralFillLayerRest = create3("neutral-fill-layer-rest").withDefault((element) => neutralFillLayerRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillLayerHover = create3("neutral-fill-layer-hover").withDefault((element) => neutralFillLayerRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillLayerActive = create3("neutral-fill-layer-active").withDefault((element) => neutralFillLayerRecipe.getValueFor(element).evaluate(element).active);
    neutralFillLayerAltRecipe = createNonCss("neutral-fill-layer-alt-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillLayerAltRestDelta.getValueFor(element), neutralFillLayerAltRestDelta.getValueFor(element), neutralFillLayerAltRestDelta.getValueFor(element), neutralFillLayerAltRestDelta.getValueFor(element))
    });
    neutralFillLayerAltRest = create3("neutral-fill-layer-alt-rest").withDefault((element) => neutralFillLayerAltRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillSecondaryRecipe = createNonCss("neutral-fill-secondary-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillSecondaryRestDelta.getValueFor(element), neutralFillSecondaryHoverDelta.getValueFor(element), neutralFillSecondaryActiveDelta.getValueFor(element), neutralFillSecondaryFocusDelta.getValueFor(element))
    });
    neutralFillSecondaryRest = create3("neutral-fill-secondary-rest").withDefault((element) => neutralFillSecondaryRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillSecondaryHover = create3("neutral-fill-secondary-hover").withDefault((element) => neutralFillSecondaryRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillSecondaryActive = create3("neutral-fill-secondary-active").withDefault((element) => neutralFillSecondaryRecipe.getValueFor(element).evaluate(element).active);
    neutralFillSecondaryFocus = create3("neutral-fill-secondary-focus").withDefault((element) => neutralFillSecondaryRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillStealthRecipe = createNonCss("neutral-fill-stealth-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillStealthRestDelta.getValueFor(element), neutralFillStealthHoverDelta.getValueFor(element), neutralFillStealthActiveDelta.getValueFor(element), neutralFillStealthFocusDelta.getValueFor(element))
    });
    neutralFillStealthRest = create3("neutral-fill-stealth-rest").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillStealthHover = create3("neutral-fill-stealth-hover").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillStealthActive = create3("neutral-fill-stealth-active").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).active);
    neutralFillStealthFocus = create3("neutral-fill-stealth-focus").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).focus);
    neutralFillStrongRecipe = createNonCss("neutral-fill-strong-recipe").withDefault({
      evaluate: (element, reference) => contrastAndDeltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), 4.5, neutralFillStrongRestDelta.getValueFor(element), neutralFillStrongHoverDelta.getValueFor(element), neutralFillStrongActiveDelta.getValueFor(element), neutralFillStrongFocusDelta.getValueFor(element))
    });
    neutralFillStrongRest = create3("neutral-fill-strong-rest").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillStrongHover = create3("neutral-fill-strong-hover").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillStrongActive = create3("neutral-fill-strong-active").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).active);
    neutralFillStrongFocus = create3("neutral-fill-strong-focus").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).focus);
    neutralForegroundRecipe = createNonCss("neutral-foreground-recipe").withDefault({
      evaluate: (element, reference) => contrastAndDeltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), 16, 0, -19, -30, 0)
    });
    neutralForegroundRest = create3("neutral-foreground-rest").withDefault((element) => neutralForegroundRecipe.getValueFor(element).evaluate(element).rest);
    neutralForegroundHover = create3("neutral-foreground-hover").withDefault((element) => neutralForegroundRecipe.getValueFor(element).evaluate(element).hover);
    neutralForegroundActive = create3("neutral-foreground-active").withDefault((element) => neutralForegroundRecipe.getValueFor(element).evaluate(element).active);
    neutralForegroundFocus = create3("neutral-foreground-focus").withDefault((element) => neutralForegroundRecipe.getValueFor(element).evaluate(element).focus);
    neutralForegroundHintRecipe = createNonCss("neutral-foreground-hint-recipe").withDefault({
      evaluate: (element, reference) => contrastSwatch(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), 4.5)
    });
    neutralForegroundHint = create3("neutral-foreground-hint").withDefault((element) => neutralForegroundHintRecipe.getValueFor(element).evaluate(element));
    neutralStrokeRecipe = createNonCss("neutral-stroke-recipe").withDefault({
      evaluate: (element, reference) => {
        return deltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralStrokeRestDelta.getValueFor(element), neutralStrokeHoverDelta.getValueFor(element), neutralStrokeActiveDelta.getValueFor(element), neutralStrokeFocusDelta.getValueFor(element));
      }
    });
    neutralStrokeRest = create3("neutral-stroke-rest").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).rest);
    neutralStrokeHover = create3("neutral-stroke-hover").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).hover);
    neutralStrokeActive = create3("neutral-stroke-active").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).active);
    neutralStrokeFocus = create3("neutral-stroke-focus").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).focus);
    neutralStrokeControlRecipe = createNonCss("neutral-stroke-control-recipe").withDefault({
      evaluate: (element, reference) => {
        return gradientShadowStroke(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralStrokeControlRestDelta.getValueFor(element), neutralStrokeControlHoverDelta.getValueFor(element), neutralStrokeControlActiveDelta.getValueFor(element), neutralStrokeControlFocusDelta.getValueFor(element), 5);
      }
    });
    neutralStrokeControlRest = create3("neutral-stroke-control-rest").withDefault((element) => neutralStrokeControlRecipe.getValueFor(element).evaluate(element).rest);
    neutralStrokeControlHover = create3("neutral-stroke-control-hover").withDefault((element) => neutralStrokeControlRecipe.getValueFor(element).evaluate(element).hover);
    neutralStrokeControlActive = create3("neutral-stroke-control-active").withDefault((element) => neutralStrokeControlRecipe.getValueFor(element).evaluate(element).active);
    neutralStrokeControlFocus = create3("neutral-stroke-control-focus").withDefault((element) => neutralStrokeControlRecipe.getValueFor(element).evaluate(element).focus);
    neutralStrokeDividerRecipe = createNonCss("neutral-stroke-divider-recipe").withDefault({
      evaluate: (element, reference) => deltaSwatch(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralStrokeDividerRestDelta.getValueFor(element))
    });
    neutralStrokeDividerRest = create3("neutral-stroke-divider-rest").withDefault((element) => neutralStrokeDividerRecipe.getValueFor(element).evaluate(element));
    neutralStrokeInputRecipe = createNonCss("neutral-stroke-input-recipe").withDefault({
      evaluate: (element, reference) => {
        return underlineStroke(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralStrokeControlRestDelta.getValueFor(element), neutralStrokeControlHoverDelta.getValueFor(element), neutralStrokeControlActiveDelta.getValueFor(element), neutralStrokeControlFocusDelta.getValueFor(element), 20, strokeWidth.getValueFor(element) + "px");
      }
    });
    neutralStrokeInputRest = create3("neutral-stroke-input-rest").withDefault((element) => neutralStrokeInputRecipe.getValueFor(element).evaluate(element).rest);
    neutralStrokeInputHover = create3("neutral-stroke-input-hover").withDefault((element) => neutralStrokeInputRecipe.getValueFor(element).evaluate(element).hover);
    neutralStrokeInputActive = create3("neutral-stroke-input-active").withDefault((element) => neutralStrokeInputRecipe.getValueFor(element).evaluate(element).active);
    neutralStrokeInputFocus = create3("neutral-stroke-input-focus").withDefault((element) => neutralStrokeInputRecipe.getValueFor(element).evaluate(element).focus);
    neutralStrokeLayerRecipe = createNonCss("neutral-stroke-layer-recipe").withDefault({
      evaluate: (element, reference) => {
        return deltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralStrokeLayerRestDelta.getValueFor(element), neutralStrokeLayerHoverDelta.getValueFor(element), neutralStrokeLayerActiveDelta.getValueFor(element), neutralStrokeLayerRestDelta.getValueFor(element));
      }
    });
    neutralStrokeLayerRest = create3("neutral-stroke-layer-rest").withDefault((element) => neutralStrokeLayerRecipe.getValueFor(element).evaluate(element).rest);
    neutralStrokeLayerHover = create3("neutral-stroke-layer-hover").withDefault((element) => neutralStrokeLayerRecipe.getValueFor(element).evaluate(element).hover);
    neutralStrokeLayerActive = create3("neutral-stroke-layer-active").withDefault((element) => neutralStrokeLayerRecipe.getValueFor(element).evaluate(element).active);
    neutralStrokeStrongRecipe = createNonCss("neutral-stroke-strong-recipe").withDefault({
      evaluate: (element, reference) => contrastAndDeltaSwatchSet(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), 5.5, 0, neutralStrokeStrongHoverDelta.getValueFor(element), neutralStrokeStrongActiveDelta.getValueFor(element), neutralStrokeStrongFocusDelta.getValueFor(element))
    });
    neutralStrokeStrongRest = create3("neutral-stroke-strong-rest").withDefault((element) => neutralStrokeStrongRecipe.getValueFor(element).evaluate(element).rest);
    neutralStrokeStrongHover = create3("neutral-stroke-strong-hover").withDefault((element) => neutralStrokeStrongRecipe.getValueFor(element).evaluate(element).hover);
    neutralStrokeStrongActive = create3("neutral-stroke-strong-active").withDefault((element) => neutralStrokeStrongRecipe.getValueFor(element).evaluate(element).active);
    neutralStrokeStrongFocus = create3("neutral-stroke-strong-focus").withDefault((element) => neutralStrokeStrongRecipe.getValueFor(element).evaluate(element).focus);
    focusStrokeOuterRecipe = createNonCss("focus-stroke-outer-recipe").withDefault({
      evaluate: (element) => focusStrokeOuter(neutralPalette.getValueFor(element), fillColor.getValueFor(element))
    });
    focusStrokeOuter2 = create3("focus-stroke-outer").withDefault((element) => focusStrokeOuterRecipe.getValueFor(element).evaluate(element));
    focusStrokeInnerRecipe = createNonCss("focus-stroke-inner-recipe").withDefault({
      evaluate: (element) => focusStrokeInner(accentPalette.getValueFor(element), fillColor.getValueFor(element), focusStrokeOuter2.getValueFor(element))
    });
    focusStrokeInner2 = create3("focus-stroke-inner").withDefault((element) => focusStrokeInnerRecipe.getValueFor(element).evaluate(element));
    foregroundOnAccentLargeRecipe = createNonCss("foreground-on-accent-large-recipe").withDefault({
      evaluate: (element) => foregroundOnAccentSet(accentFillRest.getValueFor(element), accentFillHover.getValueFor(element), accentFillActive.getValueFor(element), accentFillFocus.getValueFor(element), ContrastTarget.large)
    });
    foregroundOnAccentRestLarge = create3("foreground-on-accent-rest-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element).rest);
    foregroundOnAccentHoverLarge = create3("foreground-on-accent-hover-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillHover.getValueFor(element)).hover);
    foregroundOnAccentActiveLarge = create3("foreground-on-accent-active-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillActive.getValueFor(element)).active);
    foregroundOnAccentFocusLarge = create3("foreground-on-accent-focus-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillFocus.getValueFor(element)).focus);
    neutralFillInverseRestDelta = create3("neutral-fill-inverse-rest-delta").withDefault(0);
    neutralFillInverseHoverDelta = create3("neutral-fill-inverse-hover-delta").withDefault(-3);
    neutralFillInverseActiveDelta = create3("neutral-fill-inverse-active-delta").withDefault(7);
    neutralFillInverseFocusDelta = create3("neutral-fill-inverse-focus-delta").withDefault(0);
    neutralFillInverseRecipe = createNonCss("neutral-fill-inverse-recipe").withDefault({
      evaluate: (element, reference) => neutralFillInverse(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillInverseRestDelta.getValueFor(element), neutralFillInverseHoverDelta.getValueFor(element), neutralFillInverseActiveDelta.getValueFor(element), neutralFillInverseFocusDelta.getValueFor(element))
    });
    neutralFillInverseRest = create3("neutral-fill-inverse-rest").withDefault((element) => neutralFillInverseRecipe.getValueFor(element).evaluate(element).rest);
    neutralFillInverseHover = create3("neutral-fill-inverse-hover").withDefault((element) => neutralFillInverseRecipe.getValueFor(element).evaluate(element).hover);
    neutralFillInverseActive = create3("neutral-fill-inverse-active").withDefault((element) => neutralFillInverseRecipe.getValueFor(element).evaluate(element).active);
    neutralFillInverseFocus = create3("neutral-fill-inverse-focus").withDefault((element) => neutralFillInverseRecipe.getValueFor(element).evaluate(element).focus);
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/patterns/type-ramp.js
var typeRampBase, typeRampMinus1, typeRampMinus2, typeRampPlus1, typeRampPlus2, typeRampPlus3, typeRampPlus4, typeRampPlus5, typeRampPlus6;
var init_type_ramp2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/patterns/type-ramp.js"() {
    init_esm();
    init_design_tokens();
    typeRampBase = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampBaseFontSize};
  line-height: ${typeRampBaseLineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampBaseFontVariations};
`;
    typeRampMinus1 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampMinus1FontSize};
  line-height: ${typeRampMinus1LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampMinus1FontVariations};
`;
    typeRampMinus2 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampMinus2FontSize};
  line-height: ${typeRampMinus2LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampMinus2FontVariations};
`;
    typeRampPlus1 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampPlus1FontSize};
  line-height: ${typeRampPlus1LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampPlus1FontVariations};
`;
    typeRampPlus2 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampPlus2FontSize};
  line-height: ${typeRampPlus2LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampPlus2FontVariations};
`;
    typeRampPlus3 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampPlus3FontSize};
  line-height: ${typeRampPlus3LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampPlus3FontVariations};
`;
    typeRampPlus4 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampPlus4FontSize};
  line-height: ${typeRampPlus4LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampPlus4FontVariations};
`;
    typeRampPlus5 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampPlus5FontSize};
  line-height: ${typeRampPlus5LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampPlus5FontVariations};
`;
    typeRampPlus6 = cssPartial`
  font-family: ${bodyFont};
  font-size: ${typeRampPlus6FontSize};
  line-height: ${typeRampPlus6LineHeight};
  font-weight: initial;
  font-variation-settings: ${typeRampPlus6FontVariations};
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/accordion/accordion.styles.js
var accordionStyles;
var init_accordion_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/accordion/accordion.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_type_ramp2();
    accordionStyles = (context, definition) => css2`
    ${display("flex")} :host {
      box-sizing: border-box;
      flex-direction: column;
      ${typeRampBase}
      color: ${neutralForegroundRest};
      gap: calc(${designUnit} * 1px);
    }
  `;
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/focus.js
var focusTreatmentBase, focusTreatmentTight;
var init_focus2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/focus.js"() {
    init_esm();
    init_design_tokens();
    focusTreatmentBase = cssPartial`
  outline: calc(${focusStrokeWidth} * 1px) solid ${focusStrokeOuter2};
  outline-offset: calc(${focusStrokeWidth} * -1px);
`;
    focusTreatmentTight = cssPartial`
  outline: calc(${focusStrokeWidth} * 1px) solid ${focusStrokeOuter2};
  outline-offset: calc(${strokeWidth} * 1px);
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/size.js
var heightNumber;
var init_size = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/size.js"() {
    init_esm();
    init_design_tokens();
    heightNumber = cssPartial`(${baseHeightMultiplier} + ${density}) * ${designUnit}`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/accordion/accordion-item/accordion-item.styles.js
var neutralFillStealthRestOnNeutralFillLayerRest, neutralFillStealthHoverOnNeutralFillLayerRest, neutralFillStealthActiveOnNeutralFillLayerRest, accordionItemStyles;
var init_accordion_item_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/accordion/accordion-item/accordion-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_design_tokens();
    init_focus2();
    init_type_ramp2();
    init_size();
    neutralFillStealthRestOnNeutralFillLayerRest = DesignToken.create("neutral-fill-stealth-rest-on-neutral-fill-layer-rest").withDefault((target2) => {
      const baseRecipe = neutralFillLayerRecipe.getValueFor(target2);
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, baseRecipe.evaluate(target2).rest).rest;
    });
    neutralFillStealthHoverOnNeutralFillLayerRest = DesignToken.create("neutral-fill-stealth-hover-on-neutral-fill-layer-rest").withDefault((target2) => {
      const baseRecipe = neutralFillLayerRecipe.getValueFor(target2);
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, baseRecipe.evaluate(target2).rest).hover;
    });
    neutralFillStealthActiveOnNeutralFillLayerRest = DesignToken.create("neutral-fill-stealth-active-on-neutral-fill-layer-rest").withDefault((target2) => {
      const baseRecipe = neutralFillLayerRecipe.getValueFor(target2);
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, baseRecipe.evaluate(target2).rest).active;
    });
    accordionItemStyles = (context, definition) => css2`
    ${display("flex")} :host {
      box-sizing: border-box;
      ${typeRampBase};
      flex-direction: column;
      background: ${neutralFillLayerRest};
      color: ${neutralForegroundRest};
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeLayerRest};
      border-radius: calc(${layerCornerRadius} * 1px);
    }

    .region {
      display: none;
      padding: calc(${designUnit} * 2 * 1px);
      background: ${neutralFillLayerAltRest};
    }

    .heading {
      display: grid;
      position: relative;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
    }

    .button {
      appearance: none;
      border: none;
      background: none;
      grid-column: 2;
      grid-row: 1;
      outline: none;
      margin: calc(${designUnit} * 3 * 1px) 0;
      padding: 0 calc(${designUnit} * 2 * 1px);
      text-align: left;
      color: inherit;
      cursor: pointer;
      font: inherit;
    }

    .button::before {
      content: '';
      position: absolute;
      top: calc(${strokeWidth} * -1px);
      left: calc(${strokeWidth} * -1px);
      right: calc(${strokeWidth} * -1px);
      bottom: calc(${strokeWidth} * -1px);
      cursor: pointer;
    }

    .button:${focusVisible}::before {
      ${focusTreatmentBase}
      border-radius: calc(${layerCornerRadius} * 1px);
    }

    :host(.expanded) .button:${focusVisible}::before {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }

    :host(.expanded) .region {
      display: block;
      border-top: calc(${strokeWidth} * 1px) solid ${neutralStrokeLayerRest};
      border-bottom-left-radius: calc((${layerCornerRadius} - ${strokeWidth}) * 1px);
      border-bottom-right-radius: calc((${layerCornerRadius} - ${strokeWidth}) * 1px);
    }

    .icon {
      display: flex;
      align-items: center;
      justify-content: center;
      grid-column: 4;
      pointer-events: none;
      background: ${neutralFillStealthRestOnNeutralFillLayerRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      fill: currentcolor;
      width: calc(${heightNumber} * 1px);
      height: calc(${heightNumber} * 1px);
      margin: calc(${designUnit} * 2 * 1px);
    }

    .heading:hover .icon {
      background: ${neutralFillStealthHoverOnNeutralFillLayerRest};
    }

    .heading:active .icon {
      background: ${neutralFillStealthActiveOnNeutralFillLayerRest};
    }

    slot[name='collapsed-icon'] {
      display: flex;
    }

    :host(.expanded) slot[name='collapsed-icon'] {
      display: none;
    }

    slot[name='expanded-icon'] {
      display: none;
    }

    :host(.expanded) slot[name='expanded-icon'] {
      display: flex;
    }

    .start {
      display: flex;
      align-items: center;
      padding-inline-start: calc(${designUnit} * 2 * 1px);
      justify-content: center;
      grid-column: 1;
    }

    .end {
      display: flex;
      align-items: center;
      justify-content: center;
      grid-column: 3;
    }

    .icon,
    .start,
    .end {
      position: relative;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .button:${focusVisible}::before {
          outline-color: ${SystemColors.Highlight};
        }
        .icon {
          fill: ${SystemColors.ButtonText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/accordion/accordion-item/index.js
var fluentAccordionItem;
var init_accordion_item3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/accordion/accordion-item/index.js"() {
    init_esm2();
    init_accordion_item_styles();
    fluentAccordionItem = AccordionItem.compose({
      baseName: "accordion-item",
      template: accordionItemTemplate,
      styles: accordionItemStyles,
      collapsedIcon: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>
    </svg>
  `,
      expandedIcon: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M2.15 7.35c.2.2.5.2.7 0L6 4.21l3.15 3.14a.5.5 0 10.7-.7l-3.5-3.5a.5.5 0 00-.7 0l-3.5 3.5a.5.5 0 000 .7z"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/accordion/index.js
var fluentAccordion;
var init_accordion3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/accordion/index.js"() {
    init_esm2();
    init_accordion_styles();
    init_accordion_item3();
    fluentAccordion = Accordion.compose({
      baseName: "accordion",
      template: accordionTemplate,
      styles: accordionStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/direction.js
var DirectionalStyleSheetBehavior, DirectionalStyleSheetBehaviorSubscription;
var init_direction2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/direction.js"() {
    init_design_tokens();
    DirectionalStyleSheetBehavior = class {
      constructor(ltr2, rtl2) {
        this.cache = /* @__PURE__ */ new WeakMap();
        this.ltr = ltr2;
        this.rtl = rtl2;
      }
      /**
       * @internal
       */
      bind(source) {
        this.attach(source);
      }
      /**
       * @internal
       */
      unbind(source) {
        const cache2 = this.cache.get(source);
        if (cache2) {
          direction.unsubscribe(cache2);
        }
      }
      attach(source) {
        const subscriber = this.cache.get(source) || new DirectionalStyleSheetBehaviorSubscription(this.ltr, this.rtl, source);
        const value = direction.getValueFor(source);
        direction.subscribe(subscriber);
        subscriber.attach(value);
        this.cache.set(source, subscriber);
      }
    };
    DirectionalStyleSheetBehaviorSubscription = class {
      constructor(ltr2, rtl2, source) {
        this.ltr = ltr2;
        this.rtl = rtl2;
        this.source = source;
        this.attached = null;
      }
      handleChange({ target: target2, token }) {
        this.attach(token.getValueFor(this.source));
      }
      attach(direction2) {
        if (this.attached !== this[direction2]) {
          if (this.attached !== null) {
            this.source.$fastController.removeStyles(this.attached);
          }
          this.attached = this[direction2];
          if (this.attached !== null) {
            this.source.$fastController.addStyles(this.attached);
          }
        }
      }
    };
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/elevation.js
var ambientShadow, directionalShadow, elevation, elevationShadowRecipe, elevationShadowCardRestSize, elevationShadowCardHoverSize, elevationShadowCardActiveSize, elevationShadowCardFocusSize, elevationShadowCardRest, elevationShadowCardHover, elevationShadowCardActive, elevationShadowCardFocus, elevationShadowTooltipSize, elevationShadowTooltip, elevationShadowFlyoutSize, elevationShadowFlyout, elevationShadowDialogSize, elevationShadowDialog;
var init_elevation = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/elevation.js"() {
    init_esm2();
    ambientShadow = "0 0 2px rgba(0, 0, 0, 0.14)";
    directionalShadow = "0 calc(var(--elevation) * 0.5px) calc((var(--elevation) * 1px)) rgba(0, 0, 0, 0.2)";
    elevation = `box-shadow: ${ambientShadow}, ${directionalShadow};`;
    elevationShadowRecipe = DesignToken.create({
      name: "elevation-shadow",
      cssCustomPropertyName: null
    }).withDefault({
      evaluate: (element, size, reference) => {
        let ambientOpacity = 0.12;
        let directionalOpacity = 0.14;
        if (size > 16) {
          ambientOpacity = 0.2;
          directionalOpacity = 0.24;
        }
        const ambient = `0 0 2px rgba(0, 0, 0, ${ambientOpacity})`;
        const directional = `0 calc(${size} * 0.5px) calc((${size} * 1px)) rgba(0, 0, 0, ${directionalOpacity})`;
        return `${ambient}, ${directional}`;
      }
    });
    elevationShadowCardRestSize = DesignToken.create("elevation-shadow-card-rest-size").withDefault(4);
    elevationShadowCardHoverSize = DesignToken.create("elevation-shadow-card-hover-size").withDefault(8);
    elevationShadowCardActiveSize = DesignToken.create("elevation-shadow-card-active-size").withDefault(0);
    elevationShadowCardFocusSize = DesignToken.create("elevation-shadow-card-focus-size").withDefault(8);
    elevationShadowCardRest = DesignToken.create("elevation-shadow-card-rest").withDefault((element) => elevationShadowRecipe.getValueFor(element).evaluate(element, elevationShadowCardRestSize.getValueFor(element)));
    elevationShadowCardHover = DesignToken.create("elevation-shadow-card-hover").withDefault((element) => elevationShadowRecipe.getValueFor(element).evaluate(element, elevationShadowCardHoverSize.getValueFor(element)));
    elevationShadowCardActive = DesignToken.create("elevation-shadow-card-active").withDefault((element) => elevationShadowRecipe.getValueFor(element).evaluate(element, elevationShadowCardActiveSize.getValueFor(element)));
    elevationShadowCardFocus = DesignToken.create("elevation-shadow-card-focus").withDefault((element) => elevationShadowRecipe.getValueFor(element).evaluate(element, elevationShadowCardFocusSize.getValueFor(element)));
    elevationShadowTooltipSize = DesignToken.create("elevation-shadow-tooltip-size").withDefault(16);
    elevationShadowTooltip = DesignToken.create("elevation-shadow-tooltip").withDefault((element) => elevationShadowRecipe.getValueFor(element).evaluate(element, elevationShadowTooltipSize.getValueFor(element)));
    elevationShadowFlyoutSize = DesignToken.create("elevation-shadow-flyout-size").withDefault(32);
    elevationShadowFlyout = DesignToken.create("elevation-shadow-flyout").withDefault((element) => elevationShadowRecipe.getValueFor(element).evaluate(element, elevationShadowFlyoutSize.getValueFor(element)));
    elevationShadowDialogSize = DesignToken.create("elevation-shadow-dialog-size").withDefault(128);
    elevationShadowDialog = DesignToken.create("elevation-shadow-dialog").withDefault((element) => elevationShadowRecipe.getValueFor(element).evaluate(element, elevationShadowDialogSize.getValueFor(element)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/patterns/button.styles.js
var baseButtonStyles, NeutralButtonStyles, AccentButtonStyles, HypertextStyles, LightweightButtonStyles, OutlineButtonStyles, StealthButtonStyles;
var init_button_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/patterns/button.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_size();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    baseButtonStyles = (context, definition, interactivitySelector5, nonInteractivitySelector3 = "[disabled]") => css2`
    ${display("inline-flex")}
    
    :host {
      position: relative;
      box-sizing: border-box;
      ${typeRampBase}
      height: calc(${heightNumber} * 1px);
      min-width: calc(${heightNumber} * 1px);
      color: ${neutralForegroundRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      fill: currentcolor;
    }

    .control {
      border: calc(${strokeWidth} * 1px) solid transparent;
      flex-grow: 1;
      box-sizing: border-box;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      padding: 0 calc((10 + (${designUnit} * 2 * ${density})) * 1px);
      white-space: nowrap;
      outline: none;
      text-decoration: none;
      color: inherit;
      border-radius: inherit;
      fill: inherit;
      font-family: inherit;
    }

    .control,
    .end,
    .start {
      font: inherit;
    }

    .control.icon-only {
      padding: 0;
      line-height: 0;
    }

    .control:${focusVisible} {
      ${focusTreatmentBase}
    }

    .control::-moz-focus-inner {
      border: 0;
    }

    .content {
      pointer-events: none;
    }

    .start,
    .end {
      display: flex;
      pointer-events: none;
    }

    .start {
      margin-inline-end: 11px;
    }

    .end {
      margin-inline-start: 11px;
    }
  `;
    NeutralButtonStyles = (context, definition, interactivitySelector5, nonInteractivitySelector3 = "[disabled]") => css2`
    .control {
      background: padding-box linear-gradient(${neutralFillRest}, ${neutralFillRest}),
        border-box ${neutralStrokeControlRest};
    }

    :host(${interactivitySelector5}:hover) .control {
      background: padding-box linear-gradient(${neutralFillHover}, ${neutralFillHover}),
        border-box ${neutralStrokeControlHover};
    }

    :host(${interactivitySelector5}:active) .control {
      background: padding-box linear-gradient(${neutralFillActive}, ${neutralFillActive}),
        border-box ${neutralStrokeControlActive};
    }

    :host(${nonInteractivitySelector3}) .control {
      background: padding-box linear-gradient(${neutralFillRest}, ${neutralFillRest}),
        border-box ${neutralStrokeRest};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .control {
          background: ${SystemColors.ButtonFace};
          border-color: ${SystemColors.ButtonText};
          color: ${SystemColors.ButtonText};
        }

        :host(${interactivitySelector5}:hover) .control,
        :host(${interactivitySelector5}:active) .control {
          forced-color-adjust: none;
          background: ${SystemColors.HighlightText};
          border-color: ${SystemColors.Highlight};
          color: ${SystemColors.Highlight};
        }

        :host(${nonInteractivitySelector3}) .control {
          background: transparent;
          border-color: ${SystemColors.GrayText};
          color: ${SystemColors.GrayText};
        }

        .control:${focusVisible} {
          outline-color: ${SystemColors.CanvasText};
        }

        :host([href]) .control {
          background: transparent;
          border-color: ${SystemColors.LinkText};
          color: ${SystemColors.LinkText};
        }

        :host([href]:hover) .control,
        :host([href]:active) .control {
          background: transparent;
          border-color: ${SystemColors.CanvasText};
          color: ${SystemColors.CanvasText};
        }
    `));
    AccentButtonStyles = (context, definition, interactivitySelector5, nonInteractivitySelector3 = "[disabled]") => css2`
    .control {
      background: padding-box linear-gradient(${accentFillRest}, ${accentFillRest}),
        border-box ${accentStrokeControlRest};
      color: ${foregroundOnAccentRest};
    }

    :host(${interactivitySelector5}:hover) .control {
      background: padding-box linear-gradient(${accentFillHover}, ${accentFillHover}),
        border-box ${accentStrokeControlHover};
      color: ${foregroundOnAccentHover};
    }

    :host(${interactivitySelector5}:active) .control {
      background: padding-box linear-gradient(${accentFillActive}, ${accentFillActive}),
        border-box ${accentStrokeControlActive};
      color: ${foregroundOnAccentActive};
    }

    :host(${nonInteractivitySelector3}) .control {
      background: ${accentFillRest};
    }

    .control:${focusVisible} {
      box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px) ${focusStrokeInner2} inset !important;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .control {
          forced-color-adjust: none;
          background: ${SystemColors.Highlight};
          color: ${SystemColors.HighlightText};
        }

        :host(${interactivitySelector5}:hover) .control,
        :host(${interactivitySelector5}:active) .control {
          background: ${SystemColors.HighlightText};
          border-color: ${SystemColors.Highlight};
          color: ${SystemColors.Highlight};
        }

        :host(${nonInteractivitySelector3}) .control {
          background: transparent;
          border-color: ${SystemColors.GrayText};
          color: ${SystemColors.GrayText};
        }

        .control:${focusVisible} {
          outline-color: ${SystemColors.CanvasText};
          box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px) ${SystemColors.HighlightText} inset !important;
        }

        :host([href]) .control {
          background: ${SystemColors.LinkText};
          color: ${SystemColors.HighlightText};
        }

        :host([href]:hover) .control,
        :host([href]:active) .control {
          background: ${SystemColors.ButtonFace};
          border-color: ${SystemColors.LinkText};
          color: ${SystemColors.LinkText};
        }
      `));
    HypertextStyles = (context, definition, interactivitySelector5, nonInteractivitySelector3 = "[disabled]") => css2`
    :host {
      height: auto;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      min-width: 0;
    }

    .control {
      display: inline;
      padding: 0;
      border: none;
      box-shadow: none;
      line-height: 1;
    }

    :host(${interactivitySelector5}) .control {
      color: ${accentForegroundRest};
      text-decoration: underline 1px;
    }

    :host(${interactivitySelector5}:hover) .control {
      color: ${accentForegroundHover};
      text-decoration: none;
    }

    :host(${interactivitySelector5}:active) .control {
      color: ${accentForegroundActive};
      text-decoration: none;
    }

    .control:${focusVisible} {
      ${focusTreatmentTight}
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host(${interactivitySelector5}) .control {
          color: ${SystemColors.LinkText};
        }

        :host(${interactivitySelector5}:hover) .control,
        :host(${interactivitySelector5}:active) .control {
          color: ${SystemColors.CanvasText};
        }

        .control:${focusVisible} {
          outline-color: ${SystemColors.CanvasText};
        }
      `));
    LightweightButtonStyles = (context, definition, interactivitySelector5, nonInteractivitySelector3 = "[disabled]") => css2`
    :host {
      color: ${accentForegroundRest};
    }

    .control {
      background: ${neutralFillStealthRest};
    }

    :host(${interactivitySelector5}:hover) .control {
      background: ${neutralFillStealthHover};
      color: ${accentForegroundHover};
    }

    :host(${interactivitySelector5}:active) .control {
      background: ${neutralFillStealthActive};
      color: ${accentForegroundActive};
    }

    :host(${nonInteractivitySelector3}) .control {
      background: ${neutralFillStealthRest};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host {
          color: ${SystemColors.ButtonText};
        }

        .control {
          forced-color-adjust: none;
          background: transparent;
        }

        :host(${interactivitySelector5}:hover) .control,
        :host(${interactivitySelector5}:active) .control {
          background: transparent;
          border-color: ${SystemColors.ButtonText};
          color: ${SystemColors.ButtonText};
        }

        :host(${nonInteractivitySelector3}) .control {
          background: transparent;
          color: ${SystemColors.GrayText};
        }

        .control:${focusVisible} {
          outline-color: ${SystemColors.CanvasText};
        }

        :host([href]) .control {
          color: ${SystemColors.LinkText};
        }

        :host([href]:hover) .control,
        :host([href]:active) .control {
          border-color: ${SystemColors.LinkText};
          color: ${SystemColors.LinkText};
        }
      `));
    OutlineButtonStyles = (context, definition, interactivitySelector5, nonInteractivitySelector3 = "[disabled]") => css2`
    .control {
      background: transparent !important;
      border-color: ${neutralStrokeRest};
    }

    :host(${interactivitySelector5}:hover) .control {
      border-color: ${neutralStrokeHover};
    }

    :host(${interactivitySelector5}:active) .control {
      border-color: ${neutralStrokeActive};
    }

    :host(${nonInteractivitySelector3}) .control {
      background: transparent !important;
      border-color: ${neutralStrokeRest};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .control {
          border-color: ${SystemColors.ButtonText};
          color: ${SystemColors.ButtonText};
        }

        :host(${interactivitySelector5}:hover) .control,
        :host(${interactivitySelector5}:active) .control {
          background: ${SystemColors.HighlightText};
          border-color: ${SystemColors.Highlight};
          color: ${SystemColors.Highlight};
        }

        :host(${nonInteractivitySelector3}) .control {
          border-color: ${SystemColors.GrayText};
          color: ${SystemColors.GrayText};
        }

        .control:${focusVisible} {
          outline-color: ${SystemColors.CanvasText};
        }

        :host([href]) .control {
          border-color: ${SystemColors.LinkText};
          color: ${SystemColors.LinkText};
        }

        :host([href]:hover) .control,
        :host([href]:active) .control {
          border-color: ${SystemColors.CanvasText};
          color: ${SystemColors.CanvasText};
        }
      `));
    StealthButtonStyles = (context, definition, interactivitySelector5, nonInteractivitySelector3 = "[disabled]") => css2`
    .control {
      background: ${neutralFillStealthRest};
    }

    :host(${interactivitySelector5}:hover) .control {
      background: ${neutralFillStealthHover};
    }

    :host(${interactivitySelector5}:active) .control {
      background: ${neutralFillStealthActive};
    }

    :host(${nonInteractivitySelector3}) .control {
      background: ${neutralFillStealthRest};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .control {
          forced-color-adjust: none;
          background: transparent;
          color: ${SystemColors.ButtonText};
        }

        :host(${interactivitySelector5}:hover) .control,
        :host(${interactivitySelector5}:active) .control {
          background: transparent;
          border-color: ${SystemColors.ButtonText};
          color: ${SystemColors.ButtonText};
        }

        :host(${nonInteractivitySelector3}) .control {
          background: transparent;
          color: ${SystemColors.GrayText};
        }
        
        .control:${focusVisible} {
          outline-color: ${SystemColors.CanvasText};
        }

        :host([href]) .control {
          color: ${SystemColors.LinkText};
        }

        :host([href]:hover) .control,
        :host([href]:active) .control {
          background: transparent;
          border-color: ${SystemColors.LinkText};
          color: ${SystemColors.LinkText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/patterns/input.styles.js
var placeholderRest, placeholderHover, filledPlaceholderRest, filledPlaceholderHover, baseInputStyles, inputStateStyles, inputOutlineStyles, inputFilledStyles, inputForcedColorStyles;
var init_input_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/patterns/input.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_design_tokens();
    init_type_ramp2();
    init_size();
    init_focus2();
    placeholderRest = DesignToken.create("input-placeholder-rest").withDefault((target2) => {
      const baseRecipe = neutralFillInputRecipe.getValueFor(target2);
      const hintRecipe = neutralForegroundHintRecipe.getValueFor(target2);
      return hintRecipe.evaluate(target2, baseRecipe.evaluate(target2).rest);
    });
    placeholderHover = DesignToken.create("input-placeholder-hover").withDefault((target2) => {
      const baseRecipe = neutralFillInputRecipe.getValueFor(target2);
      const hintRecipe = neutralForegroundHintRecipe.getValueFor(target2);
      return hintRecipe.evaluate(target2, baseRecipe.evaluate(target2).hover);
    });
    filledPlaceholderRest = DesignToken.create("input-filled-placeholder-rest").withDefault((target2) => {
      const baseRecipe = neutralFillSecondaryRecipe.getValueFor(target2);
      const hintRecipe = neutralForegroundHintRecipe.getValueFor(target2);
      return hintRecipe.evaluate(target2, baseRecipe.evaluate(target2).rest);
    });
    filledPlaceholderHover = DesignToken.create("input-filled-placeholder-hover").withDefault((target2) => {
      const baseRecipe = neutralFillSecondaryRecipe.getValueFor(target2);
      const hintRecipe = neutralForegroundHintRecipe.getValueFor(target2);
      return hintRecipe.evaluate(target2, baseRecipe.evaluate(target2).hover);
    });
    baseInputStyles = (context, definition, logicalControlSelector7) => css2`
  :host {
    ${typeRampBase}
    color: ${neutralForegroundRest};
    fill: currentcolor;
    user-select: none;
    position: relative;
  }

  ${logicalControlSelector7} {
    box-sizing: border-box;
    position: relative;
    color: inherit;
    border: calc(${strokeWidth} * 1px) solid transparent;
    border-radius: calc(${controlCornerRadius} * 1px);
    height: calc(${heightNumber} * 1px);
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
  }

  .control {
    width: 100%;
    outline: none;
  }

  .label {
    display: block;
    color: ${neutralForegroundRest};
    cursor: pointer;
    ${typeRampBase}
    margin-bottom: 4px;
  }

  .label__hidden {
    display: none;
    visibility: hidden;
  }

  :host([disabled]) ${logicalControlSelector7},
  :host([readonly]) ${logicalControlSelector7},
  :host([disabled]) .label,
  :host([readonly]) .label,
  :host([disabled]) .control,
  :host([readonly]) .control {
    cursor: ${disabledCursor};
  }

  :host([disabled]) {
    opacity: ${disabledOpacity};
  }
`;
    inputStateStyles = (context, definition, logicalControlSelector7) => css2`
  @media (forced-colors: none) {
    :host(:not([disabled]):active)::after {
      left: 50%;
      width: 40%;
      transform: translateX(-50%);
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }

    :host(:not([disabled]):focus-within)::after {
      left: 0;
      width: 100%;
      transform: none;
    }

    :host(:not([disabled]):active)::after,
    :host(:not([disabled]):focus-within:not(:active))::after {
      content: '';
      position: absolute;
      height: calc(${focusStrokeWidth} * 1px);
      bottom: 0;
      border-bottom: calc(${focusStrokeWidth} * 1px) solid ${accentFillRest};
      border-bottom-left-radius: calc(${controlCornerRadius} * 1px);
      border-bottom-right-radius: calc(${controlCornerRadius} * 1px);
      z-index: 2;
      transition: all 300ms cubic-bezier(0.1, 0.9, 0.2, 1);
    }
  }
`;
    inputOutlineStyles = (context, definition, logicalControlSelector7, interactivitySelector5 = ":not([disabled]):not(:focus-within)") => css2`
  ${logicalControlSelector7} {
    background: padding-box linear-gradient(${neutralFillInputRest}, ${neutralFillInputRest}),
      border-box ${neutralStrokeInputRest};
  }

  :host(${interactivitySelector5}:hover) ${logicalControlSelector7} {
    background: padding-box linear-gradient(${neutralFillInputHover}, ${neutralFillInputHover}),
      border-box ${neutralStrokeInputHover};
  }

  :host(:not([disabled]):focus-within) ${logicalControlSelector7} {
    background: padding-box linear-gradient(${neutralFillInputFocus}, ${neutralFillInputFocus}),
      border-box ${neutralStrokeInputRest};
  }
  
  :host([disabled]) ${logicalControlSelector7} {
    background: padding-box linear-gradient(${neutralFillInputRest}, ${neutralFillInputRest}),
      border-box ${neutralStrokeRest};
  }

  .control::placeholder {
    color: ${placeholderRest};
  }

  :host(${interactivitySelector5}:hover) .control::placeholder {
    color: ${placeholderHover};
  }
`;
    inputFilledStyles = (context, definition, logicalControlSelector7, interactivitySelector5 = ":not([disabled]):not(:focus-within)") => css2`
  ${logicalControlSelector7} {
    background: ${neutralFillSecondaryRest};
  }

  :host(${interactivitySelector5}:hover) ${logicalControlSelector7} {
    background: ${neutralFillSecondaryHover};
  }

  :host(:not([disabled]):focus-within) ${logicalControlSelector7} {
    background: ${neutralFillSecondaryFocus};
  }

  :host([disabled]) ${logicalControlSelector7} {
    background: ${neutralFillSecondaryRest};
  }

  .control::placeholder {
    color: ${filledPlaceholderRest};
  }

  :host(${interactivitySelector5}:hover) .control::placeholder {
    color: ${filledPlaceholderHover};
  }
`;
    inputForcedColorStyles = (context, definition, logicalControlSelector7, interactivitySelector5 = ":not([disabled]):not(:focus-within)") => css2`
  :host {
    color: ${SystemColors.ButtonText};
  }

  ${logicalControlSelector7} {
    background: ${SystemColors.ButtonFace};
    border-color: ${SystemColors.ButtonText};
  }

  :host(${interactivitySelector5}:hover) ${logicalControlSelector7},
  :host(:not([disabled]):focus-within) ${logicalControlSelector7} {
    border-color: ${SystemColors.Highlight};
  }

  :host([disabled]) ${logicalControlSelector7} {
    opacity: 1;
    background: ${SystemColors.ButtonFace};
    border-color: ${SystemColors.GrayText};
  }

  .control::placeholder,
  :host(${interactivitySelector5}:hover) .control::placeholder {
    color: ${SystemColors.CanvasText};
  }

  :host(:not([disabled]):focus) ${logicalControlSelector7} {
    ${focusTreatmentBase}
    outline-color: ${SystemColors.Highlight};
  }

  :host([disabled]) {
    opacity: 1;
    color: ${SystemColors.GrayText};
  }

  :host([disabled]) ::placeholder,
  :host([disabled]) ::-webkit-input-placeholder {
    color: ${SystemColors.GrayText};
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/patterns/index.js
var init_patterns2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/patterns/index.js"() {
    init_button_styles();
    init_input_styles();
    init_type_ramp2();
  }
});

// node_modules/@fluentui/web-components/dist/esm/styles/index.js
var init_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/styles/index.js"() {
    init_direction2();
    init_elevation();
    init_focus2();
    init_patterns2();
    init_size();
  }
});

// node_modules/@fluentui/web-components/dist/esm/utilities/behaviors.js
function appearanceBehavior(value, styles22) {
  return new PropertyStyleSheetBehavior("appearance", value, styles22);
}
var init_behaviors = __esm({
  "node_modules/@fluentui/web-components/dist/esm/utilities/behaviors.js"() {
    init_esm2();
  }
});

// node_modules/@fluentui/web-components/dist/esm/anchor/anchor.styles.js
var interactivitySelector, anchorStyles;
var init_anchor_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/anchor/anchor.styles.js"() {
    init_styles();
    init_behaviors();
    interactivitySelector = "[href]";
    anchorStyles = (context, definition) => baseButtonStyles(context, definition, interactivitySelector).withBehaviors(appearanceBehavior("neutral", NeutralButtonStyles(context, definition, interactivitySelector)), appearanceBehavior("accent", AccentButtonStyles(context, definition, interactivitySelector)), appearanceBehavior("hypertext", HypertextStyles(context, definition, interactivitySelector)), appearanceBehavior("lightweight", LightweightButtonStyles(context, definition, interactivitySelector)), appearanceBehavior("outline", OutlineButtonStyles(context, definition, interactivitySelector)), appearanceBehavior("stealth", StealthButtonStyles(context, definition, interactivitySelector)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/anchor/index.js
var Anchor2, fluentAnchor;
var init_anchor3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/anchor/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_anchor_styles();
    Anchor2 = class extends Anchor {
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          this.classList.add(newValue);
          this.classList.remove(oldValue);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "neutral";
        }
      }
      /**
       * Applies 'icon-only' class when there is only an SVG in the default slot
       *
       * @internal
       */
      defaultSlottedContentChanged() {
        const slottedElements = this.defaultSlottedContent.filter((x) => x.nodeType === Node.ELEMENT_NODE);
        if (slottedElements.length === 1 && slottedElements[0] instanceof SVGElement) {
          this.control.classList.add("icon-only");
        } else {
          this.control.classList.remove("icon-only");
        }
      }
    };
    __decorate([
      attr
    ], Anchor2.prototype, "appearance", void 0);
    fluentAnchor = Anchor2.compose({
      baseName: "anchor",
      baseClass: Anchor,
      template: anchorTemplate,
      styles: anchorStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/anchored-region/anchored-region.styles.js
var anchoredRegionStyles;
var init_anchored_region_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/anchored-region/anchored-region.styles.js"() {
    init_esm();
    anchoredRegionStyles = (context, definition) => css2`
  :host {
    contain: layout;
    display: block;
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/anchored-region/index.js
var fluentAnchoredRegion;
var init_anchored_region3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/anchored-region/index.js"() {
    init_esm2();
    init_anchored_region_styles();
    fluentAnchoredRegion = AnchoredRegion.compose({
      baseName: "anchored-region",
      template: anchoredRegionTemplate,
      styles: anchoredRegionStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/badge/badge.styles.js
var badgeStyles;
var init_badge_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/badge/badge.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_type_ramp2();
    badgeStyles = (context, definition) => css2`
    ${display("inline-block")} :host {
      box-sizing: border-box;
      ${typeRampMinus1};
    }

    .control {
      border-radius: calc(${controlCornerRadius} * 1px);
      padding: calc(((${designUnit} * 0.5) - ${strokeWidth}) * 1px) calc((${designUnit} - ${strokeWidth}) * 1px);
      border: calc(${strokeWidth} * 1px) solid transparent;
    }

    :host(.lightweight) .control {
      background: transparent;
      color: ${neutralForegroundRest};
      font-weight: 600;
    }

    :host(.accent) .control {
      background: ${accentFillRest};
      color: ${foregroundOnAccentRest};
    }

    :host(.neutral) .control {
      background: ${neutralFillSecondaryRest};
      color: ${neutralForegroundRest};
    }

    :host([circular]) .control {
      border-radius: 100px;
      min-width: calc(${typeRampMinus1LineHeight} - calc(${designUnit} * 1px));
      display: flex;
      align-items: center;
      justify-content: center;
    }
  `;
  }
});

// node_modules/@fluentui/web-components/dist/esm/badge/index.js
var Badge2, fluentBadge;
var init_badge3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/badge/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_badge_styles();
    Badge2 = class extends Badge {
      constructor() {
        super(...arguments);
        this.appearance = "lightweight";
      }
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          DOM.queueUpdate(() => {
            this.classList.add(newValue);
            this.classList.remove(oldValue);
          });
        }
      }
    };
    __decorate([
      attr({ mode: "fromView" })
    ], Badge2.prototype, "appearance", void 0);
    fluentBadge = Badge2.compose({
      baseName: "badge",
      baseClass: Badge,
      template: badgeTemplate,
      styles: badgeStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/breadcrumb/breadcrumb.styles.js
var breadcrumbStyles;
var init_breadcrumb_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/breadcrumb/breadcrumb.styles.js"() {
    init_esm();
    init_esm2();
    init_type_ramp2();
    breadcrumbStyles = (context, definition) => css2`
  ${display("inline-block")} :host {
    box-sizing: border-box;
    ${typeRampBase};
  }

  .list {
    display: flex;
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/breadcrumb/index.js
var fluentBreadcrumb;
var init_breadcrumb3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/breadcrumb/index.js"() {
    init_esm2();
    init_breadcrumb_styles();
    fluentBreadcrumb = Breadcrumb.compose({
      baseName: "breadcrumb",
      template: breadcrumbTemplate,
      styles: breadcrumbStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/breadcrumb-item/breadcrumb-item.styles.js
var breadcrumbItemStyles;
var init_breadcrumb_item_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/breadcrumb-item/breadcrumb-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_design_tokens();
    init_type_ramp2();
    init_styles();
    init_focus2();
    breadcrumbItemStyles = (context, definition) => css2`
    ${display("inline-flex")} :host {
      background: transparent;
      color: ${neutralForegroundRest};
      fill: currentcolor;
      box-sizing: border-box;
      ${typeRampBase};
      min-width: calc(${heightNumber} * 1px);
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    .listitem {
      display: flex;
      align-items: center;
      border-radius: inherit;
    }

    .control {
      position: relative;
      align-items: center;
      box-sizing: border-box;
      color: inherit;
      fill: inherit;
      cursor: pointer;
      display: flex;
      outline: none;
      text-decoration: none;
      white-space: nowrap;
      border-radius: inherit;
    }

    .control:hover {
      color: ${neutralForegroundHover};
    }

    .control:active {
      color: ${neutralForegroundActive};
    }

    .control:${focusVisible} {
      ${focusTreatmentTight}
    }

    :host(:not([href])),
    :host([aria-current]) .control {
      color: ${neutralForegroundRest};
      fill: currentcolor;
      cursor: default;
    }

    .start {
      display: flex;
      margin-inline-end: 6px;
    }

    .end {
      display: flex;
      margin-inline-start: 6px;
    }

    .separator {
      display: flex;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host(:not([href])),
        .start,
        .end,
        .separator {
          background: ${SystemColors.ButtonFace};
          color: ${SystemColors.ButtonText};
          fill: currentcolor;
        }
        .separator {
          fill: ${SystemColors.ButtonText};
        }
        :host([href]) {
          forced-color-adjust: none;
          background: ${SystemColors.ButtonFace};
          color: ${SystemColors.LinkText};
        }
        :host([href]) .control:hover {
          background: ${SystemColors.LinkText};
          color: ${SystemColors.HighlightText};
          fill: currentcolor;
        }
        .control:${focusVisible} {
          outline-color: ${SystemColors.LinkText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/breadcrumb-item/index.js
var fluentBreadcrumbItem;
var init_breadcrumb_item3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/breadcrumb-item/index.js"() {
    init_esm2();
    init_breadcrumb_item_styles();
    fluentBreadcrumbItem = BreadcrumbItem.compose({
      baseName: "breadcrumb-item",
      template: breadcrumbItemTemplate,
      styles: breadcrumbItemStyles,
      shadowOptions: {
        delegatesFocus: true
      },
      separator: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M4.65 2.15a.5.5 0 000 .7L7.79 6 4.65 9.15a.5.5 0 10.7.7l3.5-3.5a.5.5 0 000-.7l-3.5-3.5a.5.5 0 00-.7 0z"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/button/button.styles.js
var interactivitySelector2, nonInteractivitySelector, buttonStyles;
var init_button_styles2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/button/button.styles.js"() {
    init_esm();
    init_esm2();
    init_styles();
    init_behaviors();
    init_design_tokens();
    interactivitySelector2 = ":not([disabled])";
    nonInteractivitySelector = "[disabled]";
    buttonStyles = (context, definition) => css2`
    :host(${interactivitySelector2}) .control {
      cursor: pointer;
    }

    :host(${nonInteractivitySelector}) .control {
      cursor: ${disabledCursor};
    }

    @media (forced-colors: none) {
      :host(${nonInteractivitySelector}) .control {
        opacity: ${disabledOpacity};
      }
    }

    ${baseButtonStyles(context, definition, interactivitySelector2, nonInteractivitySelector)}
  `.withBehaviors(appearanceBehavior("neutral", NeutralButtonStyles(context, definition, interactivitySelector2, nonInteractivitySelector)), appearanceBehavior("accent", AccentButtonStyles(context, definition, interactivitySelector2, nonInteractivitySelector)), appearanceBehavior("lightweight", LightweightButtonStyles(context, definition, interactivitySelector2, nonInteractivitySelector)), appearanceBehavior("outline", OutlineButtonStyles(context, definition, interactivitySelector2, nonInteractivitySelector)), appearanceBehavior("stealth", StealthButtonStyles(context, definition, interactivitySelector2, nonInteractivitySelector)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/button/index.js
var Button2, fluentButton;
var init_button3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/button/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_button_styles2();
    Button2 = class extends Button {
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          this.classList.add(newValue);
          this.classList.remove(oldValue);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "neutral";
        }
      }
      /**
       * Applies 'icon-only' class when there is only an SVG in the default slot
       *
       * @internal
       */
      defaultSlottedContentChanged() {
        const slottedElements = this.defaultSlottedContent.filter((x) => x.nodeType === Node.ELEMENT_NODE);
        if (slottedElements.length === 1 && slottedElements[0] instanceof SVGElement) {
          this.control.classList.add("icon-only");
        } else {
          this.control.classList.remove("icon-only");
        }
      }
    };
    __decorate([
      attr
    ], Button2.prototype, "appearance", void 0);
    fluentButton = Button2.compose({
      baseName: "button",
      baseClass: Button,
      template: buttonTemplate,
      styles: buttonStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/calendar/calendar.styles.js
var ltrStyles, rtlStyles, calendarStyles;
var init_calendar_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/calendar/calendar.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_design_tokens();
    init_styles();
    init_type_ramp2();
    ltrStyles = css2`
.day.disabled::before {
  transform: translate(-50%, 0) rotate(45deg);
}
`;
    rtlStyles = css2`
.day.disabled::before {
  transform: translate(50%, 0) rotate(-45deg);
}
`;
    calendarStyles = (context, definition) => css2`
${display("inline-block")} :host {
  --calendar-cell-size: calc((${baseHeightMultiplier} + 2 + ${density}) * ${designUnit} * 1px);
  --calendar-gap: 2px;
  ${typeRampBase}
  color: ${neutralForegroundRest};
}

.title {
  padding: calc(${designUnit} * 2px);
  font-weight: 600;
}

.days {
  text-align: center;
}

.week-days,
.week {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-gap: var(--calendar-gap);
  border: 0;
  padding: 0;
}

.day,
.week-day {
  border: 0;
  width: var(--calendar-cell-size);
  height: var(--calendar-cell-size);
  line-height: var(--calendar-cell-size);
  padding: 0;
  box-sizing: initial;
}

.week-day {
  font-weight: 600;
}

.day {
  border: calc(${strokeWidth} * 1px) solid transparent;
  border-radius: calc(${controlCornerRadius} * 1px);
}

.interact .day {
  cursor: pointer;
}

.date {
  height: 100%;
}

.inactive .date,
.inactive.disabled::before {
  color: ${neutralForegroundHint};
}

.disabled::before {
  content: '';
  display: inline-block;
  width: calc(var(--calendar-cell-size) * .8);
  height: calc(${strokeWidth} * 1px);
  background: currentColor;
  position: absolute;
  margin-top: calc(var(--calendar-cell-size) / 2);
  transform-origin: center;
  z-index: 1;
}

.selected {
  color: ${accentFillRest};
  border: 1px solid ${accentFillRest};
  background: ${fillColor};
}

.selected + .selected {
  border-start-start-radius: 0;
  border-end-start-radius: 0;
  border-inline-start-width: 0;
  padding-inline-start: calc(var(--calendar-gap) + (${strokeWidth} + ${controlCornerRadius}) * 1px);
  margin-inline-start: calc((${controlCornerRadius} * -1px) - var(--calendar-gap));
}

.today.disabled::before {
  color: ${foregroundOnAccentRest};
}

.today .date {
  color: ${foregroundOnAccentRest};
  background: ${accentFillRest};
  border-radius: 50%;
  position: relative;
}
`.withBehaviors(forcedColorsStylesheetBehavior(css2`
          .day.selected {
              color: ${SystemColors.Highlight};
          }

          .today .date {
              background: ${SystemColors.Highlight};
              color: ${SystemColors.HighlightText};
          }
      `), new DirectionalStyleSheetBehavior(ltrStyles, rtlStyles));
  }
});

// node_modules/@fluentui/web-components/dist/esm/calendar/index.js
var Calendar2, fluentCalendar;
var init_calendar3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/calendar/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_calendar_styles();
    Calendar2 = class extends Calendar {
      constructor() {
        super(...arguments);
        this.readonly = true;
      }
    };
    __decorate([
      attr({ converter: booleanConverter })
    ], Calendar2.prototype, "readonly", void 0);
    fluentCalendar = Calendar2.compose({
      baseName: "calendar",
      template: calendarTemplate,
      styles: calendarStyles,
      title: CalendarTitleTemplate
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/card/card.styles.js
var cardStyles;
var init_card_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/card/card.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_design_tokens();
    init_styles();
    cardStyles = (context, definition) => css2`
    ${display("block")} :host {
      display: block;
      contain: content;
      height: var(--card-height, 100%);
      width: var(--card-width, 100%);
      box-sizing: border-box;
      background: ${fillColor};
      color: ${neutralForegroundRest};
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeLayerRest};
      border-radius: calc(${layerCornerRadius} * 1px);
      box-shadow: ${elevationShadowCardRest};
    }

    :host {
      content-visibility: auto;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host {
          background: ${SystemColors.Canvas};
          color: ${SystemColors.CanvasText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/card/index.js
var Card2, fluentCard;
var init_card3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/card/index.js"() {
    init_tslib_es6();
    init_esm2();
    init_esm();
    init_dist3();
    init_design_tokens();
    init_swatch();
    init_palette();
    init_card_styles();
    Card2 = class extends Card {
      cardFillColorChanged(prev, next) {
        if (next) {
          const parsedColor = parseColorHexRGB(next);
          if (parsedColor !== null) {
            this.neutralPaletteSource = next;
            fillColor.setValueFor(this, SwatchRGB.create(parsedColor.r, parsedColor.g, parsedColor.b));
          }
        }
      }
      neutralPaletteSourceChanged(prev, next) {
        if (next) {
          const color = parseColorHexRGB(next);
          const swatch = SwatchRGB.create(color.r, color.g, color.b);
          neutralPalette.setValueFor(this, PaletteRGB.create(swatch));
        }
      }
      /**
       * @internal
       */
      handleChange(source, propertyName) {
        if (!this.cardFillColor) {
          fillColor.setValueFor(this, (target2) => neutralFillLayerRecipe.getValueFor(target2).evaluate(target2, fillColor.getValueFor(source)).rest);
        }
      }
      connectedCallback() {
        super.connectedCallback();
        const parent = composedParent(this);
        if (parent) {
          const parentNotifier = Observable.getNotifier(parent);
          parentNotifier.subscribe(this, "fillColor");
          parentNotifier.subscribe(this, "neutralPalette");
          this.handleChange(parent, "fillColor");
        }
      }
    };
    __decorate([
      attr({
        attribute: "card-fill-color",
        mode: "fromView"
      })
    ], Card2.prototype, "cardFillColor", void 0);
    __decorate([
      attr({
        attribute: "neutral-palette-source",
        mode: "fromView"
      })
    ], Card2.prototype, "neutralPaletteSource", void 0);
    fluentCard = Card2.compose({
      baseName: "card",
      baseClass: Card,
      template: cardTemplate,
      styles: cardStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/checkbox/checkbox.styles.js
var checkboxStyles;
var init_checkbox_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/checkbox/checkbox.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_styles();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    checkboxStyles = (context, definition) => css2`
    ${display("inline-flex")} :host {
      align-items: center;
      outline: none;
      ${/*
     * Chromium likes to select label text or the default slot when
     * the checkbox is clicked. Maybe there is a better solution here?
     */
    ""} user-select: none;
    }

    .control {
      position: relative;
      width: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
      height: calc((${heightNumber} / 2 + ${designUnit}) * 1px);
      box-sizing: border-box;
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeStrongRest};
      background: ${neutralFillInputAltRest};
      cursor: pointer;
    }

    .label__hidden {
      display: none;
      visibility: hidden;
    }

    .label {
      ${typeRampBase}
      color: ${neutralForegroundRest};
      ${/* Need to discuss with Brian how HorizontalSpacingNumber can work. https://github.com/microsoft/fast/issues/2766 */
    ""} padding-inline-start: calc(${designUnit} * 2px + 2px);
      margin-inline-end: calc(${designUnit} * 2px + 2px);
      cursor: pointer;
    }

    slot[name='checked-indicator'],
    slot[name='indeterminate-indicator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      fill: ${neutralForegroundRest};
      opacity: 0;
      pointer-events: none;
    }

    slot[name='indeterminate-indicator'] {
      position: absolute;
      top: 0;
    }

    :host(.checked) slot[name='checked-indicator'],
    :host(.checked) slot[name='indeterminate-indicator'] {
      fill: ${foregroundOnAccentRest};
    }

    :host(:not(.disabled):hover) .control {
      background: ${neutralFillInputAltHover};
      border-color: ${neutralStrokeStrongHover};
    }

    :host(:not(.disabled):active) .control {
      background: ${neutralFillInputAltActive};
      border-color: ${neutralStrokeStrongActive};
    }

    :host(:${focusVisible}) .control {
      background: ${neutralFillInputAltFocus};
      ${focusTreatmentTight}
    }

    :host(.checked) .control {
      background: ${accentFillRest};
      border-color: transparent;
    }

    :host(.checked:not(.disabled):hover) .control {
      background: ${accentFillHover};
      border-color: transparent;
    }

    :host(.checked:not(.disabled):active) .control {
      background: ${accentFillActive};
      border-color: transparent;
    }

    :host(.disabled) .label,
    :host(.readonly) .label,
    :host(.readonly) .control,
    :host(.disabled) .control {
      cursor: ${disabledCursor};
    }

    :host(.checked:not(.indeterminate)) slot[name='checked-indicator'],
    :host(.indeterminate) slot[name='indeterminate-indicator'] {
      opacity: 1;
    }

    :host(.disabled) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .control {
          border-color: ${SystemColors.FieldText};
          background: ${SystemColors.Field};
        }
        :host(:not(.disabled):hover) .control,
        :host(:not(.disabled):active) .control {
          border-color: ${SystemColors.Highlight};
          background: ${SystemColors.Field};
        }
        slot[name='checked-indicator'],
        slot[name='indeterminate-indicator'] {
          fill: ${SystemColors.FieldText};
        }
        :host(:${focusVisible}) .control {
          forced-color-adjust: none;
          outline-color: ${SystemColors.FieldText};
          background: ${SystemColors.Field};
          border-color: ${SystemColors.Highlight};
        }
        :host(.checked) .control {
          background: ${SystemColors.Highlight};
          border-color: ${SystemColors.Highlight};
        }
        :host(.checked:not(.disabled):hover) .control,
        :host(.checked:not(.disabled):active) .control {
          background: ${SystemColors.HighlightText};
          border-color: ${SystemColors.Highlight};
        }
        :host(.checked) slot[name='checked-indicator'],
        :host(.checked) slot[name='indeterminate-indicator'] {
          fill: ${SystemColors.HighlightText};
        }
        :host(.checked:hover ) .control slot[name='checked-indicator'],
        :host(.checked:hover ) .control slot[name='indeterminate-indicator'] {
          fill: ${SystemColors.Highlight};
        }
        :host(.disabled) {
          opacity: 1;
        }
        :host(.disabled) .control {
          border-color: ${SystemColors.GrayText};
          background: ${SystemColors.Field};
        }
        :host(.disabled) slot[name='checked-indicator'],
        :host(.checked.disabled:hover) .control slot[name='checked-indicator'],
        :host(.disabled) slot[name='indeterminate-indicator'],
        :host(.checked.disabled:hover) .control slot[name='indeterminate-indicator'] {
          fill: ${SystemColors.GrayText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/checkbox/index.js
var fluentCheckbox;
var init_checkbox3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/checkbox/index.js"() {
    init_esm2();
    init_checkbox_styles();
    fluentCheckbox = Checkbox.compose({
      baseName: "checkbox",
      template: checkboxTemplate,
      styles: checkboxStyles,
      checkedIndicator: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <path d="M13.86 3.66a.5.5 0 01-.02.7l-7.93 7.48a.6.6 0 01-.84-.02L2.4 9.1a.5.5 0 01.72-.7l2.4 2.44 7.65-7.2a.5.5 0 01.7.02z"/>
    </svg>
  `,
      indeterminateIndicator: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <path d="M3 8c0-.28.22-.5.5-.5h9a.5.5 0 010 1h-9A.5.5 0 013 8z"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/select/select.styles.js
var logicalControlSelector, interactivitySelector3, nonInteractivitySelector2, baseSelectStyles, baseSelectForcedColorStyles, selectStyles;
var init_select_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/select/select.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_elevation();
    init_size();
    init_behaviors();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    init_styles();
    logicalControlSelector = ".control";
    interactivitySelector3 = ":not([disabled]):not([open])";
    nonInteractivitySelector2 = "[disabled]";
    baseSelectStyles = (context, definition) => css2`
    ${display("inline-flex")}
    
    :host {
      border-radius: calc(${controlCornerRadius} * 1px);
      box-sizing: border-box;
      color: ${neutralForegroundRest};
      fill: currentcolor;
      font-family: ${bodyFont};
      position: relative;
      user-select: none;
      min-width: 250px;
      vertical-align: top;
    }

    .listbox {
      box-shadow: ${elevationShadowFlyout};
      background: ${fillColor};
      border-radius: calc(${layerCornerRadius} * 1px);
      box-sizing: border-box;
      display: inline-flex;
      flex-direction: column;
      left: 0;
      max-height: calc(var(--max-height) - (${heightNumber} * 1px));
      padding: calc((${designUnit} - ${strokeWidth} ) * 1px);
      overflow-y: auto;
      position: absolute;
      width: 100%;
      z-index: 1;
      margin: 1px 0;
      border: calc(${strokeWidth} * 1px) solid transparent;
    }

    .listbox[hidden] {
      display: none;
    }

    .control {
      border: calc(${strokeWidth} * 1px) solid transparent;
      border-radius: calc(${controlCornerRadius} * 1px);
      height: calc(${heightNumber} * 1px);
      align-items: center;
      box-sizing: border-box;
      cursor: pointer;
      display: flex;
      ${typeRampBase}
      min-height: 100%;
      padding: 0 calc(${designUnit} * 2.25px);
      width: 100%;
    }

    :host(:${focusVisible}) {
      ${focusTreatmentBase}
    }

    :host([disabled]) .control {
      cursor: ${disabledCursor};
      opacity: ${disabledOpacity};
      user-select: none;
    }

    :host([open][position='above']) .listbox {
      bottom: calc((${heightNumber} + ${designUnit} * 2) * 1px);
    }

    :host([open][position='below']) .listbox {
      top: calc((${heightNumber} + ${designUnit} * 2) * 1px);
    }

    .selected-value {
      font-family: inherit;
      flex: 1 1 auto;
      text-align: start;
    }

    .indicator {
      flex: 0 0 auto;
      margin-inline-start: 1em;
    }

    slot[name='listbox'] {
      display: none;
      width: 100%;
    }

    :host([open]) slot[name='listbox'] {
      display: flex;
      position: absolute;
    }

    .start {
      margin-inline-end: 11px;
    }

    .end {
      margin-inline-start: 11px;
    }

    .start,
    .end,
    .indicator,
    ::slotted(svg) {
      display: flex;
    }

    ::slotted([role='option']) {
      flex: 0 0 auto;
    }
  `;
    baseSelectForcedColorStyles = (context, definition) => css2`
    :host([open]) .listbox {
      background: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.CanvasText};
    }
  `;
    selectStyles = (context, definition) => baseSelectStyles(context, definition).withBehaviors(appearanceBehavior("outline", NeutralButtonStyles(context, definition, interactivitySelector3, nonInteractivitySelector2)), appearanceBehavior("filled", inputFilledStyles(context, definition, logicalControlSelector, interactivitySelector3).withBehaviors(forcedColorsStylesheetBehavior(inputForcedColorStyles(context, definition, logicalControlSelector, interactivitySelector3)))), appearanceBehavior("stealth", StealthButtonStyles(context, definition, interactivitySelector3, nonInteractivitySelector2)), forcedColorsStylesheetBehavior(baseSelectForcedColorStyles(context, definition)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/combobox/combobox.styles.js
var logicalControlSelector2, interactivitySelector4, comboboxStyles;
var init_combobox_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/combobox/combobox.styles.js"() {
    init_esm();
    init_esm2();
    init_select_styles();
    init_behaviors();
    init_design_tokens();
    init_type_ramp2();
    init_styles();
    logicalControlSelector2 = ".control";
    interactivitySelector4 = ":not([disabled]):not([open])";
    comboboxStyles = (context, definition) => css2`
    ${baseSelectStyles(context, definition)}

    ${inputStateStyles(context, definition, logicalControlSelector2)}

    :host(:empty) .listbox {
      display: none;
    }

    :host([disabled]) *,
    :host([disabled]) {
      cursor: ${disabledCursor};
      user-select: none;
    }

    :host(:active) .selected-value {
      user-select: none;
    }

    .selected-value {
      -webkit-appearance: none;
      background: transparent;
      border: none;
      color: inherit;
      ${typeRampBase}
      height: calc(100% - ${strokeWidth} * 1px));
      margin: auto 0;
      width: 100%;
      outline: none;
    }
  `.withBehaviors(appearanceBehavior("outline", inputOutlineStyles(context, definition, logicalControlSelector2, interactivitySelector4)), appearanceBehavior("filled", inputFilledStyles(context, definition, logicalControlSelector2, interactivitySelector4)), forcedColorsStylesheetBehavior(inputForcedColorStyles(context, definition, logicalControlSelector2, interactivitySelector4)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/combobox/index.js
var Combobox2, fluentCombobox;
var init_combobox3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/combobox/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_design_tokens();
    init_combobox_styles();
    Combobox2 = class extends Combobox {
      /**
       * @internal
       */
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          this.classList.add(newValue);
          this.classList.remove(oldValue);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "outline";
        }
        if (this.listbox) {
          fillColor.setValueFor(this.listbox, neutralLayerFloating2);
        }
      }
    };
    __decorate([
      attr({ mode: "fromView" })
    ], Combobox2.prototype, "appearance", void 0);
    fluentCombobox = Combobox2.compose({
      baseName: "combobox",
      baseClass: Combobox,
      shadowOptions: {
        delegatesFocus: true
      },
      template: comboboxTemplate,
      styles: comboboxStyles,
      indicator: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/data-grid/data-grid.styles.js
var dataGridStyles;
var init_data_grid_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/data-grid/data-grid.styles.js"() {
    init_esm();
    dataGridStyles = (context, definition) => css2`
  :host {
    display: flex;
    position: relative;
    flex-direction: column;
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/data-grid/data-grid-row.styles.js
var dataGridRowStyles;
var init_data_grid_row_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/data-grid/data-grid-row.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    dataGridRowStyles = (context, definition) => css2`
    :host {
      display: grid;
      padding: 1px 0;
      box-sizing: border-box;
      width: 100%;
      border-bottom: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
    }

    :host(.header) {
    }

    :host(.sticky-header) {
      background: ${fillColor};
      position: sticky;
      top: 0;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host {
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/data-grid/data-grid-cell.styles.js
var dataGridCellStyles;
var init_data_grid_cell_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/data-grid/data-grid-cell.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    dataGridCellStyles = (context, definition) => css2`
    :host {
      padding: calc((${designUnit} + ${focusStrokeWidth} - ${strokeWidth}) * 1px) calc(((${designUnit} * 3) + ${focusStrokeWidth} - ${strokeWidth}) * 1px);
      color: ${neutralForegroundRest};
      box-sizing: border-box;
      ${typeRampBase}
      border: transparent calc(${strokeWidth} * 1px) solid;
      overflow: hidden;
      white-space: nowrap;
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    :host(.column-header) {
      font-weight: 600;
    }

    :host(:${focusVisible}) {
      ${focusTreatmentBase}
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host {
          forced-color-adjust: none;
          background: ${SystemColors.Field};
          color: ${SystemColors.FieldText};
        }

        :host(:${focusVisible}) {
          outline-color: ${SystemColors.FieldText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/data-grid/index.js
var fluentDataGridCell, fluentDataGridRow, fluentDataGrid;
var init_data_grid3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/data-grid/index.js"() {
    init_esm2();
    init_data_grid_styles();
    init_data_grid_row_styles();
    init_data_grid_cell_styles();
    fluentDataGridCell = DataGridCell.compose({
      baseName: "data-grid-cell",
      template: dataGridCellTemplate,
      styles: dataGridCellStyles
    });
    fluentDataGridRow = DataGridRow.compose({
      baseName: "data-grid-row",
      template: dataGridRowTemplate,
      styles: dataGridRowStyles
    });
    fluentDataGrid = DataGrid.compose({
      baseName: "data-grid",
      template: dataGridTemplate,
      styles: dataGridStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/design-system-provider/index.js
function designToken(token) {
  return (source, key) => {
    source[key + "Changed"] = function(prev, next) {
      if (next !== void 0 && next !== null) {
        token.setValueFor(this, next);
      } else {
        token.deleteValueFor(this);
      }
    };
  };
}
var swatchConverter, backgroundStyles, DesignSystemProvider, fluentDesignSystemProvider;
var init_design_system_provider = __esm({
  "node_modules/@fluentui/web-components/dist/esm/design-system-provider/index.js"() {
    init_tslib_es6();
    init_dist3();
    init_esm();
    init_esm2();
    init_dist2();
    init_swatch();
    init_design_tokens();
    swatchConverter = {
      toView(value) {
        var _a2;
        if (value === null || value === void 0) {
          return null;
        }
        return (_a2 = value) === null || _a2 === void 0 ? void 0 : _a2.toColorString();
      },
      fromView(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const color = parseColorHexRGB(value);
        return color ? SwatchRGB.create(color.r, color.g, color.b) : null;
      }
    };
    backgroundStyles = css2`
  :host {
    background-color: ${fillColor};
    color: ${neutralForegroundRest};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css2`
      :host {
        background-color: ${SystemColors.Canvas};
        box-shadow: 0 0 0 1px ${SystemColors.CanvasText};
        color: ${SystemColors.CanvasText};
      }
    `));
    DesignSystemProvider = class extends FoundationElement {
      constructor() {
        super();
        this.noPaint = false;
        const subscriber = {
          handleChange: this.noPaintChanged.bind(this)
        };
        Observable.getNotifier(this).subscribe(subscriber, "fillColor");
        Observable.getNotifier(this).subscribe(subscriber, "baseLayerLuminance");
      }
      connectedCallback() {
        super.connectedCallback();
        this.noPaintChanged();
      }
      noPaintChanged() {
        if (!this.noPaint && (this.fillColor !== void 0 || this.baseLayerLuminance)) {
          this.$fastController.addStyles(backgroundStyles);
        } else {
          this.$fastController.removeStyles(backgroundStyles);
        }
      }
    };
    __decorate([
      attr({ attribute: "no-paint", mode: "boolean" })
    ], DesignSystemProvider.prototype, "noPaint", void 0);
    __decorate([
      attr({
        attribute: "fill-color",
        converter: swatchConverter,
        mode: "fromView"
      }),
      designToken(fillColor)
    ], DesignSystemProvider.prototype, "fillColor", void 0);
    __decorate([
      attr({
        attribute: "accent-base-color",
        converter: swatchConverter,
        mode: "fromView"
      }),
      designToken(accentBaseColor)
    ], DesignSystemProvider.prototype, "accentBaseColor", void 0);
    __decorate([
      attr({
        attribute: "neutral-base-color",
        converter: swatchConverter,
        mode: "fromView"
      }),
      designToken(neutralBaseColor)
    ], DesignSystemProvider.prototype, "neutralBaseColor", void 0);
    __decorate([
      attr({
        converter: nullableNumberConverter
      }),
      designToken(density)
    ], DesignSystemProvider.prototype, "density", void 0);
    __decorate([
      attr({
        attribute: "design-unit",
        converter: nullableNumberConverter
      }),
      designToken(designUnit)
    ], DesignSystemProvider.prototype, "designUnit", void 0);
    __decorate([
      attr({
        attribute: "direction"
      }),
      designToken(direction)
    ], DesignSystemProvider.prototype, "direction", void 0);
    __decorate([
      attr({
        attribute: "base-height-multiplier",
        converter: nullableNumberConverter
      }),
      designToken(baseHeightMultiplier)
    ], DesignSystemProvider.prototype, "baseHeightMultiplier", void 0);
    __decorate([
      attr({
        attribute: "base-horizontal-spacing-multiplier",
        converter: nullableNumberConverter
      }),
      designToken(baseHorizontalSpacingMultiplier)
    ], DesignSystemProvider.prototype, "baseHorizontalSpacingMultiplier", void 0);
    __decorate([
      attr({
        attribute: "control-corner-radius",
        converter: nullableNumberConverter
      }),
      designToken(controlCornerRadius)
    ], DesignSystemProvider.prototype, "controlCornerRadius", void 0);
    __decorate([
      attr({
        attribute: "layer-corner-radius",
        converter: nullableNumberConverter
      }),
      designToken(layerCornerRadius)
    ], DesignSystemProvider.prototype, "layerCornerRadius", void 0);
    __decorate([
      attr({
        attribute: "stroke-width",
        converter: nullableNumberConverter
      }),
      designToken(strokeWidth)
    ], DesignSystemProvider.prototype, "strokeWidth", void 0);
    __decorate([
      attr({
        attribute: "focus-stroke-width",
        converter: nullableNumberConverter
      }),
      designToken(focusStrokeWidth)
    ], DesignSystemProvider.prototype, "focusStrokeWidth", void 0);
    __decorate([
      attr({
        attribute: "disabled-opacity",
        converter: nullableNumberConverter
      }),
      designToken(disabledOpacity)
    ], DesignSystemProvider.prototype, "disabledOpacity", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-minus-2-font-size"
      }),
      designToken(typeRampMinus2FontSize)
    ], DesignSystemProvider.prototype, "typeRampMinus2FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-minus-2-line-height"
      }),
      designToken(typeRampMinus2LineHeight)
    ], DesignSystemProvider.prototype, "typeRampMinus2LineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-minus-1-font-size"
      }),
      designToken(typeRampMinus1FontSize)
    ], DesignSystemProvider.prototype, "typeRampMinus1FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-minus-1-line-height"
      }),
      designToken(typeRampMinus1LineHeight)
    ], DesignSystemProvider.prototype, "typeRampMinus1LineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-base-font-size"
      }),
      designToken(typeRampBaseFontSize)
    ], DesignSystemProvider.prototype, "typeRampBaseFontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-base-line-height"
      }),
      designToken(typeRampBaseLineHeight)
    ], DesignSystemProvider.prototype, "typeRampBaseLineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-1-font-size"
      }),
      designToken(typeRampPlus1FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus1FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-1-line-height"
      }),
      designToken(typeRampPlus1LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus1LineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-2-font-size"
      }),
      designToken(typeRampPlus2FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus2FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-2-line-height"
      }),
      designToken(typeRampPlus2LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus2LineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-3-font-size"
      }),
      designToken(typeRampPlus3FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus3FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-3-line-height"
      }),
      designToken(typeRampPlus3LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus3LineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-4-font-size"
      }),
      designToken(typeRampPlus4FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus4FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-4-line-height"
      }),
      designToken(typeRampPlus4LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus4LineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-5-font-size"
      }),
      designToken(typeRampPlus5FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus5FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-5-line-height"
      }),
      designToken(typeRampPlus5LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus5LineHeight", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-6-font-size"
      }),
      designToken(typeRampPlus6FontSize)
    ], DesignSystemProvider.prototype, "typeRampPlus6FontSize", void 0);
    __decorate([
      attr({
        attribute: "type-ramp-plus-6-line-height"
      }),
      designToken(typeRampPlus6LineHeight)
    ], DesignSystemProvider.prototype, "typeRampPlus6LineHeight", void 0);
    __decorate([
      attr({
        attribute: "accent-fill-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillRestDelta)
    ], DesignSystemProvider.prototype, "accentFillRestDelta", void 0);
    __decorate([
      attr({
        attribute: "accent-fill-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillHoverDelta)
    ], DesignSystemProvider.prototype, "accentFillHoverDelta", void 0);
    __decorate([
      attr({
        attribute: "accent-fill-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillActiveDelta)
    ], DesignSystemProvider.prototype, "accentFillActiveDelta", void 0);
    __decorate([
      attr({
        attribute: "accent-fill-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentFillFocusDelta)
    ], DesignSystemProvider.prototype, "accentFillFocusDelta", void 0);
    __decorate([
      attr({
        attribute: "accent-foreground-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundRestDelta)
    ], DesignSystemProvider.prototype, "accentForegroundRestDelta", void 0);
    __decorate([
      attr({
        attribute: "accent-foreground-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundHoverDelta)
    ], DesignSystemProvider.prototype, "accentForegroundHoverDelta", void 0);
    __decorate([
      attr({
        attribute: "accent-foreground-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundActiveDelta)
    ], DesignSystemProvider.prototype, "accentForegroundActiveDelta", void 0);
    __decorate([
      attr({
        attribute: "accent-foreground-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(accentForegroundFocusDelta)
    ], DesignSystemProvider.prototype, "accentForegroundFocusDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillRestDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillHoverDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillActiveDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillFocusDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-input-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputRestDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-input-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputHoverDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-input-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputActiveDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-input-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillInputFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillInputFocusDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-layer-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillLayerRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillLayerRestDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-stealth-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthRestDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthRestDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-stealth-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthHoverDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-stealth-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthActiveDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-stealth-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStealthFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillStealthFocusDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-strong-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStrongHoverDelta)
    ], DesignSystemProvider.prototype, "neutralFillStrongHoverDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-strong-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStrongActiveDelta)
    ], DesignSystemProvider.prototype, "neutralFillStrongActiveDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-fill-strong-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralFillStrongFocusDelta)
    ], DesignSystemProvider.prototype, "neutralFillStrongFocusDelta", void 0);
    __decorate([
      attr({
        attribute: "base-layer-luminance",
        converter: nullableNumberConverter
      }),
      designToken(baseLayerLuminance)
    ], DesignSystemProvider.prototype, "baseLayerLuminance", void 0);
    __decorate([
      attr({
        attribute: "neutral-stroke-divider-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeDividerRestDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeDividerRestDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-stroke-rest-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeRestDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeRestDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-stroke-hover-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeHoverDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeHoverDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-stroke-active-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeActiveDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeActiveDelta", void 0);
    __decorate([
      attr({
        attribute: "neutral-stroke-focus-delta",
        converter: nullableNumberConverter
      }),
      designToken(neutralStrokeFocusDelta)
    ], DesignSystemProvider.prototype, "neutralStrokeFocusDelta", void 0);
    fluentDesignSystemProvider = DesignSystemProvider.compose({
      baseName: "design-system-provider",
      template: html2` <slot></slot> `,
      styles: css2`
    ${display("block")}
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/dialog/dialog.styles.js
var dialogStyles;
var init_dialog_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/dialog/dialog.styles.js"() {
    init_esm();
    init_styles();
    init_design_tokens();
    dialogStyles = (context, definition) => css2`
  :host([hidden]) {
    display: none;
  }

  :host {
    --dialog-height: 480px;
    --dialog-width: 640px;
    display: block;
  }

  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.3);
    touch-action: none;
  }

  .positioning-region {
    display: flex;
    justify-content: center;
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    overflow: auto;
  }

  .control {
    box-shadow: ${elevationShadowDialog};
    margin-top: auto;
    margin-bottom: auto;
    border-radius: calc(${layerCornerRadius} * 1px);
    width: var(--dialog-width);
    height: var(--dialog-height);
    background: ${fillColor};
    z-index: 1;
    border: calc(${strokeWidth} * 1px) solid transparent;
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/dialog/index.js
var fluentDialog;
var init_dialog3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/dialog/index.js"() {
    init_esm2();
    init_dialog_styles();
    fluentDialog = Dialog.compose({
      baseName: "dialog",
      template: dialogTemplate,
      styles: dialogStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/divider/divider.styles.js
var dividerStyles;
var init_divider_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/divider/divider.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    dividerStyles = (context, definition) => css2`
    ${display("block")} :host {
      box-sizing: content-box;
      height: 0;
      border: none;
      border-top: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
    }
  `;
  }
});

// node_modules/@fluentui/web-components/dist/esm/divider/index.js
var fluentDivider;
var init_divider3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/divider/index.js"() {
    init_esm2();
    init_divider_styles();
    fluentDivider = Divider.compose({
      baseName: "divider",
      template: dividerTemplate,
      styles: dividerStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/flipper/flipper.styles.js
var flipperStyles;
var init_flipper_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/flipper/flipper.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_styles();
    init_design_tokens();
    init_focus2();
    flipperStyles = (context, definition) => css2`
    ${display("inline-flex")} :host {
      height: calc((${heightNumber} + ${designUnit}) * 1px);
      justify-content: center;
      align-items: center;
      fill: currentcolor;
      color: ${neutralFillStrongRest};
      background: padding-box linear-gradient(${neutralFillRest}, ${neutralFillRest}),
        border-box ${neutralStrokeControlRest};
      box-sizing: border-box;
      border: calc(${strokeWidth} * 1px) solid transparent;
      border-radius: calc(${controlCornerRadius} * 1px);
      padding: 0;
    }

    :host(.disabled) {
      opacity: ${disabledOpacity};
      cursor: ${disabledCursor};
      pointer-events: none;
    }

    .next,
    .previous {
      display: flex;
    }

    :host(:not(.disabled):hover) {
      cursor: pointer;
    }

    :host(:not(.disabled):hover) {
      color: ${neutralFillStrongHover};
    }

    :host(:not(.disabled):active) {
      color: ${neutralFillStrongActive};
    }

    :host(:${focusVisible}) {
      ${focusTreatmentBase}
    }

    :host::-moz-focus-inner {
      border: 0;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host {
          background: ${SystemColors.ButtonFace};
          border-color: ${SystemColors.ButtonText};
        }
        :host .next,
        :host .previous {
          color: ${SystemColors.ButtonText};
          fill: currentcolor;
        }
        :host(:not(.disabled):hover) {
          background: ${SystemColors.Highlight};
        }
        :host(:not(.disabled):hover) .next,
        :host(:not(.disabled):hover) .previous {
          color: ${SystemColors.HighlightText};
          fill: currentcolor;
        }
        :host(.disabled) {
          opacity: 1;
        }
        :host(.disabled),
        :host(.disabled) .next,
        :host(.disabled) .previous {
          border-color: ${SystemColors.GrayText};
          color: ${SystemColors.GrayText};
          fill: currentcolor;
        }
        :host(:${focusVisible}) {
          forced-color-adjust: none;
          outline-color: ${SystemColors.Highlight};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/flipper/index.js
var fluentFlipper;
var init_flipper3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/flipper/index.js"() {
    init_esm2();
    init_flipper_styles();
    fluentFlipper = Flipper.compose({
      baseName: "flipper",
      template: flipperTemplate,
      styles: flipperStyles,
      next: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <path d="M7.57 11.84A1 1 0 016 11.02V4.98a1 1 0 011.57-.82l3.79 2.62c.85.59.85 1.85 0 2.44l-3.79 2.62z"/>
    </svg>
  `,
      previous: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <path d="M9.43 11.84a1 1 0 001.57-.82V4.98a1 1 0 00-1.57-.82L5.64 6.78c-.85.59-.85 1.85 0 2.44l3.79 2.62z"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/horizontal-scroll/horizontal-scroll.styles.js
var ltrActionsStyles, rtlActionsStyles, ActionsStyles, horizontalScrollStyles;
var init_horizontal_scroll_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/horizontal-scroll/horizontal-scroll.styles.js"() {
    init_esm();
    init_esm2();
    init_styles();
    ltrActionsStyles = css2`
  .scroll-prev {
    right: auto;
    left: 0;
  }

  .scroll.scroll-next::before,
  .scroll-next .scroll-action {
    left: auto;
    right: 0;
  }

  .scroll.scroll-next::before {
    background: linear-gradient(to right, transparent, var(--scroll-fade-next));
  }

  .scroll-next .scroll-action {
    transform: translate(50%, -50%);
  }
`;
    rtlActionsStyles = css2`
  .scroll.scroll-next {
    right: auto;
    left: 0;
  }

  .scroll.scroll-next::before {
    background: linear-gradient(to right, var(--scroll-fade-next), transparent);
    left: auto;
    right: 0;
  }

  .scroll.scroll-prev::before {
    background: linear-gradient(to right, transparent, var(--scroll-fade-previous));
  }

  .scroll-prev .scroll-action {
    left: auto;
    right: 0;
    transform: translate(50%, -50%);
  }
`;
    ActionsStyles = css2`
  .scroll-area {
    position: relative;
  }

  div.scroll-view {
    overflow-x: hidden;
  }

  .scroll {
    bottom: 0;
    pointer-events: none;
    position: absolute;
    right: 0;
    top: 0;
    user-select: none;
    width: 100px;
  }

  .scroll.disabled {
    display: none;
  }

  .scroll::before,
  .scroll-action {
    left: 0;
    position: absolute;
  }

  .scroll::before {
    background: linear-gradient(to right, var(--scroll-fade-previous), transparent);
    content: '';
    display: block;
    height: 100%;
    width: 100%;
  }

  .scroll-action {
    pointer-events: auto;
    right: auto;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  ::slotted(fluent-flipper) {
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
  }

  .scroll-area:hover ::slotted(fluent-flipper) {
    opacity: 1;
  }
`.withBehaviors(new DirectionalStyleSheetBehavior(ltrActionsStyles, rtlActionsStyles));
    horizontalScrollStyles = (context, definition) => css2`
  ${display("block")} :host {
    --scroll-align: center;
    --scroll-item-spacing: 4px;
    contain: layout;
    position: relative;
  }

  .scroll-view {
    overflow-x: auto;
    scrollbar-width: none;
  }

  ::-webkit-scrollbar {
    display: none;
  }

  .content-container {
    align-items: var(--scroll-align);
    display: inline-flex;
    flex-wrap: nowrap;
    position: relative;
  }

  .content-container ::slotted(*) {
    margin-right: var(--scroll-item-spacing);
  }

  .content-container ::slotted(*:last-child) {
    margin-right: 0;
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/horizontal-scroll/index.js
var HorizontalScroll2, fluentHorizontalScroll;
var init_horizontal_scroll3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/horizontal-scroll/index.js"() {
    init_esm();
    init_esm2();
    init_horizontal_scroll_styles();
    HorizontalScroll2 = class extends HorizontalScroll {
      /**
       * @public
       */
      connectedCallback() {
        super.connectedCallback();
        if (this.view !== "mobile") {
          this.$fastController.addStyles(ActionsStyles);
        }
      }
    };
    fluentHorizontalScroll = HorizontalScroll2.compose({
      baseName: "horizontal-scroll",
      baseClass: HorizontalScroll,
      template: horizontalScrollTemplate,
      styles: horizontalScrollStyles,
      nextFlipper: html2`
    <fluent-flipper @click="${(x) => x.scrollToNext()}" aria-hidden="${(x) => x.flippersHiddenFromAT}"></fluent-flipper>
  `,
      previousFlipper: html2`
    <fluent-flipper
      @click="${(x) => x.scrollToPrevious()}"
      direction="previous"
      aria-hidden="${(x) => x.flippersHiddenFromAT}"
    ></fluent-flipper>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/listbox/listbox.styles.js
var listboxStyles;
var init_listbox_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/listbox/listbox.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_focus2();
    listboxStyles = (context, definition) => css2`
    ${display("inline-flex")} :host {
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      box-sizing: border-box;
      flex-direction: column;
      padding: calc(${designUnit} * 1px) 0;
    }

    ::slotted(${context.tagFor(ListboxOption)}) {
      margin: 0 calc(${designUnit} * 1px);
    }

    :host(:focus-within:not([disabled])) {
      ${focusTreatmentBase}
    }
  `;
  }
});

// node_modules/@fluentui/web-components/dist/esm/listbox/index.js
var Listbox2, fluentListbox;
var init_listbox3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/listbox/index.js"() {
    init_esm2();
    init_listbox_styles();
    Listbox2 = class extends Listbox {
    };
    fluentListbox = Listbox2.compose({
      baseName: "listbox",
      template: listboxTemplate,
      styles: listboxStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/listbox-option/listbox-option.styles.js
var optionStyles;
var init_listbox_option_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/listbox-option/listbox-option.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_size();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    optionStyles = (context, definition) => css2`
    ${display("inline-flex")} :host {
      position: relative;
      ${typeRampBase}
      background: ${neutralFillStealthRest};
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid transparent;
      box-sizing: border-box;
      color: ${neutralForegroundRest};
      cursor: pointer;
      fill: currentcolor;
      height: calc(${heightNumber} * 1px);
      overflow: hidden;
      align-items: center;
      padding: 0 calc(((${designUnit} * 3) - ${strokeWidth} - 1) * 1px);
      user-select: none;
      white-space: nowrap;
    }

    :host::before {
      content: '';
      display: block;
      position: absolute;
      left: calc((${focusStrokeWidth} - ${strokeWidth}) * 1px);
      top: calc((${heightNumber} / 4) - ${focusStrokeWidth} * 1px);
      width: 3px;
      height: calc((${heightNumber} / 2) * 1px);
      background: transparent;
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    :host(:not([disabled]):hover) {
      background: ${neutralFillStealthHover};
    }

    :host(:not([disabled]):active) {
      background: ${neutralFillStealthActive};
    }

    :host(:not([disabled]):active)::before {
      background: ${accentFillRest};
      height: calc(((${heightNumber} / 2) - 6) * 1px);
    }

    :host([aria-selected='true'])::before {
      background: ${accentFillRest};
    }

    :host(:${focusVisible}) {
      ${focusTreatmentBase}
      background: ${neutralFillStealthFocus};
    }

    :host([aria-selected='true']) {
      background: ${neutralFillSecondaryRest};
    }

    :host(:not([disabled])[aria-selected='true']:hover) {
      background: ${neutralFillSecondaryHover};
    }

    :host(:not([disabled])[aria-selected='true']:active) {
      background: ${neutralFillSecondaryActive};
    }

    :host(:not([disabled]):not([aria-selected='true']):hover) {
      background: ${neutralFillStealthHover};
    }

    :host(:not([disabled]):not([aria-selected='true']):active) {
      background: ${neutralFillStealthActive};
    }

    :host([disabled]) {
      cursor: ${disabledCursor};
      opacity: ${disabledOpacity};
    }

    .content {
      grid-column-start: 2;
      justify-self: start;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .start,
    .end,
    ::slotted(svg) {
      display: flex;
    }

    ::slotted([slot='end']) {
      margin-inline-start: 1ch;
    }

    ::slotted([slot='start']) {
      margin-inline-end: 1ch;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host {
          background: ${SystemColors.ButtonFace};
          border-color: ${SystemColors.ButtonFace};
          color: ${SystemColors.ButtonText};
        }
        :host(:not([disabled]):not([aria-selected="true"]):hover),
        :host(:not([disabled])[aria-selected="true"]:hover),
        :host([aria-selected="true"]) {
          forced-color-adjust: none;
          background: ${SystemColors.Highlight};
          color: ${SystemColors.HighlightText};
        }
        :host(:not([disabled]):active)::before,
        :host([aria-selected='true'])::before {
          background: ${SystemColors.HighlightText};
        }
        :host([disabled]),
        :host([disabled]:not([aria-selected='true']):hover) {
          background: ${SystemColors.Canvas};
          color: ${SystemColors.GrayText};
          fill: currentcolor;
          opacity: 1;
        }
        :host(:${focusVisible}) {
          outline-color: ${SystemColors.CanvasText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/listbox-option/index.js
var fluentOption;
var init_listbox_option3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/listbox-option/index.js"() {
    init_esm2();
    init_listbox_option_styles();
    fluentOption = ListboxOption.compose({
      baseName: "option",
      template: listboxOptionTemplate,
      styles: optionStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/menu/menu.styles.js
var menuStyles;
var init_menu_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/menu/menu.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_styles();
    init_design_tokens();
    menuStyles = (context, definition) => css2`
    ${display("block")} :host {
      background: ${neutralLayerFloating2};
      border: calc(${strokeWidth} * 1px) solid transparent;
      border-radius: calc(${layerCornerRadius} * 1px);
      box-shadow: ${elevationShadowFlyout};
      padding: calc((${designUnit} - ${strokeWidth}) * 1px) 0;
      max-width: 368px;
      min-width: 64px;
    }

    :host([slot='submenu']) {
      width: max-content;
      margin: 0 calc(${designUnit} * 2px);
    }

    ::slotted(${context.tagFor(MenuItem)}) {
      margin: 0 calc(${designUnit} * 1px);
    }

    ::slotted(${context.tagFor(Divider)}) {
      margin: calc(${designUnit} * 1px) 0;
    }

    ::slotted(hr) {
      box-sizing: content-box;
      height: 0;
      margin: calc(${designUnit} * 1px) 0;
      border: none;
      border-top: calc(${strokeWidth} * 1px) solid ${neutralStrokeDividerRest};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host([slot='submenu']) {
          background: ${SystemColors.Canvas};
          border-color: ${SystemColors.CanvasText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/menu/index.js
var Menu2, fluentMenu;
var init_menu3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/menu/index.js"() {
    init_esm2();
    init_design_tokens();
    init_menu_styles();
    Menu2 = class extends Menu {
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        fillColor.setValueFor(this, neutralLayerFloating2);
      }
    };
    fluentMenu = Menu2.compose({
      baseName: "menu",
      baseClass: Menu,
      template: menuTemplate,
      styles: menuStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/menu-item/menu-item.styles.js
var menuItemStyles;
var init_menu_item_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/menu-item/menu-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_styles();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    menuItemStyles = (context, definition) => css2`
    ${display("grid")} :host {
      contain: layout;
      overflow: visible;
      ${typeRampBase}
      box-sizing: border-box;
      height: calc(${heightNumber} * 1px);
      grid-template-columns: minmax(32px, auto) 1fr minmax(32px, auto);
      grid-template-rows: auto;
      justify-items: center;
      align-items: center;
      padding: 0;
      white-space: nowrap;
      color: ${neutralForegroundRest};
      fill: currentcolor;
      cursor: pointer;
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid transparent;
      position: relative;
    }

    :host(.indent-0) {
      grid-template-columns: auto 1fr minmax(32px, auto);
    }

    :host(.indent-0) .content {
      grid-column: 1;
      grid-row: 1;
      margin-inline-start: 10px;
    }

    :host(.indent-0) .expand-collapse-glyph-container {
      grid-column: 5;
      grid-row: 1;
    }

    :host(.indent-2) {
      grid-template-columns: minmax(32px, auto) minmax(32px, auto) 1fr minmax(32px, auto) minmax(32px, auto);
    }

    :host(.indent-2) .content {
      grid-column: 3;
      grid-row: 1;
      margin-inline-start: 10px;
    }

    :host(.indent-2) .expand-collapse-glyph-container {
      grid-column: 5;
      grid-row: 1;
    }

    :host(.indent-2) .start {
      grid-column: 2;
    }

    :host(.indent-2) .end {
      grid-column: 4;
    }

    :host(:${focusVisible}) {
      ${focusTreatmentBase}
    }

    :host(:not([disabled]):hover) {
      background: ${neutralFillStealthHover};
    }

    :host(:not([disabled]):active),
    :host(.expanded) {
      background: ${neutralFillStealthActive};
      color: ${neutralForegroundRest};
      z-index: 2;
    }

    :host([disabled]) {
      cursor: ${disabledCursor};
      opacity: ${disabledOpacity};
    }

    .content {
      grid-column-start: 2;
      justify-self: start;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .start,
    .end {
      display: flex;
      justify-content: center;
    }

    :host(.indent-0[aria-haspopup='menu']) {
      display: grid;
      grid-template-columns: minmax(32px, auto) auto 1fr minmax(32px, auto) minmax(32px, auto);
      align-items: center;
      min-height: 32px;
    }

    :host(.indent-1[aria-haspopup='menu']),
    :host(.indent-1[role='menuitemcheckbox']),
    :host(.indent-1[role='menuitemradio']) {
      display: grid;
      grid-template-columns: minmax(32px, auto) auto 1fr minmax(32px, auto) minmax(32px, auto);
      align-items: center;
      min-height: 32px;
    }

    :host(.indent-2:not([aria-haspopup='menu'])) .end {
      grid-column: 5;
    }

    :host .input-container,
    :host .expand-collapse-glyph-container {
      display: none;
    }

    :host([aria-haspopup='menu']) .expand-collapse-glyph-container,
    :host([role='menuitemcheckbox']) .input-container,
    :host([role='menuitemradio']) .input-container {
      display: grid;
    }

    :host([aria-haspopup='menu']) .content,
    :host([role='menuitemcheckbox']) .content,
    :host([role='menuitemradio']) .content {
      grid-column-start: 3;
    }

    :host([aria-haspopup='menu'].indent-0) .content {
      grid-column-start: 1;
    }

    :host([aria-haspopup='menu']) .end,
    :host([role='menuitemcheckbox']) .end,
    :host([role='menuitemradio']) .end {
      grid-column-start: 4;
    }

    :host .expand-collapse,
    :host .checkbox,
    :host .radio {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-sizing: border-box;
    }

    :host .checkbox-indicator,
    :host .radio-indicator,
    slot[name='checkbox-indicator'],
    slot[name='radio-indicator'] {
      display: none;
    }

    ::slotted([slot='end']:not(svg)) {
      margin-inline-end: 10px;
      color: ${neutralForegroundHint};
    }

    :host([aria-checked='true']) .checkbox-indicator,
    :host([aria-checked='true']) slot[name='checkbox-indicator'],
    :host([aria-checked='true']) .radio-indicator,
    :host([aria-checked='true']) slot[name='radio-indicator'] {
      display: flex;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host,
        ::slotted([slot='end']:not(svg)) {
          forced-color-adjust: none;
          color: ${SystemColors.ButtonText};
          fill: currentcolor;
        }
        :host(:not([disabled]):hover) {
          background: ${SystemColors.Highlight};
          color: ${SystemColors.HighlightText};
          fill: currentcolor;
        }
        :host(:hover) .start,
        :host(:hover) .end,
        :host(:hover)::slotted(svg),
        :host(:active) .start,
        :host(:active) .end,
        :host(:active)::slotted(svg),
        :host(:hover) ::slotted([slot='end']:not(svg)),
        :host(:${focusVisible}) ::slotted([slot='end']:not(svg)) {
          color: ${SystemColors.HighlightText};
          fill: currentcolor;
        }
        :host(.expanded) {
          background: ${SystemColors.Highlight};
          color: ${SystemColors.HighlightText};
        }
        :host(:${focusVisible}) {
          background: ${SystemColors.Highlight};
          outline-color: ${SystemColors.ButtonText};
          color: ${SystemColors.HighlightText};
          fill: currentcolor;
        }
        :host([disabled]),
        :host([disabled]:hover),
        :host([disabled]:hover) .start,
        :host([disabled]:hover) .end,
        :host([disabled]:hover)::slotted(svg),
        :host([disabled]:${focusVisible}) {
          background: ${SystemColors.ButtonFace};
          color: ${SystemColors.GrayText};
          fill: currentcolor;
          opacity: 1;
        }
        :host([disabled]:${focusVisible}) {
          outline-color: ${SystemColors.GrayText};
        }
        :host .expanded-toggle,
        :host .checkbox,
        :host .radio {
          border-color: ${SystemColors.ButtonText};
          background: ${SystemColors.HighlightText};
        }
        :host([checked]) .checkbox,
        :host([checked]) .radio {
          background: ${SystemColors.HighlightText};
          border-color: ${SystemColors.HighlightText};
        }
        :host(:hover) .expanded-toggle,
            :host(:hover) .checkbox,
            :host(:hover) .radio,
            :host(:${focusVisible}) .expanded-toggle,
            :host(:${focusVisible}) .checkbox,
            :host(:${focusVisible}) .radio,
            :host([checked]:hover) .checkbox,
            :host([checked]:hover) .radio,
            :host([checked]:${focusVisible}) .checkbox,
            :host([checked]:${focusVisible}) .radio {
          border-color: ${SystemColors.HighlightText};
        }
        :host([aria-checked='true']) {
          background: ${SystemColors.Highlight};
          color: ${SystemColors.HighlightText};
        }
        :host([aria-checked='true']) .checkbox-indicator,
        :host([aria-checked='true']) ::slotted([slot='checkbox-indicator']),
        :host([aria-checked='true']) ::slotted([slot='radio-indicator']) {
          fill: ${SystemColors.Highlight};
        }
        :host([aria-checked='true']) .radio-indicator {
          background: ${SystemColors.Highlight};
        }
      `), new DirectionalStyleSheetBehavior(css2`
        .expand-collapse-glyph-container {
          transform: rotate(0deg);
        }
      `, css2`
        .expand-collapse-glyph-container {
          transform: rotate(180deg);
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/menu-item/index.js
var fluentMenuItem;
var init_menu_item3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/menu-item/index.js"() {
    init_esm2();
    init_menu_item_styles();
    fluentMenuItem = MenuItem.compose({
      baseName: "menu-item",
      template: menuItemTemplate,
      styles: menuItemStyles,
      checkboxIndicator: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <path d="M13.86 3.66a.5.5 0 01-.02.7l-7.93 7.48a.6.6 0 01-.84-.02L2.4 9.1a.5.5 0 01.72-.7l2.4 2.44 7.65-7.2a.5.5 0 01.7.02z"/>
    </svg>
  `,
      expandCollapseGlyph: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <path d="M5.65 3.15a.5.5 0 000 .7L9.79 8l-4.14 4.15a.5.5 0 00.7.7l4.5-4.5a.5.5 0 000-.7l-4.5-4.5a.5.5 0 00-.7 0z"/>
    </svg>
  `,
      radioIndicator: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <circle cx="8" cy="8" r="2"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/number-field/number-field.styles.js
var logicalControlSelector3, numberFieldStyles;
var init_number_field_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/number-field/number-field.styles.js"() {
    init_esm();
    init_esm2();
    init_styles();
    init_behaviors();
    init_design_tokens();
    logicalControlSelector3 = ".root";
    numberFieldStyles = (context, definition) => css2`
    ${display("inline-block")}

    ${baseInputStyles(context, definition, logicalControlSelector3)}

    ${inputStateStyles(context, definition, logicalControlSelector3)}

    .root {
      display: flex;
      flex-direction: row;
    }

    .control {
      -webkit-appearance: none;
      color: inherit;
      background: transparent;
      border: 0;
      height: calc(100% - 4px);
      margin-top: auto;
      margin-bottom: auto;
      padding: 0 calc(${designUnit} * 2px + 1px);
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }

    .start,
    .end {
      margin: auto;
      fill: currentcolor;
    }

    .start {
      display: flex;
      margin-inline-start: 11px;
    }

    .end {
      display: flex;
      margin-inline-end: 11px;
    }

    .controls {
      opacity: 0;
      position: relative;
      top: -1px;
      z-index: 3;
    }

    :host(:hover:not([disabled])) .controls,
    :host(:focus-within:not([disabled])) .controls {
      opacity: 1;
    }

    .step-up,
    .step-down {
      display: flex;
      padding: 0 8px;
      cursor: pointer;
    }

    .step-up {
      padding-top: 3px;
    }
  `.withBehaviors(appearanceBehavior("outline", inputOutlineStyles(context, definition, logicalControlSelector3)), appearanceBehavior("filled", inputFilledStyles(context, definition, logicalControlSelector3)), forcedColorsStylesheetBehavior(inputForcedColorStyles(context, definition, logicalControlSelector3)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/number-field/index.js
var NumberField2, fluentNumberField;
var init_number_field3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/number-field/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_number_field_styles();
    NumberField2 = class extends NumberField {
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "outline";
        }
      }
    };
    __decorate([
      attr
    ], NumberField2.prototype, "appearance", void 0);
    fluentNumberField = NumberField2.compose({
      baseName: "number-field",
      baseClass: NumberField,
      styles: numberFieldStyles,
      template: numberFieldTemplate,
      shadowOptions: {
        delegatesFocus: true
      },
      stepDownGlyph: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>
    </svg>
  `,
      stepUpGlyph: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M2.15 7.35c.2.2.5.2.7 0L6 4.21l3.15 3.14a.5.5 0 10.7-.7l-3.5-3.5a.5.5 0 00-.7 0l-3.5 3.5a.5.5 0 000 .7z"/>
    </svg>
`
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/progress/progress/progress.styles.js
var progressStyles;
var init_progress_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/progress/progress/progress.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_design_tokens();
    progressStyles = (context, definition) => css2`
    ${display("flex")} :host {
      align-items: center;
      height: calc((${strokeWidth} * 3) * 1px);
    }

    .progress {
      background-color: ${neutralStrokeStrongRest};
      border-radius: calc(${designUnit} * 1px);
      width: 100%;
      height: calc(${strokeWidth} * 1px);
      display: flex;
      align-items: center;
      position: relative;
    }

    .determinate {
      background-color: ${accentFillRest};
      border-radius: calc(${designUnit} * 1px);
      height: calc((${strokeWidth} * 3) * 1px);
      transition: all 0.2s ease-in-out;
      display: flex;
    }

    .indeterminate {
      height: calc((${strokeWidth} * 3) * 1px);
      border-radius: calc(${designUnit} * 1px);
      display: flex;
      width: 100%;
      position: relative;
      overflow: hidden;
    }

    .indeterminate-indicator-1 {
      position: absolute;
      opacity: 0;
      height: 100%;
      background-color: ${accentFillRest};
      border-radius: calc(${designUnit} * 1px);
      animation-timing-function: cubic-bezier(0.4, 0, 0.6, 1);
      width: 40%;
      animation: indeterminate-1 2s infinite;
    }

    .indeterminate-indicator-2 {
      position: absolute;
      opacity: 0;
      height: 100%;
      background-color: ${accentFillRest};
      border-radius: calc(${designUnit} * 1px);
      animation-timing-function: cubic-bezier(0.4, 0, 0.6, 1);
      width: 60%;
      animation: indeterminate-2 2s infinite;
    }

    :host(.paused) .indeterminate-indicator-1,
    :host(.paused) .indeterminate-indicator-2 {
      animation: none;
      background-color: ${neutralForegroundHint};
      width: 100%;
      opacity: 1;
    }

    :host(.paused) .determinate {
      background-color: ${neutralForegroundHint};
    }

    @keyframes indeterminate-1 {
      0% {
        opacity: 1;
        transform: translateX(-100%);
      }
      70% {
        opacity: 1;
        transform: translateX(300%);
      }
      70.01% {
        opacity: 0;
      }
      100% {
        opacity: 0;
        transform: translateX(300%);
      }
    }

    @keyframes indeterminate-2 {
      0% {
        opacity: 0;
        transform: translateX(-150%);
      }
      29.99% {
        opacity: 0;
      }
      30% {
        opacity: 1;
        transform: translateX(-150%);
      }
      100% {
        transform: translateX(166.66%);
        opacity: 1;
      }
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .indeterminate-indicator-1,
        .indeterminate-indicator-2,
        .determinate,
        .progress {
          background-color: ${SystemColors.ButtonText};
        }
        :host(.paused) .indeterminate-indicator-1,
        :host(.paused) .indeterminate-indicator-2,
        :host(.paused) .determinate {
          background-color: ${SystemColors.GrayText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/progress/progress/index.js
var Progress, fluentProgress;
var init_progress2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/progress/progress/index.js"() {
    init_esm2();
    init_progress_styles();
    Progress = class extends BaseProgress {
    };
    fluentProgress = Progress.compose({
      baseName: "progress",
      template: progressTemplate,
      styles: progressStyles,
      indeterminateIndicator1: `
    <span class="indeterminate-indicator-1" part="indeterminate-indicator-1"></span>
  `,
      indeterminateIndicator2: `
    <span class="indeterminate-indicator-2" part="indeterminate-indicator-2"></span>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/progress/progress-ring/progress-ring.styles.js
var progressRingStyles;
var init_progress_ring_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/progress/progress-ring/progress-ring.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_styles();
    init_design_tokens();
    progressRingStyles = (context, definition) => css2`
    ${display("flex")} :host {
      align-items: center;
      height: calc(${heightNumber} * 1px);
      width: calc(${heightNumber} * 1px);
    }

    .progress {
      height: 100%;
      width: 100%;
    }

    .background {
      fill: none;
      stroke-width: 2px;
    }

    .determinate {
      stroke: ${accentFillRest};
      fill: none;
      stroke-width: 2px;
      stroke-linecap: round;
      transform-origin: 50% 50%;
      transform: rotate(-90deg);
      transition: all 0.2s ease-in-out;
    }

    .indeterminate-indicator-1 {
      stroke: ${accentFillRest};
      fill: none;
      stroke-width: 2px;
      stroke-linecap: round;
      transform-origin: 50% 50%;
      transform: rotate(-90deg);
      transition: all 0.2s ease-in-out;
      animation: spin-infinite 2s linear infinite;
    }

    :host(.paused) .indeterminate-indicator-1 {
      animation: none;
      stroke: ${neutralForegroundHint};
    }

    :host(.paused) .determinate {
      stroke: ${neutralForegroundHint};
    }

    @keyframes spin-infinite {
      0% {
        stroke-dasharray: 0.01px 43.97px;
        transform: rotate(0deg);
      }
      50% {
        stroke-dasharray: 21.99px 21.99px;
        transform: rotate(450deg);
      }
      100% {
        stroke-dasharray: 0.01px 43.97px;
        transform: rotate(1080deg);
      }
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .background {
          stroke: ${SystemColors.Field};
        }
        .determinate,
        .indeterminate-indicator-1 {
          stroke: ${SystemColors.ButtonText};
        }
        :host(.paused) .determinate,
        :host(.paused) .indeterminate-indicator-1 {
          stroke: ${SystemColors.GrayText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/progress/progress-ring/index.js
var ProgressRing, fluentProgressRing;
var init_progress_ring2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/progress/progress-ring/index.js"() {
    init_esm2();
    init_progress_ring_styles();
    ProgressRing = class extends BaseProgress {
    };
    fluentProgressRing = ProgressRing.compose({
      baseName: "progress-ring",
      template: progressRingTemplate,
      styles: progressRingStyles,
      indeterminateIndicator: `
    <svg class="progress" part="progress" viewBox="0 0 16 16">
        <circle
            class="background"
            part="background"
            cx="8px"
            cy="8px"
            r="7px"
        ></circle>
        <circle
            class="indeterminate-indicator-1"
            part="indeterminate-indicator-1"
            cx="8px"
            cy="8px"
            r="7px"
        ></circle>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/progress/index.js
var init_progress3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/progress/index.js"() {
    init_progress2();
    init_progress_ring2();
  }
});

// node_modules/@fluentui/web-components/dist/esm/radio/radio.styles.js
var radioStyles;
var init_radio_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/radio/radio.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_styles();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    radioStyles = (context, definition) => css2`
    ${display("inline-flex")} :host {
      --input-size: calc((${heightNumber} / 2) + ${designUnit});
      align-items: center;
      outline: none;
      ${/*
     * Chromium likes to select label text or the default slot when
     * the radio button is clicked. Maybe there is a better solution here?
     */
    ""} user-select: none;
      position: relative;
      flex-direction: row;
      transition: all 0.2s ease-in-out;
    }

    .control {
      position: relative;
      width: calc(var(--input-size) * 1px);
      height: calc(var(--input-size) * 1px);
      box-sizing: border-box;
      border-radius: 50%;
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeStrongRest};
      background: ${neutralFillInputAltRest};
      cursor: pointer;
    }

    .label__hidden {
      display: none;
      visibility: hidden;
    }

    .label {
      ${typeRampBase}
      color: ${neutralForegroundRest};
      ${/* Need to discuss with Brian how HorizontalSpacingNumber can work. https://github.com/microsoft/fast/issues/2766 */
    ""} padding-inline-start: calc(${designUnit} * 2px + 2px);
      margin-inline-end: calc(${designUnit} * 2px + 2px);
      cursor: pointer;
    }

    .control,
    slot[name='checked-indicator'] {
      flex-shrink: 0;
    }

    slot[name='checked-indicator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      fill: ${foregroundOnAccentRest};
      opacity: 0;
      pointer-events: none;
    }

    :host(:not(.disabled):hover) .control {
      background: ${neutralFillInputAltHover};
      border-color: ${neutralStrokeStrongHover};
    }

    :host(:not(.disabled):active) .control {
      background: ${neutralFillInputAltActive};
      border-color: ${neutralStrokeStrongActive};
    }

    :host(:not(.disabled):active) slot[name='checked-indicator'] {
      opacity: 1;
    }

    :host(:${focusVisible}) .control {
      ${focusTreatmentTight}
      background: ${neutralFillInputAltFocus};
    }

    :host(.checked) .control {
      background: ${accentFillRest};
      border-color: transparent;
    }

    :host(.checked:not(.disabled):hover) .control {
      background: ${accentFillHover};
      border-color: transparent;
    }

    :host(.checked:not(.disabled):active) .control {
      background: ${accentFillActive};
      border-color: transparent;
    }

    :host(.disabled) .label,
    :host(.readonly) .label,
    :host(.readonly) .control,
    :host(.disabled) .control {
      cursor: ${disabledCursor};
    }

    :host(.checked) slot[name='checked-indicator'] {
      opacity: 1;
    }

    :host(.disabled) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .control {
          background: ${SystemColors.Field};
          border-color: ${SystemColors.FieldText};
        }
        :host(:not(.disabled):hover) .control,
        :host(:not(.disabled):active) .control {
          border-color: ${SystemColors.Highlight};
        }
        :host(:${focusVisible}) .control {
          forced-color-adjust: none;
          background: ${SystemColors.Field};
          outline-color: ${SystemColors.FieldText};
        }
        :host(.checked:not(.disabled):hover) .control,
        :host(.checked:not(.disabled):active) .control {
          border-color: ${SystemColors.Highlight};
          background: ${SystemColors.Highlight};
        }
        :host(.checked) slot[name='checked-indicator'] {
          fill: ${SystemColors.Highlight};
        }
        :host(.checked:hover) .control slot[name='checked-indicator'] {
          fill: ${SystemColors.HighlightText};
        }
        :host(.disabled) {
          opacity: 1;
        }
        :host(.disabled) .label {
          color: ${SystemColors.GrayText};
        }
        :host(.disabled) .control,
        :host(.checked.disabled) .control {
          background: ${SystemColors.Field};
          border-color: ${SystemColors.GrayText};
        }
        :host(.disabled) slot[name='checked-indicator'],
        :host(.checked.disabled) slot[name='checked-indicator'] {
          fill: ${SystemColors.GrayText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/radio/index.js
var fluentRadio;
var init_radio3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/radio/index.js"() {
    init_esm2();
    init_radio_styles();
    fluentRadio = Radio.compose({
      baseName: "radio",
      template: radioTemplate,
      styles: radioStyles,
      checkedIndicator: `
    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">
      <circle cx="8" cy="8" r="4"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/radio-group/radio-group.styles.js
var radioGroupStyles;
var init_radio_group_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/radio-group/radio-group.styles.js"() {
    init_esm();
    init_esm2();
    radioGroupStyles = (context, definition) => css2`
  ${display("flex")} :host {
    align-items: flex-start;
    flex-direction: column;
  }

  .positioning-region {
    display: flex;
    flex-wrap: wrap;
  }

  :host([orientation='vertical']) .positioning-region {
    flex-direction: column;
  }

  :host([orientation='horizontal']) .positioning-region {
    flex-direction: row;
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/radio-group/index.js
var fluentRadioGroup;
var init_radio_group3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/radio-group/index.js"() {
    init_esm2();
    init_radio_group_styles();
    fluentRadioGroup = RadioGroup.compose({
      baseName: "radio-group",
      template: radioGroupTemplate,
      styles: radioGroupStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/search/search.template.js
var searchTemplate;
var init_search_template2 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/search/search.template.js"() {
    init_esm();
    init_esm2();
    searchTemplate = (context, definition) => html2`
  <template
    class="
            ${(x) => x.readOnly ? "readonly" : ""}
        "
  >
    <label
      part="label"
      for="control"
      class="${(x) => x.defaultSlottedNodes && x.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
    >
      <slot ${slotted({ property: "defaultSlottedNodes", filter: whitespaceFilter })}></slot>
    </label>
    <div class="root" part="root" ${ref("root")}>
      ${startSlotTemplate(context, definition)}
      <div class="input-wrapper" part="input-wrapper">
        <input
          class="control"
          part="control"
          id="control"
          @input="${(x) => x.handleTextInput()}"
          @change="${(x) => x.handleChange()}"
          ?autofocus="${(x) => x.autofocus}"
          ?disabled="${(x) => x.disabled}"
          list="${(x) => x.list}"
          maxlength="${(x) => x.maxlength}"
          minlength="${(x) => x.minlength}"
          pattern="${(x) => x.pattern}"
          placeholder="${(x) => x.placeholder}"
          ?readonly="${(x) => x.readOnly}"
          ?required="${(x) => x.required}"
          size="${(x) => x.size}"
          ?spellcheck="${(x) => x.spellcheck}"
          :value="${(x) => x.value}"
          type="search"
          aria-atomic="${(x) => x.ariaAtomic}"
          aria-busy="${(x) => x.ariaBusy}"
          aria-controls="${(x) => x.ariaControls}"
          aria-current="${(x) => x.ariaCurrent}"
          aria-describedby="${(x) => x.ariaDescribedby}"
          aria-details="${(x) => x.ariaDetails}"
          aria-disabled="${(x) => x.ariaDisabled}"
          aria-errormessage="${(x) => x.ariaErrormessage}"
          aria-flowto="${(x) => x.ariaFlowto}"
          aria-haspopup="${(x) => x.ariaHaspopup}"
          aria-hidden="${(x) => x.ariaHidden}"
          aria-invalid="${(x) => x.ariaInvalid}"
          aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
          aria-label="${(x) => x.ariaLabel}"
          aria-labelledby="${(x) => x.ariaLabelledby}"
          aria-live="${(x) => x.ariaLive}"
          aria-owns="${(x) => x.ariaOwns}"
          aria-relevant="${(x) => x.ariaRelevant}"
          aria-roledescription="${(x) => x.ariaRoledescription}"
          ${ref("control")}
        />
        <slot name="clear-button">
          <button
            class="clear-button ${(x) => x.value ? "" : "clear-button__hidden"}"
            part="clear-button"
            tabindex="-1"
            @click=${(x) => x.handleClearInput()}
          >
            <slot name="clear-glyph">
              <svg width="12" height="12" viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="m2.09 2.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L6 5.29l3.15-3.14a.5.5 0 1 1 .7.7L6.71 6l3.14 3.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L6 6.71 2.85 9.85a.5.5 0 0 1-.7-.7L5.29 6 2.15 2.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"
                />
              </svg>
            </slot>
          </button>
        </slot>
      </div>
      ${endSlotTemplate(context, definition)}
    </div>
  </template>
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/search/search.styles.js
var logicalControlSelector4, clearButtonHover, clearButtonActive, searchStyles;
var init_search_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/search/search.styles.js"() {
    init_esm();
    init_esm2();
    init_styles();
    init_behaviors();
    init_design_tokens();
    init_type_ramp2();
    logicalControlSelector4 = ".root";
    clearButtonHover = DesignToken.create("clear-button-hover").withDefault((target2) => {
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      const inputRecipe = neutralFillInputRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, inputRecipe.evaluate(target2).focus).hover;
    });
    clearButtonActive = DesignToken.create("clear-button-active").withDefault((target2) => {
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      const inputRecipe = neutralFillInputRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, inputRecipe.evaluate(target2).focus).active;
    });
    searchStyles = (context, definition) => css2`
    ${display("inline-block")}

    ${baseInputStyles(context, definition, logicalControlSelector4)}

    ${inputStateStyles(context, definition, logicalControlSelector4)}

    .root {
      display: flex;
      flex-direction: row;
    }
    .control {
      -webkit-appearance: none;
      color: inherit;
      background: transparent;
      border: 0;
      height: calc(100% - 4px);
      margin-top: auto;
      margin-bottom: auto;
      padding: 0 calc(${designUnit} * 2px + 1px);
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }
    .clear-button {
      display: inline-flex;
      align-items: center;
      margin: 1px;
      height: calc(100% - 2px);
      opacity: 0;
      background: transparent;
      color: ${neutralForegroundRest};
      fill: currentcolor;
      border: none;
      border-radius: calc(${controlCornerRadius} * 1px);
      min-width: calc(${heightNumber} * 1px);
      ${typeRampBase}
      outline: none;
      padding: 0 calc((10 + (${designUnit} * 2 * ${density})) * 1px);
    }
    .clear-button:hover {
      background: ${clearButtonHover};
    }
    .clear-button:active {
      background: ${clearButtonActive};
    }
    :host(:hover:not([disabled], [readOnly])) .clear-button,
    :host(:active:not([disabled], [readOnly])) .clear-button,
    :host(:focus-within:not([disabled], [readOnly])) .clear-button {
        opacity: 1;
    }
    :host(:hover:not([disabled], [readOnly])) .clear-button__hidden,
    :host(:active:not([disabled], [readOnly])) .clear-button__hidden,
    :host(:focus-within:not([disabled], [readOnly])) .clear-button__hidden {
        opacity: 0;
    }
    .control::-webkit-search-cancel-button {
      -webkit-appearance: none;
    }
    .input-wrapper {
      display: flex;
      position: relative;
      width: 100%;
    }
    .start,
    .end {
      display: flex;
      margin: 1px;
      align-items: center;
    }
    .start {
      display: flex;
      margin-inline-start: 11px;
    }
    ::slotted([slot="end"]) {
      height: 100%
    }
    .clear-button__hidden {
      opacity: 0;
    }
    .end {
        margin-inline-end: 11px;
    }
    ::slotted(${context.tagFor(Button)}) {
      margin-inline-end: 1px;
    }
  `.withBehaviors(appearanceBehavior("outline", inputOutlineStyles(context, definition, logicalControlSelector4)), appearanceBehavior("filled", inputFilledStyles(context, definition, logicalControlSelector4)), forcedColorsStylesheetBehavior(inputForcedColorStyles(context, definition, logicalControlSelector4)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/search/index.js
var Search2, fluentSearch;
var init_search3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/search/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_search_template2();
    init_search_styles();
    init_search_template2();
    Search2 = class extends Search {
      constructor() {
        super(...arguments);
        this.appearance = "outline";
      }
    };
    __decorate([
      attr
    ], Search2.prototype, "appearance", void 0);
    fluentSearch = Search2.compose({
      baseName: "search",
      baseClass: Search,
      template: searchTemplate,
      styles: searchStyles,
      start: `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg%22%3E"><path d="M8.5 3a5.5 5.5 0 0 1 4.23 9.02l4.12 4.13a.5.5 0 0 1-.63.76l-.07-.06-4.13-4.12A5.5 5.5 0 1 1 8.5 3Zm0 1a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Z"/></svg>`,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/select/index.js
var Select2, fluentSelect;
var init_select3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/select/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_design_tokens();
    init_select_styles();
    Select2 = class extends Select {
      /**
       * @internal
       */
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          this.classList.add(newValue);
          this.classList.remove(oldValue);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "outline";
        }
        if (this.listbox) {
          fillColor.setValueFor(this.listbox, neutralLayerFloating2);
        }
      }
    };
    __decorate([
      attr({ mode: "fromView" })
    ], Select2.prototype, "appearance", void 0);
    fluentSelect = Select2.compose({
      baseName: "select",
      baseClass: Select,
      template: selectTemplate,
      styles: selectStyles,
      indicator: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/skeleton/skeleton.styles.js
var skeletonStyles;
var init_skeleton_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/skeleton/skeleton.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_design_tokens();
    skeletonStyles = (context, definition) => css2`
    ${display("block")} :host {
      --skeleton-fill-default: ${neutralFillSecondaryRest};
      overflow: hidden;
      width: 100%;
      position: relative;
      background-color: var(--skeleton-fill, var(--skeleton-fill-default));
      --skeleton-animation-gradient-default: linear-gradient(
        270deg,
        var(--skeleton-fill, var(--skeleton-fill-default)) 0%,
        ${neutralFillSecondaryHover} 51%,
        var(--skeleton-fill, var(--skeleton-fill-default)) 100%
      );
      --skeleton-animation-timing-default: ease-in-out;
    }

    :host(.rect) {
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    :host(.circle) {
      border-radius: 100%;
      overflow: hidden;
    }

    object {
      position: absolute;
      width: 100%;
      height: auto;
      z-index: 2;
    }

    object img {
      width: 100%;
      height: auto;
    }

    ${display("block")} span.shimmer {
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: var(--skeleton-animation-gradient, var(--skeleton-animation-gradient-default));
      background-size: 0px 0px / 90% 100%;
      background-repeat: no-repeat;
      background-color: var(--skeleton-animation-fill, ${neutralFillSecondaryRest});
      animation: shimmer 2s infinite;
      animation-timing-function: var(--skeleton-animation-timing, var(--skeleton-timing-default));
      animation-direction: normal;
      z-index: 1;
    }

    ::slotted(svg) {
      z-index: 2;
    }

    ::slotted(.pattern) {
      width: 100%;
      height: 100%;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host{
          background-color: ${SystemColors.CanvasText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/skeleton/index.js
var fluentSkeleton;
var init_skeleton3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/skeleton/index.js"() {
    init_esm2();
    init_skeleton_styles();
    fluentSkeleton = Skeleton.compose({
      baseName: "skeleton",
      template: skeletonTemplate,
      styles: skeletonStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/slider/slider.styles.js
var sliderStyles;
var init_slider_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/slider/slider.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_styles();
    init_design_tokens();
    sliderStyles = (context, definition) => css2`
    ${display("inline-grid")} :host {
      --thumb-size: calc((${heightNumber} / 2) + ${designUnit} + (${strokeWidth} * 2));
      --thumb-translate: calc(var(--thumb-size) * -0.5 + var(--track-width) / 2);
      --track-overhang: calc((${designUnit} / 2) * -1);
      --track-width: ${designUnit};
      align-items: center;
      width: 100%;
      user-select: none;
      box-sizing: border-box;
      border-radius: calc(${controlCornerRadius} * 1px);
      outline: none;
      cursor: pointer;
    }
    :host(.horizontal) .positioning-region {
      position: relative;
      margin: 0 8px;
      display: grid;
      grid-template-rows: calc(var(--thumb-size) * 1px) 1fr;
    }
    :host(.vertical) .positioning-region {
      position: relative;
      margin: 0 8px;
      display: grid;
      height: 100%;
      grid-template-columns: calc(var(--thumb-size) * 1px) 1fr;
    }
    :host(:${focusVisible}) .thumb-cursor {
      box-shadow: 0 0 0 2px ${fillColor}, 0 0 0 4px ${focusStrokeOuter2};
    }
    .thumb-container {
      position: absolute;
      height: calc(var(--thumb-size) * 1px);
      width: calc(var(--thumb-size) * 1px);
      transition: all 0.2s ease;
    }
    .thumb-cursor {
      display: flex;
      position: relative;
      border: none;
      width: calc(var(--thumb-size) * 1px);
      height: calc(var(--thumb-size) * 1px);
      background: padding-box linear-gradient(${neutralFillRest}, ${neutralFillRest}),
        border-box ${neutralStrokeControlRest};
      border: calc(${strokeWidth} * 1px) solid transparent;
      border-radius: 50%;
      box-sizing: border-box;
    }
    .thumb-cursor::after {
      content: '';
      display: block;
      border-radius: 50%;
      width: 100%;
      margin: 4px;
      background: ${accentFillRest};
    }
    :host(:not(.disabled)) .thumb-cursor:hover::after {
      background: ${accentFillHover};
      margin: 3px;
    }
    :host(:not(.disabled)) .thumb-cursor:active::after {
      background: ${accentFillActive};
      margin: 5px;
    }
    :host(:not(.disabled)) .thumb-cursor:hover {
      background: padding-box linear-gradient(${neutralFillRest}, ${neutralFillRest}),
        border-box ${neutralStrokeControlHover};
    }
    :host(:not(.disabled)) .thumb-cursor:active {
      background: padding-box linear-gradient(${neutralFillRest}, ${neutralFillRest}),
        border-box ${neutralStrokeControlActive};
    }
    .track-start {
      background: ${accentFillRest};
      position: absolute;
      height: 100%;
      left: 0;
      border-radius: calc(${controlCornerRadius} * 1px);
    }
    :host(.horizontal) .thumb-container {
      transform: translateX(calc(var(--thumb-size) * 0.5px)) translateY(calc(var(--thumb-translate) * 1px));
    }
    :host(.vertical) .thumb-container {
      transform: translateX(calc(var(--thumb-translate) * 1px)) translateY(calc(var(--thumb-size) * 0.5px));
    }
    :host(.horizontal) {
      min-width: calc(var(--thumb-size) * 1px);
    }
    :host(.horizontal) .track {
      right: calc(var(--track-overhang) * 1px);
      left: calc(var(--track-overhang) * 1px);
      align-self: start;
      height: calc(var(--track-width) * 1px);
    }
    :host(.vertical) .track {
      top: calc(var(--track-overhang) * 1px);
      bottom: calc(var(--track-overhang) * 1px);
      width: calc(var(--track-width) * 1px);
      height: 100%;
    }
    .track {
      background: ${neutralFillStrongRest};
      border: 1px solid ${neutralStrokeStrongRest};
      border-radius: 2px;
      box-sizing: border-box;
      position: absolute;
    }
    :host(.vertical) {
      height: 100%;
      min-height: calc(${designUnit} * 60px);
      min-width: calc(${designUnit} * 20px);
    }
    :host(.vertical) .track-start {
      height: auto;
      width: 100%;
      top: 0;
    }
    :host(.disabled),
    :host(.readonly) {
      cursor: ${disabledCursor};
    }
    :host(.disabled) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .thumb-cursor {
          forced-color-adjust: none;
          border-color: ${SystemColors.FieldText};
          background: ${SystemColors.FieldText};
        }
        :host(:not(.disabled)) .thumb-cursor:hover,
        :host(:not(.disabled)) .thumb-cursor:active {
          background: ${SystemColors.Highlight};
        }
        .track {
          forced-color-adjust: none;
          background: ${SystemColors.FieldText};
        }
        .thumb-cursor::after,
        :host(:not(.disabled)) .thumb-cursor:hover::after,
        :host(:not(.disabled)) .thumb-cursor:active::after {
          background: ${SystemColors.Field};
        }
        :host(:${focusVisible}) .thumb-cursor {
          background: ${SystemColors.Highlight};
          border-color: ${SystemColors.Highlight};
          box-shadow: 0 0 0 1px ${SystemColors.Field}, 0 0 0 3px ${SystemColors.FieldText};
        }
        :host(.disabled) {
          opacity: 1;
        }
        :host(.disabled) .track,
        :host(.disabled) .thumb-cursor {
          forced-color-adjust: none;
          background: ${SystemColors.GrayText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/slider/index.js
var fluentSlider;
var init_slider3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/slider/index.js"() {
    init_esm2();
    init_slider_styles();
    fluentSlider = Slider.compose({
      baseName: "slider",
      template: sliderTemplate,
      styles: sliderStyles,
      thumb: `
    <div class="thumb-cursor"></div>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/slider-label/slider-label.styles.js
var sliderLabelStyles;
var init_slider_label_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/slider-label/slider-label.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_design_tokens();
    init_type_ramp2();
    sliderLabelStyles = (context, definition) => css2`
    ${display("block")} :host {
      ${typeRampMinus1}
    }
    .root {
      position: absolute;
      display: grid;
    }
    :host(.horizontal) {
      align-self: start;
      grid-row: 2;
      margin-top: -4px;
    }
    :host(.vertical) {
      justify-self: start;
      grid-column: 2;
      margin-left: 2px;
    }
    .container {
      display: grid;
      justify-self: center;
    }
    :host(.horizontal) .container {
      grid-template-rows: auto auto;
      grid-template-columns: 0;
    }
    :host(.vertical) .container {
      grid-template-columns: auto auto;
      grid-template-rows: 0;
      min-width: calc(var(--thumb-size) * 1px);
      height: calc(var(--thumb-size) * 1px);
    }
    .label {
      justify-self: center;
      align-self: center;
      white-space: nowrap;
      max-width: 30px;
      margin: 2px 0;
    }
    .mark {
      width: calc(${strokeWidth} * 1px);
      height: calc(${designUnit} * 1px);
      background: ${neutralStrokeStrongRest};
      justify-self: center;
    }
    :host(.vertical) .mark {
      transform: rotate(90deg);
      align-self: center;
    }
    :host(.vertical) .label {
      margin-left: calc((${designUnit} / 2) * 2px);
      align-self: center;
    }
    :host(.disabled) {
      opacity: ${disabledOpacity};
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .mark {
          forced-color-adjust: none;
          background: ${SystemColors.FieldText};
        }
        :host(.disabled) {
          forced-color-adjust: none;
          opacity: 1;
        }
        :host(.disabled) .label {
          color: ${SystemColors.GrayText};
        }
        :host(.disabled) .mark {
          background: ${SystemColors.GrayText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/slider-label/index.js
var fluentSliderLabel;
var init_slider_label3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/slider-label/index.js"() {
    init_esm2();
    init_slider_label_styles();
    fluentSliderLabel = SliderLabel.compose({
      baseName: "slider-label",
      template: sliderLabelTemplate,
      styles: sliderLabelStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/switch/switch.styles.js
var switchStyles;
var init_switch_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/switch/switch.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_styles();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    switchStyles = (context, definition) => css2`
    :host([hidden]) {
      display: none;
    }

    ${display("inline-flex")} :host {
      align-items: center;
      outline: none;
      font-family: ${bodyFont};
      ${/*
     * Chromium likes to select label text or the default slot when
     * the checkbox is clicked. Maybe there is a better solution here?
     */
    ""} user-select: none;
    }

    :host(.disabled) {
      opacity: ${disabledOpacity};
    }

    :host(.disabled) .label,
    :host(.readonly) .label,
    :host(.disabled) .switch,
    :host(.readonly) .switch,
    :host(.disabled) .status-message,
    :host(.readonly) .status-message {
      cursor: ${disabledCursor};
    }

    .switch {
      position: relative;
      box-sizing: border-box;
      width: calc(((${heightNumber} / 2) + ${designUnit}) * 2px);
      height: calc(((${heightNumber} / 2) + ${designUnit}) * 1px);
      background: ${neutralFillInputAltRest};
      border-radius: calc(${heightNumber} * 1px);
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeStrongRest};
      cursor: pointer;
    }

    :host(:not(.disabled):hover) .switch {
      background: ${neutralFillInputAltHover};
      border-color: ${neutralStrokeStrongHover};
    }

    :host(:not(.disabled):active) .switch {
      background: ${neutralFillInputAltActive};
      border-color: ${neutralStrokeStrongActive};
    }

    :host(:${focusVisible}) .switch {
      ${focusTreatmentTight}
      background: ${neutralFillInputAltFocus};
    }

    :host(.checked) .switch {
      background: ${accentFillRest};
      border-color: transparent;
    }

    :host(.checked:not(.disabled):hover) .switch {
      background: ${accentFillHover};
      border-color: transparent;
    }

    :host(.checked:not(.disabled):active) .switch {
      background: ${accentFillActive};
      border-color: transparent;
    }

    slot[name='switch'] {
      position: absolute;
      display: flex;
      border: 1px solid transparent; /* Spacing included in the transform reference box */
      fill: ${neutralForegroundRest};
      transition: all 0.2s ease-in-out;
    }

    .status-message {
      color: ${neutralForegroundRest};
      cursor: pointer;
      ${typeRampBase}
    }

    .label__hidden {
      display: none;
      visibility: hidden;
    }

    .label {
      color: ${neutralForegroundRest};
      ${typeRampBase}
      margin-inline-end: calc(${designUnit} * 2px + 2px);
      cursor: pointer;
    }

    ::slotted([slot="checked-message"]),
    ::slotted([slot="unchecked-message"]) {
        margin-inline-start: calc(${designUnit} * 2px + 2px);
    }

    :host(.checked) .switch {
      background: ${accentFillRest};
    }

    :host(.checked) .switch slot[name='switch'] {
      fill: ${foregroundOnAccentRest};
      filter: drop-shadow(0px 1px 1px rgba(0, 0, 0, 0.15));
    }

    :host(.checked:not(.disabled)) .switch:hover {
      background: ${accentFillHover};
    }

    :host(.checked:not(.disabled)) .switch:hover slot[name='switch'] {
      fill: ${foregroundOnAccentHover};
    }

    :host(.checked:not(.disabled)) .switch:active {
      background: ${accentFillActive};
    }

    :host(.checked:not(.disabled)) .switch:active slot[name='switch'] {
      fill: ${foregroundOnAccentActive};
    }

    .unchecked-message {
      display: block;
    }

    .checked-message {
      display: none;
    }

    :host(.checked) .unchecked-message {
      display: none;
    }

    :host(.checked) .checked-message {
      display: block;
    }
  `.withBehaviors(new DirectionalStyleSheetBehavior(css2`
        slot[name='switch'] {
          left: 0;
        }

        :host(.checked) slot[name='switch'] {
          left: 100%;
          transform: translateX(-100%);
        }
      `, css2`
        slot[name='switch'] {
          right: 0;
        }

        :host(.checked) slot[name='switch'] {
          right: 100%;
          transform: translateX(100%);
        }
      `), forcedColorsStylesheetBehavior(css2`
        :host(:not(.disabled)) .switch slot[name='switch'] {
          forced-color-adjust: none;
          fill: ${SystemColors.FieldText};
        }
        .switch {
          background: ${SystemColors.Field};
          border-color: ${SystemColors.FieldText};
        }
        :host(.checked) .switch {
          background: ${SystemColors.Highlight};
          border-color: ${SystemColors.Highlight};
        }
        :host(:not(.disabled):hover) .switch ,
        :host(:not(.disabled):active) .switch,
        :host(.checked:not(.disabled):hover) .switch {
          background: ${SystemColors.HighlightText};
          border-color: ${SystemColors.Highlight};
        }
        :host(.checked:not(.disabled)) .switch slot[name="switch"] {
          fill: ${SystemColors.HighlightText};
        }
        :host(.checked:not(.disabled):hover) .switch slot[name='switch'] {
          fill: ${SystemColors.Highlight};
        }
        :host(:${focusVisible}) .switch {
          forced-color-adjust: none;
          background: ${SystemColors.Field}; 
          border-color: ${SystemColors.Highlight};
          outline-color: ${SystemColors.FieldText};
        }
        :host(.disabled) {
          opacity: 1;
        }
        :host(.disabled) slot[name='switch'] {
          forced-color-adjust: none;
          fill: ${SystemColors.GrayText};
        }
        :host(.disabled) .switch {
          background: ${SystemColors.Field};
          border-color: ${SystemColors.GrayText};
        }
        .status-message,
        .label {
          color: ${SystemColors.FieldText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/switch/index.js
var fluentSwitch;
var init_switch3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/switch/index.js"() {
    init_esm2();
    init_switch_styles();
    fluentSwitch = Switch.compose({
      baseName: "switch",
      template: switchTemplate,
      styles: switchStyles,
      switch: `
    <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
      <rect x="2" y="2" width="12" height="12" rx="6"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/tabs/tabs.styles.js
var tabsStyles;
var init_tabs_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tabs/tabs.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_design_tokens();
    init_styles();
    init_type_ramp2();
    tabsStyles = (context, definition) => css2`
      ${display("grid")} :host {
        box-sizing: border-box;
        ${typeRampBase}
        color: ${neutralForegroundRest};
        grid-template-columns: auto 1fr auto;
        grid-template-rows: auto 1fr;
      }

      .tablist {
        display: grid;
        grid-template-rows: calc(${heightNumber} * 1px); auto;
        grid-template-columns: auto;
        position: relative;
        width: max-content;
        align-self: end;
      }

      .start,
      .end {
        align-self: center;
      }

      .activeIndicator {
        grid-row: 2;
        grid-column: 1;
        width: 20px;
        height: 3px;
        border-radius: calc(${controlCornerRadius} * 1px);
        justify-self: center;
        background: ${accentFillRest};
      }

      .activeIndicatorTransition {
        transition: transform 0.2s ease-in-out;
      }

      .tabpanel {
        grid-row: 2;
        grid-column-start: 1;
        grid-column-end: 4;
        position: relative;
      }

      :host(.vertical) {
        grid-template-rows: auto 1fr auto;
        grid-template-columns: auto 1fr;
      }

      :host(.vertical) .tablist {
        grid-row-start: 2;
        grid-row-end: 2;
        display: grid;
        grid-template-rows: auto;
        grid-template-columns: auto 1fr;
        position: relative;
        width: max-content;
        justify-self: end;
        align-self: flex-start;
        width: 100%;
      }

      :host(.vertical) .tabpanel {
        grid-column: 2;
        grid-row-start: 1;
        grid-row-end: 4;
      }

      :host(.vertical) .end {
        grid-row: 3;
      }

      :host(.vertical) .activeIndicator {
        grid-column: 1;
        grid-row: 1;
        width: 3px;
        height: 20px;
        margin-inline-start: calc(${focusStrokeWidth} * 1px);
        border-radius: calc(${controlCornerRadius} * 1px);
        align-self: center;
        background: ${accentFillRest};
      }

      :host(.vertical) .activeIndicatorTransition {
        transition: transform 0.2s linear;
      }
    `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        .activeIndicator,
        :host(.vertical) .activeIndicator {
          background: ${SystemColors.Highlight};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/tabs/tab/tab.styles.js
var tabStyles;
var init_tab_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tabs/tab/tab.styles.js"() {
    init_esm();
    init_dist2();
    init_esm2();
    init_styles();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    tabStyles = (context, definition) => css2`
      ${display("inline-flex")} :host {
        box-sizing: border-box;
        ${typeRampBase}
        height: calc((${heightNumber} + (${designUnit} * 2)) * 1px);
        padding: 0 calc((6 + (${designUnit} * 2 * ${density})) * 1px);
        color: ${neutralForegroundRest};
        border-radius: calc(${controlCornerRadius} * 1px);
        border: calc(${strokeWidth} * 1px) solid transparent;
        align-items: center;
        justify-content: center;
        grid-row: 1 / 3;
        cursor: pointer;
      }

      :host([aria-selected='true']) {
        z-index: 2;
      }

      :host(:hover),
      :host(:active) {
        color: ${neutralForegroundRest};
      }

      :host(:${focusVisible}) {
        ${focusTreatmentBase}
      }

      :host(.vertical) {
        justify-content: start;
        grid-column: 1 / 3;
      }

      :host(.vertical[aria-selected='true']) {
        z-index: 2;
      }

      :host(.vertical:hover),
      :host(.vertical:active) {
        color: ${neutralForegroundRest};
      }

      :host(.vertical:hover[aria-selected='true']) {
      }
    `.withBehaviors(forcedColorsStylesheetBehavior(css2`
          :host {
            forced-color-adjust: none;
            border-color: transparent;
            color: ${SystemColors.ButtonText};
            fill: currentcolor;
          }
          :host(:hover),
          :host(.vertical:hover),
          :host([aria-selected='true']:hover) {
            background: transparent;
            color: ${SystemColors.Highlight};
            fill: currentcolor;
          }
          :host([aria-selected='true']) {
            background: transparent;
            color: ${SystemColors.Highlight};
            fill: currentcolor;
          }
          :host(:${focusVisible}) {
            background: transparent;
            outline-color: ${SystemColors.ButtonText};
          }
        `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/tabs/tab/index.js
var fluentTab;
var init_tab3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tabs/tab/index.js"() {
    init_esm2();
    init_tab_styles();
    fluentTab = Tab.compose({
      baseName: "tab",
      template: tabTemplate,
      styles: tabStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/tabs/tab-panel/tab-panel.styles.js
var tabPanelStyles;
var init_tab_panel_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tabs/tab-panel/tab-panel.styles.js"() {
    init_esm();
    init_esm2();
    init_design_tokens();
    init_type_ramp2();
    tabPanelStyles = (context, definition) => css2`
  ${display("block")} :host {
    box-sizing: border-box;
    ${typeRampBase}
    padding: 0 calc((6 + (${designUnit} * 2 * ${density})) * 1px);
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/tabs/tab-panel/index.js
var fluentTabPanel;
var init_tab_panel3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tabs/tab-panel/index.js"() {
    init_esm2();
    init_tab_panel_styles();
    fluentTabPanel = TabPanel.compose({
      baseName: "tab-panel",
      template: tabPanelTemplate,
      styles: tabPanelStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/tabs/index.js
var fluentTabs;
var init_tabs3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tabs/index.js"() {
    init_esm2();
    init_tabs_styles();
    init_tab3();
    init_tab_panel3();
    fluentTabs = Tabs.compose({
      baseName: "tabs",
      template: tabsTemplate,
      styles: tabsStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/text-area/text-area.styles.js
var logicalControlSelector5, textAreaStyles;
var init_text_area_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/text-area/text-area.styles.js"() {
    init_esm();
    init_esm2();
    init_styles();
    init_behaviors();
    init_design_tokens();
    logicalControlSelector5 = ".control";
    textAreaStyles = (context, definition) => css2`
    ${display("inline-flex")}

    ${baseInputStyles(context, definition, logicalControlSelector5)}

    ${inputStateStyles(context, definition, logicalControlSelector5)}

    :host {
      flex-direction: column;
      vertical-align: bottom;
    }

    .control {
      height: calc((${heightNumber} * 2) * 1px);
      padding: calc(${designUnit} * 1.5px) calc(${designUnit} * 2px + 1px);
    }

    :host .control {
      resize: none;
    }

    :host(.resize-both) .control {
      resize: both;
    }

    :host(.resize-horizontal) .control {
      resize: horizontal;
    }

    :host(.resize-vertical) .control {
      resize: vertical;
    }
  `.withBehaviors(appearanceBehavior("outline", inputOutlineStyles(context, definition, logicalControlSelector5)), appearanceBehavior("filled", inputFilledStyles(context, definition, logicalControlSelector5)), forcedColorsStylesheetBehavior(inputForcedColorStyles(context, definition, logicalControlSelector5)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/text-area/index.js
var TextArea2, fluentTextArea;
var init_text_area3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/text-area/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_text_area_styles();
    TextArea2 = class extends TextArea {
      /**
       * @internal
       */
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          this.classList.add(newValue);
          this.classList.remove(oldValue);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "outline";
        }
      }
    };
    __decorate([
      attr
    ], TextArea2.prototype, "appearance", void 0);
    fluentTextArea = TextArea2.compose({
      baseName: "text-area",
      baseClass: TextArea,
      template: textAreaTemplate,
      styles: textAreaStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/text-field/text-field.styles.js
var logicalControlSelector6, textFieldStyles;
var init_text_field_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/text-field/text-field.styles.js"() {
    init_esm();
    init_esm2();
    init_styles();
    init_behaviors();
    init_design_tokens();
    logicalControlSelector6 = ".root";
    textFieldStyles = (context, definition) => css2`
    ${display("inline-block")}

    ${baseInputStyles(context, definition, logicalControlSelector6)}

    ${inputStateStyles(context, definition, logicalControlSelector6)}

    .root {
      display: flex;
      flex-direction: row;
    }

    .control {
      -webkit-appearance: none;
      color: inherit;
      background: transparent;
      border: 0;
      height: calc(100% - 4px);
      margin-top: auto;
      margin-bottom: auto;
      padding: 0 calc(${designUnit} * 2px + 1px);
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }

    .start,
    .end {
      display: flex;
      margin: auto;
    }

    .start {
      display: flex;
      margin-inline-start: 11px;
    }

    .end {
      display: flex;
      margin-inline-end: 11px;
    }
  `.withBehaviors(appearanceBehavior("outline", inputOutlineStyles(context, definition, logicalControlSelector6)), appearanceBehavior("filled", inputFilledStyles(context, definition, logicalControlSelector6)), forcedColorsStylesheetBehavior(inputForcedColorStyles(context, definition, logicalControlSelector6)));
  }
});

// node_modules/@fluentui/web-components/dist/esm/text-field/index.js
var TextField2, fluentTextField;
var init_text_field3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/text-field/index.js"() {
    init_tslib_es6();
    init_esm();
    init_esm2();
    init_text_field_styles();
    TextField2 = class extends TextField {
      /**
       * @internal
       */
      appearanceChanged(oldValue, newValue) {
        if (oldValue !== newValue) {
          this.classList.add(newValue);
          this.classList.remove(oldValue);
        }
      }
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        if (!this.appearance) {
          this.appearance = "outline";
        }
      }
    };
    __decorate([
      attr
    ], TextField2.prototype, "appearance", void 0);
    fluentTextField = TextField2.compose({
      baseName: "text-field",
      baseClass: TextField,
      template: textFieldTemplate,
      styles: textFieldStyles,
      shadowOptions: {
        delegatesFocus: true
      }
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/toolbar/toolbar.styles.js
var toolbarStyles;
var init_toolbar_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/toolbar/toolbar.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_design_tokens();
    init_focus2();
    toolbarStyles = (context, definition) => css2`
    ${display("inline-flex")} :host {
      --toolbar-item-gap: calc(${designUnit} * 1px);
      background: ${fillColor};
      fill: currentcolor;
      padding: var(--toolbar-item-gap);
      box-sizing: border-box;
      align-items: center;
    }

    :host(${focusVisible}) {
      ${focusTreatmentBase}
    }

    .positioning-region {
      align-items: center;
      display: inline-flex;
      flex-flow: row wrap;
      justify-content: flex-start;
      flex-grow: 1;
    }

    :host([orientation='vertical']) .positioning-region {
      flex-direction: column;
      align-items: start;
    }

    ::slotted(:not([slot])) {
      flex: 0 0 auto;
      margin: 0 var(--toolbar-item-gap);
    }

    :host([orientation='vertical']) ::slotted(:not([slot])) {
      margin: var(--toolbar-item-gap) 0;
    }

    :host([orientation='vertical']) {
      display: inline-flex;
      flex-direction: column;
    }

    .start,
    .end {
      display: flex;
      align-items: center;
    }

    .end {
      margin-inline-start: auto;
    }

    .start__hidden,
    .end__hidden {
      display: none;
    }

    ::slotted(svg) {
      ${/* Glyph size is temporary - replace when adaptive typography is figured out */
    ""}
      width: 16px;
      height: 16px;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host(:${focusVisible}) {
          outline-color: ${SystemColors.Highlight};
          color: ${SystemColors.ButtonText};
          forced-color-adjust: none;
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/toolbar/index.js
var Toolbar2, fluentToolbar;
var init_toolbar3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/toolbar/index.js"() {
    init_esm2();
    init_toolbar_styles();
    Toolbar2 = class extends Toolbar {
    };
    fluentToolbar = Toolbar2.compose({
      baseName: "toolbar",
      baseClass: Toolbar,
      template: toolbarTemplate,
      styles: toolbarStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/tooltip/tooltip.styles.js
var tooltipStyles;
var init_tooltip_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tooltip/tooltip.styles.js"() {
    init_esm();
    init_esm2();
    init_styles();
    init_design_tokens();
    init_type_ramp2();
    tooltipStyles = (context, definition) => css2`
    :host {
      position: relative;
      contain: layout;
      overflow: visible;
      height: 0;
      width: 0;
      z-index: 10000;
    }

    .tooltip {
      box-sizing: border-box;
      border-radius: calc(${controlCornerRadius} * 1px);
      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeLayerRest};
      background: ${fillColor};
      color: ${neutralForegroundRest};
      padding: 4px 12px;
      height: fit-content;
      width: fit-content;
      ${typeRampBase}
      white-space: nowrap;
      box-shadow: ${elevationShadowTooltip};
    }

    ${context.tagFor(AnchoredRegion)} {
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: visible;
      flex-direction: row;
    }

    ${context.tagFor(AnchoredRegion)}.right,
    ${context.tagFor(AnchoredRegion)}.left {
      flex-direction: column;
    }

    ${context.tagFor(AnchoredRegion)}.top .tooltip::after,
    ${context.tagFor(AnchoredRegion)}.bottom .tooltip::after,
    ${context.tagFor(AnchoredRegion)}.left .tooltip::after,
    ${context.tagFor(AnchoredRegion)}.right .tooltip::after {
      content: '';
      width: 12px;
      height: 12px;
      background: ${fillColor};
      border-top: calc(${strokeWidth} * 1px) solid ${neutralStrokeLayerRest};
      border-left: calc(${strokeWidth} * 1px) solid ${neutralStrokeLayerRest};
      position: absolute;
    }

    ${context.tagFor(AnchoredRegion)}.top .tooltip::after {
      transform: translateX(-50%) rotate(225deg);
      bottom: 5px;
      left: 50%;
    }

    ${context.tagFor(AnchoredRegion)}.top .tooltip {
      margin-bottom: 12px;
    }

    ${context.tagFor(AnchoredRegion)}.bottom .tooltip::after {
      transform: translateX(-50%) rotate(45deg);
      top: 5px;
      left: 50%;
    }

    ${context.tagFor(AnchoredRegion)}.bottom .tooltip {
      margin-top: 12px;
    }

    ${context.tagFor(AnchoredRegion)}.left .tooltip::after {
      transform: translateY(-50%) rotate(135deg);
      top: 50%;
      right: 5px;
    }

    ${context.tagFor(AnchoredRegion)}.left .tooltip {
      margin-right: 12px;
    }

    ${context.tagFor(AnchoredRegion)}.right .tooltip::after {
      transform: translateY(-50%) rotate(-45deg);
      top: 50%;
      left: 5px;
    }

    ${context.tagFor(AnchoredRegion)}.right .tooltip {
      margin-left: 12px;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css2`
        :host([disabled]) {
          opacity: 1;
        }
        ${context.tagFor(AnchoredRegion)}.top .tooltip::after,
        ${context.tagFor(AnchoredRegion)}.bottom .tooltip::after,
        ${context.tagFor(AnchoredRegion)}.left .tooltip::after,
        ${context.tagFor(AnchoredRegion)}.right .tooltip::after {
          content: '';
          width: unset;
          height: unset;
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/tooltip/index.js
var Tooltip2, fluentTooltip;
var init_tooltip3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tooltip/index.js"() {
    init_esm2();
    init_design_tokens();
    init_tooltip_styles();
    Tooltip2 = class extends Tooltip {
      /**
       * @internal
       */
      connectedCallback() {
        super.connectedCallback();
        fillColor.setValueFor(this, neutralLayerFloating2);
      }
    };
    fluentTooltip = Tooltip2.compose({
      baseName: "tooltip",
      baseClass: Tooltip,
      template: tooltipTemplate,
      styles: tooltipStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/tree-view/tree-view.styles.js
var treeViewStyles;
var init_tree_view_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tree-view/tree-view.styles.js"() {
    init_esm();
    init_esm2();
    treeViewStyles = (context, definition) => css2`
  :host([hidden]) {
    display: none;
  }

  ${display("flex")} :host {
    flex-direction: column;
    align-items: stretch;
    min-width: fit-content;
    font-size: 0;
  }
`;
  }
});

// node_modules/@fluentui/web-components/dist/esm/tree-view/index.js
var fluentTreeView;
var init_tree_view3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tree-view/index.js"() {
    init_esm2();
    init_tree_view_styles();
    fluentTreeView = TreeView.compose({
      baseName: "tree-view",
      template: treeViewTemplate,
      styles: treeViewStyles
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/tree-item/tree-item.styles.js
var ltr, rtl, expandCollapseButtonSize, expandCollapseHover, selectedExpandCollapseHover, treeItemStyles;
var init_tree_item_styles = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tree-item/tree-item.styles.js"() {
    init_esm();
    init_esm2();
    init_dist2();
    init_styles();
    init_design_tokens();
    init_type_ramp2();
    init_focus2();
    ltr = css2`
  .expand-collapse-button svg {
    transform: rotate(0deg);
  }
  :host(.nested) .expand-collapse-button {
    left: var(--expand-collapse-button-nested-width, calc(${heightNumber} * -1px));
  }
  :host([selected])::after {
    left: calc(${focusStrokeWidth} * 1px);
  }
  :host([expanded]) > .positioning-region .expand-collapse-button svg {
    transform: rotate(90deg);
  }
`;
    rtl = css2`
  .expand-collapse-button svg {
    transform: rotate(180deg);
  }
  :host(.nested) .expand-collapse-button {
    right: var(--expand-collapse-button-nested-width, calc(${heightNumber} * -1px));
  }
  :host([selected])::after {
    right: calc(${focusStrokeWidth} * 1px);
  }
  :host([expanded]) > .positioning-region .expand-collapse-button svg {
    transform: rotate(90deg);
  }
`;
    expandCollapseButtonSize = cssPartial`((${baseHeightMultiplier} / 2) * ${designUnit}) + ((${designUnit} * ${density}) / 2)`;
    expandCollapseHover = DesignToken.create("tree-item-expand-collapse-hover").withDefault((target2) => {
      const recipe = neutralFillStealthRecipe.getValueFor(target2);
      return recipe.evaluate(target2, recipe.evaluate(target2).hover).hover;
    });
    selectedExpandCollapseHover = DesignToken.create("tree-item-expand-collapse-selected-hover").withDefault((target2) => {
      const baseRecipe = neutralFillSecondaryRecipe.getValueFor(target2);
      const buttonRecipe = neutralFillStealthRecipe.getValueFor(target2);
      return buttonRecipe.evaluate(target2, baseRecipe.evaluate(target2).rest).hover;
    });
    treeItemStyles = (context, definition) => css2`
    ${display("block")} :host {
      contain: content;
      position: relative;
      outline: none;
      color: ${neutralForegroundRest};
      fill: currentcolor;
      cursor: pointer;
      font-family: ${bodyFont};
      --expand-collapse-button-size: calc(${heightNumber} * 1px);
      --tree-item-nested-width: 0;
    }

    .positioning-region {
      display: flex;
      position: relative;
      box-sizing: border-box;
      background: ${neutralFillStealthRest};
      border: calc(${strokeWidth} * 1px) solid transparent;
      border-radius: calc(${controlCornerRadius} * 1px);
      height: calc((${heightNumber} + 1) * 1px);
    }

    :host(:${focusVisible}) .positioning-region {
      ${focusTreatmentBase}
    }

    .positioning-region::before {
      content: '';
      display: block;
      width: var(--tree-item-nested-width);
      flex-shrink: 0;
    }

    :host(:not([disabled])) .positioning-region:hover {
      background: ${neutralFillStealthHover};
    }

    :host(:not([disabled])) .positioning-region:active {
      background: ${neutralFillStealthActive};
    }

    .content-region {
      display: inline-flex;
      align-items: center;
      white-space: nowrap;
      width: 100%;
      height: calc(${heightNumber} * 1px);
      margin-inline-start: calc(${designUnit} * 2px + 8px);
      ${typeRampBase}
    }

    .items {
      display: none;
      ${/* Font size should be based off calc(1em + (design-unit + glyph-size-number) * 1px) -
        update when density story is figured out */
    ""} font-size: calc(1em + (${designUnit} + 16) * 1px);
    }

    .expand-collapse-button {
      background: none;
      border: none;
      border-radius: calc(${controlCornerRadius} * 1px);
      ${/* Width and Height should be based off calc(glyph-size-number + (design-unit * 4) * 1px) -
        update when density story is figured out */
    ""} width: calc((${expandCollapseButtonSize} + (${designUnit} * 2)) * 1px);
      height: calc((${expandCollapseButtonSize} + (${designUnit} * 2)) * 1px);
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      margin: 0 6px;
    }

    .expand-collapse-button svg {
      transition: transform 0.1s linear;
      pointer-events: none;
    }

    .start,
    .end {
      display: flex;
    }

    .start {
      ${/* need to swap out once we understand how horizontalSpacing will work */
    ""} margin-inline-end: calc(${designUnit} * 2px + 2px);
    }

    .end {
      ${/* need to swap out once we understand how horizontalSpacing will work */
    ""} margin-inline-start: calc(${designUnit} * 2px + 2px);
    }

    :host(.expanded) > .items {
      display: block;
    }

    :host([disabled]) {
      opacity: ${disabledOpacity};
      cursor: ${disabledCursor};
    }

    :host(.nested) .content-region {
      position: relative;
      margin-inline-start: var(--expand-collapse-button-size);
    }

    :host(.nested) .expand-collapse-button {
      position: absolute;
    }

    :host(.nested) .expand-collapse-button:hover {
      background: ${expandCollapseHover};
    }

    :host(:not([disabled])[selected]) .positioning-region {
      background: ${neutralFillSecondaryRest};
    }

    :host(:not([disabled])[selected]) .expand-collapse-button:hover {
      background: ${selectedExpandCollapseHover};
    }

    :host([selected])::after {
      content: '';
      display: block;
      position: absolute;
      top: calc((${heightNumber} / 4) * 1px);
      width: 3px;
      height: calc((${heightNumber} / 2) * 1px);
      ${/* The french fry background needs to be calculated based on the selected background state for this control.
        We currently have no way of changing that, so setting to accent-foreground-rest for the time being */
    ""} background: ${accentFillRest};
      border-radius: calc(${controlCornerRadius} * 1px);
    }

    ::slotted(fluent-tree-item) {
      --tree-item-nested-width: 1em;
      --expand-collapse-button-nested-width: calc(${heightNumber} * -1px);
    }
  `.withBehaviors(new DirectionalStyleSheetBehavior(ltr, rtl), forcedColorsStylesheetBehavior(css2`
        :host {
          color: ${SystemColors.ButtonText};
        }
        .positioning-region {
          border-color: ${SystemColors.ButtonFace};
          background: ${SystemColors.ButtonFace};
        }
        :host(:not([disabled])) .positioning-region:hover,
        :host(:not([disabled])) .positioning-region:active,
        :host(:not([disabled])[selected]) .positioning-region {
          background: ${SystemColors.Highlight};
        }
        :host .positioning-region:hover .content-region,
        :host([selected]) .positioning-region .content-region {
          forced-color-adjust: none;
          color: ${SystemColors.HighlightText};
        }
        :host([disabled][selected]) .positioning-region .content-region {
          color: ${SystemColors.GrayText};
        }
        :host([selected])::after {
          background: ${SystemColors.HighlightText};
        }
        :host(:${focusVisible}) .positioning-region {
          forced-color-adjust: none;
          outline-color: ${SystemColors.ButtonFace};
        }
        :host([disabled]),
        :host([disabled]) .content-region,
        :host([disabled]) .positioning-region:hover .content-region {
          opacity: 1;
          color: ${SystemColors.GrayText};
        }
        :host(.nested) .expand-collapse-button:hover,
        :host(:not([disabled])[selected]) .expand-collapse-button:hover {
          background: ${SystemColors.ButtonFace};
          fill: ${SystemColors.ButtonText};
        }
      `));
  }
});

// node_modules/@fluentui/web-components/dist/esm/tree-item/index.js
var fluentTreeItem;
var init_tree_item3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/tree-item/index.js"() {
    init_esm2();
    init_tree_item_styles();
    fluentTreeItem = TreeItem.compose({
      baseName: "tree-item",
      template: treeItemTemplate,
      styles: treeItemStyles,
      expandCollapseGlyph: `
    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
      <path d="M4.65 2.15a.5.5 0 000 .7L7.79 6 4.65 9.15a.5.5 0 10.7.7l3.5-3.5a.5.5 0 000-.7l-3.5-3.5a.5.5 0 00-.7 0z"/>
    </svg>
  `
    });
  }
});

// node_modules/@fluentui/web-components/dist/esm/custom-elements.js
var init_custom_elements = __esm({
  "node_modules/@fluentui/web-components/dist/esm/custom-elements.js"() {
    init_accordion3();
    init_anchor3();
    init_anchored_region3();
    init_badge3();
    init_breadcrumb3();
    init_breadcrumb_item3();
    init_button3();
    init_calendar3();
    init_card3();
    init_checkbox3();
    init_combobox3();
    init_data_grid3();
    init_design_system_provider();
    init_dialog3();
    init_divider3();
    init_flipper3();
    init_horizontal_scroll3();
    init_listbox3();
    init_listbox_option3();
    init_menu3();
    init_menu_item3();
    init_number_field3();
    init_progress3();
    init_radio3();
    init_radio_group3();
    init_search3();
    init_select3();
    init_skeleton3();
    init_slider3();
    init_slider_label3();
    init_switch3();
    init_tabs3();
    init_text_area3();
    init_text_field3();
    init_toolbar3();
    init_tooltip3();
    init_tree_view3();
    init_tree_item3();
  }
});

// node_modules/@fluentui/web-components/dist/esm/fluent-design-system.js
function provideFluentDesignSystem(element) {
  return DesignSystem.getOrCreate(element).withPrefix("fluent");
}
var init_fluent_design_system = __esm({
  "node_modules/@fluentui/web-components/dist/esm/fluent-design-system.js"() {
    init_esm2();
  }
});

// node_modules/@fluentui/web-components/dist/esm/index.js
var init_esm3 = __esm({
  "node_modules/@fluentui/web-components/dist/esm/index.js"() {
    init_custom_elements();
    init_fluent_design_system();
    init_accordion3();
    init_anchor3();
    init_anchored_region3();
    init_badge3();
    init_breadcrumb3();
    init_breadcrumb_item3();
    init_button3();
    init_card3();
    init_checkbox3();
    init_combobox3();
    init_data_grid3();
    init_design_system_provider();
    init_dialog3();
    init_divider3();
    init_flipper3();
    init_horizontal_scroll3();
    init_listbox3();
    init_listbox_option3();
    init_menu3();
    init_menu_item3();
    init_number_field3();
    init_progress3();
    init_radio3();
    init_radio_group3();
    init_search3();
    init_select3();
    init_skeleton3();
    init_slider3();
    init_slider_label3();
    init_switch3();
    init_tabs3();
    init_text_area3();
    init_text_field3();
    init_toolbar3();
    init_tooltip3();
    init_tree_item3();
    init_tree_view3();
    init_design_tokens();
    init_styles();
    init_palette();
    init_swatch();
    init_is_dark();
    init_base_layer_luminance();
  }
});

// node_modules/@microsoft/mgt-components/dist/es6/utils/FluentComponents.js
var designSystem, registerFluentComponents;
var init_FluentComponents = __esm({
  "node_modules/@microsoft/mgt-components/dist/es6/utils/FluentComponents.js"() {
    init_esm3();
    designSystem = provideFluentDesignSystem();
    registerFluentComponents = (...fluentComponents) => {
      if (!fluentComponents || !fluentComponents.length) {
        return;
      }
      for (const component of fluentComponents) {
        designSystem.register(component());
      }
    };
  }
});

// node_modules/@microsoft/mgt-components/dist/es6/styles/theme-manager.js
function applyTheme(theme, element = document.body) {
  const settings = getThemeSettings(theme);
  applyColorScheme(settings, element);
}
function applyColorScheme(settings, element = document.body) {
  accentBaseColor.setValueFor(element, SwatchRGB.from(parseColorHexRGB(settings.accentBaseColor)));
  neutralBaseColor.setValueFor(element, SwatchRGB.from(parseColorHexRGB(settings.neutralBaseColor)));
  baseLayerLuminance.setValueFor(element, settings.baseLayerLuminance);
}
function getThemeSettings(theme) {
  switch (theme) {
    case "contrast":
      return {
        accentBaseColor: "#7f85f5",
        neutralBaseColor: "#adadad",
        baseLayerLuminance: StandardLuminance.DarkMode
      };
    case "default":
      return {
        accentBaseColor: "#5b5fc7",
        neutralBaseColor: "#616161",
        baseLayerLuminance: StandardLuminance.LightMode
      };
    case "dark":
      return {
        accentBaseColor: "#479ef5",
        neutralBaseColor: "#adadad",
        baseLayerLuminance: StandardLuminance.DarkMode
      };
    case "light":
    default:
      return {
        accentBaseColor: "#0f6cbd",
        neutralBaseColor: "#616161",
        baseLayerLuminance: StandardLuminance.LightMode
      };
  }
}
var init_theme_manager = __esm({
  "node_modules/@microsoft/mgt-components/dist/es6/styles/theme-manager.js"() {
    init_esm3();
    init_dist3();
  }
});

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-theme-toggle/strings.js
var strings17;
var init_strings2 = __esm({
  "node_modules/@microsoft/mgt-components/dist/es6/components/mgt-theme-toggle/strings.js"() {
    strings17 = {
      label: "Color mode:",
      on: "Dark",
      off: "Light"
    };
  }
});

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-theme-toggle/mgt-theme-toggle.js
var require_mgt_theme_toggle = __commonJS({
  "node_modules/@microsoft/mgt-components/dist/es6/components/mgt-theme-toggle/mgt-theme-toggle.js"(exports) {
    init_lit();
    init_decorators();
    init_es6();
    init_switch3();
    init_FluentComponents();
    init_theme_manager();
    init_strings2();
    var __decorate27 = exports && exports.__decorate || function(decorators, target2, key, desc) {
      var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target2, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
      return c > 3 && r && Object.defineProperty(target2, key, r), r;
    };
    var __metadata24 = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    registerFluentComponents(fluentSwitch);
    var MgtThemeToggle = class MgtThemeToggle extends MgtBaseComponent {
      constructor() {
        super();
        const prefersDarkMode = window.matchMedia("(prefers-color-scheme:dark)").matches;
        this.darkModeActive = prefersDarkMode;
        this.applyTheme(this.darkModeActive);
      }
      /**
       * Provides strings for localization
       *
       * @readonly
       * @protected
       * @memberof MgtDarkToggle
       */
      get strings() {
        return strings17;
      }
      /**
       * Fires after a component is updated.
       * Allows a component to trigger side effects after updating.
       *
       * @param {Map<string, any>} changedProperties
       * @memberof MgtDarkToggle
       */
      updated(changedProperties) {
        if (changedProperties.has("darkModeActive")) {
          this.applyTheme(this.darkModeActive);
        }
      }
      /**
       * renders the component
       *
       * @return {TemplateResult}
       * @memberof MgtDarkToggle
       */
      render() {
        return html`
      <fluent-switch checked=${this.darkModeActive} @change=${this.onSwitchChanged}>
        <span slot="checked-message">${strings17.on}</span>
        <span slot="unchecked-message">${strings17.off}</span>
        <label for="direction-switch">${strings17.label}</label>
      </fluent-switch>
`;
      }
      onSwitchChanged(e) {
        this.darkModeActive = e.target.checked;
        this.fireCustomEvent("darkmodechanged", this.darkModeActive);
      }
      applyTheme(active) {
        const targetTheme = active ? "dark" : "light";
        applyTheme(targetTheme);
        document.body.classList.remove("mgt-dark-mode", "mgt-light-mode");
        document.body.classList.add(`mgt-${targetTheme}-mode`);
      }
    };
    __decorate27([
      property({
        attribute: "mode",
        reflect: true,
        type: String,
        converter: {
          fromAttribute(value) {
            return value === "dark";
          },
          toAttribute(value) {
            return value ? "dark" : "light";
          }
        }
      }),
      __metadata24("design:type", Boolean)
    ], MgtThemeToggle.prototype, "darkModeActive", void 0);
    MgtThemeToggle = __decorate27([
      customElement("theme-toggle"),
      __metadata24("design:paramtypes", [])
    ], MgtThemeToggle);
  }
});

// node_modules/@microsoft/mgt-react/dist/es6/index.js
var es6_exports2 = {};
__export(es6_exports2, {
  Agenda: () => Agenda,
  BatchResponse: () => BatchResponse,
  BetaGraph: () => BetaGraph,
  CacheService: () => CacheService,
  CacheStore: () => CacheStore,
  ComponentMediaQuery: () => ComponentMediaQuery,
  EventDispatcher: () => EventDispatcher,
  File: () => File,
  FileList: () => FileList,
  Get: () => Get,
  Graph: () => Graph,
  GraphPageIterator: () => GraphPageIterator,
  GroupType: () => GroupType,
  IProvider: () => IProvider,
  LocalizationHelper: () => LocalizationHelper,
  Login: () => Login,
  LoginType: () => LoginType,
  MICROSOFT_GRAPH_DEFAULT_ENDPOINT: () => MICROSOFT_GRAPH_DEFAULT_ENDPOINT,
  MICROSOFT_GRAPH_ENDPOINTS: () => MICROSOFT_GRAPH_ENDPOINTS,
  Mgt: () => Mgt,
  MgtAgenda: () => MgtAgenda,
  MgtBaseComponent: () => MgtBaseComponent,
  MgtBaseProvider: () => MgtBaseProvider,
  MgtContact: () => MgtContact,
  MgtFile: () => MgtFile,
  MgtFileList: () => MgtFileList,
  MgtGet: () => MgtGet,
  MgtLogin: () => MgtLogin,
  MgtMessages: () => MgtMessages,
  MgtOrganization: () => MgtOrganization,
  MgtPeople: () => MgtPeople,
  MgtPeoplePicker: () => MgtPeoplePicker,
  MgtPerson: () => MgtPerson,
  MgtPersonCard: () => MgtPersonCard,
  MgtPicker: () => MgtPicker,
  MgtProfile: () => MgtProfile,
  MgtTasks: () => MgtTasks,
  MgtTeamsChannelPicker: () => MgtTeamsChannelPicker,
  MgtTemplatedComponent: () => MgtTemplatedComponent,
  MgtTodo: () => MgtTodo,
  MockProvider: () => MockProvider,
  PACKAGE_VERSION: () => PACKAGE_VERSION,
  People: () => People,
  PeoplePicker: () => PeoplePicker,
  Person: () => Person,
  PersonCard: () => PersonCard,
  PersonCardInteraction: () => PersonCardInteraction,
  PersonType: () => PersonType,
  PersonViewType: () => PersonViewType,
  Picker: () => Picker,
  ProviderState: () => ProviderState,
  Providers: () => Providers,
  ProvidersChangedState: () => ProvidersChangedState,
  ResponseType: () => ResponseType2,
  SimpleProvider: () => SimpleProvider,
  Tasks: () => Tasks,
  TasksSource: () => TasksSource,
  TeamsChannelPicker: () => TeamsChannelPicker,
  TeamsHelper: () => TeamsHelper,
  TemplateHelper: () => TemplateHelper,
  ThemeToggle: () => ThemeToggle,
  Todo: () => Todo,
  UserType: () => UserType,
  ViewType: () => ViewType,
  arraysAreEqual: () => arraysAreEqual,
  avatarType: () => avatarType,
  chainMiddleware: () => chainMiddleware,
  createFromProvider: () => createFromProvider,
  customElement: () => customElement,
  customElementHelper: () => customElementHelper,
  equals: () => equals,
  mgtHtml: () => mgtHtml,
  prepScopes: () => prepScopes,
  validateBaseURL: () => validateBaseURL,
  wrapMgt: () => wrapMgt
});

// node_modules/@microsoft/mgt-react/dist/es6/Mgt.js
var import_react2 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/wc-react/dist/esm/Wc.js
var import_react = __toESM(require_react());
var ignoredProps = /* @__PURE__ */ new Set(["children", "wcType"]);
var Wc = class extends import_react.Component {
  /**
   * Gets the web component element reference
   *
   * @readonly
   * @memberof Wc
   */
  get element() {
    return this._element;
  }
  /**
   * Gets the web component tag name from the 'wcType' prop
   *
   * @protected
   * @returns
   * @memberof Wc
   */
  getTag() {
    let tag;
    if (typeof this.props.wcType === "function") {
      tag = this.props.wcType.name.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
    } else if (typeof this.props.wcType === "string") {
      tag = this.props.wcType;
    }
    return tag;
  }
  /**
   * Renders the web component
   *
   * @returns
   * @memberof Wc
   */
  render() {
    const tag = this.getTag();
    if (!tag) {
      throw '"wcType" must be set!';
    }
    const allBools = {};
    for (const key of Object.keys(this.props)) {
      if (key && this.props[key] === true) {
        allBools[key] = true;
      }
    }
    return import_react.default.createElement(tag, Object.assign(Object.assign({}, allBools), { ref: (element) => this.setRef(element) }), this.props.children);
  }
  /**
   * Sets the web component reference and syncs the props
   *
   * @protected
   * @param {HTMLElement} element
   * @memberof Wc
   */
  setRef(element) {
    if (element) {
      if (element !== this._element) {
        this.cleanUp();
      }
      this._element = element;
      this.syncProps(this.props);
    } else {
      this.cleanUp();
    }
    if (this.props.innerRef) {
      if (typeof this.props.innerRef === "function") {
        this.props.innerRef(element);
      } else {
        this.props.innerRef.current = element;
      }
    }
  }
  /**
   * Removes all event listeners from web component element
   *
   * @protected
   * @returns
   * @memberof Wc
   */
  cleanUp() {
    if (!this._element) {
      return;
    }
    for (const prop in this.props) {
      if (!this.props.hasOwnProperty(prop)) {
        continue;
      }
      if (this.isEventProp(prop, this.props[prop])) {
        this.removeEventListener(prop, this.props[prop]);
      }
    }
    this._element = null;
  }
  /**
   * Updates props on web component
   *
   * @param {*} prevProps
   * @memberof Wc
   */
  componentDidUpdate(prevProps) {
    const newProps = {};
    for (const prop in this.props) {
      if (!this.props.hasOwnProperty(prop)) {
        continue;
      }
      if (!prevProps[prop] || prevProps[prop] !== this.props[prop]) {
        newProps[prop] = this.props[prop];
        if (prevProps[prop] && this.isEventProp(prop, prevProps[prop])) {
          this.removeEventListener(prop, prevProps[prop]);
        }
      }
    }
    for (const prop in prevProps) {
      if (!prevProps.hasOwnProperty(prop)) {
        continue;
      }
      if (!this.props[prop] && this.isEventProp(prop, prevProps[prop])) {
        this.removeEventListener(prop, prevProps[prop]);
      }
    }
    this.syncProps(newProps);
  }
  /**
   * Syncs all React component props to web component
   *
   * @protected
   * @param {*} props
   * @memberof Wc
   */
  syncProps(props) {
    if (this._element) {
      for (const prop in props) {
        if (ignoredProps.has(prop)) {
          continue;
        }
        if (this.isEventProp(prop, props[prop])) {
          this.addEventListener(prop, props[prop]);
        }
        this._element[prop] = props[prop];
      }
    }
  }
  /**
   * Returns true if prop should be treated as event
   *
   * @protected
   * @param {string} prop
   * @param {*} value
   * @returns
   * @memberof Wc
   */
  isEventProp(prop, value) {
    return prop && typeof value === "function";
  }
  /**
   * Adds event listener on web component
   *
   * @protected
   * @param {string} propName
   * @param {EventListenerOrEventListenerObject} handler
   * @memberof Wc
   */
  addEventListener(propName, handler) {
    let eventName = propName;
    if (eventName.match(/^on[A-Z]/gm)) {
      eventName = eventName.substring(2).toLowerCase();
    }
    this._element.addEventListener(eventName, handler);
  }
  /**
   * Removes event listener from web component
   *
   * @protected
   * @param {string} propName
   * @param {EventListenerOrEventListenerObject} handler
   * @memberof Wc
   */
  removeEventListener(propName, handler) {
    let eventName = propName;
    if (eventName.match(/^on[A-Z]/gm)) {
      eventName = eventName.substring(2).toLowerCase();
    }
    this._element.removeEventListener(eventName, handler);
  }
};

// node_modules/@microsoft/mgt-react/dist/es6/Mgt.js
init_es6();
var Mgt = class extends Wc {
  constructor(props) {
    super(props);
    this.handleTemplateRendered = this.handleTemplateRendered.bind(this);
  }
  getTag() {
    let tag = super.getTag();
    const tagPrefix = `${customElementHelper.prefix}-`;
    if (!tag.startsWith(tagPrefix)) {
      tag = tagPrefix + tag;
    }
    return tag;
  }
  render() {
    const tag = this.getTag();
    if (!tag) {
      throw new Error('"wcType" must be set!');
    }
    this.processTemplates(this.props.children);
    const templateElements = [];
    if (this._templates) {
      for (const t in this._templates) {
        if (this._templates.hasOwnProperty(t)) {
          const element = import_react2.default.createElement("template", { key: t, "data-type": t }, null);
          templateElements.push(element);
        }
      }
    }
    return import_react2.default.createElement(tag, { ref: (element) => this.setRef(element) }, templateElements);
  }
  /**
   * Sets the web component reference and syncs the props
   *
   * @protected
   * @param {HTMLElement} element
   * @memberof Wc
   */
  setRef(component) {
    if (component) {
      component.addEventListener("templateRendered", this.handleTemplateRendered);
    }
    super.setRef(component);
  }
  /**
   * Removes all event listeners from web component element
   *
   * @protected
   * @returns
   * @memberof Mgt
   */
  cleanUp() {
    if (!this.element) {
      return;
    }
    this.element.removeEventListener("templateRendered", this.handleTemplateRendered);
    super.cleanUp();
  }
  /**
   * Renders a template
   *
   * @protected
   * @param {*} e
   * @returns
   * @memberof Mgt
   */
  handleTemplateRendered(e) {
    if (!this._templates) {
      return;
    }
    const templateType = e.detail.templateType;
    const dataContext = e.detail.context;
    const element = e.detail.element;
    let template = this._templates[templateType];
    if (template) {
      template = import_react2.default.cloneElement(template, { dataContext });
      import_react_dom.default.render(template, element);
    }
  }
  /**
   * Prepares templates for rendering
   *
   * @protected
   * @param {ReactNode} children
   * @returns
   * @memberof Mgt
   */
  processTemplates(children2) {
    if (!children2) {
      return;
    }
    const templates = {};
    import_react2.default.Children.forEach(children2, (child) => {
      const element = child;
      if (element && element.props && element.props.template) {
        templates[element.props.template] = element;
      } else {
        templates["default"] = element;
      }
    });
    this._templates = templates;
  }
};
var wrapMgt = (tag) => {
  const component = import_react2.default.forwardRef((props, ref2) => import_react2.default.createElement(Mgt, Object.assign({ wcType: tag, innerRef: ref2 }, props)));
  return component;
};

// node_modules/@microsoft/mgt-react/dist/es6/generated/react.js
var Agenda = wrapMgt("agenda");
var File = wrapMgt("file");
var FileList = wrapMgt("file-list");
var Get = wrapMgt("get");
var Login = wrapMgt("login");
var People = wrapMgt("people");
var PeoplePicker = wrapMgt("people-picker");
var Person = wrapMgt("person");
var PersonCard = wrapMgt("person-card");
var Picker = wrapMgt("picker");
var Tasks = wrapMgt("tasks");
var TeamsChannelPicker = wrapMgt("teams-channel-picker");
var ThemeToggle = wrapMgt("theme-toggle");
var Todo = wrapMgt("todo");

// node_modules/@microsoft/mgt-components/dist/es6/index.js
var es6_exports = {};
__export(es6_exports, {
  GroupType: () => GroupType,
  MgtAgenda: () => MgtAgenda,
  MgtContact: () => MgtContact,
  MgtFile: () => MgtFile,
  MgtFileList: () => MgtFileList,
  MgtGet: () => MgtGet,
  MgtLogin: () => MgtLogin,
  MgtMessages: () => MgtMessages,
  MgtOrganization: () => MgtOrganization,
  MgtPeople: () => MgtPeople,
  MgtPeoplePicker: () => MgtPeoplePicker,
  MgtPerson: () => MgtPerson,
  MgtPersonCard: () => MgtPersonCard,
  MgtPicker: () => MgtPicker,
  MgtProfile: () => MgtProfile,
  MgtTasks: () => MgtTasks,
  MgtTeamsChannelPicker: () => MgtTeamsChannelPicker,
  MgtTodo: () => MgtTodo,
  PersonCardInteraction: () => PersonCardInteraction,
  PersonType: () => PersonType,
  PersonViewType: () => PersonViewType,
  ResponseType: () => ResponseType2,
  TasksSource: () => TasksSource,
  UserType: () => UserType,
  ViewType: () => ViewType,
  avatarType: () => avatarType
});

// node_modules/@microsoft/mgt-components/dist/es6/components/components.js
var components_exports = {};
__export(components_exports, {
  GroupType: () => GroupType,
  MgtAgenda: () => MgtAgenda,
  MgtContact: () => MgtContact,
  MgtFile: () => MgtFile,
  MgtFileList: () => MgtFileList,
  MgtGet: () => MgtGet,
  MgtLogin: () => MgtLogin,
  MgtMessages: () => MgtMessages,
  MgtOrganization: () => MgtOrganization,
  MgtPeople: () => MgtPeople,
  MgtPeoplePicker: () => MgtPeoplePicker,
  MgtPerson: () => MgtPerson,
  MgtPersonCard: () => MgtPersonCard,
  MgtPicker: () => MgtPicker,
  MgtProfile: () => MgtProfile,
  MgtTasks: () => MgtTasks,
  MgtTeamsChannelPicker: () => MgtTeamsChannelPicker,
  MgtTodo: () => MgtTodo,
  PersonCardInteraction: () => PersonCardInteraction,
  PersonType: () => PersonType,
  PersonViewType: () => PersonViewType,
  ResponseType: () => ResponseType2,
  TasksSource: () => TasksSource,
  UserType: () => UserType,
  avatarType: () => avatarType
});

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-agenda/mgt-agenda.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/styles/theme-css.js
init_lit();
var styles = [
  css`
.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--selected-person-background-color:#f0f0f0}.mgt-dark{--selected-person-background-color:#4f4f4f}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--dropdown-item-selected-background:#deecf9;--arrow-fill:#000000}.mgt-dark{--dropdown-item-selected-background:#333d47;--arrow-fill:#605e5c}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--button-color:var(--neutral-foreground-rest, #1a1a1a);--popup-color:var(--neutral-foreground-rest, #1a1a1a)}.mgt-dark{--button-color:#f3f2f1;--popup-color:#f3f2f1}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--event-background-color:#ffffff;background-color:transparent}.mgt-dark{--event-background-color:#161514;background-color:transparent!important}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--presence-background-color:#ffffff;--presence-icon-color:#ffffff;--line1-color:#000000;--line2-color:var(--neutral-foreground-hint, #717171);--line3-color:var(--neutral-foreground-hint, #717171);--line4-color:var(--neutral-foreground-hint, #717171);--initials-color:black;--initials-background-color:white}.mgt-dark{--presence-background-color:#000000;--presence-icon-color:#000000;--line1-color:#ffffff;--line2-color:#c8c6c4;--line3-color:#c8c6c4;--line4-color:#c8c6c4;--initials-color:white;--initials-background-color:black}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--presence-background-color:#ffffff;--presence-icon-color:#ffffff;--line1-color:#000000;--line2-color:var(--neutral-foreground-hint, #717171);--line3-color:var(--neutral-foreground-hint, #717171);--line4-color:var(--neutral-foreground-hint, #717171);--initials-color:black;--initials-background-color:white}.mgt-dark{--presence-background-color:#000000;--presence-icon-color:#000000;--line1-color:#ffffff;--line2-color:#c8c6c4;--line3-color:#c8c6c4;--line4-color:#c8c6c4;--initials-color:white;--initials-background-color:black}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--person-card-contact-link-color:#023b8f;--person-card-contact-link-hover-color:#106ebe}.mgt-dark{--person-card-contact-link-color:#ffffff;--person-card-contact-link-hover-color:#f3f2f1}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--person-card-active-org-member-color:#023b8f}.mgt-dark{--person-card-active-org-member-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--token-overflow-color:#023b8f}.mgt-dark{--token-overflow-color:#f3f2f1}.mgt-light{--person-card-background-color:#ffffff;--person-card-display-name-color:#000000;--person-card-title-color:var(--neutral-foreground-hint, #717171);--person-card-subtitle-color:var(--neutral-foreground-hint, #717171);--person-card-nav-back-arrow-color:#023b8f;--person-card-nav-back-arrow-color:#000000;--person-card-show-more-color:#023b8f;--person-card-show-more-hover-color:#106ebe}.mgt-dark{--person-card-background-color:#000000;--person-card-display-name-color:#ffffff;--person-card-title-color:#c8c6c4;--person-card-subtitle-color:#c8c6c4;--person-card-nav-back-arrow-color:#106ebe;--person-card-nav-back-arrow-color:#ffffff;--person-card-show-more-color:#ffffff;--person-card-show-more-hover-color:#f3f2f1}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--task-border:1px solid #e1dfdd;--task-complete-border:2px dotted #e1dfdd;--task-new-add-button-disabled-background:#ebebeb;--task-icon-color:#000000}.mgt-dark{--task-border:1px solid #717171;--task-complete-border:2px dotted #717171;--task-new-add-button-disabled-background:#4f4f4f;--task-icon-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{background-color:#fff}.mgt-dark{background-color:#424242}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--file-item-background-color--hover:#f7f7f7;--file-item-background-color--active:#fbfbfb;--file-list-background-color:#ffffff;--file-upload-button-background-color:#f3f2f1;--file-upload-dialog-background-color:rgba(0, 0, 0, 0.1);--file-upload-dialog-content-background-color:white;--file-upload-dialog-content-color:#323130;--file-upload-dialog-primarybutton-color:white;--file-upload-dialog-primarybutton-background-color:#006cbe}.mgt-dark{--file-item-background-color--hover:#0078d4;--file-item-background-color--active:#238ada;--file-list-background-color:#424242;--file-upload-button-background-color:#006cbe;--file-upload-dialog-background-color:rgba(0, 0, 0, 0.3);--file-upload-dialog-content-background-color:#787878;--file-upload-dialog-content-color:#000;--file-upload-dialog-primarybutton-color:white;--file-upload-dialog-primarybutton-background-color:#006cbe}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/styles/style-helper.js
var fabricFont = document.createElement("style");
fabricFont.type = "text/css";
fabricFont.appendChild(document.createTextNode(`
@font-face {
    font-family: 'FabricMDL2Icons';
    src: url('https://static2.sharepointonline.com/files/fabric/assets/icons/fabricmdl2icons-2.68.woff2') format('woff2'),
    url(https://static2.sharepointonline.com/files/fabric/assets/icons/fabricmdl2icons-2.68.woff) format("woff"),
    url(https://static2.sharepointonline.com/files/fabric/assets/icons/fabricmdl2icons-2.68.ttf) format("truetype");;
}
`));
document.head.appendChild(fabricFont);
var themeStyle = document.createElement("style");
themeStyle.innerHTML = styles.toString();
document.head.appendChild(themeStyle);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person/mgt-person.js
init_lit();
init_decorators();

// node_modules/lit-html/development/directives/class-map.js
init_lit_html();

// node_modules/lit-html/development/directive.js
var PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
var directive = (c) => (...values) => ({
  // This property needs to remain unminified.
  ["_$litDirective$"]: c,
  values
});
var Directive = class {
  constructor(_partInfo) {
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /** @internal */
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  /** @internal */
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
};

// node_modules/lit-html/development/directives/class-map.js
var ClassMapDirective = class extends Directive {
  constructor(partInfo) {
    var _a2;
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "class" || ((_a2 = partInfo.strings) === null || _a2 === void 0 ? void 0 : _a2.length) > 2) {
      throw new Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
  }
  render(classInfo) {
    return " " + Object.keys(classInfo).filter((key) => classInfo[key]).join(" ") + " ";
  }
  update(part, [classInfo]) {
    var _a2, _b2;
    if (this._previousClasses === void 0) {
      this._previousClasses = /* @__PURE__ */ new Set();
      if (part.strings !== void 0) {
        this._staticClasses = new Set(part.strings.join(" ").split(/\s/).filter((s) => s !== ""));
      }
      for (const name in classInfo) {
        if (classInfo[name] && !((_a2 = this._staticClasses) === null || _a2 === void 0 ? void 0 : _a2.has(name))) {
          this._previousClasses.add(name);
        }
      }
      return this.render(classInfo);
    }
    const classList = part.element.classList;
    this._previousClasses.forEach((name) => {
      if (!(name in classInfo)) {
        classList.remove(name);
        this._previousClasses.delete(name);
      }
    });
    for (const name in classInfo) {
      const value = !!classInfo[name];
      if (value !== this._previousClasses.has(name) && !((_b2 = this._staticClasses) === null || _b2 === void 0 ? void 0 : _b2.has(name))) {
        if (value) {
          classList.add(name);
          this._previousClasses.add(name);
        } else {
          classList.remove(name);
          this._previousClasses.delete(name);
        }
      }
    }
    return noChange;
  }
};
var classMap = directive(ClassMapDirective);

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.people.js
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/utils/Utils.js
function getRelativeDisplayDate(date) {
  const now = /* @__PURE__ */ new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  if (date >= today) {
    return date.toLocaleString("default", {
      hour: "numeric",
      minute: "numeric"
    });
  }
  const sunday = new Date(today);
  sunday.setDate(now.getDate() - now.getDay());
  if (date >= sunday) {
    return date.toLocaleString("default", {
      hour: "numeric",
      minute: "numeric",
      weekday: "short"
    });
  }
  const lastTwoWeeks = new Date(sunday);
  lastTwoWeeks.setDate(sunday.getDate() - 7);
  if (date >= lastTwoWeeks) {
    return date.toLocaleString("default", {
      day: "numeric",
      month: "numeric",
      weekday: "short"
    });
  }
  return date.toLocaleString("default", {
    day: "numeric",
    month: "numeric",
    year: "numeric"
  });
}
function getShortDateString(date) {
  const month = date.getMonth();
  const day = date.getDate();
  return `${getMonthString(month)} ${day}`;
}
function getMonthString(month) {
  switch (month) {
    case 0:
      return "January";
    case 1:
      return "February";
    case 2:
      return "March";
    case 3:
      return "April";
    case 4:
      return "May";
    case 5:
      return "June";
    case 6:
      return "July";
    case 7:
      return "August";
    case 8:
      return "September";
    case 9:
      return "October";
    case 10:
      return "November";
    case 11:
      return "December";
    default:
      return "Month";
  }
}
function debounce(func, time) {
  let timeout;
  return function() {
    const functionCall = () => func.apply(this, arguments);
    clearTimeout(timeout);
    timeout = setTimeout(functionCall, time);
  };
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = (_) => {
      resolve(reader.result);
    };
    reader.readAsDataURL(blob);
  });
}
function extractEmailAddress(emailString) {
  if (emailString.startsWith("[")) {
    return emailString.match(/([a-zA-Z0-9+._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/gi).toString();
  } else
    return emailString;
}
function isValidEmail(emailString) {
  const emailRx = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return emailRx.test(emailString);
}
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
}

// node_modules/@microsoft/mgt-components/dist/es6/graph/cacheStores.js
var schemas = {
  presence: {
    name: "presence",
    stores: {
      presence: "presence"
    },
    version: 1
  },
  users: {
    name: "users",
    stores: {
      users: "users",
      usersQuery: "usersQuery",
      userFilters: "userFilters"
    },
    version: 2
  },
  photos: {
    name: "photos",
    stores: {
      contacts: "contacts",
      users: "users",
      groups: "groups",
      teams: "teams"
    },
    version: 1
  },
  people: {
    name: "people",
    stores: {
      contacts: "contacts",
      groupPeople: "groupPeople",
      peopleQuery: "peopleQuery"
    },
    version: 2
  },
  groups: {
    name: "groups",
    stores: {
      groups: "groups",
      groupsQuery: "groupsQuery"
    },
    version: 4
  },
  get: {
    name: "responses",
    stores: {
      responses: "responses"
    },
    version: 1
  },
  files: {
    name: "files",
    stores: {
      driveFiles: "driveFiles",
      groupFiles: "groupFiles",
      siteFiles: "siteFiles",
      userFiles: "userFiles",
      insightFiles: "insightFiles",
      fileQueries: "fileQueries"
    },
    version: 1
  },
  fileLists: {
    name: "file-lists",
    stores: {
      fileLists: "fileLists",
      insightfileLists: "insightfileLists"
    },
    version: 1
  }
};

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.people.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PersonType;
(function(PersonType2) {
  PersonType2[PersonType2["any"] = 0] = "any";
  PersonType2["person"] = "person";
  PersonType2["group"] = "group";
})(PersonType || (PersonType = {}));
var UserType;
(function(UserType2) {
  UserType2["any"] = "any";
  UserType2["user"] = "user";
  UserType2["contact"] = "contact";
})(UserType || (UserType = {}));
var getPeopleInvalidationTime = () => CacheService.config.people.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsPeopleCacheEnabled = () => CacheService.config.people.isEnabled && CacheService.config.isEnabled;
function findPeople(graph, query, top = 10, userType = UserType.any, filters = "") {
  return __awaiter(this, void 0, void 0, function* () {
    const scopes = "people.read";
    let cache2;
    const cacheKey = `${query}:${top}:${userType}`;
    if (getIsPeopleCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
      const result = getIsPeopleCacheEnabled() ? yield cache2.getValue(cacheKey) : null;
      if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
        return result.results.map((peopleStr) => JSON.parse(peopleStr));
      }
    }
    let filter = "personType/class eq 'Person'";
    if (userType !== UserType.any) {
      if (userType === UserType.user) {
        filter += "and personType/subclass eq 'OrganizationUser'";
      } else {
        filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
      }
    }
    if (filters !== "") {
      filter += `${filter} and ${filters}`;
    }
    let graphResult;
    try {
      let graphRequest = graph.api("/me/people").search('"' + query + '"').top(top).filter(filter).middlewareOptions(prepScopes(scopes));
      if (userType !== UserType.contact) {
        graphRequest = graphRequest.header("X-PeopleQuery-QuerySources", "Mailbox,Directory");
      }
      graphResult = yield graphRequest.get();
      if (getIsPeopleCacheEnabled() && graphResult) {
        const item = { maxResults: top, results: null };
        item.results = graphResult.value.map((personStr) => JSON.stringify(personStr));
        cache2.putValue(cacheKey, item);
      }
    } catch (error) {
    }
    return graphResult ? graphResult.value : null;
  });
}
function getPeople(graph, userType = UserType.any, peopleFilters = "") {
  return __awaiter(this, void 0, void 0, function* () {
    const scopes = "people.read";
    let cache2;
    const cacheKey = peopleFilters ? peopleFilters : `*:${userType}`;
    if (getIsPeopleCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
      const cacheRes = yield cache2.getValue(cacheKey);
      if (cacheRes && getPeopleInvalidationTime() > Date.now() - cacheRes.timeCached) {
        return cacheRes.results.map((ppl) => JSON.parse(ppl));
      }
    }
    const uri = "/me/people";
    let filter = "personType/class eq 'Person'";
    if (userType !== UserType.any) {
      if (userType === UserType.user) {
        filter += "and personType/subclass eq 'OrganizationUser'";
      } else {
        filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
      }
    }
    if (peopleFilters) {
      filter += ` and ${peopleFilters}`;
    }
    let people;
    try {
      let graphRequest = graph.api(uri).middlewareOptions(prepScopes(scopes)).filter(filter);
      if (userType != UserType.contact) {
        graphRequest = graphRequest.header("X-PeopleQuery-QuerySources", "Mailbox,Directory");
      }
      people = yield graphRequest.get();
      if (getIsPeopleCacheEnabled() && people) {
        cache2.putValue(cacheKey, { maxResults: 10, results: people.value.map((ppl) => JSON.stringify(ppl)) });
      }
    } catch (_) {
    }
    return people ? people.value : null;
  });
}
function getEmailFromGraphEntity(entity) {
  const person = entity;
  const user = entity;
  const contact = entity;
  if (user.mail) {
    return extractEmailAddress(user.mail);
  } else if (person.scoredEmailAddresses && person.scoredEmailAddresses.length) {
    return extractEmailAddress(person.scoredEmailAddresses[0].address);
  } else if (contact.emailAddresses && contact.emailAddresses.length) {
    return extractEmailAddress(contact.emailAddresses[0].address);
  }
  return null;
}
function findContactsByEmail(graph, email) {
  return __awaiter(this, void 0, void 0, function* () {
    const scopes = "contacts.read";
    let cache2;
    if (getIsPeopleCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.people, schemas.people.stores.contacts);
      const contact = yield cache2.getValue(email);
      if (contact && getPeopleInvalidationTime() > Date.now() - contact.timeCached) {
        return JSON.parse(contact.person);
      }
    }
    const encodedEmail = `${email.replace(/#/g, "%2523")}`;
    const result = yield graph.api("/me/contacts").filter(`emailAddresses/any(a:a/address eq '${encodedEmail}')`).middlewareOptions(prepScopes(scopes)).get();
    if (getIsPeopleCacheEnabled() && result) {
      cache2.putValue(email, { person: JSON.stringify(result.value) });
    }
    return result ? result.value : null;
  });
}
function getPeopleFromResource(graph, version, resource, scopes) {
  return __awaiter(this, void 0, void 0, function* () {
    let cache2;
    const key = `${version}${resource}`;
    if (getIsPeopleCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
      const result = yield cache2.getValue(key);
      if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
        return result.results.map((peopleStr) => JSON.parse(peopleStr));
      }
    }
    let request = graph.api(resource).version(version);
    if (scopes && scopes.length) {
      request = request.middlewareOptions(prepScopes(...scopes));
    }
    let response = yield request.get();
    if (response && Array.isArray(response.value) && response["@odata.nextLink"]) {
      let pageCount = 1;
      let page = response;
      while (page && page["@odata.nextLink"]) {
        pageCount++;
        const nextResource = page["@odata.nextLink"].split(version)[1];
        page = yield graph.client.api(nextResource).version(version).get();
        if (page && page.value && page.value.length) {
          page.value = response.value.concat(page.value);
          response = page;
        }
      }
    }
    if (getIsPeopleCacheEnabled() && response) {
      const item = { results: null };
      if (Array.isArray(response.value)) {
        item.results = response.value.map((personStr) => JSON.stringify(personStr));
      } else {
        item.results = [JSON.stringify(response)];
      }
      cache2.putValue(key, item);
    }
    if (response) {
      return Array.isArray(response.value) ? response.value : [response];
    } else {
      return null;
    }
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.photos.js
init_es6();
init_browser();

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.user.js
init_es6();
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getUserInvalidationTime = () => CacheService.config.users.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsUsersCacheEnabled = () => CacheService.config.users.isEnabled && CacheService.config.isEnabled;
function getUsers(graph, userFilters = "", top = 10) {
  return __awaiter2(this, void 0, void 0, function* () {
    let apiString = "/users";
    let cache2;
    const cacheKey = userFilters === "" ? "*" : userFilters;
    const cacheItem = { maxResults: top, results: null };
    if (getIsUsersCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.users, schemas.users.stores.userFilters);
      const cacheRes = yield cache2.getValue(cacheKey);
      if (cacheRes && getUserInvalidationTime() > Date.now() - cacheRes.timeCached) {
        return cacheRes.results.map((userStr) => JSON.parse(userStr));
      }
    }
    const graphClient = graph.api(apiString).top(top);
    if (userFilters) {
      graphClient.filter(userFilters);
    }
    try {
      const response = yield graphClient.middlewareOptions(prepScopes("user.read")).get();
      if (getIsUsersCacheEnabled() && response) {
        cacheItem.results = response.value.map((userStr) => JSON.stringify(userStr));
        cache2.putValue(userFilters, cacheItem);
      }
      return response.value;
    } catch (error) {
    }
  });
}
function getMe(graph, requestedProps) {
  return __awaiter2(this, void 0, void 0, function* () {
    let cache2;
    if (getIsUsersCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.users, schemas.users.stores.users);
      const me = yield cache2.getValue("me");
      if (me && getUserInvalidationTime() > Date.now() - me.timeCached) {
        const cachedData = JSON.parse(me.user);
        const uniqueProps = requestedProps ? requestedProps.filter((prop) => !Object.keys(cachedData).includes(prop)) : null;
        if (!uniqueProps || uniqueProps.length <= 1) {
          return cachedData;
        }
      }
    }
    let apiString = "me";
    if (requestedProps) {
      apiString = apiString + "?$select=" + requestedProps.toString();
    }
    const response = graph.api(apiString).middlewareOptions(prepScopes("user.read")).get();
    if (getIsUsersCacheEnabled()) {
      cache2.putValue("me", { user: JSON.stringify(yield response) });
    }
    return response;
  });
}
function getUser(graph, userPrincipleName, requestedProps) {
  return __awaiter2(this, void 0, void 0, function* () {
    const scopes = "user.readbasic.all";
    let cache2;
    if (getIsUsersCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.users, schemas.users.stores.users);
      const user = yield cache2.getValue(userPrincipleName);
      if (user && getUserInvalidationTime() > Date.now() - user.timeCached) {
        const cachedData = user.user ? JSON.parse(user.user) : null;
        const uniqueProps = requestedProps && cachedData ? requestedProps.filter((prop) => !Object.keys(cachedData).includes(prop)) : null;
        if (!uniqueProps || uniqueProps.length <= 1) {
          return cachedData;
        }
      }
    }
    let apiString = `/users/${userPrincipleName}`;
    if (requestedProps) {
      apiString = apiString + "?$select=" + requestedProps.toString();
    }
    let response;
    try {
      response = yield graph.api(apiString).middlewareOptions(prepScopes(scopes)).get();
    } catch (_) {
    }
    if (getIsUsersCacheEnabled()) {
      cache2.putValue(userPrincipleName, { user: JSON.stringify(response) });
    }
    return response;
  });
}
function getUsersForUserIds(graph, userIds, searchInput = "", userFilters = "", fallbackDetails) {
  return __awaiter2(this, void 0, void 0, function* () {
    if (!userIds || userIds.length === 0) {
      return [];
    }
    const batch = graph.createBatch();
    const peopleDict = {};
    const peopleSearchMatches = {};
    const notInCache = [];
    searchInput = searchInput.toLowerCase();
    let cache2;
    if (getIsUsersCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.users, schemas.users.stores.users);
    }
    for (const id of userIds) {
      peopleDict[id] = null;
      let apiUrl = `/users/${id}`;
      let user = null;
      if (getIsUsersCacheEnabled()) {
        user = yield cache2.getValue(id);
      }
      if ((user === null || user === void 0 ? void 0 : user.user) && getUserInvalidationTime() > Date.now() - user.timeCached) {
        user = JSON.parse(user === null || user === void 0 ? void 0 : user.user);
        if (searchInput) {
          if (user) {
            const displayName = user.displayName;
            const searchMatches = displayName && displayName.toLowerCase().includes(searchInput);
            if (searchMatches) {
              peopleSearchMatches[id] = user;
            }
          }
        } else {
          if (user) {
            peopleDict[id] = user;
          } else {
            batch.get(id, apiUrl, ["user.readbasic.all"]);
            notInCache.push(id);
          }
        }
      } else if (id !== "") {
        if (id.toString() === "me") {
          peopleDict[id] = yield getMe(graph);
        } else {
          let apiUrl2 = `/users/${id}`;
          if (userFilters) {
            apiUrl2 += `${apiUrl2}?$filter=${userFilters}`;
          }
          batch.get(id, apiUrl2, ["user.readbasic.all"]);
          notInCache.push(id);
        }
      }
    }
    try {
      if (batch.hasRequests) {
        const responses = yield batch.executeAll();
        for (const id of userIds) {
          const response = responses.get(id);
          if (response && response.content) {
            const user = response.content;
            if (searchInput) {
              const displayName = user === null || user === void 0 ? void 0 : user.displayName.toLowerCase();
              if (displayName.contains(searchInput)) {
                peopleSearchMatches[id] = user;
              }
            } else {
              peopleDict[id] = user;
            }
            if (getIsUsersCacheEnabled()) {
              cache2.putValue(id, { user: JSON.stringify(user) });
            }
          } else {
            const fallback = fallbackDetails.find((detail) => Object.values(detail).includes(id));
            if (fallback) {
              peopleDict[id] = fallback;
            }
          }
        }
        if (searchInput && Object.keys(peopleSearchMatches).length) {
          return Promise.all(Object.values(peopleSearchMatches));
        }
        return Promise.all(Object.values(peopleDict));
      }
    } catch (_) {
      try {
        userIds.filter((id) => notInCache.includes(id)).forEach((id) => peopleDict[id] = getUser(graph, id));
        if (getIsUsersCacheEnabled()) {
          userIds.filter((id) => notInCache.includes(id)).forEach((id) => __awaiter2(this, void 0, void 0, function* () {
            return cache2.putValue(id, { user: JSON.stringify(yield peopleDict[id]) });
          }));
        }
        return Promise.all(Object.values(peopleDict));
      } catch (_2) {
        return [];
      }
    }
  });
}
function getUsersForPeopleQueries(graph, peopleQueries, fallbackDetails) {
  return __awaiter2(this, void 0, void 0, function* () {
    if (!peopleQueries || peopleQueries.length === 0) {
      return [];
    }
    const batch = graph.createBatch();
    const people = [];
    let cacheRes;
    let cache2;
    if (getIsUsersCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
    }
    for (const personQuery of peopleQueries) {
      if (getIsUsersCacheEnabled()) {
        cacheRes = yield cache2.getValue(personQuery);
      }
      if (getIsUsersCacheEnabled() && (cacheRes === null || cacheRes === void 0 ? void 0 : cacheRes.results[0]) && getUserInvalidationTime() > Date.now() - cacheRes.timeCached) {
        const person = JSON.parse(cacheRes.results[0]);
        people.push(person);
      } else {
        batch.get(personQuery, `/me/people?$search="${personQuery}"`, ["people.read"], {
          "X-PeopleQuery-QuerySources": "Mailbox,Directory"
        });
      }
    }
    if (batch.hasRequests) {
      try {
        const responses = yield batch.executeAll();
        for (const personQuery of peopleQueries) {
          const response = responses.get(personQuery);
          if (response && response.content && response.content.value && response.content.value.length > 0) {
            people.push(response.content.value[0]);
            if (getIsUsersCacheEnabled()) {
              cache2.putValue(personQuery, { maxResults: 1, results: [JSON.stringify(response.content.value[0])] });
            }
          } else {
            const fallback = fallbackDetails.find((detail) => Object.values(detail).includes(personQuery));
            if (fallback) {
              people.push(fallback);
            }
          }
        }
        return people;
      } catch (_) {
        try {
          return Promise.all(peopleQueries.filter((personQuery) => personQuery && personQuery !== "").map((personQuery) => __awaiter2(this, void 0, void 0, function* () {
            const personArray = yield findPeople(graph, personQuery, 1);
            if (personArray && personArray.length) {
              if (getIsUsersCacheEnabled()) {
                cache2.putValue(personQuery, { maxResults: 1, results: [JSON.stringify(personArray[0])] });
              }
              return personArray[0];
            }
          })));
        } catch (_2) {
          return [];
        }
      }
    }
    return people;
  });
}
function findUsers(graph, query, top = 10, userFilters = "") {
  return __awaiter2(this, void 0, void 0, function* () {
    const scopes = "User.ReadBasic.All";
    const item = { maxResults: top, results: null };
    let cache2;
    if (getIsUsersCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
      const result = yield cache2.getValue(query);
      if (result && getUserInvalidationTime() > Date.now() - result.timeCached) {
        return result.results.map((userStr) => JSON.parse(userStr));
      }
    }
    let encodedQuery = `${query.replace(/#/g, "%2523")}`;
    let graphBuilder = graph.api("users").header("ConsistencyLevel", "eventual").count(true).search(`"displayName:${encodedQuery}" OR "mail:${encodedQuery}"`);
    let graphResult;
    if (userFilters !== "") {
      graphBuilder.filter(userFilters);
    }
    try {
      graphResult = yield graphBuilder.top(top).middlewareOptions(prepScopes(scopes)).get();
    } catch (_a2) {
    }
    if (getIsUsersCacheEnabled() && graphResult) {
      item.results = graphResult.value.map((userStr) => JSON.stringify(userStr));
      cache2.putValue(query, item);
    }
    return graphResult ? graphResult.value : null;
  });
}
function findGroupMembers(graph, query, groupId, top = 10, personType = PersonType.person, transitive = false, userFilters = "", peopleFilters = "") {
  return __awaiter2(this, void 0, void 0, function* () {
    const scopes = ["user.read.all", "people.read"];
    const item = { maxResults: top, results: null };
    let cache2;
    const key = `${groupId || "*"}:${query || "*"}:${personType}:${transitive}:${userFilters}`;
    if (getIsUsersCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
      const result = yield cache2.getValue(key);
      if (result && getUserInvalidationTime() > Date.now() - result.timeCached) {
        return result.results.map((userStr) => JSON.parse(userStr));
      }
    }
    let filter = "";
    if (query) {
      filter = `startswith(displayName,'${query}') or startswith(givenName,'${query}') or startswith(surname,'${query}') or startswith(mail,'${query}') or startswith(userPrincipalName,'${query}')`;
    }
    let apiUrl = `/groups/${groupId}/${transitive ? "transitiveMembers" : "members"}`;
    if (personType === PersonType.person) {
      apiUrl += `/microsoft.graph.user`;
    } else if (personType === PersonType.group) {
      apiUrl += `/microsoft.graph.group`;
      if (query) {
        filter = `startswith(displayName,'${query}') or startswith(mail,'${query}')`;
      }
    }
    if (userFilters) {
      filter += query ? ` and ${userFilters}` : userFilters;
    }
    if (peopleFilters) {
      filter += query ? ` and ${peopleFilters}` : peopleFilters;
    }
    const graphResult = yield graph.api(apiUrl).count(true).top(top).filter(filter).header("ConsistencyLevel", "eventual").middlewareOptions(prepScopes(...scopes)).get();
    if (getIsUsersCacheEnabled() && graphResult) {
      item.results = graphResult.value.map((userStr) => JSON.stringify(userStr));
      cache2.putValue(key, item);
    }
    return graphResult ? graphResult.value : null;
  });
}
function findUsersFromGroupIds(graph, query, groupIds, top = 10, personType = PersonType.person, transitive = false, groupFilters = "") {
  return __awaiter2(this, void 0, void 0, function* () {
    const users = [];
    for (let i = 0; i < groupIds.length; i++) {
      const groupId = groupIds[i];
      try {
        const groupUsers = yield findGroupMembers(graph, query, groupId, top, personType, transitive, groupFilters);
        users.push(...groupUsers);
      } catch (_) {
        continue;
      }
    }
    return users;
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.photos.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getPhotoInvalidationTime = () => CacheService.config.photos.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsPhotosCacheEnabled = () => CacheService.config.photos.isEnabled && CacheService.config.isEnabled;
function getPhotoForResource(graph, resource, scopes) {
  return __awaiter3(this, void 0, void 0, function* () {
    try {
      const response = yield graph.api(`${resource}/photo/$value`).responseType(ResponseType.RAW).middlewareOptions(prepScopes(...scopes)).get();
      if (response.status === 404) {
        return { eTag: null, photo: null };
      } else if (!response.ok) {
        return null;
      }
      const eTag = response.headers.get("eTag");
      const blob = yield blobToBase64(yield response.blob());
      return { eTag, photo: blob };
    } catch (e) {
      return null;
    }
  });
}
function getContactPhoto(graph, contactId) {
  return __awaiter3(this, void 0, void 0, function* () {
    let cache2;
    let photoDetails;
    if (getIsPhotosCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.photos, schemas.photos.stores.contacts);
      photoDetails = yield cache2.getValue(contactId);
      if (photoDetails && getPhotoInvalidationTime() > Date.now() - photoDetails.timeCached) {
        return photoDetails.photo;
      }
    }
    photoDetails = yield getPhotoForResource(graph, `me/contacts/${contactId}`, ["contacts.read"]);
    if (getIsPhotosCacheEnabled() && photoDetails) {
      cache2.putValue(contactId, photoDetails);
    }
    return photoDetails ? photoDetails.photo : null;
  });
}
function getUserPhoto(graph, userId) {
  return __awaiter3(this, void 0, void 0, function* () {
    let cache2;
    let photoDetails;
    if (getIsPhotosCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.photos, schemas.photos.stores.users);
      photoDetails = yield cache2.getValue(userId);
      if (photoDetails && getPhotoInvalidationTime() > Date.now() - photoDetails.timeCached) {
        return photoDetails.photo;
      } else if (photoDetails) {
        try {
          const response = yield graph.api(`users/${userId}/photo`).get();
          if (response && (response["@odata.mediaEtag"] !== photoDetails.eTag || response["@odata.mediaEtag"] === null && response.eTag === null)) {
            photoDetails = null;
          }
        } catch (_a2) {
          return null;
        }
      }
    }
    photoDetails = photoDetails || (yield getPhotoForResource(graph, `users/${userId}`, ["user.readbasic.all"]));
    if (getIsPhotosCacheEnabled() && photoDetails) {
      cache2.putValue(userId, photoDetails);
    }
    return photoDetails ? photoDetails.photo : null;
  });
}
function getPersonImage(graph, person, useContactsApis = true) {
  return __awaiter3(this, void 0, void 0, function* () {
    if ("personType" in person && person.personType.subclass !== "OrganizationUser") {
      if (person.personType.subclass === "PersonalContact" && useContactsApis) {
        const email2 = getEmailFromGraphEntity(person);
        const contact = yield findContactsByEmail(graph, email2);
        if (contact && contact.length && contact[0].id) {
          return yield getContactPhoto(graph, contact[0].id);
        }
      }
      return null;
    }
    if (person.userPrincipalName || person.id) {
      const id = person.userPrincipalName || person.id;
      return yield getUserPhoto(graph, id);
    }
    if (person.id) {
      const image = yield getUserPhoto(graph, person.id);
      if (image) {
        return image;
      }
    }
    const email = getEmailFromGraphEntity(person);
    if (email) {
      const users = yield findUsers(graph, email, 1);
      if (users && users.length) {
        return yield getUserPhoto(graph, users[0].id);
      }
      if (useContactsApis) {
        const contacts = yield findContactsByEmail(graph, email);
        if (contacts && contacts.length) {
          return yield getContactPhoto(graph, contacts[0].id);
        }
      }
    }
    return null;
  });
}
function getGroupImage(graph, group, useContactsApis = true) {
  return __awaiter3(this, void 0, void 0, function* () {
    let photoDetails;
    let cache2;
    let groupId = group.id;
    if (getIsPhotosCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.photos, schemas.photos.stores.groups);
      photoDetails = yield cache2.getValue(groupId);
      if (photoDetails && getPhotoInvalidationTime() > Date.now() - photoDetails.timeCached) {
        return photoDetails.photo;
      } else if (photoDetails) {
        try {
          const response = yield graph.api(`groups/${groupId}/photo`).get();
          if (response && (response["@odata.mediaEtag"] !== photoDetails.eTag || response["@odata.mediaEtag"] === null && response.eTag === null)) {
            photoDetails = null;
          }
        } catch (_a2) {
          return null;
        }
      }
    }
    photoDetails = photoDetails || (yield getPhotoForResource(graph, `groups/${groupId}`, ["user.readbasic.all"]));
    if (getIsPhotosCacheEnabled() && photoDetails) {
      cache2.putValue(groupId, photoDetails);
    }
    return photoDetails ? photoDetails.photo : null;
  });
}
function getPhotoFromCache(userId, storeName) {
  return __awaiter3(this, void 0, void 0, function* () {
    const cache2 = CacheService.getCache(schemas.photos, storeName);
    const item = yield cache2.getValue(userId);
    return item;
  });
}
function storePhotoInCache(userId, storeName, value) {
  return __awaiter3(this, void 0, void 0, function* () {
    const cache2 = CacheService.getCache(schemas.photos, storeName);
    cache2.putValue(userId, value);
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.presence.js
init_es6();
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getPresenceInvalidationTime = () => CacheService.config.presence.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsPresenceCacheEnabled = () => CacheService.config.presence.isEnabled && CacheService.config.isEnabled;
function getUserPresence(graph, userId) {
  return __awaiter4(this, void 0, void 0, function* () {
    let cache2;
    if (getIsPresenceCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.presence, schemas.presence.stores.presence);
      const presence = yield cache2.getValue(userId || "me");
      if (presence && getPresenceInvalidationTime() > Date.now() - presence.timeCached) {
        return JSON.parse(presence.presence);
      }
    }
    const scopes = userId ? ["presence.read.all"] : ["presence.read"];
    const resource = userId ? `/users/${userId}/presence` : "/me/presence";
    const result = yield graph.api(resource).middlewareOptions(prepScopes(...scopes)).get();
    if (getIsPresenceCacheEnabled()) {
      cache2.putValue(userId || "me", { presence: JSON.stringify(result) });
    }
    return result;
  });
}
function getUsersPresenceByPeople(graph, people) {
  return __awaiter4(this, void 0, void 0, function* () {
    if (!people || people.length === 0) {
      return {};
    }
    const peoplePresence = {};
    const peoplePresenceToQuery = [];
    const scopes = ["presence.read.all"];
    let cache2;
    if (getIsPresenceCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.presence, schemas.presence.stores.presence);
    }
    for (const person of people) {
      if (person === null || person === void 0 ? void 0 : person.id) {
        const id = person.id;
        peoplePresence[id] = null;
        let presence;
        if (getIsPresenceCacheEnabled()) {
          presence = yield cache2.getValue(id);
        }
        if (getIsPresenceCacheEnabled() && presence && getPresenceInvalidationTime() > Date.now() - (yield presence).timeCached) {
          peoplePresence[id] = JSON.parse(presence.presence);
        } else {
          peoplePresenceToQuery.push(id);
        }
      }
    }
    try {
      if (peoplePresenceToQuery.length > 0) {
        const presenceResult = yield graph.api("/communications/getPresencesByUserId").middlewareOptions(prepScopes(...scopes)).post({
          ids: peoplePresenceToQuery
        });
        for (const r of presenceResult.value) {
          peoplePresence[r.id] = r;
          if (getIsPresenceCacheEnabled()) {
            cache2.putValue(r.id, { presence: JSON.stringify(r) });
          }
        }
      }
      return peoplePresence;
    } catch (_) {
      try {
        const response = yield Promise.all(people.filter((person) => person && person.id && !peoplePresence[person.id] && "personType" in person && person.personType.subclass === "OrganizationUser").map((person) => getUserPresence(graph, person.id)));
        for (const r of response) {
          peoplePresence[r.id] = r;
        }
        return peoplePresence;
      } catch (_2) {
        return null;
      }
    }
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.userWithPhoto.js
init_es6();
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUserWithPhoto(graph, userId, requestedProps) {
  return __awaiter5(this, void 0, void 0, function* () {
    let photo = null;
    let user = null;
    let cachedPhoto;
    let cachedUser;
    const resource = userId ? `users/${userId}` : "me";
    const fullResource = resource + (requestedProps ? `?$select=${requestedProps.toString()}` : "");
    const scopes = userId ? ["user.readbasic.all"] : ["user.read"];
    if (getIsUsersCacheEnabled()) {
      const cache2 = CacheService.getCache(schemas.users, schemas.users.stores.users);
      cachedUser = yield cache2.getValue(userId || "me");
      if (cachedUser && getUserInvalidationTime() > Date.now() - cachedUser.timeCached) {
        user = cachedUser.user ? JSON.parse(cachedUser.user) : null;
        if (user !== null && requestedProps) {
          const uniqueProps = requestedProps.filter((prop) => !Object.keys(user).includes(prop));
          if (uniqueProps.length >= 1) {
            user = null;
            cachedUser = null;
          }
        }
      } else {
        cachedUser = null;
      }
    }
    if (getIsPhotosCacheEnabled()) {
      cachedPhoto = yield getPhotoFromCache(userId || "me", schemas.photos.stores.users);
      if (cachedPhoto && getPhotoInvalidationTime() > Date.now() - cachedPhoto.timeCached) {
        photo = cachedPhoto.photo;
      } else if (cachedPhoto) {
        try {
          const response = yield graph.api(`${resource}/photo`).get();
          if (response && response["@odata.mediaEtag"] && response["@odata.mediaEtag"] === cachedPhoto.eTag) {
            storePhotoInCache(userId || "me", schemas.photos.stores.users, cachedPhoto);
            photo = cachedPhoto.photo;
          } else {
            cachedPhoto = null;
          }
        } catch (e) {
          if (e.code === "ErrorItemNotFound" || e.code === "ImageNotFound") {
            storePhotoInCache(userId || "me", schemas.photos.stores.users, { eTag: null, photo: null });
          }
        }
      }
    }
    if (!cachedPhoto && !cachedUser) {
      let eTag;
      const batch = graph.createBatch();
      if (userId) {
        batch.get("user", `/users/${userId}${requestedProps ? "?$select=" + requestedProps.toString() : ""}`, [
          "user.readbasic.all"
        ]);
        batch.get("photo", `users/${userId}/photo/$value`, ["user.readbasic.all"]);
      } else {
        batch.get("user", "me", ["user.read"]);
        batch.get("photo", "me/photo/$value", ["user.read"]);
      }
      const response = yield batch.executeAll();
      const photoResponse = response.get("photo");
      if (photoResponse) {
        eTag = photoResponse.headers["ETag"];
        photo = photoResponse.content;
      }
      const userResponse = response.get("user");
      if (userResponse) {
        user = userResponse.content;
      }
      if (getIsUsersCacheEnabled()) {
        const cache2 = CacheService.getCache(schemas.users, schemas.users.stores.users);
        cache2.putValue(userId || "me", { user: JSON.stringify(user) });
      }
      if (getIsPhotosCacheEnabled()) {
        storePhotoInCache(userId || "me", schemas.photos.stores.users, { eTag, photo });
      }
    } else if (!cachedPhoto) {
      try {
        const response = yield getPhotoForResource(graph, resource, scopes);
        if (response) {
          if (getIsPhotosCacheEnabled()) {
            storePhotoInCache(userId || "me", schemas.photos.stores.users, {
              eTag: response.eTag,
              photo: response.photo
            });
          }
          photo = response.photo;
        }
      } catch (_) {
      }
    } else if (!cachedUser) {
      try {
        const response = yield graph.api(fullResource).middlewareOptions(prepScopes(...scopes)).get();
        if (response) {
          if (getIsUsersCacheEnabled()) {
            const cache2 = CacheService.getCache(schemas.users, schemas.users.stores.users);
            cache2.putValue(userId || "me", { user: JSON.stringify(response) });
          }
          user = response;
        }
      } catch (_) {
      }
    }
    if (user) {
      user.personImage = photo;
    }
    return user;
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/graph/types.js
var ViewType;
(function(ViewType2) {
  ViewType2[ViewType2["image"] = 2] = "image";
  ViewType2[ViewType2["oneline"] = 3] = "oneline";
  ViewType2[ViewType2["twolines"] = 4] = "twolines";
  ViewType2[ViewType2["threelines"] = 5] = "threelines";
  ViewType2[ViewType2["fourlines"] = 6] = "fourlines";
})(ViewType || (ViewType = {}));

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person/mgt-person.js
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/utils/SvgHelper.js
init_lit();
var SvgIcon;
(function(SvgIcon2) {
  SvgIcon2[SvgIcon2["ArrowRight"] = 0] = "ArrowRight";
  SvgIcon2[SvgIcon2["ArrowDown"] = 1] = "ArrowDown";
  SvgIcon2[SvgIcon2["TeamSeparator"] = 2] = "TeamSeparator";
  SvgIcon2[SvgIcon2["Search"] = 3] = "Search";
  SvgIcon2[SvgIcon2["SkypeArrow"] = 4] = "SkypeArrow";
  SvgIcon2[SvgIcon2["SmallEmail"] = 5] = "SmallEmail";
  SvgIcon2[SvgIcon2["SmallEmailHovered"] = 6] = "SmallEmailHovered";
  SvgIcon2[SvgIcon2["SmallChat"] = 7] = "SmallChat";
  SvgIcon2[SvgIcon2["SmallChatHovered"] = 8] = "SmallChatHovered";
  SvgIcon2[SvgIcon2["Video"] = 9] = "Video";
  SvgIcon2[SvgIcon2["VideoHovered"] = 10] = "VideoHovered";
  SvgIcon2[SvgIcon2["ExpandDown"] = 11] = "ExpandDown";
  SvgIcon2[SvgIcon2["Overview"] = 12] = "Overview";
  SvgIcon2[SvgIcon2["Send"] = 13] = "Send";
  SvgIcon2[SvgIcon2["Contact"] = 14] = "Contact";
  SvgIcon2[SvgIcon2["Copy"] = 15] = "Copy";
  SvgIcon2[SvgIcon2["Phone"] = 16] = "Phone";
  SvgIcon2[SvgIcon2["CellPhone"] = 17] = "CellPhone";
  SvgIcon2[SvgIcon2["Chat"] = 18] = "Chat";
  SvgIcon2[SvgIcon2["Call"] = 19] = "Call";
  SvgIcon2[SvgIcon2["CallHovered"] = 20] = "CallHovered";
  SvgIcon2[SvgIcon2["Confirmation"] = 21] = "Confirmation";
  SvgIcon2[SvgIcon2["Department"] = 22] = "Department";
  SvgIcon2[SvgIcon2["Email"] = 23] = "Email";
  SvgIcon2[SvgIcon2["OfficeLocation"] = 24] = "OfficeLocation";
  SvgIcon2[SvgIcon2["Person"] = 25] = "Person";
  SvgIcon2[SvgIcon2["Messages"] = 26] = "Messages";
  SvgIcon2[SvgIcon2["Organization"] = 27] = "Organization";
  SvgIcon2[SvgIcon2["ExpandRight"] = 28] = "ExpandRight";
  SvgIcon2[SvgIcon2["Profile"] = 29] = "Profile";
  SvgIcon2[SvgIcon2["Birthday"] = 30] = "Birthday";
  SvgIcon2[SvgIcon2["File"] = 31] = "File";
  SvgIcon2[SvgIcon2["Files"] = 32] = "Files";
  SvgIcon2[SvgIcon2["Back"] = 33] = "Back";
  SvgIcon2[SvgIcon2["Close"] = 34] = "Close";
  SvgIcon2[SvgIcon2["Upload"] = 35] = "Upload";
  SvgIcon2[SvgIcon2["FileCloud"] = 36] = "FileCloud";
  SvgIcon2[SvgIcon2["DragFile"] = 37] = "DragFile";
  SvgIcon2[SvgIcon2["Cancel"] = 38] = "Cancel";
  SvgIcon2[SvgIcon2["Success"] = 39] = "Success";
  SvgIcon2[SvgIcon2["Fail"] = 40] = "Fail";
  SvgIcon2[SvgIcon2["SelectAccount"] = 41] = "SelectAccount";
})(SvgIcon || (SvgIcon = {}));
function getSvg(svgIcon, color) {
  switch (svgIcon) {
    case SvgIcon.ArrowRight:
      return html`
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M8 7L4.46481 10.5359L4.46481 7L4.46481 3.46413L8 7Z" />
        </svg>
      `;
    case SvgIcon.ArrowDown:
      return html`
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M6 9L2.46447 5.46447H6H9.53553L6 9Z" />
        </svg>
      `;
    case SvgIcon.TeamSeparator:
      return html`
        <svg width="6" height="10" viewBox="0 0 6 10" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M5.70711 5L1.49999 9.20711L0.792886 8.50001L4.29289 5L0.792887 1.49999L1.49999 0.792885L5.70711 5Z"
            fill=${color}
          />
        </svg>
      `;
    case SvgIcon.Search:
      return html`
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M7.30887 8.01596C6.53903 8.63179 5.56252 9.00004 4.5 9.00004C2.01472 9.00004 0 6.98531 0 4.50002C0 2.01473 2.01472 0 4.5 0C6.98528 0 9 2.01473 9 4.50002C9 5.56252 8.63177 6.53901 8.01597 7.30885L11.8536 11.1464C12.0488 11.3417 12.0488 11.6583 11.8536 11.8536C11.6583 12.0488 11.3417 12.0488 11.1464 11.8536L7.30887 8.01596ZM8 4.50002C8 2.56701 6.433 1 4.5 1C2.567 1 1 2.56701 1 4.50002C1 6.43302 2.567 8.00003 4.5 8.00003C6.433 8.00003 8 6.43302 8 4.50002Z" fill="#212121"/>
        </svg>`;
    case SvgIcon.SkypeArrow:
      return html`
        <svg viewBox="0 0 12 10" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M3.95184 0.480534C4.23385 0.10452 4.70926 -0.0724722 5.1685 0.0275755C5.62775 0.127623 5.98645 0.486329 6.0865 0.945575C6.18655 1.40482 6.00956 1.88023 5.63354 2.16224L4.07196 3.72623H10.7988C11.4622 3.72623 12 4.26403 12 4.92744C12 5.59086 11.4622 6.12866 10.7988 6.12866H4.07196L5.63114 7.68784C6.0955 8.15225 6.0955 8.90515 5.63114 9.36955C5.51655 9.48381 5.38119 9.57514 5.23234 9.63862C5.09341 9.69857 4.94399 9.73042 4.79269 9.73232C4.63498 9.73233 4.4789 9.70046 4.33382 9.63862C4.18765 9.57669 4.05593 9.48507 3.94703 9.36955L0.343377 5.7659C-0.114459 5.29881 -0.114459 4.55128 0.343377 4.08419L3.95184 0.480534Z"
            fill="#B4009E"
          />
        </svg>
      `;
    case SvgIcon.SmallEmail:
      return html`
        <svg width="17" height="14" viewBox="0 0 17 14" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M13.608 0.833496C14.9887 0.833496 16.108 1.95278 16.108 3.3335V11.3335C16.108 12.7142 14.9887 13.8335 13.608 13.8335H2.60803C1.22732 13.8335 0.108032 12.7142 0.108032 11.3335V3.3335C0.108032 1.95278 1.22732 0.833496 2.60803 0.833496H13.608ZM15.108 4.7945L8.36154 8.76446C8.23115 8.84117 8.07464 8.85395 7.93554 8.80281L7.85452 8.76446L1.10803 4.7965V11.3335C1.10803 12.1619 1.77961 12.8335 2.60803 12.8335H13.608C14.4365 12.8335 15.108 12.1619 15.108 11.3335V4.7945ZM13.608 1.8335H2.60803C1.77961 1.8335 1.10803 2.50507 1.10803 3.3335V3.6355L8.10803 7.75341L15.108 3.6345V3.3335C15.108 2.50507 14.4365 1.8335 13.608 1.8335Z" fill="#023B8F"/>
        </svg>
      `;
    case SvgIcon.SmallEmailHovered:
      return html`
      <svg width="17" height="14" viewBox="0 0 17 14" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M16 3.373V10.5C16 11.8807 14.8807 13 13.5 13H2.5C1.11929 13 -7.62939e-05 11.8807 -7.62939e-05 10.5V3.373L7.74649 7.93097C7.90297 8.02301 8.09704 8.02301 8.25351 7.93097L16 3.373ZM13.5 0C14.7871 0 15.847 0.972604 15.9848 2.22293L8 6.91991L0.0151832 2.22293C0.15304 0.972604 1.21294 0 2.5 0H13.5Z" fill="#023B8F"/>
      </svg>
      `;
    case SvgIcon.SmallChat:
      return html`
        <svg width="17" height="17" viewBox="0 0 17 17" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M8.38599 0.833496C12.8043 0.833496 16.386 4.41522 16.386 8.8335C16.386 13.2518 12.8043 16.8335 8.38599 16.8335C7.11277 16.8335 5.8819 16.5353 4.77267 15.9728L4.65199 15.9085L1.00708 16.8186C0.697255 16.8959 0.41221 16.6704 0.387296 16.3773L0.387128 16.2959L0.400919 16.2122L1.31099 12.5685L1.24768 12.4488C0.792589 11.5521 0.510317 10.5757 0.418733 9.56176L0.393362 9.17984L0.385986 8.8335C0.385986 4.41522 3.96771 0.833496 8.38599 0.833496ZM8.38599 1.8335C4.51999 1.8335 1.38599 4.9675 1.38599 8.8335C1.38599 10.0505 1.69653 11.2213 2.27951 12.2584C2.32645 12.3419 2.34809 12.4365 2.34291 12.5308L2.32873 12.6247L1.57299 15.6455L4.59703 14.8918C4.65892 14.8764 4.72261 14.8731 4.78472 14.8814L4.87629 14.9026L4.963 14.941C5.9996 15.5233 7.16969 15.8335 8.38599 15.8335C12.252 15.8335 15.386 12.6995 15.386 8.8335C15.386 4.9675 12.252 1.8335 8.38599 1.8335ZM8.88599 9.8335C9.16213 9.8335 9.38599 10.0574 9.38599 10.3335C9.38599 10.579 9.20911 10.7831 8.97586 10.8254L8.88599 10.8335H5.88599C5.60984 10.8335 5.38599 10.6096 5.38599 10.3335C5.38599 10.088 5.56286 9.88389 5.79611 9.84155L5.88599 9.8335H8.88599ZM10.886 6.8335C11.1621 6.8335 11.386 7.05735 11.386 7.3335C11.386 7.57896 11.2091 7.7831 10.9759 7.82544L10.886 7.8335L5.88599 7.8335C5.60984 7.8335 5.38599 7.60964 5.38599 7.3335C5.38599 7.08804 5.56286 6.88389 5.79611 6.84155L5.88599 6.8335L10.886 6.8335Z" fill="#023B8F"/>
        </svg>
      `;
    case SvgIcon.SmallChatHovered:
      return html`
      <svg width="17" height="17" viewBox="0 0 17 17" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C6.72679 16 5.49591 15.7018 4.38669 15.1393L4.266 15.075L0.621091 15.9851C0.311269 16.0625 0.0262241 15.8369 0.00130987 15.5438L0.00114131 15.4624L0.0149329 15.3787L0.925 11.735L0.86169 11.6153C0.406602 10.7186 0.124331 9.74223 0.0327466 8.72826L0.00737596 8.34634L0 8C0 3.58172 3.58172 0 8 0ZM8.5 9H5.5L5.41012 9.00806C5.17688 9.05039 5 9.25454 5 9.5C5 9.74546 5.17688 9.94961 5.41012 9.99194L5.5 10H8.5L8.58988 9.99194C8.82312 9.94961 9 9.74546 9 9.5C9 9.25454 8.82312 9.05039 8.58988 9.00806L8.5 9ZM10.5 6H5.5L5.41012 6.00806C5.17688 6.05039 5 6.25454 5 6.5C5 6.74546 5.17688 6.94961 5.41012 6.99194L5.5 7H10.5L10.5899 6.99194C10.8231 6.94961 11 6.74546 11 6.5C11 6.25454 10.8231 6.05039 10.5899 6.00806L10.5 6Z" fill="#023B8F"/>
      </svg>
      `;
    case SvgIcon.Video:
      return html`
        <svg width="17" height="13" viewBox="0 0 17 13" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2.72095 0.833496C1.34024 0.833496 0.220947 1.95278 0.220947 3.3335V10.3335C0.220947 11.7142 1.34024 12.8335 2.72095 12.8335H9.72095C11.1017 12.8335 12.2209 11.7142 12.2209 10.3335V9.33348L14.6209 11.1335C15.2802 11.6279 16.2209 11.1575 16.2209 10.3335V3.33348C16.2209 2.50944 15.2802 2.03905 14.6209 2.53348L12.2209 4.33348V3.3335C12.2209 1.95278 11.1017 0.833496 9.72095 0.833496H2.72095ZM12.2209 5.58348L15.2209 3.33348V10.3335L12.2209 8.08348V5.58348ZM11.2209 3.3335V10.3335C11.2209 11.1619 10.5494 11.8335 9.72095 11.8335H2.72095C1.89252 11.8335 1.22095 11.1619 1.22095 10.3335V3.3335C1.22095 2.50507 1.89252 1.8335 2.72095 1.8335H9.72095C10.5494 1.8335 11.2209 2.50507 11.2209 3.3335Z" fill="#023B8F"/>
        </svg>
      `;
    case SvgIcon.VideoHovered:
      return html`
      <svg width="17" height="13" viewBox="0 0 17 13" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M11 2.5C11 1.11929 9.88071 0 8.5 0H2.5C1.11929 0 0 1.11929 0 2.5V9.5C0 10.8807 1.11929 12 2.5 12H8.5C9.88071 12 11 10.8807 11 9.5V2.5ZM12 3.93082V8.08149L14.7642 10.4319C15.2512 10.8461 16 10.4999 16 9.86055V2.19315C16 1.55685 15.2575 1.20962 14.7692 1.61756L12 3.93082Z" fill="#023B8F"/>
      </svg>
      `;
    case SvgIcon.ExpandDown: {
      return html`
        <svg width="15" height="8" viewBox="0 0 15 8" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M14 1L7.5 7L1 1" stroke="#3078CD" />
        </svg>
      `;
    }
    case SvgIcon.Overview:
      return html`
        <svg width="16" height="13" viewBox="0 0 16 13" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M3.5 10.5C2.67157 10.5 2 9.82843 2 9V4C2 3.17157 2.67157 2.5 3.5 2.5H12.5C13.3284 2.5 14 3.17157 14 4V9C14 9.82843 13.3284 10.5 12.5 10.5H3.5ZM3.5 3.5C3.22386 3.5 3 3.72386 3 4V5.5H13V4C13 3.72386 12.7761 3.5 12.5 3.5H3.5ZM5 6.5H3V9C3 9.27614 3.22386 9.5 3.5 9.5H5V6.5ZM6 9.5H12.5C12.7761 9.5 13 9.27614 13 9V6.5H6V9.5ZM0 3C0 1.61929 1.11929 0.5 2.5 0.5H13.5C14.8807 0.5 16 1.61929 16 3V10C16 11.3807 14.8807 12.5 13.5 12.5H2.5C1.11929 12.5 0 11.3807 0 10V3ZM2.5 1.5C1.67157 1.5 1 2.17157 1 3V10C1 10.8284 1.67157 11.5 2.5 11.5H13.5C14.3284 11.5 15 10.8284 15 10V3C15 2.17157 14.3284 1.5 13.5 1.5H2.5Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Send:
      return html`
        <svg xmlns="http://www.w3.org/2000/svg">
          <path
            d="M4.27144 8.99999L1.72572 2.45387C1.54854 1.99826 1.9928 1.56256 2.43227 1.71743L2.50153 1.74688L16.0015 8.49688C16.3902 8.69122 16.4145 9.22336 16.0744 9.45992L16.0015 9.50311L2.50153 16.2531C2.0643 16.4717 1.58932 16.0697 1.70282 15.6178L1.72572 15.5461L4.27144 8.99999L1.72572 2.45387L4.27144 8.99999ZM3.3028 3.4053L5.25954 8.43705L10.2302 8.43749C10.515 8.43749 10.7503 8.64911 10.7876 8.92367L10.7927 8.99999C10.7927 9.28476 10.5811 9.52011 10.3065 9.55736L10.2302 9.56249L5.25954 9.56205L3.3028 14.5947L14.4922 8.99999L3.3028 3.4053Z"
          />
        </svg>
      `;
    case SvgIcon.Contact:
      return html`
        <svg width="16" height="12" viewBox="0 0 16 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M6 4.5C6 5.32843 5.32843 6 4.5 6C3.67157 6 3 5.32843 3 4.5C3 3.67157 3.67157 3 4.5 3C5.32843 3 6 3.67157 6 4.5ZM2 7.69879C2 7.17479 2.42479 6.75 2.94879 6.75H6.05121C6.57521 6.75 7 7.17479 7 7.69879C7 8.54603 6.42338 9.28454 5.60144 9.49003L5.54243 9.50478C4.85801 9.67589 4.14199 9.67589 3.45757 9.50478L3.39856 9.49003C2.57661 9.28454 2 8.54603 2 7.69879ZM9.5 4C9.22386 4 9 4.22386 9 4.5C9 4.77614 9.22386 5 9.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H9.5ZM9.5 7C9.22386 7 9 7.22386 9 7.5C9 7.77614 9.22386 8 9.5 8H12.5C12.7761 8 13 7.77614 13 7.5C13 7.22386 12.7761 7 12.5 7H9.5ZM0 1.75C0 0.783502 0.783502 0 1.75 0H14.25C15.2165 0 16 0.783502 16 1.75V10.25C16 11.2165 15.2165 12 14.25 12H1.75C0.783501 12 0 11.2165 0 10.25V1.75ZM1.75 1C1.33579 1 1 1.33579 1 1.75V10.25C1 10.6642 1.33579 11 1.75 11H14.25C14.6642 11 15 10.6642 15 10.25V1.75C15 1.33579 14.6642 1 14.25 1H1.75Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Call:
      return html`
        <svg width="13" height="17" viewBox="0 0 13 17" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M3.9292 0.399388L3.2125 0.615419C1.90898 1.00834 0.951582 2.1215 0.758116 3.46915C0.461142 5.53787 1.12537 7.95591 2.72582 10.728C4.32291 13.4942 6.0808 15.2768 8.01603 16.0565C9.28562 16.5681 10.7369 16.2927 11.7308 15.3515L12.2736 14.8374C13.0011 14.1485 13.1065 13.0275 12.5202 12.215L11.1636 10.3349C10.788 9.81423 10.1226 9.59039 9.50865 9.7781L7.45794 10.4051L7.40494 10.4154C7.17877 10.4485 6.65754 9.95942 6.00741 8.83335C5.32726 7.65531 5.1863 6.96648 5.37408 6.7889L6.41743 5.81598C7.19937 5.08681 7.43039 3.94078 6.99201 2.96562L6.33055 1.49424C5.91866 0.578005 4.89102 0.109471 3.9292 0.399388ZM5.41847 1.90427L6.07993 3.37564C6.34277 3.96031 6.20426 4.64744 5.73543 5.08463L4.68953 6.05994C4.02044 6.69268 4.24206 7.77567 5.14138 9.33335C5.98759 10.799 6.75958 11.5233 7.58908 11.3977L7.71341 11.3711L9.80102 10.7344C10.0057 10.6718 10.2275 10.7464 10.3527 10.92L11.7093 12.8001C12.0024 13.2064 11.9497 13.7669 11.586 14.1113L11.0432 14.6254C10.3333 15.2977 9.29663 15.4944 8.38977 15.129C6.6917 14.4448 5.08689 12.8175 3.59185 10.228C2.09375 7.63319 1.48745 5.42604 1.74797 3.61125C1.88616 2.64864 2.57001 1.85352 3.5011 1.57287L4.2178 1.35684C4.69871 1.21188 5.21253 1.44615 5.41847 1.90427Z" fill="#023B8F"/>
        </svg>
      `;
    case SvgIcon.CallHovered:
      return html`
      <svg width="13" height="17" viewBox="0 0 13 17" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3.98706 1.06589C4.89545 0.792081 5.86254 1.19479 6.31418 2.01224L6.38841 2.16075L7.04987 3.63213C7.46246 4.54992 7.28209 5.61908 6.60754 6.3496L6.47529 6.48248L5.43194 7.45541C5.24417 7.63298 5.38512 8.32181 6.06527 9.49986C6.67716 10.5597 7.17487 11.0552 7.41986 11.0823L7.4628 11.082L7.5158 11.0716L9.56651 10.4446C10.1332 10.2713 10.7438 10.4487 11.1298 10.8865L11.2215 11.0014L12.5781 12.8815C13.1299 13.6462 13.0689 14.6842 12.4533 15.378L12.3314 15.5039L11.7886 16.018C10.7948 16.9592 9.34348 17.2346 8.07389 16.7231C6.13867 15.9433 4.38077 14.1607 2.78368 11.3945C1.18323 8.62242 0.519004 6.20438 0.815977 4.13565C0.99977 2.85539 1.87301 1.78674 3.07748 1.3462L3.27036 1.28192L3.98706 1.06589Z" fill="#023B8F"/>
      </svg>
      `;
    case SvgIcon.Confirmation:
      return html`
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M7.03212 13.9072L3.56056 10.0017C3.28538 9.69214 2.81132 9.66425 2.50174 9.93944C2.19215 10.2146 2.16426 10.6887 2.43945 10.9983L6.43945 15.4983C6.72614 15.8208 7.2252 15.8355 7.53034 15.5303L18.0303 5.03033C18.3232 4.73744 18.3232 4.26256 18.0303 3.96967C17.7374 3.67678 17.2626 3.67678 16.9697 3.96967L7.03212 13.9072Z" fill="#009E00"/>
      </svg>
      `;
    case SvgIcon.Copy:
      return html`
        <svg width="13" height="14" viewBox="0 0 13 14" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M12.625 5.50293V14H3.875V11.375H0.375V0H6.24707L8.87207 2.625H9.74707L12.625 5.50293ZM10 5.25H11.1279L10 4.12207V5.25ZM3.875 2.625H7.62793L5.87793 0.875H1.25V10.5H3.875V2.625ZM11.75 6.125H9.125V3.5H4.75V13.125H11.75V6.125Z"
          />
        </svg>
      `;
    case SvgIcon.Phone:
      return html`
        <svg width="15" height="15" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2048 2048" fill="none">
            <path d="M1607 1213q44 0 84 16t72 48l220 220q31 31 47 71t17 85q0 44-16 84t-48 72l-14 14q-54 54-99 96t-94 70-109 44-143 15q-125 0-257-39t-262-108-256-164-237-207-206-238-162-256T38 775 0 523q0-83 14-142t43-108 70-93 96-99l16-16q31-31 71-48t85-17q44 0 84 17t72 48l220 220q31 31 47 71t17 85q0 44-15 78t-37 63-48 51-49 45-37 44-15 49q0 38 27 65l551 551q27 27 65 27 26 0 48-15t45-37 45-48 51-49 62-37 79-15zm-83 707q72 0 120-13t88-39 76-64 85-86q27-27 27-65 0-18-14-42t-38-52-51-55-56-54-51-47-37-35q-27-27-66-27-26 0-48 15t-44 37-45 48-52 49-62 37-79 15q-44 0-84-16t-72-48L570 927q-31-31-47-71t-17-85q0-44 15-78t37-63 48-51 49-46 37-44 15-48q0-39-27-66-13-13-34-36t-47-51-54-56-56-52-51-37-43-15q-38 0-65 27l-85 85q-37 37-64 76t-40 87-14 120q0 112 36 231t101 238 153 234 192 219 219 190 234 150 236 99 226 36z" fill="${color}"></path>
        </svg>
      `;
    case SvgIcon.CellPhone:
      return html`
        <svg width="10" height="16" viewBox="0 0 10 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M4 12C3.72386 12 3.5 12.2239 3.5 12.5C3.5 12.7761 3.72386 13 4 13H6C6.27614 13 6.5 12.7761 6.5 12.5C6.5 12.2239 6.27614 12 6 12H4ZM2 0C0.89543 0 0 0.895431 0 2V14C0 15.1046 0.895431 16 2 16H8C9.10457 16 10 15.1046 10 14V2C10 0.89543 9.10457 0 8 0H2ZM1 2C1 1.44772 1.44772 1 2 1H8C8.55228 1 9 1.44772 9 2V14C9 14.5523 8.55228 15 8 15H2C1.44772 15 1 14.5523 1 14V2Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Chat:
      return html`
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C6.72679 16 5.49591 15.7018 4.38669 15.1393L4.266 15.075L0.621091 15.9851C0.311269 16.0625 0.0262241 15.8369 0.00130987 15.5438L0.00114131 15.4624L0.0149329 15.3787L0.925 11.735L0.86169 11.6153C0.406602 10.7186 0.124331 9.74223 0.0327466 8.72826L0.00737596 8.34634L0 8C0 3.58172 3.58172 0 8 0ZM8 1C4.13401 1 1 4.13401 1 8C1 9.21704 1.31054 10.3878 1.89352 11.4249C1.94046 11.5084 1.9621 11.603 1.95692 11.6973L1.94274 11.7912L1.187 14.812L4.21104 14.0583C4.27294 14.0429 4.33662 14.0396 4.39873 14.0479L4.4903 14.0691L4.57701 14.1075C5.61362 14.6898 6.7837 15 8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1ZM8.5 9C8.77614 9 9 9.22386 9 9.5C9 9.74546 8.82312 9.94961 8.58988 9.99194L8.5 10H5.5C5.22386 10 5 9.77614 5 9.5C5 9.25454 5.17688 9.05039 5.41012 9.00806L5.5 9H8.5ZM10.5 6C10.7761 6 11 6.22386 11 6.5C11 6.74546 10.8231 6.94961 10.5899 6.99194L10.5 7L5.5 7C5.22386 7 5 6.77614 5 6.5C5 6.25454 5.17688 6.05039 5.41012 6.00806L5.5 6L10.5 6Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Department:
      return html`
        <svg width="17" height="14" viewBox="0 0 17 14" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M4 1.5V3H2C0.895431 3 0 3.89543 0 5V12C0 13.1046 0.895432 14 2 14H14.0026C15.1071 14 16.0026 13.1046 16.0026 12V5C16.0026 3.89543 15.1071 3 14.0026 3H12V1.5C12 0.671573 11.3284 0 10.5 0H5.5C4.67157 0 4 0.671573 4 1.5ZM5.5 1H10.5C10.7761 1 11 1.22386 11 1.5V3H5V1.5C5 1.22386 5.22386 1 5.5 1ZM2 4H14.0026C14.5549 4 15.0026 4.44772 15.0026 5V7H12L12 6.50073C12 6.22459 11.7761 6.00073 11.5 6.00073C11.2239 6.00073 11 6.22459 11 6.50074L11 7H5V6.50073C5 6.22459 4.77614 6.00073 4.5 6.00073C4.22386 6.00073 4 6.22459 4 6.50073V7H1V5C1 4.44772 1.44772 4 2 4ZM11 8L11 8.5C11 8.77615 11.2239 9 11.5 9C11.7762 9 12 8.77614 12 8.5L12 8H15.0026V12C15.0026 12.5523 14.5549 13 14.0026 13H2C1.44772 13 1 12.5523 1 12V8H4V8.5C4 8.77614 4.22386 9 4.5 9C4.77614 9 5 8.77614 5 8.5V8H11Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Email:
      return html`
        <svg width="16" height="13" viewBox="0 0 16 13" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M13.5 0C14.8807 0 16 1.11929 16 2.5V10.5C16 11.8807 14.8807 13 13.5 13H2.5C1.11929 13 0 11.8807 0 10.5V2.5C0 1.11929 1.11929 0 2.5 0H13.5ZM15 3.961L8.25351 7.93097C8.12311 8.00767 7.96661 8.02045 7.82751 7.96932L7.74649 7.93097L1 3.963V10.5C1 11.3284 1.67157 12 2.5 12H13.5C14.3284 12 15 11.3284 15 10.5V3.961ZM13.5 1H2.5C1.67157 1 1 1.67157 1 2.5V2.802L8 6.91991L15 2.801V2.5C15 1.67157 14.3284 1 13.5 1Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.OfficeLocation:
      return html`
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M5.84303 4.56789C9.24344 1.16748 14.7566 1.16748 18.157 4.56789C21.5574 7.9683 21.5574 13.4815 18.157 16.8819L16.97 18.0558C16.0952 18.9144 14.96 20.0184 13.5642 21.3679C12.6919 22.2113 11.3081 22.2112 10.436 21.3677L6.9449 17.9718C6.50614 17.541 6.13887 17.1777 5.84303 16.8819C2.44262 13.4815 2.44262 7.9683 5.84303 4.56789ZM17.0963 5.62855C14.2817 2.81392 9.71832 2.81392 6.90369 5.62855C4.08907 8.44317 4.08907 13.0066 6.90369 15.8212L8.39077 17.2887C9.20967 18.0901 10.2391 19.0905 11.4788 20.2895C11.7695 20.5706 12.2308 20.5707 12.5215 20.2896L15.9164 16.9881C16.3854 16.5278 16.7787 16.1388 17.0963 15.8212C19.911 13.0066 19.911 8.44317 17.0963 5.62855ZM12 7.99854C13.6577 7.99854 15.0016 9.34238 15.0016 11.0001C15.0016 12.6578 13.6577 14.0016 12 14.0016C10.3423 14.0016 8.99847 12.6578 8.99847 11.0001C8.99847 9.34238 10.3423 7.99854 12 7.99854ZM12 9.49854C11.1707 9.49854 10.4985 10.1708 10.4985 11.0001C10.4985 11.8294 11.1707 12.5016 12 12.5016C12.8293 12.5016 13.5016 11.8294 13.5016 11.0001C13.5016 10.1708 12.8293 9.49854 12 9.49854Z" fill="#212121" />
        </svg>
      `;
    case SvgIcon.Birthday:
      return html`
        <svg width="14" height="13" viewBox="0 0 14 13" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M5.81357 0.667333C6.07581 0.320242 6.48151 0 7 0C7.51849 0 7.92419 0.320242 8.18643 0.667333C8.45471 1.0224 8.63508 1.47991 8.69561 1.93392C8.75552 2.3832 8.70532 2.89341 8.42852 3.3086C8.134 3.75039 7.63965 4 7 4C6.36035 4 5.866 3.75039 5.57148 3.3086C5.29468 2.89341 5.24448 2.3832 5.30439 1.93392C5.36492 1.47991 5.54529 1.0224 5.81357 0.667333ZM6.40353 2.7539C6.484 2.87461 6.63965 3 7 3C7.36035 3 7.516 2.87461 7.59647 2.7539C7.69468 2.60659 7.74448 2.3668 7.70439 2.06608C7.66492 1.77009 7.54529 1.4776 7.38857 1.27017C7.22581 1.05476 7.08151 1 7 1C6.91849 1 6.77419 1.05476 6.61143 1.27017C6.45471 1.4776 6.33508 1.77009 6.29561 2.06608C6.25552 2.3668 6.30532 2.60659 6.40353 2.7539ZM1 7C1 5.89543 1.89543 5 3 5H11C12.1046 5 13 5.89543 13 7V12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7761 13.7761 13 13.5 13H0.5C0.223858 13 0 12.7761 0 12.5C0 12.2239 0.223858 12 0.5 12H1V7ZM2 12H12V9.01931C11.9109 9.10285 11.8174 9.18842 11.7208 9.27412C11.4006 9.55804 11.0346 9.85319 10.6715 10.0802C10.3274 10.2953 9.90815 10.5 9.5 10.5C8.77182 10.5 8.30806 9.98986 8.00471 9.65617C7.9834 9.63273 7.96289 9.61016 7.94312 9.58869C7.5876 9.20261 7.35769 9 7 9C6.64231 9 6.4124 9.20261 6.05688 9.58869C6.03711 9.61016 6.0166 9.63273 5.99529 9.65617C5.69194 9.98986 5.22818 10.5 4.5 10.5C4.10587 10.5 3.69263 10.2897 3.35907 10.0789C3.00198 9.85313 2.63516 9.55951 2.31117 9.27666C2.20329 9.18247 2.09896 9.08844 2 8.9971V12ZM2 7.59993C2.05039 7.65198 2.11363 7.71652 2.1873 7.7902C2.38843 7.99132 2.6649 8.25801 2.96883 8.52334C3.27484 8.79049 3.59802 9.04687 3.89343 9.23362C4.21237 9.43525 4.41413 9.5 4.5 9.5C4.75817 9.5 4.93171 9.33433 5.32125 8.91131L5.32447 8.90781C5.65956 8.5439 6.16039 8 7 8C7.83961 8 8.34044 8.5439 8.67553 8.90781L8.67875 8.91131C9.06828 9.33433 9.24183 9.5 9.5 9.5C9.6106 9.5 9.82569 9.42967 10.1414 9.23229C10.4381 9.04681 10.7573 8.79196 11.0573 8.52588C11.3554 8.26163 11.6238 7.99594 11.8184 7.7955C11.89 7.72165 11.9513 7.65703 12 7.60506V7C12 6.44772 11.5523 6 11 6H3C2.44772 6 2 6.44772 2 7V7.59993Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Person:
      return html`
        <svg width="14" height="16" viewBox="0 0 14 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M7 0C4.79086 0 3 1.79086 3 4C3 6.20914 4.79086 8 7 8C9.20914 8 11 6.20914 11 4C11 1.79086 9.20914 0 7 0ZM4 4C4 2.34315 5.34315 1 7 1C8.65685 1 10 2.34315 10 4C10 5.65685 8.65685 7 7 7C5.34315 7 4 5.65685 4 4ZM2.00873 9C0.903151 9 0 9.88687 0 11C0 12.6912 0.83281 13.9663 2.13499 14.7966C3.41697 15.614 5.14526 16 7 16C8.85474 16 10.583 15.614 11.865 14.7966C13.1672 13.9663 14 12.6912 14 11C14 9.89557 13.1045 9.00001 12 9.00001L2.00873 9ZM1 11C1 10.4467 1.44786 10 2.00873 10L12 10C12.5522 10 13 10.4478 13 11C13 12.3088 12.3777 13.2837 11.3274 13.9534C10.2568 14.636 8.73511 15 7 15C5.26489 15 3.74318 14.636 2.67262 13.9534C1.62226 13.2837 1 12.3088 1 11Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Messages:
      return html`
        <svg width="16" height="13" viewBox="0 0 16 13" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M13.5 0C14.8807 0 16 1.11929 16 2.5V10.5C16 11.8807 14.8807 13 13.5 13H2.5C1.11929 13 0 11.8807 0 10.5V2.5C0 1.11929 1.11929 0 2.5 0H13.5ZM15 3.961L8.25351 7.93097C8.12311 8.00767 7.96661 8.02045 7.82751 7.96932L7.74649 7.93097L1 3.963V10.5C1 11.3284 1.67157 12 2.5 12H13.5C14.3284 12 15 11.3284 15 10.5V3.961ZM13.5 1H2.5C1.67157 1 1 1.67157 1 2.5V2.802L8 6.91991L15 2.801V2.5C15 1.67157 14.3284 1 13.5 1Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Organization:
      return html`
        <svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M7.99992 0C6.34271 0 4.99927 1.34344 4.99927 3.00066C4.99927 4.48754 6.08073 5.72183 7.49999 5.95985V7.5H4.5C3.67157 7.5 3 8.17157 3 9V10.0416C1.5811 10.2799 0.5 11.514 0.5 13.0007C0.5 14.6579 1.84344 16.0013 3.50066 16.0013C5.15787 16.0013 6.50131 14.6579 6.50131 13.0007C6.50131 11.5136 5.41954 10.2791 4 10.0414V9C4 8.72386 4.22386 8.5 4.5 8.5H11.5C11.7761 8.5 12 8.72386 12 9V10.0416C10.5811 10.2799 9.5 11.514 9.5 13.0007C9.5 14.6579 10.8434 16.0013 12.5007 16.0013C14.1579 16.0013 15.5013 14.6579 15.5013 13.0007C15.5013 11.5136 14.4195 10.2791 13 10.0414V9C13 8.17157 12.3284 7.5 11.5 7.5H8.49999V5.95983C9.91918 5.72176 11.0006 4.48749 11.0006 3.00066C11.0006 1.34344 9.65714 0 7.99992 0ZM5.99927 3.00066C5.99927 1.89572 6.89499 1 7.99992 1C9.10485 1 10.0006 1.89572 10.0006 3.00066C10.0006 4.10559 9.10485 5.00131 7.99992 5.00131C6.89499 5.00131 5.99927 4.10559 5.99927 3.00066ZM1.5 13.0007C1.5 11.8957 2.39572 11 3.50066 11C4.60559 11 5.50131 11.8957 5.50131 13.0007C5.50131 14.1056 4.60559 15.0013 3.50066 15.0013C2.39572 15.0013 1.5 14.1056 1.5 13.0007ZM12.5007 11C13.6056 11 14.5013 11.8957 14.5013 13.0007C14.5013 14.1056 13.6056 15.0013 12.5007 15.0013C11.3957 15.0013 10.5 14.1056 10.5 13.0007C10.5 11.8957 11.3957 11 12.5007 11Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.ExpandRight:
      return html`
        <svg width="8" height="13" viewBox="0 0 8 13" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M1 12L6.5 6.5L1 1" stroke="#B8B8B8" stroke-width="2" />
        </svg>
      `;
    case SvgIcon.Profile:
      return html`
        <svg width="14" height="16" viewBox="0 0 14 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M7 0C4.79086 0 3 1.79086 3 4C3 6.20914 4.79086 8 7 8C9.20914 8 11 6.20914 11 4C11 1.79086 9.20914 0 7 0ZM4 4C4 2.34315 5.34315 1 7 1C8.65685 1 10 2.34315 10 4C10 5.65685 8.65685 7 7 7C5.34315 7 4 5.65685 4 4ZM2.00873 9C0.903151 9 0 9.88687 0 11C0 12.6912 0.83281 13.9663 2.13499 14.7966C3.41697 15.614 5.14526 16 7 16C8.85474 16 10.583 15.614 11.865 14.7966C13.1672 13.9663 14 12.6912 14 11C14 9.89557 13.1045 9.00001 12 9.00001L2.00873 9ZM1 11C1 10.4467 1.44786 10 2.00873 10L12 10C12.5522 10 13 10.4478 13 11C13 12.3088 12.3777 13.2837 11.3274 13.9534C10.2568 14.636 8.73511 15 7 15C5.26489 15 3.74318 14.636 2.67262 13.9534C1.62226 13.2837 1 12.3088 1 11Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.File:
      return html`
        <svg width="28" height="28" viewBox="0 0 20 28" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            opacity="0.64"
            d="M19.613 6.993L13.018 0.421C12.7473 0.15221 12.3815 0.000947397 12 0H1.4C0.628 0 0 0.615 0 1.372V24.642C0 25.391 0.622 26 1.386 26H18.6C19.372 26 20 25.385 20 24.628V7.923C20 7.577 19.86 7.237 19.613 6.993Z"
            fill="#605E5C"
          />
          <path
            d="M19 24.628C19 24.83 18.816 25 18.6 25H1.386C1.173 25 1 24.84 1 24.642V1.372C1 1.17 1.184 1 1.4 1H12V6.6C12 7.372 12.628 8 13.4 8H19V24.628Z"
            fill="white"
          />
          <path d="M18.204 6.99994L13 1.81494V6.59994C13 6.81994 13.18 6.99994 13.4 6.99994H18.204Z" fill="white" />
        </svg>
      `;
    case SvgIcon.Files:
      return html`
        <svg width="17" height="15" viewBox="0 0 17 15" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M14.9956 4.07309V4C14.9956 2.61929 13.8763 1.5 12.4956 1.5H7.66418L6.06391 0.299946C5.80428 0.105247 5.48851 0 5.16399 0H2.5C1.11916 0 -0.000181445 1.11949 2.20615e-08 2.50033L0.0011832 11.4978C0.00135142 12.7772 0.962583 13.8321 2.2023 13.9798C2.2867 13.9945 2.37375 14.0021 2.46289 14.0021H13.1798C13.8981 14.0021 14.5156 13.4929 14.6524 12.7877L16.0097 5.78769C16.1587 5.01967 15.696 4.29703 14.9956 4.07309ZM2.5 1H5.16399C5.27216 1 5.37742 1.03508 5.46396 1.09998L7.19756 2.40002C7.2841 2.46492 7.38936 2.5 7.49753 2.5H12.4956C13.324 2.5 13.9956 3.17157 13.9956 4V4.00214H3.824C3.10596 4.00214 2.48863 4.511 2.35158 5.21583L1.05351 11.8916C1.01941 11.7661 1.0012 11.634 1.00118 11.4976L1 2.5002C0.999891 1.67169 1.6715 1 2.5 1ZM3.33319 5.4067C3.37888 5.17176 3.58465 5.00214 3.824 5.00214H14.5372C14.8515 5.00214 15.0879 5.28874 15.028 5.59732L13.6706 12.5973C13.6251 12.8324 13.4192 13.0021 13.1798 13.0021H2.46289C2.14845 13.0021 1.91206 12.7154 1.97208 12.4067L3.33319 5.4067Z" fill="#717171"/>
        </svg>
      `;
    case SvgIcon.Back:
      return html`
        <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M16 8.5H1.95312L8.10156 14.6484L7.39844 15.3516L0.046875 8L7.39844 0.648438L8.10156 1.35156L1.95312 7.5H16V8.5Z"
          />
        </svg>
      `;
    case SvgIcon.Close:
      return html`
        <svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M5.73838 5.032L9.70337 1.067L8.99638 0.360001L5.03137 4.325L1.06637 0.360001L0.359375 1.067L4.32438 5.032L0.359375 8.997L1.06637 9.704L5.03137 5.739L8.99638 9.704L9.70337 8.997L5.73838 5.032Z" fill="black"/>
        </svg>
     `;
    case SvgIcon.Upload:
      return html`
        <svg class="upload-icon" width="21" height="12" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M4.5 2C4.08579 2 3.75 2.33579 3.75 2.75C3.75 3.16421 4.08579 3.5 4.5 3.5H15C15.4142 3.5 15.75 3.16421 15.75 2.75C15.75 2.33579 15.4142 2 15 2H4.5ZM10.4963 17.3493C10.4466 17.7154 10.1328 17.9976 9.75311 17.9976C9.3389 17.9976 9.00311 17.6618 9.00311 17.2476L9.00249 7.05856L6.02995 10.026L5.94578 10.0986C5.65202 10.3162 5.23537 10.2917 4.96929 10.0253C4.67661 9.73215 4.67695 9.25728 4.97005 8.96459L9.25962 4.67989C9.33377 4.61512 9.42089 4.56485 9.5169 4.53385L9.59777 4.51072C9.64749 4.50019 9.69837 4.4947 9.74849 4.4947L9.80855 4.49661L9.87781 4.50451L9.99828 4.53462L10.0895 4.57254L10.1259 4.59371L10.2169 4.6523L10.2875 4.71481L14.5303 8.96546L14.6029 9.04964C14.8205 9.34345 14.7959 9.7601 14.5294 10.0261L14.4452 10.0987C14.1514 10.3162 13.7347 10.2917 13.4687 10.0251L10.5025 7.05456L10.5031 17.2476L10.4963 17.3493Z" fill="#ffffff"/>
        </svg>
      `;
    case SvgIcon.FileCloud:
      return html`
        <svg width="16" height="16"  xmlns="http://www.w3.org/2000/svg">
          <path
            d="m8,0c2.8166,0 4.4145,1.9233 4.6469,4.246l0.071,0c1.8127,0 3.2821,1.5119 3.2821,3.377c0,0.0953 -0.0038,0.1897 -0.0114,0.283c-0.322,-0.4017 -0.6967,-0.7591 -1.1138,-1.062c-0.3104,-0.9329 -1.1627,-1.598 -2.1568,-1.598l-0.0711,0c-0.5137,0 -0.9439,-0.3893 -0.9951,-0.9005c-0.2021,-2.0206 -1.5433,-3.3455 -3.6518,-3.3455c-2.1139,0 -3.4489,1.3159 -3.6518,3.3455c-0.0511,0.5112 -0.4813,0.9005 -0.9951,0.9005l-0.071,0c-1.2539,0 -2.2821,1.0579 -2.2821,2.377c0,1.3191 1.0282,2.377 2.2821,2.377l2.6655,0c-0.087,0.323 -0.1466,0.6572 -0.1762,1l-2.4893,0c-1.8127,0 -3.2821,-1.5119 -3.2821,-3.377c0,-1.8029 1.3731,-3.2758 3.102,-3.372l0.2511,-0.005c0.2338,-2.338 1.8303,-4.246 4.6469,-4.246zm3.5,16c2.4853,0 4.5,-2.0147 4.5,-4.5c0,-2.4853 -2.0147,-4.5 -4.5,-4.5c-2.4853,0 -4.5,2.0147 -4.5,4.5c0,2.4853 2.0147,4.5 4.5,4.5zm0,-7c0.2761,0 0.5,0.2239 0.5,0.5l0,1.5l1.5,0c0.2761,0 0.5,0.2239 0.5,0.5c0,0.2761 -0.2239,0.5 -0.5,0.5l-1.5,0l0,1.5c0,0.2761 -0.2239,0.5 -0.5,0.5c-0.2761,0 -0.5,-0.2239 -0.5,-0.5l0,-1.5l-1.5,0c-0.2761,0 -0.5,-0.2239 -0.5,-0.5c0,-0.2761 0.2239,-0.5 0.5,-0.5l1.5,0l0,-1.5c0,-0.2761 0.2239,-0.5 0.5,-0.5z" fill="#0078D4"
          />
        </svg>
      `;
    case SvgIcon.DragFile:
      return html`
        <svg width="13" height="16" xmlns="http://www.w3.org/2000/svg">
          <path
            d="m0,1.00189c0,-0.8451 0.983,-1.3091 1.636,-0.772l11.006,9.0622c0.724,0.5964 0.302,1.772 -0.636,1.772l-5.592,0c-0.435,0 -0.849,0.1892 -1.134,0.5185l-3.524,4.0725c-0.606,0.7003 -1.756,0.2717 -1.756,-0.6544l0,-13.9988zm12.006,9.0622l-11.006,-9.0622l0,13.9988l3.524,-4.0724c0.475,-0.5488 1.164,-0.8642 1.89,-0.8642l5.592,0z"
          />
        </svg>
      `;
    case SvgIcon.Cancel:
      return html`
        <svg class="cancel-icon" width="10" height="10" xmlns="http://www.w3.org/2000/svg">
          <path
          d="m5.52795,4.92946l4.37418,4.36141l-0.57055,0.56806l-4.38052,-4.35509l-4.38052,4.35509l-0.57055,-0.56806l4.37418,-4.36141l-4.37418,-4.36141l0.57055,-0.56806l4.38052,4.35509l4.38052,-4.35509l0.57055,0.56806l-4.37418,4.36141z"
          />
        </svg>
      `;
    case SvgIcon.Success:
      return html`
        <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
          <path fill="#009E00" d="m6.322,12c3.492,0 6.323,-2.6863 6.323,-6c0,-3.3137 -2.831,-6 -6.323,-6c-3.491,0 -6.322,2.6863 -6.322,6c0,3.3137 2.831,6 6.322,6z"/>
          <path fill="white" d="m9.629,3.7509c-0.131,-0.125 -0.31,-0.1952 -0.496,-0.1952c-0.187,0 -0.365,0.0702 -0.497,0.1952l-3.267,3.1l-1.393,-1.3222c-0.177,-0.1695 -0.436,-0.2361 -0.68,-0.1746c-0.243,0.0615 -0.433,0.2418 -0.497,0.4725c-0.065,0.2307 0.005,0.4767 0.184,0.6449l1.807,1.7154c0.019,0.0331 0.041,0.0646 0.066,0.094c0.289,0.2562 0.738,0.2562 1.027,0c0.024,-0.0294 0.047,-0.0609 0.065,-0.0941l3.681,-3.4931c0.275,-0.2603 0.275,-0.6824 0,-0.9428z"/>
        </svg>
      `;
    case SvgIcon.Fail:
      return html`
        <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">
          <path fill="#EF355D" d="m6,12c3.314,0 6,-2.6863 6,-6c0,-3.3137 -2.686,-6 -6,-6c-3.314,0 -6,2.6863 -6,6c0,3.3137 2.686,6 6,6z"/>
          <path fill="white" d="m6.943,6.0004l1.544,-1.5444c0.169,-0.1683 0.236,-0.4142 0.174,-0.6448c-0.061,-0.2306 -0.241,-0.4107 -0.472,-0.4722c-0.231,-0.0616 -0.477,0.0049 -0.645,0.1742l-1.544,1.5443l-1.545,-1.5443c-0.26,-0.259 -0.681,-0.2583 -0.941,0.0014c-0.26,0.2598 -0.26,0.6808 -0.001,0.9414l1.544,1.5444l-1.544,1.5444c-0.259,0.2606 -0.259,0.6815 0.001,0.9413c0.26,0.2598 0.681,0.2604 0.941,0.0015l1.545,-1.5444l1.544,1.5444c0.261,0.2589 0.682,0.2583 0.942,-0.0015c0.259,-0.2598 0.26,-0.6807 0.001,-0.9413l-1.544,-1.5444z" />
        </svg>
      `;
    case SvgIcon.SelectAccount:
      return html`
    <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 17 17" fill="none">
      <path fill=${color} d="M6.22176 13.9567C3.55468 13.653 2 11.8026 2 10V9.5C2 8.67157 2.67157 8 3.5 8H5.59971C5.43777 8.31679 5.30564 8.65136 5.20703 9H3.5C3.22386 9 3 9.22386 3 9.5V10C3 11.1281 3.88187 12.333 5.50235 12.7996C5.69426 13.216 5.93668 13.6043 6.22176 13.9567ZM9.62596 5.06907C9.70657 4.81036 9.75 4.53525 9.75 4.25C9.75 2.73122 8.51878 1.5 7 1.5C5.48122 1.5 4.25 2.73122 4.25 4.25C4.25 5.53662 5.13357 6.61687 6.32704 6.91706C6.64202 6.55055 7.00446 6.226 7.40482 5.95294C7.27488 5.98371 7.13934 6 7 6C6.0335 6 5.25 5.2165 5.25 4.25C5.25 3.2835 6.0335 2.5 7 2.5C7.9665 2.5 8.75 3.2835 8.75 4.25C8.75 4.73141 8.55561 5.16743 8.24104 5.48382C8.67558 5.28783 9.14016 5.14664 9.62596 5.06907ZM10.5 15C12.9853 15 15 12.9853 15 10.5C15 8.01472 12.9853 6 10.5 6C8.01472 6 6 8.01472 6 10.5C6 12.9853 8.01472 15 10.5 15ZM10.5 8C10.7761 8 11 8.22386 11 8.5V10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H11V12.5C11 12.7761 10.7761 13 10.5 13C10.2239 13 10 12.7761 10 12.5V11H8.5C8.22386 11 8 10.7761 8 10.5C8 10.2239 8.22386 10 8.5 10H10V8.5C10 8.22386 10.2239 8 10.5 8Z"/>
    </svg>
  `;
  }
}

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-flyout/mgt-flyout.js
init_lit();
init_decorators();

// node_modules/@microsoft/mgt-components/dist/es6/utils/WindowSegmentHelpers.js
function isWindowSegmentAware() {
  return window.getWindowSegments !== void 0;
}
function getSegmentAwareWindow() {
  return isWindowSegmentAware() ? window : null;
}

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-flyout/mgt-flyout-css.js
init_lit();
var styles2 = [
  css`
.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.root .scout-top{position:fixed;top:0;left:0}.root .scout-bottom{position:fixed;bottom:0;right:0}.root .flyout{display:none;position:fixed;z-index:9999999;opacity:0;box-shadow:var(--box-shadow,0 3.2px 7.2px 0 rgba(0,0,0,.132));border-radius:8px}.root .flyout.small{overflow-y:auto;overflow-x:hidden}.root.visible .flyout{display:inline-block;animation-name:fadeIn;animation-duration:.3s;animation-timing-function:cubic-bezier(.1,.9,.2,1);animation-fill-mode:both;transition:top .3s ease,bottom .3s ease,left .3s ease}.root.visible .flyout.small{overflow-y:auto;overflow-x:hidden}@keyframes fadeIn{from{opacity:0;margin-top:-10px;margin-bottom:-10px}to{opacity:1;margin-top:0;margin-bottom:0}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-flyout/mgt-flyout.js
init_es6();
var __decorate2 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtFlyout = class MgtFlyout2 extends MgtBaseComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles2;
  }
  /**
   * Gets or sets whether the flyout is visible
   *
   * @type {string}
   * @memberof MgtFlyout
   */
  get isOpen() {
    return this._isOpen;
  }
  set isOpen(value) {
    const oldValue = this._isOpen;
    if (oldValue === value) {
      return;
    }
    this._isOpen = value;
    window.requestAnimationFrame(() => {
      this.setupWindowEvents(this.isOpen);
      const flyout = this._flyout;
      if (!this.isOpen && flyout) {
        flyout.style.width = null;
        flyout.style.setProperty("--mgt-flyout-set-width", null);
        flyout.style.setProperty("--mgt-flyout-set-height", null);
        flyout.style.maxHeight = null;
        flyout.style.top = null;
        flyout.style.left = null;
        flyout.style.bottom = null;
      }
    });
    this.requestUpdate("isOpen", oldValue);
    this.dispatchEvent(new Event(value ? "opened" : "closed"));
  }
  get _flyout() {
    return this.renderRoot.querySelector(".flyout");
  }
  get _anchor() {
    return this.renderRoot.querySelector(".anchor");
  }
  get _topScout() {
    return this.renderRoot.querySelector(".scout-top");
  }
  get _bottomScout() {
    return this.renderRoot.querySelector(".scout-bottom");
  }
  constructor() {
    super();
    this._edgePadding = 24;
    this._renderedOnce = false;
    this._isOpen = false;
    this._smallView = false;
    this.avoidHidingAnchor = true;
    this.handleWindowEvent = this.handleWindowEvent.bind(this);
    this.handleResize = this.handleResize.bind(this);
    this.handleKeyUp = this.handleKeyUp.bind(this);
    this.addEventListener("expanded", () => {
      window.requestAnimationFrame(() => {
        this.updateFlyout();
      });
    });
  }
  /**
   * Show the flyout.
   */
  open() {
    this.isOpen = true;
  }
  /**
   * Close the flyout.
   */
  close() {
    this.isOpen = false;
  }
  /**
   * Invoked each time the custom element is disconnected from the document's DOM
   *
   * @memberof MgtFlyout
   */
  disconnectedCallback() {
    this.setupWindowEvents(false);
    super.disconnectedCallback();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param changedProperties Map of changed properties with old values
   */
  updated(changedProps) {
    super.updated(changedProps);
    window.requestAnimationFrame(() => {
      this.updateFlyout();
    });
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    const flyoutClasses = {
      dir: this.direction,
      root: true,
      visible: this.isOpen
    };
    const anchorTemplate2 = this.renderAnchor();
    let flyoutTemplate = null;
    this._windowHeight = window.innerHeight && document.documentElement.clientHeight ? Math.min(window.innerHeight, document.documentElement.clientHeight) : window.innerHeight || document.documentElement.clientHeight;
    if (this._windowHeight < 250) {
      this._smallView = true;
    }
    if (this.isOpen || this._renderedOnce) {
      this._renderedOnce = true;
      flyoutTemplate = html`
        <div class=${this._smallView ? "flyout small" : "flyout"} @wheel=${this.handleFlyoutWheel}>
          ${this.renderFlyout()}
        </div>
      `;
    }
    return html`
      <div class=${classMap(flyoutClasses)}>
        <div class="anchor">
          ${anchorTemplate2}
        </div>
        <div class="scout-top"></div>
        <div class="scout-bottom"></div>
        ${flyoutTemplate}
      </div>
    `;
  }
  /**
   * Renders the anchor content.
   *
   * @protected
   * @returns
   * @memberof MgtFlyout
   */
  renderAnchor() {
    return html`
      <slot></slot>
    `;
  }
  /**
   * Renders the flyout.
   */
  renderFlyout() {
    return html`
      <slot name="flyout"></slot>
    `;
  }
  updateFlyout() {
    if (!this.isOpen) {
      return;
    }
    const anchor = this._anchor;
    const flyout = this._flyout;
    if (flyout && anchor) {
      const windowWidth = window.innerWidth && document.documentElement.clientWidth ? Math.min(window.innerWidth, document.documentElement.clientWidth) : window.innerWidth || document.documentElement.clientWidth;
      this._windowHeight = window.innerHeight && document.documentElement.clientHeight ? Math.min(window.innerHeight, document.documentElement.clientHeight) : window.innerHeight || document.documentElement.clientHeight;
      let left = 0;
      let bottom;
      let top = 0;
      let height;
      let width;
      const flyoutRect = flyout.getBoundingClientRect();
      const anchorRect = anchor.getBoundingClientRect();
      const topScoutRect = this._topScout.getBoundingClientRect();
      const bottomScoutRect = this._bottomScout.getBoundingClientRect();
      const windowRect = {
        height: this._windowHeight,
        left: 0,
        top: 0,
        width: windowWidth
      };
      if (isWindowSegmentAware()) {
        const segmentAwareWindow = getSegmentAwareWindow();
        const screenSegments = segmentAwareWindow.getWindowSegments();
        let anchorSegment;
        const anchorCenterX = anchorRect.left + anchorRect.width / 2;
        const anchorCenterY = anchorRect.top + anchorRect.height / 2;
        for (const segment of screenSegments) {
          if (anchorCenterX >= segment.left && anchorCenterY >= segment.top) {
            anchorSegment = segment;
            break;
          }
        }
        if (anchorSegment) {
          windowRect.left = anchorSegment.left;
          windowRect.top = anchorSegment.top;
          windowRect.width = anchorSegment.width;
          windowRect.height = anchorSegment.height;
        }
      }
      if (flyoutRect.width + 2 * this._edgePadding > windowRect.width) {
        if (flyoutRect.width > windowRect.width) {
          width = windowRect.width;
          left = 0;
        } else {
          left = (windowRect.width - flyoutRect.width) / 2;
        }
      } else if (anchorRect.left + flyoutRect.width + this._edgePadding > windowRect.width) {
        left = anchorRect.left - (anchorRect.left + flyoutRect.width + this._edgePadding - windowRect.width);
      } else if (anchorRect.left < this._edgePadding) {
        left = this._edgePadding;
      } else {
        left = anchorRect.left;
      }
      const anchorRectBottomToWindowBottom = windowRect.height - (anchorRect.top + anchorRect.height);
      const anchorRectTopToWindowTop = anchorRect.top;
      if (this.avoidHidingAnchor) {
        if (anchorRectBottomToWindowBottom <= flyoutRect.height) {
          if (anchorRectTopToWindowTop < flyoutRect.height) {
            if (anchorRectTopToWindowTop > anchorRectBottomToWindowBottom) {
              bottom = windowRect.height - anchorRect.top;
              height = anchorRectTopToWindowTop;
            } else {
              top = anchorRect.bottom;
              height = anchorRectBottomToWindowBottom;
            }
          } else {
            bottom = windowRect.height - anchorRect.top;
            height = anchorRectTopToWindowTop;
          }
        } else {
          top = anchorRect.bottom;
          height = anchorRectBottomToWindowBottom;
        }
      } else {
        if (flyoutRect.height + 2 * this._edgePadding > windowRect.height) {
          if (flyoutRect.height >= windowRect.height) {
            height = windowRect.height;
            top = 0;
          } else {
            top = (windowRect.height - flyoutRect.height) / 2;
          }
        } else {
          if (anchorRect.top + anchorRect.height + flyoutRect.height + this._edgePadding > windowRect.height) {
            top = windowRect.height - flyoutRect.height - this._edgePadding;
          } else {
            top = Math.max(anchorRect.top + anchorRect.height, this._edgePadding);
          }
        }
      }
      if (topScoutRect.top !== 0 || topScoutRect.left !== 0) {
        left -= topScoutRect.left;
        if (typeof bottom !== "undefined") {
          bottom += bottomScoutRect.top - this._windowHeight;
        } else {
          top -= topScoutRect.top;
        }
      }
      if (this.direction === "rtl") {
        if (left > 100 && this.offsetLeft > 100) {
          flyout.style.left = `${windowRect.width - left + flyoutRect.left - flyoutRect.width - 30}px`;
        }
      } else {
        flyout.style.left = `${left + windowRect.left}px`;
      }
      if (typeof bottom !== "undefined") {
        flyout.style.top = "unset";
        flyout.style.bottom = `${bottom}px`;
      } else {
        flyout.style.bottom = "unset";
        flyout.style.top = `${top + windowRect.top}px`;
      }
      if (width) {
        flyout.style.width = `${width}px`;
        flyout.style.setProperty("--mgt-flyout-set-width", `${width}px`);
        window.requestAnimationFrame(() => this.updateFlyout());
      }
      if (height) {
        flyout.style.maxHeight = `${height}px`;
        flyout.style.setProperty("--mgt-flyout-set-height", `${height}px`);
      } else {
        flyout.style.maxHeight = null;
        flyout.style.setProperty("--mgt-flyout-set-height", "unset");
      }
    }
  }
  setupWindowEvents(isOpen) {
    if (isOpen && this.isLightDismiss) {
      window.addEventListener("wheel", this.handleWindowEvent);
      window.addEventListener("pointerdown", this.handleWindowEvent);
      window.addEventListener("resize", this.handleResize);
      window.addEventListener("keyup", this.handleKeyUp);
    } else {
      window.removeEventListener("wheel", this.handleWindowEvent);
      window.removeEventListener("pointerdown", this.handleWindowEvent);
      window.removeEventListener("resize", this.handleResize);
      window.removeEventListener("keyup", this.handleKeyUp);
    }
  }
  handleWindowEvent(e) {
    const flyout = this._flyout;
    if (flyout) {
      if (!e.composedPath) {
        let currentElem = e.target;
        while (currentElem) {
          currentElem = currentElem.parentElement;
          if (currentElem === flyout || e.type === "pointerdown" && currentElem === this) {
            return;
          }
        }
      } else {
        const path = e.composedPath();
        if (path.includes(flyout) || e.type === "pointerdown" && path.includes(this)) {
          return;
        }
      }
    }
    this.close();
  }
  handleResize(e) {
    this.close();
  }
  handleKeyUp(e) {
    if (e.key === "Escape") {
      this.close();
    }
  }
  handleFlyoutWheel(e) {
    e.preventDefault();
  }
};
__decorate2([
  property({
    attribute: "light-dismiss",
    type: Boolean
  }),
  __metadata("design:type", Boolean)
], MgtFlyout.prototype, "isLightDismiss", void 0);
__decorate2([
  property({
    attribute: null,
    type: Boolean
  }),
  __metadata("design:type", Boolean)
], MgtFlyout.prototype, "avoidHidingAnchor", void 0);
__decorate2([
  property({
    attribute: "isOpen",
    type: Boolean
  }),
  __metadata("design:type", Boolean),
  __metadata("design:paramtypes", [Boolean])
], MgtFlyout.prototype, "isOpen", null);
MgtFlyout = __decorate2([
  customElement("flyout"),
  __metadata("design:paramtypes", [])
], MgtFlyout);

// node_modules/@microsoft/mgt-components/dist/es6/components/PersonCardInteraction.js
var PersonCardInteraction;
(function(PersonCardInteraction2) {
  PersonCardInteraction2[PersonCardInteraction2["none"] = 0] = "none";
  PersonCardInteraction2[PersonCardInteraction2["hover"] = 1] = "hover";
  PersonCardInteraction2[PersonCardInteraction2["click"] = 2] = "click";
})(PersonCardInteraction || (PersonCardInteraction = {}));

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person/mgt-person-css.js
init_lit();
var styles3 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--presence-background-color:#ffffff;--presence-icon-color:#ffffff;--line1-color:#000000;--line2-color:var(--neutral-foreground-hint, #717171);--line3-color:var(--neutral-foreground-hint, #717171);--line4-color:var(--neutral-foreground-hint, #717171);--initials-color:black;--initials-background-color:white}.mgt-dark{--presence-background-color:#000000;--presence-icon-color:#000000;--line1-color:#ffffff;--line2-color:#c8c6c4;--line3-color:#c8c6c4;--line4-color:#c8c6c4;--initials-color:white;--initials-background-color:black}.flyout{--mgt-flyout-border-radius:2px}:host([hidden]){display:none}:host{display:block;font-family:var(--font-family,var(--default-font-family))}:host :focus-visible{outline-offset:var(--focus-offset,11px)}:host .root{display:block}:host svg,mgt-person svg{width:var(--avatar-size,var(--avatar-size,40px));height:var(--avatar-size,var(--avatar-size,40px))}:host .person-root,mgt-person .person-root{position:relative;display:flex;align-items:center;color:var(--color,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)));flex-direction:var(--person-flex-direction,row)}:host .person-root.clickable,mgt-person .person-root.clickable{cursor:pointer}:host .person-root.vertical,mgt-person .person-root.vertical{text-align:center;display:block}:host .person-root .user-avatar,mgt-person .person-root .user-avatar{position:relative;width:var(--avatar-size,var(--avatar-size,40px));height:var(--avatar-size,var(--avatar-size,40px));display:flex;justify-content:center;align-items:center;flex-shrink:0;cursor:var(--avatar-cursor,inherit)}:host .person-root .user-avatar .user-presence,mgt-person .person-root .user-avatar .user-presence{position:absolute;left:calc(var(--avatar-size,var(--avatar-size,40px)) * .72 - 2px);top:calc(var(--avatar-size,var(--avatar-size,40px)) * .72 - 2px);width:calc(var(--avatar-size,var(--avatar-size,40px)) * .28);height:calc(var(--avatar-size,var(--avatar-size,40px)) * .28);border:1px solid var(--presence-background-color,#fff);border-radius:50%}:host .person-root .user-avatar .user-presence .presence-oof-offline-wrapper,mgt-person .person-root .user-avatar .user-presence .presence-oof-offline-wrapper{background-color:var(--presence-background-color,#fff);border-color:#b4009e}:host .person-root .user-avatar .user-presence .presence-oof-offline-wrapper .presence-oof-offline svg,mgt-person .person-root .user-avatar .user-presence .presence-oof-offline-wrapper .presence-oof-offline svg{color:#b4009e;width:calc(var(--avatar-size,var(--avatar-size,40px)) * .14);margin-inline-start:calc(var(--avatar-size,var(--avatar-size,40px)) * .07 - 2px)}:host .person-root .user-avatar .user-presence.presence-offline,mgt-person .person-root .user-avatar .user-presence.presence-offline{background-color:#8a8886;border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-available,mgt-person .person-root .user-avatar .user-presence.presence-available{background-color:#13a10e;border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-oof-offline,mgt-person .person-root .user-avatar .user-presence.presence-oof-offline{background-color:var(--presence-background-color,#fff);border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-oof-available,mgt-person .person-root .user-avatar .user-presence.presence-oof-available{background-color:var(--presence-background-color,#fff);border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-away,mgt-person .person-root .user-avatar .user-presence.presence-away{background-color:#fa4;border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-dnd,mgt-person .person-root .user-avatar .user-presence.presence-dnd{background-color:#c50f1f;border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-oof-dnd,mgt-person .person-root .user-avatar .user-presence.presence-oof-dnd{background-color:var(--presence-background-color,#fff);border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-busy,mgt-person .person-root .user-avatar .user-presence.presence-busy{background-color:#c50f1f;border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence.presence-oof-busy,mgt-person .person-root .user-avatar .user-presence.presence-oof-busy{background-color:var(--presence-background-color,#fff);border-color:var(--presence-background-color,#fff)}:host .person-root .user-avatar .user-presence .presence-basic,mgt-person .person-root .user-avatar .user-presence .presence-basic{width:calc(var(--avatar-size,var(--avatar-size,40px)) * .28 - 4px);height:calc(var(--avatar-size,var(--avatar-size,40px)) * .28 - 4px);border-style:solid;border-width:2px;border-radius:50%;margin:0;font-size:calc(var(--avatar-size,var(--avatar-size,40px)) * .14);vertical-align:top;display:flex;align-items:center}:host .person-root .user-avatar .user-presence .presence-basic.presence-offline,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-offline{background-color:var(--presence-background-color,#fff);border-color:#8a8886}:host .person-root .user-avatar .user-presence .presence-basic.presence-available,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-available{background-color:#13a10e;border-color:#13a10e}:host .person-root .user-avatar .user-presence .presence-basic.presence-oof-available,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-oof-available{background-color:var(--presence-background-color,#fff);border-color:#13a10e}:host .person-root .user-avatar .user-presence .presence-basic.presence-away,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-away{background-color:#fa4;border-color:#fa4}:host .person-root .user-avatar .user-presence .presence-basic.presence-dnd,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-dnd{background-color:#c50f1f;border-color:#c50f1f}:host .person-root .user-avatar .user-presence .presence-basic.presence-oof-dnd,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-oof-dnd{background-color:var(--presence-background-color,#fff);border-color:#c50f1f}:host .person-root .user-avatar .user-presence .presence-basic.presence-busy,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-busy{background-color:#c50f1f;border-color:#c50f1f}:host .person-root .user-avatar .user-presence .presence-basic.presence-oof-busy,mgt-person .person-root .user-avatar .user-presence .presence-basic.presence-oof-busy{background-color:var(--presence-background-color,#fff);border-color:#c50f1f}:host .person-root .user-avatar .user-presence .presence-offline::before,mgt-person .person-root .user-avatar .user-presence .presence-offline::before{content:"\uf13d";color:#8a8886;font-weight:700;margin-inline-start:calc(var(--avatar-size,var(--avatar-size,40px)) * .07 - 2px)}:host .person-root .user-avatar .user-presence .presence-available::before,mgt-person .person-root .user-avatar .user-presence .presence-available::before{content:"\uef80";color:var(--presence-icon-color,#fff);margin-inline-start:calc(var(--avatar-size,var(--avatar-size,40px)) * .07 - 2px)}:host .person-root .user-avatar .user-presence .presence-oof-available::before,mgt-person .person-root .user-avatar .user-presence .presence-oof-available::before{content:"\uef80";color:#13a10e;margin-inline-start:calc(var(--avatar-size,var(--avatar-size,40px)) * .07 - 2px)}:host .person-root .user-avatar .user-presence .presence-away::before,mgt-person .person-root .user-avatar .user-presence .presence-away::before{content:"\uef81";color:var(--presence-icon-color,#fff);margin-inline-start:calc(var(--avatar-size,var(--avatar-size,40px)) * .07 - 2px)}:host .person-root .user-avatar .user-presence .presence-dnd::before,mgt-person .person-root .user-avatar .user-presence .presence-dnd::before{content:"\uef82";color:var(--presence-icon-color,#fff);margin-inline-start:calc(var(--avatar-size,var(--avatar-size,40px)) * .07 - 2px)}:host .person-root .user-avatar .user-presence .presence-oof-dnd::before,mgt-person .person-root .user-avatar .user-presence .presence-oof-dnd::before{content:"\uef82";color:#c50f1f;margin-inline-start:calc(var(--avatar-size,var(--avatar-size,40px)) * .07 - 2px)}:host .person-root .user-avatar.initials,mgt-person .person-root .user-avatar.initials{color:var(--initials-color,#000);border-radius:var(--avatar-border-radius,50%);font-weight:400}:host .person-root .user-avatar.initials .contact-icon,:host .person-root .user-avatar.initials .initials-text,mgt-person .person-root .user-avatar.initials .contact-icon,mgt-person .person-root .user-avatar.initials .initials-text{cursor:var(--avatar-cursor,inherit);margin-top:-1px;font-size:calc(var(--avatar-size,var(--avatar-size,40px)) * .4)}:host .person-root .user-avatar.initials .contact-icon svg,:host .person-root .user-avatar.initials .initials-text svg,mgt-person .person-root .user-avatar.initials .contact-icon svg,mgt-person .person-root .user-avatar.initials .initials-text svg{height:30px;width:30px}:host .person-root .user-avatar.initials .contact-icon,mgt-person .person-root .user-avatar.initials .contact-icon{display:inline}:host .person-root .user-avatar.small,mgt-person .person-root .user-avatar.small{width:var(--avatar-size-s,var(--avatar-size,24px));height:var(--avatar-size-s,var(--avatar-size,24px))}:host .person-root .user-avatar.small .contact-icon,:host .person-root .user-avatar.small .initials-text,mgt-person .person-root .user-avatar.small .contact-icon,mgt-person .person-root .user-avatar.small .initials-text{font-size:calc(var(--avatar-size-s,var(--avatar-size,24px)) * .4)}:host .person-root .user-avatar.small .user-presence,mgt-person .person-root .user-avatar.small .user-presence{left:calc(var(--avatar-size-s,var(--avatar-size,24px)) - 8px);top:calc(var(--avatar-size-s,var(--avatar-size,24px)) - 8px);width:6px;height:6px}:host .person-root .user-avatar.small .user-presence__people,mgt-person .person-root .user-avatar.small .user-presence__people{left:calc(var(--avatar-size-s,var(--avatar-size,24px)) - 6px);border:0;width:6px;height:6px}:host .person-root .user-avatar.small .user-presence .presence-basic,mgt-person .person-root .user-avatar.small .user-presence .presence-basic{width:2px;height:2px;border-radius:50%;padding:0;font-size:calc(var(--avatar-size-s,var(--avatar-size,24px)) * .14)}:host .person-root .user-avatar.small .user-presence .presence-basic .presence-oof-offline svg,mgt-person .person-root .user-avatar.small .user-presence .presence-basic .presence-oof-offline svg{width:calc(var(--avatar-size-s,var(--avatar-size,24px)) * .14);margin-inline-start:calc(var(--avatar-size-s,var(--avatar-size,24px)) * .07 - 2px)}:host .person-root .user-avatar.small .user-presence .presence-available::before,:host .person-root .user-avatar.small .user-presence .presence-away::before,:host .person-root .user-avatar.small .user-presence .presence-dnd::before,:host .person-root .user-avatar.small .user-presence .presence-offline::before,:host .person-root .user-avatar.small .user-presence .presence-oof-available::before,:host .person-root .user-avatar.small .user-presence .presence-oof-away::before,:host .person-root .user-avatar.small .user-presence .presence-oof-dnd::before,:host .person-root .user-avatar.small .user-presence .presence-oof-offline::before,mgt-person .person-root .user-avatar.small .user-presence .presence-available::before,mgt-person .person-root .user-avatar.small .user-presence .presence-away::before,mgt-person .person-root .user-avatar.small .user-presence .presence-dnd::before,mgt-person .person-root .user-avatar.small .user-presence .presence-offline::before,mgt-person .person-root .user-avatar.small .user-presence .presence-oof-available::before,mgt-person .person-root .user-avatar.small .user-presence .presence-oof-away::before,mgt-person .person-root .user-avatar.small .user-presence .presence-oof-dnd::before,mgt-person .person-root .user-avatar.small .user-presence .presence-oof-offline::before{margin-inline-start:calc(var(--avatar-size-s,var(--avatar-size,24px)) * .07 - 2px)}:host .person-root .user-avatar.threeLines,mgt-person .person-root .user-avatar.threeLines{width:var(--avatar-size-3-lines,var(--avatar-size,56px));height:var(--avatar-size-3-lines,var(--avatar-size,56px))}:host .person-root .user-avatar.threeLines .contact-icon,:host .person-root .user-avatar.threeLines .initials-text,mgt-person .person-root .user-avatar.threeLines .contact-icon,mgt-person .person-root .user-avatar.threeLines .initials-text{font-size:calc(var(--avatar-size-3-lines,var(--avatar-size,56px)) * .4)}:host .person-root .user-avatar.threeLines .user-presence,mgt-person .person-root .user-avatar.threeLines .user-presence{left:calc(var(--avatar-size-3-lines,var(--avatar-size,56px)) - 18px);top:calc(var(--avatar-size-3-lines,var(--avatar-size,56px)) - 18px);width:16px;height:16px}:host .person-root .user-avatar.threeLines .user-presence .presence-basic,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-basic{width:12px;height:12px;border-radius:50%;padding:0;font-size:calc(var(--avatar-size-3-lines,var(--avatar-size,56px)) * .14)}:host .person-root .user-avatar.threeLines .user-presence .presence-basic .presence-oof-offline svg,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-basic .presence-oof-offline svg{width:calc(var(--avatar-size-3-lines,var(--avatar-size,56px)) * .14);margin-inline-start:calc(var(--avatar-size-3-lines,var(--avatar-size,56px)) * .07 - 2px)}:host .person-root .user-avatar.threeLines .user-presence .presence-available::before,:host .person-root .user-avatar.threeLines .user-presence .presence-away::before,:host .person-root .user-avatar.threeLines .user-presence .presence-dnd::before,:host .person-root .user-avatar.threeLines .user-presence .presence-offline::before,:host .person-root .user-avatar.threeLines .user-presence .presence-oof-available::before,:host .person-root .user-avatar.threeLines .user-presence .presence-oof-away::before,:host .person-root .user-avatar.threeLines .user-presence .presence-oof-dnd::before,:host .person-root .user-avatar.threeLines .user-presence .presence-oof-offline::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-available::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-away::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-dnd::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-offline::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-oof-available::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-oof-away::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-oof-dnd::before,mgt-person .person-root .user-avatar.threeLines .user-presence .presence-oof-offline::before{margin-inline-start:calc(var(--avatar-size-3-lines,var(--avatar-size,56px)) * .07 - var(--user-presence-margin-offset,2px))}:host .person-root .user-avatar.fourLines,:host .person-root .user-avatar.vertical,mgt-person .person-root .user-avatar.fourLines,mgt-person .person-root .user-avatar.vertical{width:var(--avatar-size-4-lines,var(--avatar-size,72px));height:var(--avatar-size-4-lines,var(--avatar-size,72px))}:host .person-root .user-avatar.fourLines .contact-icon,:host .person-root .user-avatar.fourLines .initials-text,:host .person-root .user-avatar.vertical .contact-icon,:host .person-root .user-avatar.vertical .initials-text,mgt-person .person-root .user-avatar.fourLines .contact-icon,mgt-person .person-root .user-avatar.fourLines .initials-text,mgt-person .person-root .user-avatar.vertical .contact-icon,mgt-person .person-root .user-avatar.vertical .initials-text{font-size:calc(var(--avatar-size-4-lines,var(--avatar-size,72px)) * .4)}:host .person-root .user-avatar.fourLines .user-presence,:host .person-root .user-avatar.vertical .user-presence,mgt-person .person-root .user-avatar.fourLines .user-presence,mgt-person .person-root .user-avatar.vertical .user-presence{left:calc(var(--avatar-size-4-lines,var(--avatar-size,72px)) - 22px);top:calc(var(--avatar-size-4-lines,var(--avatar-size,72px)) - 22px);width:20px;height:20px}:host .person-root .user-avatar.fourLines .user-presence .presence-basic,:host .person-root .user-avatar.vertical .user-presence .presence-basic,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-basic,mgt-person .person-root .user-avatar.vertical .user-presence .presence-basic{width:16px;height:16px;border-radius:50%;padding:0;font-size:calc(var(--avatar-size-4-lines,var(--avatar-size,72px)) * .14)}:host .person-root .user-avatar.fourLines .user-presence .presence-basic .presence-oof-offline svg,:host .person-root .user-avatar.vertical .user-presence .presence-basic .presence-oof-offline svg,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-basic .presence-oof-offline svg,mgt-person .person-root .user-avatar.vertical .user-presence .presence-basic .presence-oof-offline svg{width:calc(var(--avatar-size-4-lines,var(--avatar-size,72px)) * .14);margin-inline-start:calc(var(--avatar-size-4-lines,var(--avatar-size,72px)) * .07 - 2px)}:host .person-root .user-avatar.fourLines .user-presence .presence-available::before,:host .person-root .user-avatar.fourLines .user-presence .presence-away::before,:host .person-root .user-avatar.fourLines .user-presence .presence-dnd::before,:host .person-root .user-avatar.fourLines .user-presence .presence-offline::before,:host .person-root .user-avatar.fourLines .user-presence .presence-oof-available::before,:host .person-root .user-avatar.fourLines .user-presence .presence-oof-away::before,:host .person-root .user-avatar.fourLines .user-presence .presence-oof-dnd::before,:host .person-root .user-avatar.fourLines .user-presence .presence-oof-offline::before,:host .person-root .user-avatar.vertical .user-presence .presence-available::before,:host .person-root .user-avatar.vertical .user-presence .presence-away::before,:host .person-root .user-avatar.vertical .user-presence .presence-dnd::before,:host .person-root .user-avatar.vertical .user-presence .presence-offline::before,:host .person-root .user-avatar.vertical .user-presence .presence-oof-available::before,:host .person-root .user-avatar.vertical .user-presence .presence-oof-away::before,:host .person-root .user-avatar.vertical .user-presence .presence-oof-dnd::before,:host .person-root .user-avatar.vertical .user-presence .presence-oof-offline::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-available::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-away::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-dnd::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-offline::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-oof-available::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-oof-away::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-oof-dnd::before,mgt-person .person-root .user-avatar.fourLines .user-presence .presence-oof-offline::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-available::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-away::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-dnd::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-offline::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-oof-available::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-oof-away::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-oof-dnd::before,mgt-person .person-root .user-avatar.vertical .user-presence .presence-oof-offline::before{margin-inline-start:calc(var(--avatar-size-4-lines,var(--avatar-size,72px)) * .07 - 2px)}:host .person-root .user-avatar.vertical,mgt-person .person-root .user-avatar.vertical{margin-inline-start:auto}:host .person-root .user-avatar .img-wrapper,mgt-person .person-root .user-avatar .img-wrapper{height:100%;width:100%;display:flex;overflow:hidden;border:var(--avatar-border,0);border-radius:var(--avatar-border-radius,50%);position:relative}:host .person-root .user-avatar .img-wrapper img,mgt-person .person-root .user-avatar .img-wrapper img{position:absolute;display:block;inset:-100%;margin:auto;height:100%;width:100%;object-fit:cover;object-position:top}:host .person-root .user-avatar .img-wrapper img:focus(),mgt-person .person-root .user-avatar .img-wrapper img:focus(){outline:0}:host .person-root .user-avatar.pinkRed10,mgt-person .person-root .user-avatar.pinkRed10{background-color:var(var(--initials-background-color,#fff),#750b1c)}:host .person-root .user-avatar.red20,mgt-person .person-root .user-avatar.red20{background-color:var(var(--initials-background-color,#fff),#a4262c)}:host .person-root .user-avatar.red10,mgt-person .person-root .user-avatar.red10{background-color:var(var(--initials-background-color,#fff),#d13438)}:host .person-root .user-avatar.orange20,mgt-person .person-root .user-avatar.orange20{background-color:var(var(--initials-background-color,#fff),#ca5010)}:host .person-root .user-avatar.orangeYellow20,mgt-person .person-root .user-avatar.orangeYellow20{background-color:var(var(--initials-background-color,#fff),#986f0b)}:host .person-root .user-avatar.green10,mgt-person .person-root .user-avatar.green10{background-color:var(var(--initials-background-color,#fff),#498205)}:host .person-root .user-avatar.green20,mgt-person .person-root .user-avatar.green20{background-color:var(var(--initials-background-color,#fff),#0b6a0b)}:host .person-root .user-avatar.cyan20,mgt-person .person-root .user-avatar.cyan20{background-color:var(var(--initials-background-color,#fff),#038387)}:host .person-root .user-avatar.cyan30,mgt-person .person-root .user-avatar.cyan30{background-color:var(var(--initials-background-color,#fff),#005b70)}:host .person-root .user-avatar.cyanBlue10,mgt-person .person-root .user-avatar.cyanBlue10{background-color:var(var(--initials-background-color,#fff),#0078d4)}:host .person-root .user-avatar.cyanBlue20,mgt-person .person-root .user-avatar.cyanBlue20{background-color:var(var(--initials-background-color,#fff),#004e8c)}:host .person-root .user-avatar.blue10,mgt-person .person-root .user-avatar.blue10{background-color:var(var(--initials-background-color,#fff),#4f6bed)}:host .person-root .user-avatar.blueMagenta30,mgt-person .person-root .user-avatar.blueMagenta30{background-color:var(var(--initials-background-color,#fff),#5c2e91)}:host .person-root .user-avatar.blueMagenta20,mgt-person .person-root .user-avatar.blueMagenta20{background-color:var(var(--initials-background-color,#fff),#8764b8)}:host .person-root .user-avatar.magenta20,mgt-person .person-root .user-avatar.magenta20{background-color:var(var(--initials-background-color,#fff),#881798)}:host .person-root .user-avatar.magenta10,mgt-person .person-root .user-avatar.magenta10{background-color:var(var(--initials-background-color,#fff),#c239b3)}:host .person-root .user-avatar.magentaPink10,mgt-person .person-root .user-avatar.magentaPink10{background-color:var(var(--initials-background-color,#fff),#e3008c)}:host .person-root .user-avatar.orange30,mgt-person .person-root .user-avatar.orange30{background-color:var(var(--initials-background-color,#fff),#8e562e)}:host .person-root .user-avatar.gray30,mgt-person .person-root .user-avatar.gray30{background-color:var(var(--initials-background-color,#fff),#7a7574)}:host .person-root .user-avatar.lightGrey,mgt-person .person-root .user-avatar.lightGrey{background-color:#e5e5e5}:host .person-root .details,mgt-person .person-root .details{flex-shrink:1;display:flex;flex-direction:column;overflow:hidden;line-height:1.6;margin-inline-start:var(--details-spacing,12px)}:host .person-root .details.small,mgt-person .person-root .details.small{margin-inline-start:var(--details-spacing,8px)}:host .person-root .details.small .line1,mgt-person .person-root .details.small .line1{font-weight:400}:host .person-root .details.threeLines,mgt-person .person-root .details.threeLines{margin-inline-start:var(--details-spacing,14px);margin-bottom:var(--details-cta-spacing,0)}:host .person-root .details.threeLines .line1,mgt-person .person-root .details.threeLines .line1{font-size:var(var(--line1-font-size,var(--font-size,14px)),16px);line-height:var(var(--line1-line-height,20px),22px)}:host .person-root .details.fourLines,mgt-person .person-root .details.fourLines{margin-inline-start:var(--details-spacing,16px);height:84px}:host .person-root .details.fourLines .line1,mgt-person .person-root .details.fourLines .line1{font-size:20px;line-height:26px;margin-bottom:6px}:host .person-root .details.vertical,mgt-person .person-root .details.vertical{text-align:center;align-items:center;margin-top:var(--details-spacing,7px)}:host .person-root .details.vertical.small,mgt-person .person-root .details.vertical.small{margin-top:var(--details-spacing,7px)}:host .person-root .details.vertical.threelines,mgt-person .person-root .details.vertical.threelines{margin-top:var(--details-spacing,12px)}:host .person-root .details.vertical.fourlines,mgt-person .person-root .details.vertical.fourlines{margin-top:var(--details-spacing,10px)}:host .person-root .details.vertical.fourlines .line1,:host .person-root .details.vertical.threelines .line1,mgt-person .person-root .details.vertical.fourlines .line1,mgt-person .person-root .details.vertical.threelines .line1{margin-bottom:0}:host .person-root .details>div,mgt-person .person-root .details>div{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}:host .person-root .details .line1,mgt-person .person-root .details .line1{color:var(--line1-color,#000);font-size:var(--line1-font-size,var(--font-size,14px));font-weight:var(--line1-font-weight,600);text-transform:var(text-transform,none);line-height:var(--line1-line-height,20px);width:fit-content}:host .person-root .details .line2,mgt-person .person-root .details .line2{color:var(--line2-color,var(--neutral-foreground-hint,#717171));font-size:var(--line2-font-size,var(--email-font-size,12px));font-weight:var(--line2-font-weight,400);text-transform:var(--line2-text-transform,var(text-transform,none));line-height:var(--line2-line-height,16px)}:host .person-root .details .line3,mgt-person .person-root .details .line3{color:var(--line3-color,var(--neutral-foreground-hint,#717171));font-size:var(--line3-font-size,var(--email-font-size,12px));font-weight:var(--line3-font-weight,400);text-transform:var(--line3-text-transform,var(text-transform,none));line-height:var(--line3-line-height,16px)}:host .person-root .details .line4,mgt-person .person-root .details .line4{color:var(--line4-color,var(--neutral-foreground-hint,#717171));font-size:var(--line4-font-size,var(--email-font-size,12px));font-weight:var(--line4-font-weight,400);text-transform:var(--line4-text-transform,var(text-transform,none));line-height:16px}:host .avatar-icon,mgt-person .avatar-icon{display:flex;align-items:center;justify-content:center;line-height:1;margin:0;font-size:calc(var(--avatar-size,var(--avatar-size,40px)) * .5);width:var(--avatar-size,var(--avatar-size,40px));height:var(--avatar-size,var(--avatar-size,40px));overflow:hidden;border-radius:var(--avatar-border-radius,50%)}:host .avatar-icon.small,mgt-person .avatar-icon.small{font-size:var(--avatar-size-s,var(--avatar-size,24px));width:var(--avatar-size-s,var(--avatar-size,24px));height:var(--avatar-size-s,var(--avatar-size,24px))}:host .avatar-icon.threeLines,mgt-person .avatar-icon.threeLines{font-size:var(--avatar-size-3-lines,var(--avatar-size,56px));width:var(--avatar-size-3-lines,var(--avatar-size,56px));height:var(--avatar-size-3-lines,var(--avatar-size,56px))}:host .avatar-icon.fourLines,mgt-person .avatar-icon.fourLines{font-size:var(--avatar-size-4-lines,var(--avatar-size,72px));width:var(--avatar-size-4-lines,var(--avatar-size,72px));height:var(--avatar-size-4-lines,var(--avatar-size,72px))}:host .vertical,mgt-person .vertical{display:block}[dir=rtl] .root{direction:rtl}[dir=rtl] svg{direction:rtl}[dir=rtl] .person-root .user-avatar{position:relative}[dir=rtl] .person-root.small .contact-icon,[dir=rtl] .person-root.small .initials-text{font-size:calc(var(--avatar-size-s,var(--avatar-size,24px)) * .4)}[dir=rtl] .person-root.small .user-presence{left:calc(var(--avatar-size-s,var(--avatar-size,24px)) - 8px);top:calc(var(--avatar-size-s,var(--avatar-size,24px)) - 8px);width:8px;height:8px}[dir=rtl] .person-root.small .user-presence__people{border:0;width:6px;height:6px;left:calc(var(--avatar-size-s,var(--avatar-size,24px)) - 6px)}[dir=rtl] .person-root.small .user-presence .presence-basic{width:4px;height:4px;border-radius:4px;padding:0}[dir=rtl] .person-root.small .user-presence .presence-basic .presence-oof-offline svg{height:0;width:0}[dir=rtl] .person-root.vertical{text-align:center;display:block}[dir=rtl] .person-root.vertical .user-avatar{display:block;margin-inline-start:auto}@media (forced-colors:active) and (prefers-color-scheme:dark){:host svg,:host svg>path,mgt-person svg,mgt-person svg>path{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}@media (forced-colors:active) and (prefers-color-scheme:dark){:host svg,:host svg>path,mgt-person svg,mgt-person svg>path{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person/strings.js
var strings = {
  photoFor: "Photo for",
  emailAddress: "Email address",
  initials: "Initials"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person/mgt-person-types.js
var PersonViewType;
(function(PersonViewType2) {
  PersonViewType2[PersonViewType2["avatar"] = 2] = "avatar";
  PersonViewType2[PersonViewType2["oneline"] = 3] = "oneline";
  PersonViewType2[PersonViewType2["twolines"] = 4] = "twolines";
  PersonViewType2[PersonViewType2["threelines"] = 5] = "threelines";
  PersonViewType2[PersonViewType2["fourlines"] = 6] = "fourlines";
})(PersonViewType || (PersonViewType = {}));
var avatarType;
(function(avatarType2) {
  avatarType2["photo"] = "photo";
  avatarType2["initials"] = "initials";
})(avatarType || (avatarType = {}));

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person/mgt-person.js
var __decorate3 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata2 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtPerson_1;
var defaultPersonProperties = [
  "businessPhones",
  "displayName",
  "givenName",
  "jobTitle",
  "department",
  "mail",
  "mobilePhone",
  "officeLocation",
  "preferredLanguage",
  "surname",
  "userPrincipalName",
  "id"
];
var MgtPerson = MgtPerson_1 = class MgtPerson2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles3;
  }
  get strings() {
    return strings;
  }
  /**
   * allows developer to define name of person for component
   * @type {string}
   */
  get personQuery() {
    return this._personQuery;
  }
  set personQuery(value) {
    if (value === this._personQuery) {
      return;
    }
    this._personQuery = value;
    this.personDetailsInternal = null;
    this.requestStateUpdate();
  }
  /**
   * Fallback when no user is found
   * @type {IDynamicPerson}
   */
  get fallbackDetails() {
    return this._fallbackDetails;
  }
  set fallbackDetails(value) {
    if (value === this._fallbackDetails) {
      return;
    }
    this._fallbackDetails = value;
    if (this.personDetailsInternal) {
      return;
    }
    if (value && value.displayName) {
      this._personAvatarBg = this.getColorFromName(value.displayName);
    } else {
      this._personAvatarBg = "lightGrey";
    }
    this.requestStateUpdate();
  }
  /**
   * user-id property allows developer to use id value to determine person
   * @type {string}
   */
  get userId() {
    return this._userId;
  }
  set userId(value) {
    if (value === this._userId) {
      return;
    }
    this._userId = value;
    this.personDetailsInternal = null;
    this.requestStateUpdate();
  }
  /**
   * usage property allows you to specify where the component is being used to add
   * customized personalization for it. Currently only supports "people" as used in
   * the people component.
   * @type {string}
   */
  get usage() {
    return this._usage;
  }
  set usage(value) {
    if (value === this._usage) {
      return;
    }
    this._usage = value;
    this.requestStateUpdate();
  }
  /**
   * object containing Graph details on person
   * a copy of person-details attribute
   * @type {IDynamicPerson}
   */
  get personDetailsInternal() {
    return this._personDetailsInternal;
  }
  set personDetailsInternal(value) {
    if (this._personDetailsInternal === value) {
      return;
    }
    this._personDetailsInternal = value;
    if (value && value.displayName) {
      this._personAvatarBg = this.getColorFromName(value.displayName);
    } else {
      this._personAvatarBg = "lightGrey";
    }
    this._fetchedImage = null;
    this._fetchedPresence = null;
    this.requestStateUpdate();
    this.requestUpdate("personDetailsInternal");
  }
  /**
   * object containing Graph details on person
   * @type {IDynamicPerson}
   */
  get personDetails() {
    return this._personDetails;
  }
  set personDetails(value) {
    if (this._personDetails === value) {
      return;
    }
    this._personDetails = value;
    if (value && value.displayName) {
      this._personAvatarBg = this.getColorFromName(value.displayName);
    } else {
      this._personAvatarBg = "lightGrey";
    }
    this._fetchedImage = null;
    this._fetchedPresence = null;
    this.requestStateUpdate();
    this.requestUpdate("personDetails");
  }
  /**
   * Set the image of the person
   *
   * @type {string}
   * @memberof MgtPersonCard
   */
  get personImage() {
    return this._personImage || this._fetchedImage;
  }
  set personImage(value) {
    if (value === this._personImage) {
      return;
    }
    this._isInvalidImageSrc = !value;
    const oldValue = this._personImage;
    this._personImage = value;
    this.requestUpdate("personImage", oldValue);
  }
  /**
   * Determines and sets person avatar
   *
   *
   * @type {string}
   * @memberof MgtPerson
   */
  get avatarType() {
    return this._avatarType;
  }
  set avatarType(value) {
    if (value === this._avatarType) {
      return;
    }
    this._avatarType = value;
    this.requestStateUpdate();
  }
  /**
   * Gets or sets presence of person
   *
   * @type {MicrosoftGraph.Presence}
   * @memberof MgtPerson
   */
  get personPresence() {
    return this._personPresence || this._fetchedPresence;
  }
  set personPresence(value) {
    if (value === this._personPresence) {
      return;
    }
    const oldValue = this._personPresence;
    this._personPresence = value;
    this.requestUpdate("personPresence", oldValue);
  }
  /**
   * Get the scopes required for person
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtPerson
   */
  static get requiredScopes() {
    const scopes = ["user.readbasic.all", "user.read", "people.read", "presence.read.all", "presence.read"];
    if (MgtPerson_1.config.useContactApis) {
      scopes.push("contacts.read");
    }
    return scopes;
  }
  /**
   * Gets the flyout element
   *
   * @protected
   * @type {MgtFlyout}
   * @memberof MgtPerson
   */
  get flyout() {
    return this.renderRoot.querySelector(".flyout");
  }
  constructor() {
    super();
    this.personCardInteraction = PersonCardInteraction.none;
    this.line1Property = "displayName";
    this.line2Property = "jobTitle";
    this.line3Property = "department";
    this.line4Property = "email";
    this.view = ViewType.image;
    this.avatarSize = "auto";
    this.disableImageFetch = false;
    this._isInvalidImageSrc = false;
    this._avatarType = "photo";
    this.verticalLayout = false;
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    if (this.isLoadingState && !this.personDetails && !this.personDetailsInternal && !this.fallbackDetails) {
      return this.renderLoading();
    }
    const person = this.personDetails || this.personDetailsInternal || this.fallbackDetails;
    const image = this.getImage();
    const presence = this.personPresence || this._fetchedPresence;
    if (!person && !image) {
      return this.renderNoData();
    }
    if (!(person && person.personImage) && image) {
      person.personImage = image;
    }
    let personTemplate = this.renderTemplate("default", { person, personImage: image, personPresence: presence });
    if (!personTemplate) {
      const detailsTemplate = this.renderDetails(person, presence);
      const imageWithPresenceTemplate = this.renderAvatar(person, image, presence);
      const rootClasses = {
        "person-root": true,
        clickable: this.personCardInteraction === PersonCardInteraction.click,
        vertical: this.isVertical()
      };
      personTemplate = html`
        <div class=${classMap(rootClasses)}>
          ${imageWithPresenceTemplate} ${detailsTemplate}
        </div>
      `;
    }
    if (this.personCardInteraction !== PersonCardInteraction.none) {
      personTemplate = this.renderFlyout(personTemplate, person, image, presence);
    }
    return html`
      <div
        class="root"
        dir=${this.direction}
        @click=${this.handleMouseClick}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
        @keydown=${this.handleKeyDown}
        tabindex=0
      >
        ${personTemplate}
      </div>
    `;
  }
  /**
   * Render the loading state
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPerson
   */
  renderLoading() {
    return this.renderTemplate("loading", null) || html``;
  }
  /**
   * Clears state of the component
   *
   * @protected
   * @memberof MgtPerson
   */
  clearState() {
    this._personImage = "";
    this._personDetailsInternal = null;
    this._fetchedImage = null;
    this._fetchedPresence = null;
  }
  /**
   * Render the state when no data is available
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPerson
   */
  renderNoData() {
    const noDataTemplate = this.renderTemplate("no-data", null);
    if (noDataTemplate) {
      return noDataTemplate;
    }
    const avatarClasses = {
      "avatar-icon": true,
      vertical: this.isVertical(),
      small: !this.isLargeAvatar(),
      threeLines: this.isThreeLines(),
      fourLines: this.isFourLines()
    };
    return html`
       <i class=${classMap(avatarClasses)}></i>
     `;
  }
  /**
   * Render a person icon.
   *
   * @protected
   * @returns
   * @memberof MgtPerson
   */
  renderPersonIcon() {
    return html`
       <svg width="10" height="13" viewBox="0 0 10 13" fill="none" xmlns="http://www.w3.org/2000/svg">
       <path d="M8.5 7C9.32843 7 10 7.67157 10 8.5V9C10 10.9714 8.14049 13 5 13C1.85951 13 0 10.9714 0 9V8.5C0 7.67157 0.671573 7 1.5 7H8.5ZM8.5 8H1.5C1.22386 8 1 8.22386 1 8.5V9C1 10.4376 2.43216 12 5 12C7.56784 12 9 10.4376 9 9V8.5C9 8.22386 8.77614 8 8.5 8ZM5 0.5C6.51878 0.5 7.75 1.73122 7.75 3.25C7.75 4.76878 6.51878 6 5 6C3.48122 6 2.25 4.76878 2.25 3.25C2.25 1.73122 3.48122 0.5 5 0.5ZM5 1.5C4.0335 1.5 3.25 2.2835 3.25 3.25C3.25 4.2165 4.0335 5 5 5C5.9665 5 6.75 4.2165 6.75 3.25C6.75 2.2835 5.9665 1.5 5 1.5Z" fill="#616161"/>
       </svg>
     `;
  }
  /**
   * Render the image part of the person template.
   * If the image is unavailable, the person's initials will be used instead.
   *
   * @protected
   * @param {string} [imageSrc]
   * @param {IDynamicPerson} [personDetailsInternal]
   * @returns
   * @memberof MgtPerson
   */
  renderImage(personDetailsInternal, imageSrc) {
    if (imageSrc && !this._isInvalidImageSrc && this._avatarType === "photo") {
      const altText = `${this.strings.photoFor} ${personDetailsInternal.displayName}`;
      return html`
        <div class="img-wrapper">
          <img alt=${altText} src=${imageSrc} @error=${() => this._isInvalidImageSrc = true} />
        </div>
      `;
    } else if (personDetailsInternal) {
      const initials = this.getInitials(personDetailsInternal);
      return html`
        <span class="initials-text" aria-label="${this.strings.initials} ${initials}">
          ${initials && initials.length ? html`
                ${initials}
              ` : html`
                <i class="contact-icon">${this.renderPersonIcon()}</i>
              `}
        </span>
      `;
    }
  }
  /**
   * Render presence for the person.
   *
   * @protected
   * @param
   * @memberof MgtPersonCard
   */
  renderPresence(presence) {
    if (!this.showPresence || !presence) {
      return html``;
    }
    let statusClass = null;
    switch (presence.availability) {
      case "DoNotDisturb":
        switch (presence.activity) {
          case "OutOfOffice":
            statusClass = "presence-oof-dnd";
            break;
          default:
            statusClass = "presence-dnd";
            break;
        }
        break;
      case "BeRightBack":
        statusClass = "presence-away";
        break;
      case "Available":
        switch (presence.activity) {
          case "Available":
            statusClass = "presence-available";
            break;
          case "OutOfOffice":
            statusClass = "presence-oof-available";
            break;
        }
        break;
      case "Busy":
        switch (presence.activity) {
          case "OutOfOffice":
            statusClass = "presence-oof-busy";
            break;
          default:
            statusClass = "presence-busy";
            break;
        }
        break;
      case "Away":
        switch (presence.activity) {
          case "Away":
            statusClass = "presence-away";
            break;
          case "OutOfOffice":
            statusClass = "presence-oof-offline";
            break;
        }
        break;
      case "Offline":
        switch (presence.activity) {
          case "Offline":
            statusClass = "presence-offline";
            break;
          case "OutOfOffice":
            statusClass = "presence-oof-offline";
            break;
          case "OffWork":
            statusClass = "presence-offline";
            break;
        }
        break;
      default:
        statusClass = "presence-offline";
        break;
    }
    const presenceClasses = {
      "ms-Icon": true,
      "presence-basic": true
    };
    presenceClasses[statusClass] = true;
    let iconHtml = null;
    if (statusClass === "presence-oof-offline") {
      iconHtml = html`
         <div class="ms-Icon presence-basic presence-oof-offline-wrapper">
           <i class="presence-oof-offline">
             ${getSvg(SvgIcon.SkypeArrow, "#666666")}
           </i>
         </div>
       `;
    } else {
      iconHtml = html`
         <i class=${classMap(presenceClasses)} aria-hidden="true"></i>
       `;
    }
    const userPresenceClass = {
      "user-presence": true,
      "user-presence__people": this._usage === "people"
    };
    userPresenceClass[statusClass] = true;
    return html`
       <div class=${classMap(userPresenceClass)} title=${presence.activity} aria-label=${presence.activity} role="img">
         ${iconHtml}
       </div>
     `;
  }
  /**
   * Render image with presence for the person.
   *
   * @protected
   * @param
   * @memberof MgtPersonCard
   */
  renderAvatar(personDetailsInternal, image, presence) {
    const hasInitials = !image || this._isInvalidImageSrc || this._avatarType === avatarType.initials;
    const imageClasses = {
      initials: hasInitials,
      small: !this.isLargeAvatar(),
      threeLines: this.isThreeLines(),
      fourLines: this.isFourLines(),
      "user-avatar": true,
      vertical: this.isVertical()
    };
    let title = "";
    if (hasInitials && personDetailsInternal) {
      imageClasses[this._personAvatarBg] = true;
      title = `${this.strings.initials} ${this.getInitials(personDetailsInternal)}`;
    } else {
      title = personDetailsInternal ? personDetailsInternal.displayName || "" : "";
      if (title !== "") {
        title = `${this.strings.photoFor} ${title}`;
      }
    }
    if (title === "") {
      const emailAddress = getEmailFromGraphEntity(personDetailsInternal);
      if (emailAddress !== null) {
        title = `${this.strings.emailAddress} ${emailAddress}`;
      }
    }
    const imageTemplate = this.renderImage(personDetailsInternal, image);
    const presenceTemplate = this.renderPresence(presence);
    return html`
       <div class=${classMap(imageClasses)} title=${title} aria-label=${title}>
         ${imageTemplate} ${presenceTemplate}
       </div>
     `;
  }
  handleLine1Clicked() {
    this.fireCustomEvent("line1clicked", this.personDetailsInternal);
  }
  handleLine2Clicked() {
    this.fireCustomEvent("line2clicked", this.personDetailsInternal);
  }
  handleLine3Clicked() {
    this.fireCustomEvent("line3clicked", this.personDetailsInternal);
  }
  handleLine4Clicked() {
    this.fireCustomEvent("line4clicked", this.personDetailsInternal);
  }
  /**
   * Render the details part of the person template.
   *
   * @protected
   * @param {IDynamicPerson} [person]
   * @param {string} [image]
   * @returns {TemplateResult}
   * @memberof MgtPerson
   */
  renderDetails(personProps, presence) {
    if (!personProps || this.view === ViewType.image || this.view === PersonViewType.avatar) {
      return html``;
    }
    const person = personProps;
    if (presence) {
      person.presenceActivity = presence === null || presence === void 0 ? void 0 : presence.activity;
      person.presenceAvailability = presence === null || presence === void 0 ? void 0 : presence.availability;
    }
    const details = [];
    if (this.view > ViewType.image) {
      const text = this.getTextFromProperty(person, this.line1Property);
      if (this.hasTemplate("line1")) {
        const template = this.renderTemplate("line1", { person });
        details.push(html`
           <div class="line1" @click=${() => this.handleLine1Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
      } else {
        if (text) {
          details.push(html`
             <div class="line1" @click=${() => this.handleLine1Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
        }
      }
    }
    if (this.view > ViewType.oneline) {
      const text = this.getTextFromProperty(person, this.line2Property);
      if (this.hasTemplate("line2")) {
        const template = this.renderTemplate("line2", { person });
        details.push(html`
           <div class="line2" @click=${() => this.handleLine2Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
      } else {
        if (text) {
          details.push(html`
             <div class="line2" @click=${() => this.handleLine2Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
        }
      }
    }
    if (this.view > ViewType.twolines) {
      const text = this.getTextFromProperty(person, this.line3Property);
      if (this.hasTemplate("line3")) {
        const template = this.renderTemplate("line3", { person });
        details.push(html`
           <div class="line3" @click=${() => this.handleLine3Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
      } else {
        if (text) {
          details.push(html`
             <div class="line3" @click=${() => this.handleLine3Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
        }
      }
    }
    if (this.view > ViewType.threelines) {
      const text = this.getTextFromProperty(person, this.line4Property);
      if (this.hasTemplate("line4")) {
        const template = this.renderTemplate("line4", { person });
        details.push(html`
          <div class="line4" @click=${() => this.handleLine4Clicked()} role="presentation" aria-label="${text}">${template}</div>
        `);
      } else {
        if (text) {
          details.push(html`
            <div class="line4" @click=${() => this.handleLine4Clicked()} role="presentation" aria-label="${text}">${text}</div>
          `);
        }
      }
    }
    const detailsClasses = classMap({
      details: true,
      small: !this.isLargeAvatar(),
      threeLines: this.isThreeLines(),
      fourLines: this.isFourLines(),
      vertical: this.isVertical()
    });
    return html`
       <div class="${detailsClasses}">
         ${details}
       </div>
     `;
  }
  /**
   * Render the details flyout.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPerson
   */
  renderFlyout(anchor, personDetails, image, presence) {
    const flyoutContent = this._personCardShouldRender ? html`
           <div slot="flyout" data-testid="flyout-slot">
             ${this.renderFlyoutContent(personDetails, image, presence)}
           </div>
         ` : html``;
    return mgtHtml`
      <mgt-flyout light-dismiss class="flyout" .avoidHidingAnchor=${false}>
        ${anchor} ${flyoutContent}
      </mgt-flyout>
`;
  }
  /**
   * Render the flyout menu content.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPerson
   */
  renderFlyoutContent(personDetails, image, presence) {
    return this.renderTemplate("person-card", { person: personDetails, personImage: image }) || mgtHtml`
        <mgt-person-card
          lock-tab-navigation
          .personDetails=${personDetails}
          .personImage=${image}
          .personPresence=${presence}
          .showPresence=${this.showPresence}
        ></mgt-person-card>
      `;
  }
  /**
   * load state into the component.
   *
   * @protected
   * @returns
   * @memberof MgtPerson
   */
  loadState() {
    return __awaiter6(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      if (!provider || provider.state === ProviderState.Loading) {
        return;
      }
      if (provider && provider.state === ProviderState.SignedOut) {
        this.personDetailsInternal = null;
        return;
      }
      const graph = provider.graph.forComponent(this);
      if (this.fallbackDetails) {
        this.line2Property = "email";
      }
      if (this.verticalLayout && this.view < ViewType.fourlines) {
        this.line2Property = "email";
      }
      let personProps = [
        ...defaultPersonProperties,
        this.line1Property,
        this.line2Property,
        this.line3Property,
        this.line4Property
      ];
      personProps = personProps.filter((email) => email !== "email");
      let details = this.personDetailsInternal || this.personDetails || this.fallbackDetails;
      if (details) {
        if (!details.personImage && this.fetchImage && this._avatarType === "photo" && !this.personImage && !this._fetchedImage) {
          let image;
          if ("groupTypes" in details) {
            image = yield getGroupImage(graph, details, MgtPerson_1.config.useContactApis);
          } else {
            image = yield getPersonImage(graph, details, MgtPerson_1.config.useContactApis);
          }
          if (image) {
            details.personImage = image;
            this._fetchedImage = image;
          }
        }
      } else if (this.userId || this.personQuery === "me") {
        let person;
        if (this._avatarType === "photo" && !this.disableImageFetch) {
          person = yield getUserWithPhoto(graph, this.userId, personProps);
        } else {
          if (this.personQuery === "me") {
            person = yield getMe(graph, personProps);
          } else {
            person = yield getUser(graph, this.userId, personProps);
          }
        }
        this.personDetailsInternal = person;
        this.personDetails = person;
        this._fetchedImage = this.getImage();
      } else if (this.personQuery) {
        let people = yield findPeople(graph, this.personQuery, 1);
        if (!people || people.length === 0) {
          people = (yield findUsers(graph, this.personQuery, 1)) || [];
        }
        if (people && people.length) {
          this.personDetailsInternal = people[0];
          this.personDetails = people[0];
          if (this._avatarType === "photo" && !this.disableImageFetch) {
            const image = yield getPersonImage(graph, people[0], MgtPerson_1.config.useContactApis);
            if (image) {
              this.personDetailsInternal.personImage = image;
              this.personDetails.personImage = image;
              this._fetchedImage = image;
            }
          }
        }
      }
      const defaultPresence = {
        activity: "Offline",
        availability: "Offline",
        id: null
      };
      if (this.showPresence && !this.personPresence && !this._fetchedPresence) {
        try {
          details = this.personDetailsInternal || this.personDetails;
          if (details) {
            const userId = this.personQuery !== "me" ? details === null || details === void 0 ? void 0 : details.id : null;
            this._fetchedPresence = yield getUserPresence(graph, userId);
          } else {
            this._fetchedPresence = defaultPresence;
          }
        } catch (_) {
          this._fetchedPresence = defaultPresence;
        }
      }
    });
  }
  /**
   * Gets the user initials
   *
   * @protected
   * @returns {string}
   * @memberof MgtPerson
   */
  getInitials(person) {
    if (!person) {
      person = this.personDetailsInternal;
    }
    if (person.initials) {
      return person.initials;
    }
    let initials = "";
    if (person.givenName) {
      initials += person.givenName[0].toUpperCase();
    }
    if (person.surname) {
      initials += person.surname[0].toUpperCase();
    }
    if (!initials && person.displayName) {
      const name = person.displayName.split(/\s+/);
      for (let i = 0; i < 2 && i < name.length; i++) {
        if (name[i][0] && this.isLetter(name[i][0])) {
          initials += name[i][0].toUpperCase();
        }
      }
    }
    return initials;
  }
  /**
   * Gets color from name
   *
   * @protected
   * @param {string} name
   * @returns {string}
   * @memberof MgtPerson
   */
  getColorFromName(name) {
    const charCodes = name.split("").map((char) => char.charCodeAt(0)).join("");
    const nameInt = parseInt(charCodes, 10);
    const colors = [
      "pinkRed10",
      "red20",
      "red10",
      "orange20",
      "orangeYellow20",
      "green10",
      "green20",
      "cyan20",
      "cyan30",
      "cyanBlue10",
      "cyanBlue20",
      "blue10",
      "blueMagenta30",
      "blueMagenta20",
      "magenta20",
      "magenta10",
      "magentaPink10",
      "orange30",
      "gray30",
      // 'gray20',
      "lightGrey"
    ];
    return colors[nameInt % colors.length];
  }
  getImage() {
    if (this.personImage) {
      return this.personImage;
    }
    if (this._fetchedImage) {
      return this._fetchedImage;
    }
    const person = this.personDetailsInternal || this.personDetails;
    return person && person.personImage ? person.personImage : null;
  }
  isLetter(char) {
    try {
      return char.match(new RegExp("\\p{L}", "u"));
    } catch (e) {
      return char.toLowerCase() !== char.toUpperCase();
    }
  }
  getTextFromProperty(personDetailsInternal, prop) {
    if (!prop || prop.length === 0) {
      return null;
    }
    const properties = prop.trim().split(",");
    let text;
    let i = 0;
    while (!text && i < properties.length) {
      const currentProp = properties[i].trim();
      switch (currentProp) {
        case "mail":
        case "email":
          text = getEmailFromGraphEntity(personDetailsInternal);
          break;
        default:
          text = personDetailsInternal[currentProp];
      }
      i++;
    }
    return text;
  }
  isLargeAvatar() {
    return this.avatarSize === "large" || this.avatarSize === "auto" && this.view > ViewType.oneline;
  }
  isThreeLines() {
    return this.view === ViewType.threelines;
  }
  isFourLines() {
    return this.view === ViewType.fourlines;
  }
  isVertical() {
    return this.verticalLayout;
  }
  handleMouseClick(e) {
    const element = e.target;
    if (this.personCardInteraction === PersonCardInteraction.click && element.tagName !== "MGT-PERSON-CARD") {
      this.showPersonCard();
    }
  }
  handleKeyDown(e) {
    if (e) {
      if (e.key === "Enter") {
        this.showPersonCard();
      }
    }
  }
  handleMouseEnter(e) {
    clearTimeout(this._mouseEnterTimeout);
    clearTimeout(this._mouseLeaveTimeout);
    if (this.personCardInteraction !== PersonCardInteraction.hover) {
      return;
    }
    this._mouseEnterTimeout = setTimeout(this.showPersonCard.bind(this), 500);
  }
  handleMouseLeave(e) {
    clearTimeout(this._mouseEnterTimeout);
    clearTimeout(this._mouseLeaveTimeout);
    this._mouseLeaveTimeout = setTimeout(this.hidePersonCard.bind(this), 500);
  }
  /**
   * hides the person card
   *
   * @memberof MgtPerson
   */
  hidePersonCard() {
    const flyout = this.flyout;
    if (flyout) {
      flyout.close();
    }
    const personCard = this.querySelector("mgt-person-card") || this.renderRoot.querySelector("mgt-person-card");
    if (personCard) {
      personCard.isExpanded = false;
      personCard.clearHistory();
    }
  }
  showPersonCard() {
    if (!this._personCardShouldRender) {
      this._personCardShouldRender = true;
    }
    const flyout = this.flyout;
    if (flyout) {
      flyout.open();
    }
  }
};
MgtPerson.config = {
  useContactApis: true
};
__decorate3([
  property({
    attribute: "person-query"
  }),
  __metadata2("design:type", String),
  __metadata2("design:paramtypes", [String])
], MgtPerson.prototype, "personQuery", null);
__decorate3([
  property({
    attribute: "fallback-details",
    type: Object
  }),
  __metadata2("design:type", Object),
  __metadata2("design:paramtypes", [Object])
], MgtPerson.prototype, "fallbackDetails", null);
__decorate3([
  property({
    attribute: "user-id"
  }),
  __metadata2("design:type", String),
  __metadata2("design:paramtypes", [String])
], MgtPerson.prototype, "userId", null);
__decorate3([
  property({
    attribute: "usage"
  }),
  __metadata2("design:type", String),
  __metadata2("design:paramtypes", [String])
], MgtPerson.prototype, "usage", null);
__decorate3([
  property({
    attribute: "show-presence",
    type: Boolean
  }),
  __metadata2("design:type", Boolean)
], MgtPerson.prototype, "showPresence", void 0);
__decorate3([
  property({
    attribute: "avatar-size",
    type: String
  }),
  __metadata2("design:type", String)
], MgtPerson.prototype, "avatarSize", void 0);
__decorate3([
  property({
    attribute: null,
    type: Object
  }),
  __metadata2("design:type", Object),
  __metadata2("design:paramtypes", [Object])
], MgtPerson.prototype, "personDetailsInternal", null);
__decorate3([
  property({
    attribute: "person-details",
    type: Object
  }),
  __metadata2("design:type", Object),
  __metadata2("design:paramtypes", [Object])
], MgtPerson.prototype, "personDetails", null);
__decorate3([
  property({
    attribute: "person-image",
    type: String
  }),
  __metadata2("design:type", String),
  __metadata2("design:paramtypes", [String])
], MgtPerson.prototype, "personImage", null);
__decorate3([
  property({
    attribute: "fetch-image",
    type: Boolean
  }),
  __metadata2("design:type", Boolean)
], MgtPerson.prototype, "fetchImage", void 0);
__decorate3([
  property({
    attribute: "disable-image-fetch",
    type: Boolean
  }),
  __metadata2("design:type", Boolean)
], MgtPerson.prototype, "disableImageFetch", void 0);
__decorate3([
  property({
    attribute: "vertical-layout",
    type: Boolean
  }),
  __metadata2("design:type", Boolean)
], MgtPerson.prototype, "verticalLayout", void 0);
__decorate3([
  property({
    attribute: "avatar-type",
    converter: (value) => {
      value = value.toLowerCase();
      if (value === "initials") {
        return avatarType.initials;
      } else {
        return avatarType.photo;
      }
    }
  }),
  __metadata2("design:type", String),
  __metadata2("design:paramtypes", [String])
], MgtPerson.prototype, "avatarType", null);
__decorate3([
  property({
    attribute: "person-presence",
    type: Object
  }),
  __metadata2("design:type", Object),
  __metadata2("design:paramtypes", [Object])
], MgtPerson.prototype, "personPresence", null);
__decorate3([
  property({
    attribute: "person-card",
    converter: (value, type) => {
      value = value.toLowerCase();
      if (typeof PersonCardInteraction[value] === "undefined") {
        return PersonCardInteraction.none;
      } else {
        return PersonCardInteraction[value];
      }
    }
  }),
  __metadata2("design:type", Number)
], MgtPerson.prototype, "personCardInteraction", void 0);
__decorate3([
  property({ attribute: "line1-property" }),
  __metadata2("design:type", String)
], MgtPerson.prototype, "line1Property", void 0);
__decorate3([
  property({ attribute: "line2-property" }),
  __metadata2("design:type", String)
], MgtPerson.prototype, "line2Property", void 0);
__decorate3([
  property({ attribute: "line3-property" }),
  __metadata2("design:type", String)
], MgtPerson.prototype, "line3Property", void 0);
__decorate3([
  property({ attribute: "line4-property" }),
  __metadata2("design:type", String)
], MgtPerson.prototype, "line4Property", void 0);
__decorate3([
  property({
    converter: (value) => {
      if (!value || value.length === 0) {
        return ViewType.image;
      }
      value = value.toLowerCase();
      if (typeof ViewType[value] === "undefined") {
        return ViewType.image;
      } else {
        return ViewType[value];
      }
    }
  }),
  __metadata2("design:type", Number)
], MgtPerson.prototype, "view", void 0);
__decorate3([
  state(),
  __metadata2("design:type", String)
], MgtPerson.prototype, "_fetchedImage", void 0);
__decorate3([
  state(),
  __metadata2("design:type", Object)
], MgtPerson.prototype, "_fetchedPresence", void 0);
__decorate3([
  state(),
  __metadata2("design:type", Boolean)
], MgtPerson.prototype, "_isInvalidImageSrc", void 0);
__decorate3([
  state(),
  __metadata2("design:type", Boolean)
], MgtPerson.prototype, "_personCardShouldRender", void 0);
MgtPerson = MgtPerson_1 = __decorate3([
  customElement("person"),
  __metadata2("design:paramtypes", [])
], MgtPerson);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-agenda/mgt-agenda-css.js
init_lit();
var styles4 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--event-background-color:#ffffff;background-color:transparent}.mgt-dark{--event-background-color:#161514;background-color:transparent!important}:host,mgt-agenda{--card-height:auto;--card-width:99%}:host .header,mgt-agenda .header{margin:var(--agenda-header-margin,18px 0 12px 10px);font-family:var(--default-font-family);font-size:var(--agenda-header-font-size,24px);font-style:normal;font-weight:400;line-height:32px;color:var(--agenda-header-color,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)));opacity:.9}:host .agenda,:host .group,mgt-agenda .agenda,mgt-agenda .group{display:flex;flex-direction:column;row-gap:var(--event-row-gap,14px)}:host .agenda>.group:first-child>.header,:host .group>.group:first-child>.header,mgt-agenda .agenda>.group:first-child>.header,mgt-agenda .group>.group:first-child>.header{margin-top:0}:host .agenda .event,:host .group .event,mgt-agenda .agenda .event,mgt-agenda .group .event{background:var(--event-background-color,#fff);border:var(--event-border,solid 2px transparent);box-shadow:var(--elevation-shadow-card-rest,--event-box-shadow);padding:var(--event-padding,12px);position:relative;display:flex;flex:1 1 auto;content-visibility:visible;contain:none}:host .agenda .event-container,:host .group .event-container,mgt-agenda .agenda .event-container,mgt-agenda .group .event-container{border-radius:calc(var(--layer-corner-radius) * 1px);padding:1px}:host .agenda .event.narrow,:host .group .event.narrow,mgt-agenda .agenda .event.narrow,mgt-agenda .group .event.narrow{display:flex;flex-direction:column;inset:0}:host .agenda .event-time-container,:host .group .event-time-container,mgt-agenda .agenda .event-time-container,mgt-agenda .group .event-time-container{font-family:var(--default-font-family);font-style:normal;font-weight:600;font-size:12px;color:var(--event-time-color,var(--color,#000));width:112px;height:16px}:host .agenda .event-time-container.narrow,:host .group .event-time-container.narrow,mgt-agenda .agenda .event-time-container.narrow,mgt-agenda .group .event-time-container.narrow{margin-bottom:1px;width:100%}:host .agenda .event-time-container .event-time-loading.loading-element,:host .group .event-time-container .event-time-loading.loading-element,mgt-agenda .agenda .event-time-container .event-time-loading.loading-element,mgt-agenda .group .event-time-container .event-time-loading.loading-element{background:var(--event-background-color,#fff);border-radius:1px}:host .agenda .event-time,:host .group .event-time,mgt-agenda .agenda .event-time,mgt-agenda .group .event-time{font-size:var(--event-time-font-size,12px);color:var(--event-time-color,var(--color,#000));font-weight:600}:host .agenda .event-details-container,:host .group .event-details-container,mgt-agenda .agenda .event-details-container,mgt-agenda .group .event-details-container{display:flex;flex-direction:column;position:relative;bottom:8px;top:0;padding-inline-start:32px}:host .agenda .event-details-container.narrow,:host .group .event-details-container.narrow,mgt-agenda .agenda .event-details-container.narrow,mgt-agenda .group .event-details-container.narrow{position:inherit;left:6px;display:flex;flex-direction:column;padding-inline-start:0}:host .agenda .event-details-container .event-subject-loading.loading-element,:host .group .event-details-container .event-subject-loading.loading-element,mgt-agenda .agenda .event-details-container .event-subject-loading.loading-element,mgt-agenda .group .event-details-container .event-subject-loading.loading-element{background:var(--event-background-color,#fff);border-radius:1px}:host .agenda .event-subject,:host .group .event-subject,mgt-agenda .agenda .event-subject,mgt-agenda .group .event-subject{font-family:var(--default-font-family);font-style:normal;font-weight:400;font-size:var(--event-subject-font-size,20px);line-height:28px;color:var(--event-subject-color,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)));mix-blend-mode:normal;position:inherit;bottom:8px}:host .agenda .event-location-container,:host .group .event-location-container,mgt-agenda .agenda .event-location-container,mgt-agenda .group .event-location-container{display:inline-flex;flex-direction:row}:host .agenda .event-location-container .event-location,:host .group .event-location-container .event-location,mgt-agenda .agenda .event-location-container .event-location,mgt-agenda .group .event-location-container .event-location{padding-inline-start:3px;font-family:var(--default-font-family);font-style:normal;font-weight:400;font-size:var(--event-location-font-size,12px);line-height:16px;color:var(--event-location-color,var(--color,#000))}:host .agenda .event-location-container .event-location-loading,:host .group .event-location-container .event-location-loading,mgt-agenda .agenda .event-location-container .event-location-loading,mgt-agenda .group .event-location-container .event-location-loading{width:90px;height:10px;margin:2px 0 0 4px}:host .agenda .event-location-container .event-location-loading.loading-element,:host .group .event-location-container .event-location-loading.loading-element,mgt-agenda .agenda .event-location-container .event-location-loading.loading-element,mgt-agenda .group .event-location-container .event-location-loading.loading-element{background:var(--event-background-color,#fff);border-radius:1px}:host .agenda .event-location-container .event-location-icon svg,:host .group .event-location-container .event-location-icon svg,mgt-agenda .agenda .event-location-container .event-location-icon svg,mgt-agenda .group .event-location-container .event-location-icon svg{position:relative;top:2px;width:12px;height:12px}:host .agenda .event-location-container .event-location-icon svg path,:host .group .event-location-container .event-location-icon svg path,mgt-agenda .agenda .event-location-container .event-location-icon svg path,mgt-agenda .group .event-location-container .event-location-icon svg path{stroke:var(--event-location-color,var(--color,#000))}:host .agenda .event-location-container .event-location-icon-loading,:host .group .event-location-container .event-location-icon-loading,mgt-agenda .agenda .event-location-container .event-location-icon-loading,mgt-agenda .group .event-location-container .event-location-icon-loading{width:14px;height:14px}:host .agenda .event-location-container .event-location-icon-loading.loading-element,:host .group .event-location-container .event-location-icon-loading.loading-element,mgt-agenda .agenda .event-location-container .event-location-icon-loading.loading-element,mgt-agenda .group .event-location-container .event-location-icon-loading.loading-element{background:var(--event-background-color,#fff);border-radius:1px}:host .agenda .event-location-container .event-attendee-loading,:host .group .event-location-container .event-attendee-loading,mgt-agenda .agenda .event-location-container .event-attendee-loading,mgt-agenda .group .event-location-container .event-attendee-loading{width:20px;height:20px;border-radius:10px;margin:0 2px 0 0}:host .agenda .event-location-container .event-attendee-loading.loading-element,:host .group .event-location-container .event-attendee-loading.loading-element,mgt-agenda .agenda .event-location-container .event-attendee-loading.loading-element,mgt-agenda .group .event-location-container .event-attendee-loading.loading-element{background:var(--event-background-color,#fff);border-radius:1px}:host .agenda .event-attendees,:host .group .event-attendees,mgt-agenda .agenda .event-attendees,mgt-agenda .group .event-attendees{--list-margin:8px 0 0 0;--avatar-size-s:20px}fluent-card.event.event-loading{--card-height:90px}:host mgt-people{--color:$event__attendees__color}:host fluent-tooltip{width:auto;contain:inline-size}[dir=rtl] :host{direction:rtl}[dir=rtl] .event-time-container{direction:ltr;display:flex;justify-content:flex-end}@media (forced-colors:active) and (prefers-color-scheme:dark){:host .agenda .event-location-container .event-location-icon svg path,mgt-agenda .agenda .event-location-container .event-location-icon svg path{stroke:#fff!important}}@media (forced-colors:active) and (prefers-color-scheme:light){:host .agenda .event-location-container .event-location-icon svg path,mgt-agenda .agenda .event-location-container .event-location-icon svg path{stroke:#000!important}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-agenda/mgt-agenda.graph.js
init_es6();
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getEventsPageIterator(graph, startDateTime, endDateTime, groupId) {
  return __awaiter7(this, void 0, void 0, function* () {
    const scopes = "calendars.read";
    const sdt = `startdatetime=${startDateTime.toISOString()}`;
    const edt = `enddatetime=${endDateTime.toISOString()}`;
    let uri;
    if (groupId) {
      uri = `groups/${groupId}/calendar`;
    } else {
      uri = "me";
    }
    uri += `/calendarview?${sdt}&${edt}`;
    let request = graph.api(uri).middlewareOptions(prepScopes(scopes)).orderby("start/dateTime");
    return GraphPageIterator.create(graph, request);
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people/mgt-people.js
init_lit();
init_decorators();

// node_modules/lit-html/development/directives/repeat.js
init_lit_html();

// node_modules/lit-html/development/directive-helpers.js
init_lit_html();
var _a;
var _b;
var { _ChildPart: ChildPart } = _$LH;
var ENABLE_SHADYDOM_NOPATCH = true;
var wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
var createMarker = () => document.createComment("");
var insertPart = (containerPart, refPart, part) => {
  var _a2;
  const container = wrap(containerPart._$startNode).parentNode;
  const refNode = refPart === void 0 ? containerPart._$endNode : refPart._$startNode;
  if (part === void 0) {
    const startNode = wrap(container).insertBefore(createMarker(), refNode);
    const endNode = wrap(container).insertBefore(createMarker(), refNode);
    part = new ChildPart(startNode, endNode, containerPart, containerPart.options);
  } else {
    const endNode = wrap(part._$endNode).nextSibling;
    const oldParent = part._$parent;
    const parentChanged = oldParent !== containerPart;
    if (parentChanged) {
      (_a2 = part._$reparentDisconnectables) === null || _a2 === void 0 ? void 0 : _a2.call(part, containerPart);
      part._$parent = containerPart;
      let newConnectionState;
      if (part._$notifyConnectionChanged !== void 0 && (newConnectionState = containerPart._$isConnected) !== oldParent._$isConnected) {
        part._$notifyConnectionChanged(newConnectionState);
      }
    }
    if (endNode !== refNode || parentChanged) {
      let start = part._$startNode;
      while (start !== endNode) {
        const n = wrap(start).nextSibling;
        wrap(container).insertBefore(start, refNode);
        start = n;
      }
    }
  }
  return part;
};
var setChildPartValue = (part, value, directiveParent = part) => {
  part._$setValue(value, directiveParent);
  return part;
};
var RESET_VALUE = {};
var setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;
var getCommittedValue = (part) => part._$committedValue;
var removePart = (part) => {
  var _a2;
  (_a2 = part._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(part, false, true);
  let start = part._$startNode;
  const end = wrap(part._$endNode).nextSibling;
  while (start !== end) {
    const n = wrap(start).nextSibling;
    wrap(start).remove();
    start = n;
  }
};

// node_modules/lit-html/development/directives/repeat.js
var generateMap = (list, start, end) => {
  const map = /* @__PURE__ */ new Map();
  for (let i = start; i <= end; i++) {
    map.set(list[i], i);
  }
  return map;
};
var RepeatDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error("repeat() can only be used in text expressions");
    }
  }
  _getValuesAndKeys(items, keyFnOrTemplate, template) {
    let keyFn;
    if (template === void 0) {
      template = keyFnOrTemplate;
    } else if (keyFnOrTemplate !== void 0) {
      keyFn = keyFnOrTemplate;
    }
    const keys = [];
    const values = [];
    let index = 0;
    for (const item of items) {
      keys[index] = keyFn ? keyFn(item, index) : index;
      values[index] = template(item, index);
      index++;
    }
    return {
      values,
      keys
    };
  }
  render(items, keyFnOrTemplate, template) {
    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;
  }
  update(containerPart, [items, keyFnOrTemplate, template]) {
    var _a2;
    const oldParts = getCommittedValue(containerPart);
    const { values: newValues, keys: newKeys } = this._getValuesAndKeys(items, keyFnOrTemplate, template);
    if (!Array.isArray(oldParts)) {
      this._itemKeys = newKeys;
      return newValues;
    }
    const oldKeys = (_a2 = this._itemKeys) !== null && _a2 !== void 0 ? _a2 : this._itemKeys = [];
    const newParts = [];
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldHead], newValues[newTail]);
        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldTail], newValues[newHead]);
        insertPart(containerPart, oldParts[oldHead], oldParts[oldTail]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === void 0) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== void 0 ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = insertPart(containerPart, oldParts[oldHead]);
            setChildPartValue(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);
            insertPart(containerPart, oldParts[oldHead], oldPart);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = insertPart(containerPart, newParts[newTail + 1]);
      setChildPartValue(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    this._itemKeys = newKeys;
    setCommittedValue(containerPart, newParts);
    return noChange;
  }
};
var repeat = directive(RepeatDirective);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people/mgt-people.js
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people/mgt-people-css.js
init_lit();
var styles5 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}:host .people-list,mgt-people .people-list{list-style-type:none;margin:var(--list-margin,8px 4px 8px 8px);padding:0;font-family:var(--default-font-family);color:var(--color,#000);font-style:normal;font-weight:400;display:flex;align-items:center}:host .people-person,mgt-people .people-person{margin:var(--avatar-margin,0 4px 0 0);display:flex}:host .overflow span,mgt-people .overflow span{vertical-align:middle;color:var(--color,#1a1a1a);font-size:12px;font-weight:400}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people/mgt-people.js
var __decorate4 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata3 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtPeople = class MgtPeople2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles5;
  }
  /**
   * determines if agenda events come from specific group
   * @type {string}
   */
  get groupId() {
    return this._groupId;
  }
  set groupId(value) {
    if (this._groupId === value) {
      return;
    }
    this._groupId = value;
    this.requestStateUpdate(true);
  }
  /**
   * user id array
   *
   * @memberof MgtPeople
   */
  get userIds() {
    return this._userIds;
  }
  set userIds(value) {
    if (arraysAreEqual(this._userIds, value)) {
      return;
    }
    this._userIds = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to define queries of people for component
   * @type {string[]}
   */
  get peopleQueries() {
    return this._peopleQueries;
  }
  set peopleQueries(value) {
    if (arraysAreEqual(this._peopleQueries, value)) {
      return;
    }
    this._peopleQueries = value;
    this.requestStateUpdate(true);
  }
  /**
   * The resource to get
   *
   * @type {string}
   * @memberof MgtPeople
   */
  get resource() {
    return this._resource;
  }
  set resource(value) {
    if (this._resource === value) {
      return;
    }
    this._resource = value;
    this.requestStateUpdate(true);
  }
  /**
   * Api version to use for request
   *
   * @type {string}
   * @memberof MgtPeople
   */
  get version() {
    return this._version;
  }
  set version(value) {
    if (this._version === value) {
      return;
    }
    this._version = value;
    this.requestStateUpdate(true);
  }
  /**
   * Fallback when no user is found
   * @type {IDynamicPerson[]}
   */
  get fallbackDetails() {
    return this._fallbackDetails;
  }
  set fallbackDetails(value) {
    if (value === this._fallbackDetails) {
      return;
    }
    this._fallbackDetails = value;
    this.requestStateUpdate();
  }
  /**
   * Get the scopes required for people
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtPeople
   */
  static get requiredScopes() {
    return [
      .../* @__PURE__ */ new Set([
        "user.read.all",
        "people.read",
        "user.readbasic.all",
        "presence.read.all",
        "contacts.read",
        ...MgtPerson.requiredScopes
      ])
    ];
  }
  constructor() {
    super();
    this.personCardInteraction = PersonCardInteraction.hover;
    this.scopes = [];
    this._version = "v1.0";
    this.showMax = 3;
  }
  /**
   * Clears the state of the component
   *
   * @protected
   * @memberof MgtPeople
   */
  clearState() {
    this.people = null;
  }
  /**
   * Request to reload the state.
   * Use reload instead of load to ensure loading events are fired.
   *
   * @protected
   * @memberof MgtBaseComponent
   */
  requestStateUpdate(force) {
    if (force) {
      this.people = null;
    }
    return super.requestStateUpdate(force);
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    if (this.isLoadingState) {
      return this.renderLoading();
    }
    if (!this.people || this.people.length === 0) {
      return this.renderNoData();
    }
    return this.renderTemplate("default", { people: this.people, max: this.showMax }) || this.renderPeople();
  }
  /**
   * Render the loading state.
   *
   * @protected
   * @returns
   * @memberof MgtPeople
   */
  renderLoading() {
    return this.renderTemplate("loading", null) || html``;
  }
  /**
   * Render the list of people.
   *
   * @protected
   * @param {*} people
   * @returns {TemplateResult}
   * @memberof MgtPeople
   */
  renderPeople() {
    const maxPeople = this.people.slice(0, this.showMax).filter((pple) => pple);
    return html`
      <ul class="people-list" aria-label="people">
        ${repeat(maxPeople, (p) => p.id ? p.id : p.displayName, (p) => html`
            <li class="people-person">
              ${this.renderPerson(p)}
            </li>
          `)}
        ${this.people.length > this.showMax ? this.renderOverflow() : null}
      </ul>
    `;
  }
  /**
   * Render the overflow content to represent any extra people, beyond the max.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeople
   */
  renderOverflow() {
    const extra = this.people.length - this.showMax;
    return this.renderTemplate("overflow", {
      extra,
      max: this.showMax,
      people: this.people
    }) || html`
        <li aria-label="and ${extra} more attendees" class="overflow"><span>+${extra}<span></li>
      `;
  }
  /**
   * Render an individual person.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeople
   */
  renderPerson(person) {
    let personPresence = {
      // set up default presence
      activity: "Offline",
      availability: "Offline",
      id: null
    };
    if (this.showPresence && this._peoplePresence) {
      personPresence = this._peoplePresence[person.id];
    }
    const avatarSize = "small";
    return this.renderTemplate("person", { person }, person.id) || // set image to @ to flag the mgt-person component to
    // query the image from the graph
    mgtHtml`
        <mgt-person
          .personDetails=${person}
          .fetchImage=${true}
          .avatarSize=${avatarSize}
          .personCardInteraction=${this.personCardInteraction}
          .showPresence=${this.showPresence}
          .personPresence=${personPresence}
          .usage=${"people"}
        ></mgt-person>
      `;
  }
  /**
   * render the no data state.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeople
   */
  renderNoData() {
    return this.renderTemplate("no-data", null) || html``;
  }
  /**
   * load state into the component.
   *
   * @protected
   * @returns
   * @memberof MgtPeople
   */
  loadState() {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!this.people) {
        const provider = Providers.globalProvider;
        if (provider && provider.state === ProviderState.SignedIn) {
          const graph = provider.graph.forComponent(this);
          if (this.groupId) {
            this.people = yield findGroupMembers(graph, null, this.groupId, this.showMax, PersonType.person);
          } else if (this.userIds || this.peopleQueries) {
            this.userIds ? this.people = yield getUsersForUserIds(graph, this.userIds, "", "", this._fallbackDetails) : this.people = yield getUsersForPeopleQueries(graph, this.peopleQueries, this._fallbackDetails);
          } else if (this.resource) {
            this.people = yield getPeopleFromResource(graph, this.version, this.resource, this.scopes);
          } else {
            this.people = yield getPeople(graph);
          }
          if (this.showPresence) {
            this._peoplePresence = yield getUsersPresenceByPeople(graph, this.people);
          } else {
            this._peoplePresence = null;
          }
        }
      }
    });
  }
};
__decorate4([
  property({
    attribute: "group-id",
    type: String
  }),
  __metadata3("design:type", String),
  __metadata3("design:paramtypes", [Object])
], MgtPeople.prototype, "groupId", null);
__decorate4([
  property({
    attribute: "user-ids",
    converter: (value, type) => {
      return value.split(",").map((v) => v.trim());
    }
  }),
  __metadata3("design:type", Array),
  __metadata3("design:paramtypes", [Array])
], MgtPeople.prototype, "userIds", null);
__decorate4([
  property({
    attribute: "people",
    type: Object
  }),
  __metadata3("design:type", Array)
], MgtPeople.prototype, "people", void 0);
__decorate4([
  property({
    attribute: "people-queries",
    converter: (value, type) => {
      return value.split(",").map((v) => v.trim());
    }
  }),
  __metadata3("design:type", Array),
  __metadata3("design:paramtypes", [Array])
], MgtPeople.prototype, "peopleQueries", null);
__decorate4([
  property({
    attribute: "show-max",
    type: Number
  }),
  __metadata3("design:type", Number)
], MgtPeople.prototype, "showMax", void 0);
__decorate4([
  property({
    attribute: "show-presence",
    type: Boolean
  }),
  __metadata3("design:type", Boolean)
], MgtPeople.prototype, "showPresence", void 0);
__decorate4([
  property({
    attribute: "person-card",
    converter: (value, type) => {
      value = value.toLowerCase();
      if (typeof PersonCardInteraction[value] === "undefined") {
        return PersonCardInteraction.hover;
      } else {
        return PersonCardInteraction[value];
      }
    }
  }),
  __metadata3("design:type", Number)
], MgtPeople.prototype, "personCardInteraction", void 0);
__decorate4([
  property({
    attribute: "resource",
    type: String
  }),
  __metadata3("design:type", String),
  __metadata3("design:paramtypes", [Object])
], MgtPeople.prototype, "resource", null);
__decorate4([
  property({
    attribute: "version",
    type: String
  }),
  __metadata3("design:type", String),
  __metadata3("design:paramtypes", [Object])
], MgtPeople.prototype, "version", null);
__decorate4([
  property({
    attribute: "scopes",
    converter: (value) => {
      return value ? value.toLowerCase().split(",") : null;
    },
    reflect: true
  }),
  __metadata3("design:type", Array)
], MgtPeople.prototype, "scopes", void 0);
__decorate4([
  property({
    attribute: "fallback-details",
    type: Array
  }),
  __metadata3("design:type", Array),
  __metadata3("design:paramtypes", [Array])
], MgtPeople.prototype, "fallbackDetails", null);
MgtPeople = __decorate4([
  customElement("people"),
  __metadata3("design:paramtypes", [])
], MgtPeople);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-agenda/mgt-agenda.js
init_FluentComponents();
init_esm3();
var __decorate6 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata4 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
registerFluentComponents(fluentCard, fluentTooltip);
var MgtAgenda = class MgtAgenda2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles4;
  }
  /**
   * stores current date for initial calender selection in events.
   * @type {string}
   */
  get date() {
    return this._date;
  }
  set date(value) {
    if (this._date === value) {
      return;
    }
    this._date = value;
    this.reloadState();
  }
  /**
   * determines if agenda events come from specific group
   * @type {string}
   */
  get groupId() {
    return this._groupId;
  }
  set groupId(value) {
    if (this._groupId === value) {
      return;
    }
    this._groupId = value;
    this.reloadState();
  }
  /**
   * sets number of days until end date, 3 is the default
   * @type {number}
   */
  get days() {
    return this._days;
  }
  set days(value) {
    if (this._days === value) {
      return;
    }
    this._days = value;
    this.reloadState();
  }
  /**
   * allows developer to specify a different graph query that retrieves events
   * @type {string}
   */
  get eventQuery() {
    return this._eventQuery;
  }
  set eventQuery(value) {
    if (this._eventQuery === value) {
      return;
    }
    this._eventQuery = value;
    this.reloadState();
  }
  /**
   * allows developer to specify preferred timezone that should be used for
   * retrieving events from Graph, eg. `Pacific Standard Time`. The preferred timezone for
   * the current user can be retrieved by calling `me/mailboxSettings` and
   * retrieving the value of the `timeZone` property.
   * @type {string}
   */
  get preferredTimezone() {
    return this._preferredTimezone;
  }
  set preferredTimezone(value) {
    if (this._preferredTimezone === value) {
      return;
    }
    this._preferredTimezone = value;
    this.reloadState();
  }
  /**
   * Get the scopes required for agenda
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtAgenda
   */
  static get requiredScopes() {
    return [.../* @__PURE__ */ new Set(["calendars.read", ...MgtPeople.requiredScopes])];
  }
  constructor() {
    super();
    this._days = 3;
    this.onResize = this.onResize.bind(this);
  }
  /**
   * Determines width available if resize is necessary, adds onResize event listener to window
   *
   * @memberof MgtAgenda
   */
  connectedCallback() {
    this._isNarrow = this.offsetWidth < 600;
    super.connectedCallback();
    window.addEventListener("resize", this.onResize);
  }
  /**
   * Removes onResize event listener from window
   *
   * @memberof MgtAgenda
   */
  disconnectedCallback() {
    window.removeEventListener("resize", this.onResize);
    super.disconnectedCallback();
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return a lit-html TemplateResult.
   * Setting properties inside this method will not trigger the element to update
   *
   * @returns
   * @memberof MgtAgenda
   */
  render() {
    if (!this.events && this.isLoadingState) {
      return this.renderLoading();
    }
    if (!this.events || this.events.length === 0) {
      return this.renderNoData();
    }
    const events = this.showMax && this.showMax > 0 ? this.events.slice(0, this.showMax) : this.events;
    const renderedTemplate = this.renderTemplate("default", { events });
    if (renderedTemplate) {
      return renderedTemplate;
    }
    const agendaClasses = {
      agenda: true,
      grouped: this.groupByDay
    };
    return html`
      <div dir=${this.direction} class="${classMap(agendaClasses)}">
        ${this.groupByDay ? this.renderGroups(events) : this.renderEvents(events)}
        ${this.isLoadingState ? this.renderLoading() : html``}
      </div>
    `;
  }
  /**
   * Reloads the component with its current settings and potential new data
   *
   * @memberof MgtAgenda
   */
  reload() {
    return __awaiter9(this, void 0, void 0, function* () {
      this.events = yield this.loadEvents();
    });
  }
  /**
   * Render the loading state
   *
   * @protected
   * @returns
   * @memberof MgtAgenda
   */
  renderLoading() {
    return this.renderTemplate("loading", null) || html`
        <fluent-card class="event event-loading">
          <div class="event-time-container">
            <div class="event-time-loading loading-element"></div>
          </div>
          <div class="event-details-container">
            <div class="event-subject-loading loading-element"></div>
            <div class="event-location-container">
              <div class="event-location-icon-loading loading-element"></div>
              <div class="event-location-loading loading-element"></div>
            </div>
            <div class="event-location-container">
              <div class="event-attendee-loading loading-element"></div>
              <div class="event-attendee-loading loading-element"></div>
              <div class="event-attendee-loading loading-element"></div>
            </div>
          </div>
        </fluent-card>`;
  }
  /**
   * Clears state of the component
   *
   * @protected
   * @memberof MgtAgenda
   */
  clearState() {
    this.events = null;
  }
  /**
   * Render the no-data state.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtAgenda
   */
  renderNoData() {
    return this.renderTemplate("no-data", null) || html``;
  }
  /**
   * Render an individual Event.
   *
   * @protected
   * @param {MicrosoftGraph.Event} event
   * @returns
   * @memberof MgtAgenda
   */
  renderEvent(event) {
    this._isNarrow = this.offsetWidth < 600;
    const eventClasses = {
      narrow: this._isNarrow
    };
    return html`
      <fluent-card class="${classMap(Object.assign({ event: true }, eventClasses))}">
        <div class="${classMap(Object.assign({ "event-time-container": true }, eventClasses))}">
          <div class="event-time" aria-label="${this.getEventTimeString(event)}">${this.getEventTimeString(event)}</div>
        </div>
        <div class="${classMap(Object.assign({ "event-details-container": true }, eventClasses))}">
          ${this.renderTitle(event)} ${this.renderLocation(event)} ${this.renderAttendees(event)}
        </div>
        <div class="event-other-container">${this.renderOther(event)}</div>
      </fluent-card>
    `;
  }
  /**
   * Render the header for a group.
   * Only relevant for grouped Events.
   *
   * @protected
   * @param {Date} date
   * @returns
   * @memberof MgtAgenda
   */
  renderHeader(header) {
    return this.renderTemplate("header", { header }, "header-" + header) || html`
        <div class="header" aria-label="${header}">${header}</div>
      `;
  }
  /**
   * Render the title field of an Event
   *
   * @protected
   * @param {MicrosoftGraph.Event} event
   * @returns
   * @memberof MgtAgenda
   */
  renderTitle(event) {
    let eventDescription = (event === null || event === void 0 ? void 0 : event.bodyPreview) ? event.bodyPreview.slice(0, 100) : "";
    const hasDescription = eventDescription !== "";
    const eventSubjectClasses = {
      "event-subject": true,
      narrow: this._isNarrow
    };
    eventDescription = eventDescription.split(" ").slice(0, -1).join(" ") + "...";
    const hasDescriptionDiv = html`
      <div
        aria-describedby="tooltip-${event.id}"
        class="${classMap(eventSubjectClasses)}"
        id=${event.id}>
          ${event.subject}
      </div>
      <fluent-tooltip
        id="tooltip-${event.id}"
        position="right"
        anchor="${event.id}">
          ${eventDescription}
      </fluent-tooltip>
    `;
    const noDescriptionDiv = html`
      <div
        aria-label=${event.subject}
        class="${classMap(eventSubjectClasses)}">
          ${event.subject}
      </div>`;
    return hasDescription ? hasDescriptionDiv : noDescriptionDiv;
  }
  /**
   * Render the location field of an Event
   *
   * @protected
   * @param {MicrosoftGraph.Event} event
   * @returns
   * @memberof MgtAgenda
   */
  renderLocation(event) {
    if (!event.location.displayName) {
      return null;
    }
    return html`
      <div class="event-location-container">
        <div class="event-location-icon">${getSvg(SvgIcon.OfficeLocation)}</div>
        <div class="event-location" aria-label="${event.location.displayName}">${event.location.displayName}</div>
      </div>
    `;
  }
  /**
   * Render the attendees field of an Event
   *
   * @protected
   * @param {MicrosoftGraph.Event} event
   * @returns
   * @memberof MgtAgenda
   */
  renderAttendees(event) {
    if (!event.attendees.length) {
      return null;
    }
    return mgtHtml`
      <mgt-people
        show-max="5"
        show-presence
        class="event-attendees"
        .peopleQueries=${event.attendees.map((attendee) => {
      return attendee.emailAddress.address;
    })}
      ></mgt-people>
    `;
  }
  /**
   * Render the event other field of an Event
   *
   * @protected
   * @param {MicrosoftGraph.Event} event
   * @returns
   * @memberof MgtAgenda
   */
  renderOther(event) {
    return this.hasTemplate("event-other") ? html`
          ${this.renderTemplate("event-other", { event }, event.id + "-other")}
        ` : null;
  }
  /**
   * Render the events in groups, each with a header.
   *
   * @protected
   * @param {MicrosoftGraph.Event[]} events
   * @returns {TemplateResult}
   * @memberof MgtAgenda
   */
  renderGroups(events) {
    const grouped = {};
    events.forEach((event) => {
      var _a2;
      let dateString = (_a2 = event === null || event === void 0 ? void 0 : event.start) === null || _a2 === void 0 ? void 0 : _a2.dateTime;
      if (event.end.timeZone === "UTC") {
        dateString += "Z";
      }
      const header = this.getDateHeaderFromDateTimeString(dateString);
      grouped[header] = grouped[header] || [];
      grouped[header].push(event);
    });
    return html`
      ${Object.keys(grouped).map((header) => html`
            <div class="group">${this.renderHeader(header)} ${this.renderEvents(grouped[header])}</div>
          `)}
    `;
  }
  /**
   * Render a list of events.
   *
   * @protected
   * @param {MicrosoftGraph.Event[]} events
   * @returns {TemplateResult}
   * @memberof MgtAgenda
   */
  renderEvents(events) {
    return html`
        ${events.map((event) => html`
              <div
                class="event-container"
                tabindex="0"
                @focus=${() => this.eventClicked(event)}>
                ${this.renderTemplate("event", { event }, event.id) || this.renderEvent(event)}
              </div>`)}`;
  }
  /**
   * Load state into the component
   *
   * @protected
   * @returns
   * @memberof MgtAgenda
   */
  loadState() {
    return __awaiter9(this, void 0, void 0, function* () {
      if (this.events) {
        return;
      }
      const events = yield this.loadEvents();
      if (events && events.length > 0) {
        this.events = events;
      }
    });
  }
  reloadState() {
    return __awaiter9(this, void 0, void 0, function* () {
      this.events = null;
      this.requestStateUpdate(true);
    });
  }
  onResize() {
    this._isNarrow = this.offsetWidth < 600;
  }
  eventClicked(event) {
    this.fireCustomEvent("eventClick", event);
  }
  getEventTimeString(event) {
    if (event.isAllDay) {
      return "ALL DAY";
    }
    let startString = event.start.dateTime;
    if (event.start.timeZone === "UTC") {
      startString += "Z";
    }
    let endString = event.end.dateTime;
    if (event.end.timeZone === "UTC") {
      endString += "Z";
    }
    const start = this.prettyPrintTimeFromDateTime(new Date(startString));
    const end = this.prettyPrintTimeFromDateTime(new Date(endString));
    return `${start} - ${end}`;
  }
  loadEvents() {
    return __awaiter9(this, void 0, void 0, function* () {
      const p = Providers.globalProvider;
      let events = [];
      if (p && p.state === ProviderState.SignedIn) {
        const graph = p.graph.forComponent(this);
        if (this.eventQuery) {
          try {
            const tokens = this.eventQuery.split("|");
            let scope;
            let query;
            if (tokens.length > 1) {
              query = tokens[0].trim();
              scope = tokens[1].trim();
            } else {
              query = this.eventQuery;
            }
            let request = graph.api(query);
            if (scope) {
              request = request.middlewareOptions(prepScopes(scope));
            }
            const results = yield request.get();
            if (results && results.value) {
              events = results.value;
            }
          } catch (e) {
          }
        } else {
          const start = this.date ? new Date(this.date) : /* @__PURE__ */ new Date();
          const end = new Date(start.getTime());
          end.setDate(start.getDate() + this.days);
          try {
            const iterator = yield getEventsPageIterator(graph, start, end, this.groupId);
            if (iterator && iterator.value) {
              events = iterator.value;
              while (iterator.hasNext) {
                yield iterator.next();
                events = iterator.value;
              }
            }
          } catch (error) {
          }
        }
      }
      return events;
    });
  }
  prettyPrintTimeFromDateTime(date) {
    return date.toLocaleTimeString(navigator.language, {
      timeStyle: "short",
      timeZone: this.preferredTimezone
    });
  }
  getDateHeaderFromDateTimeString(dateTimeString) {
    const date = new Date(dateTimeString);
    return date.toLocaleDateString(navigator.language, {
      dateStyle: "full",
      timeZone: this.preferredTimezone
    });
  }
};
__decorate6([
  property({
    attribute: "date",
    type: String
  }),
  __metadata4("design:type", String),
  __metadata4("design:paramtypes", [Object])
], MgtAgenda.prototype, "date", null);
__decorate6([
  property({
    attribute: "group-id",
    type: String
  }),
  __metadata4("design:type", String),
  __metadata4("design:paramtypes", [Object])
], MgtAgenda.prototype, "groupId", null);
__decorate6([
  property({
    attribute: "days",
    type: Number
  }),
  __metadata4("design:type", Number),
  __metadata4("design:paramtypes", [Object])
], MgtAgenda.prototype, "days", null);
__decorate6([
  property({
    attribute: "event-query",
    type: String
  }),
  __metadata4("design:type", String),
  __metadata4("design:paramtypes", [Object])
], MgtAgenda.prototype, "eventQuery", null);
__decorate6([
  property({
    attribute: "events",
    type: Array
  }),
  __metadata4("design:type", Array)
], MgtAgenda.prototype, "events", void 0);
__decorate6([
  property({
    attribute: "show-max",
    type: Number
  }),
  __metadata4("design:type", Number)
], MgtAgenda.prototype, "showMax", void 0);
__decorate6([
  property({
    attribute: "group-by-day",
    type: Boolean
  }),
  __metadata4("design:type", Boolean)
], MgtAgenda.prototype, "groupByDay", void 0);
__decorate6([
  property({
    attribute: "preferred-timezone",
    type: String
  }),
  __metadata4("design:type", String),
  __metadata4("design:paramtypes", [Object])
], MgtAgenda.prototype, "preferredTimezone", null);
__decorate6([
  property({ attribute: false }),
  __metadata4("design:type", Boolean)
], MgtAgenda.prototype, "_isNarrow", void 0);
MgtAgenda = __decorate6([
  customElement("agenda"),
  __metadata4("design:paramtypes", [])
], MgtAgenda);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file/mgt-file.js
init_lit();
init_decorators();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file/mgt-file-css.js
init_lit();
var styles6 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{background-color:#fff}.mgt-dark{background-color:#424242}:host{font-family:var(--font-family,var(--default-font-family))}:host .item,mgt-file .item{display:flex;flex-flow:row nowrap;align-items:center;background-color:var(background-color,#fff)}:host .item__file-type-icon,mgt-file .item__file-type-icon{height:var(--file-type-icon-height,28px);display:flex;align-items:center;justify-content:center}:host .item__file-type-icon img,mgt-file .item__file-type-icon img{height:var(--file-type-icon-height,28px)}:host .item__details,mgt-file .item__details{padding-inline-start:var(--file-padding-inline-start,14px)}:host .item__details .line1,mgt-file .item__details .line1{font-size:var(--font-size,14px);font-weight:var(--font-weight,400);text-transform:var(text-transform,none);line-height:20px;color:var(--line1-color,var(--color,#000))}:host .item__details .line2,mgt-file .item__details .line2{color:var(--line2-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:var(--line2-font-size,var(--last-modified-font-size,12px));font-weight:var(--line2-font-weight,400);text-transform:var(--line2-text-transform,var(text-transform,none));line-height:16px}:host .item__details .line3,mgt-file .item__details .line3{color:var(--line3-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:var(--line3-font-size,var(--size-font-size,12px));font-weight:var(--line3-font-weight,400);text-transform:var(--line3-text-transform,var(text-transform,none));line-height:16px}[dir=rtl] .item{direction:rtl}[dir=rtl] .item__details{direction:rtl}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file/mgt-file.js
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.files.js
init_es6();
init_browser();
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function clearFilesCache() {
  let cache2;
  cache2 = CacheService.getCache(schemas.fileLists, schemas.fileLists.stores.fileLists);
  cache2.clearStore();
}
var getFileInvalidationTime = () => CacheService.config.files.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsFilesCacheEnabled = () => CacheService.config.files.isEnabled && CacheService.config.isEnabled;
var getFileListInvalidationTime = () => CacheService.config.fileLists.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsFileListsCacheEnabled = () => CacheService.config.fileLists.isEnabled && CacheService.config.isEnabled;
function getDriveItemByQuery(graph, resource) {
  return __awaiter10(this, void 0, void 0, function* () {
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.fileQueries);
    const cachedFile = yield getFileFromCache(cache2, resource);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(resource).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(resource, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getDriveItemById(graph, driveId, itemId) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/items/${itemId}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.driveFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getDriveItemByPath(graph, driveId, itemPath) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/root:/${itemPath}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.driveFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getGroupDriveItemById(graph, groupId, itemId) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/items/${itemId}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.groupFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getGroupDriveItemByPath(graph, groupId, itemPath) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/root:/${itemPath}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.groupFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getMyDriveItemById(graph, itemId) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/me/drive/items/${itemId}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.userFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getMyDriveItemByPath(graph, itemPath) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/me/drive/root:/${itemPath}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.userFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getSiteDriveItemById(graph, siteId, itemId) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/items/${itemId}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.siteFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getSiteDriveItemByPath(graph, siteId, itemPath) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/root:/${itemPath}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.siteFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getListDriveItemById(graph, siteId, listId, itemId) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/lists/${listId}/items/${itemId}/driveItem`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.siteFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getUserDriveItemById(graph, userId, itemId) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/items/${itemId}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.userFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getUserDriveItemByPath(graph, userId, itemPath) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/root:/${itemPath}`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.userFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "files.read";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getMyInsightsDriveItemById(graph, insightType, id) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/me/insights/${insightType}/${id}/resource`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.insightFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "sites.read.all";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getUserInsightsDriveItemById(graph, userId, insightType, id) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/insights/${insightType}/${id}/resource`;
    let cache2;
    cache2 = CacheService.getCache(schemas.files, schemas.files.stores.insightFiles);
    const cachedFile = yield getFileFromCache(cache2, endpoint);
    if (cachedFile) {
      return cachedFile;
    }
    const scopes = "sites.read.all";
    let response;
    try {
      response = yield graph.api(endpoint).middlewareOptions(prepScopes(scopes)).get();
      if (getIsFilesCacheEnabled()) {
        cache2.putValue(endpoint, { file: JSON.stringify(response) });
      }
    } catch (_a2) {
    }
    return response || null;
  });
}
function getFilesIterator(graph, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = "/me/drive/root/children";
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getDriveFilesByIdIterator(graph, driveId, itemId, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/items/${itemId}/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getDriveFilesByPathIterator(graph, driveId, itemPath, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/root:/${itemPath}:/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getGroupFilesByIdIterator(graph, groupId, itemId, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/items/${itemId}/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getGroupFilesByPathIterator(graph, groupId, itemPath, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/root:/${itemPath}:/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getFilesByIdIterator(graph, itemId, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/me/drive/items/${itemId}/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getFilesByPathIterator(graph, itemPath, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/me/drive/root:/${itemPath}:/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getSiteFilesByIdIterator(graph, siteId, itemId, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/items/${itemId}/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getSiteFilesByPathIterator(graph, siteId, itemPath, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/root:/${itemPath}:/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getUserFilesByIdIterator(graph, userId, itemId, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/items/${itemId}/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getUserFilesByPathIterator(graph, userId, itemPath, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/root:/${itemPath}:/children`;
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = "files.read";
    let request;
    try {
      request = graph.api(endpoint).middlewareOptions(prepScopes(scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(endpoint, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getFilesByListQueryIterator(graph, listQuery, top) {
  return __awaiter10(this, void 0, void 0, function* () {
    let filesPageIterator;
    let cache2;
    const cacheStore = schemas.fileLists.stores.fileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, listQuery);
    if (fileList) {
      filesPageIterator = yield getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
      return filesPageIterator;
    }
    const scopes = ["files.read", "sites.read.all"];
    let request;
    try {
      request = yield graph.api(listQuery).middlewareOptions(prepScopes(...scopes));
      if (top) {
        request.top(top);
      }
      filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
      if (getIsFileListsCacheEnabled()) {
        cache2.putValue(listQuery, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
      }
    } catch (_a2) {
    }
    return filesPageIterator || null;
  });
}
function getMyInsightsFiles(graph, insightType) {
  return __awaiter10(this, void 0, void 0, function* () {
    const endpoint = `/me/insights/${insightType}`;
    let cache2;
    const cacheStore = schemas.fileLists.stores.insightfileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, endpoint);
    if (fileList) {
      return fileList.files;
    }
    const scopes = ["sites.read.all"];
    let insightResponse;
    try {
      insightResponse = yield graph.api(endpoint).filter(`resourceReference/type eq 'microsoft.graph.driveItem'`).middlewareOptions(prepScopes(...scopes)).get();
    } catch (_a2) {
    }
    const result = yield getDriveItemsByInsights(graph, insightResponse, scopes);
    if (getIsFileListsCacheEnabled()) {
      cache2.putValue(endpoint, { files: result });
    }
    return result || null;
  });
}
function getUserInsightsFiles(graph, userId, insightType) {
  return __awaiter10(this, void 0, void 0, function* () {
    let endpoint;
    let filter;
    if (insightType === "shared") {
      endpoint = `/me/insights/shared`;
      filter = `((lastshared/sharedby/id eq '${userId}') and (resourceReference/type eq 'microsoft.graph.driveItem'))`;
    } else {
      endpoint = `/users/${userId}/insights/${insightType}`;
      filter = `resourceReference/type eq 'microsoft.graph.driveItem'`;
    }
    const key = `${endpoint}?$filter=${filter}`;
    let cache2;
    const cacheStore = schemas.fileLists.stores.insightfileLists;
    cache2 = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache2, cacheStore, key);
    if (fileList) {
      return fileList.files;
    }
    const scopes = ["sites.read.all"];
    let insightResponse;
    try {
      insightResponse = yield graph.api(endpoint).filter(filter).middlewareOptions(prepScopes(...scopes)).get();
    } catch (_a2) {
    }
    const result = yield getDriveItemsByInsights(graph, insightResponse, scopes);
    if (getIsFileListsCacheEnabled()) {
      cache2.putValue(endpoint, { files: result });
    }
    return result || null;
  });
}
function getFilesByQueries(graph, fileQueries) {
  return __awaiter10(this, void 0, void 0, function* () {
    if (!fileQueries || fileQueries.length === 0) {
      return [];
    }
    const batch = graph.createBatch();
    const files = [];
    const scopes = ["files.read"];
    let cache2;
    let cachedFile;
    if (getIsFilesCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.files, schemas.files.stores.fileQueries);
    }
    for (const fileQuery of fileQueries) {
      if (getIsFilesCacheEnabled()) {
        cachedFile = yield cache2.getValue(fileQuery);
      }
      if (getIsFilesCacheEnabled() && cachedFile && getFileInvalidationTime() > Date.now() - cachedFile.timeCached) {
        files.push(JSON.parse(cachedFile.file));
      } else if (fileQuery !== "") {
        batch.get(fileQuery, fileQuery, scopes);
      }
    }
    try {
      const responses = yield batch.executeAll();
      for (const fileQuery of fileQueries) {
        const response = responses.get(fileQuery);
        if (response && response.content) {
          files.push(response.content);
          if (getIsFilesCacheEnabled()) {
            cache2.putValue(fileQuery, { file: JSON.stringify(response.content) });
          }
        }
      }
      return files;
    } catch (_) {
      try {
        return Promise.all(fileQueries.filter((fileQuery) => fileQuery && fileQuery !== "").map((fileQuery) => __awaiter10(this, void 0, void 0, function* () {
          const file = yield getDriveItemByQuery(graph, fileQuery);
          if (file) {
            if (getIsFilesCacheEnabled()) {
              cache2.putValue(fileQuery, { file: JSON.stringify(file) });
            }
            return file;
          }
        })));
      } catch (_2) {
        return [];
      }
    }
  });
}
function getDriveItemsByInsights(graph, insightResponse, scopes) {
  return __awaiter10(this, void 0, void 0, function* () {
    if (!insightResponse) {
      return [];
    }
    const insightItems = insightResponse.value;
    const batch = graph.createBatch();
    const driveItems = [];
    for (const item of insightItems) {
      const driveItemId = item.resourceReference.id;
      if (driveItemId !== "") {
        batch.get(driveItemId, driveItemId, scopes);
      }
    }
    try {
      const driveItemResponses = yield batch.executeAll();
      for (const item of insightItems) {
        const driveItemResponse = driveItemResponses.get(item.resourceReference.id);
        if (driveItemResponse && driveItemResponse.content) {
          driveItems.push(driveItemResponse.content);
        }
      }
      return driveItems;
    } catch (_) {
      try {
        return Promise.all(insightItems.filter((insightItem) => insightItem.resourceReference.id && insightItem.resourceReference.id !== "").map((insightItem) => __awaiter10(this, void 0, void 0, function* () {
          const driveItemResponses = yield graph.api(insightItem.resourceReference.id).middlewareOptions(prepScopes(...scopes)).get();
          if (driveItemResponses && driveItemResponses.length) {
            return driveItemResponses[0].content;
          }
        })));
      } catch (_2) {
        return [];
      }
    }
  });
}
function getFilesPageIteratorFromRequest(graph, request) {
  return __awaiter10(this, void 0, void 0, function* () {
    return GraphPageIterator.create(graph, request);
  });
}
function getFilesPageIteratorFromCache(graph, value, nextLink) {
  return __awaiter10(this, void 0, void 0, function* () {
    return GraphPageIterator.createFromValue(graph, value, nextLink);
  });
}
function getFileFromCache(cache2, key) {
  return __awaiter10(this, void 0, void 0, function* () {
    if (getIsFilesCacheEnabled()) {
      const file = yield cache2.getValue(key);
      if (file && getFileInvalidationTime() > Date.now() - file.timeCached) {
        const cachedFile = JSON.parse(file.file);
        return cachedFile;
      }
    }
    return null;
  });
}
function getFileListFromCache(cache2, store, key) {
  return __awaiter10(this, void 0, void 0, function* () {
    if (!cache2) {
      cache2 = CacheService.getCache(schemas.fileLists, store);
    }
    if (getIsFileListsCacheEnabled()) {
      const fileList = yield cache2.getValue(key);
      if (fileList && getFileListInvalidationTime() > Date.now() - fileList.timeCached) {
        return fileList;
      }
    }
    return null;
  });
}
function fetchNextAndCacheForFilesPageIterator(filesPageIterator) {
  return __awaiter10(this, void 0, void 0, function* () {
    const nextLink = filesPageIterator._nextLink;
    if (filesPageIterator.hasNext) {
      yield filesPageIterator.next();
    }
    if (getIsFileListsCacheEnabled()) {
      let cache2;
      cache2 = CacheService.getCache(schemas.fileLists, schemas.fileLists.stores.fileLists);
      const reg = /(graph.microsoft.com\/(v1.0|beta))(.*?)(?=\?)/gi;
      const matches2 = reg.exec(nextLink);
      const key = matches2[3];
      cache2.putValue(key, { files: filesPageIterator.value, nextLink: filesPageIterator._nextLink });
    }
  });
}
function getDocumentThumbnail(graph, resource, scopes) {
  return __awaiter10(this, void 0, void 0, function* () {
    try {
      const response = yield graph.api(resource).responseType(ResponseType.RAW).middlewareOptions(prepScopes(...scopes)).get();
      if (response.status === 404) {
        return { eTag: null, thumbnail: null };
      } else if (!response.ok) {
        return null;
      }
      const eTag = response.headers.get("eTag");
      const blob = yield blobToBase64(yield response.blob());
      return { eTag, thumbnail: blob };
    } catch (e) {
      return null;
    }
  });
}
function getGraphfile(graph, resource) {
  return __awaiter10(this, void 0, void 0, function* () {
    try {
      const scopes = "files.read";
      let response;
      try {
        response = yield graph.api(resource).middlewareOptions(prepScopes(scopes)).get().catch((error) => {
          return null;
        });
      } catch (_a2) {
      }
      return response || null;
    } catch (e) {
      return null;
    }
  });
}
function getUploadSession(graph, resource, conflictBehavior) {
  return __awaiter10(this, void 0, void 0, function* () {
    try {
      const scopes = "files.readwrite";
      const sessionOptions = {
        item: {
          "@microsoft.graph.conflictBehavior": conflictBehavior === 0 || conflictBehavior === null ? "rename" : "replace"
        }
      };
      let response;
      try {
        response = yield graph.api(resource).middlewareOptions(prepScopes(scopes)).post(JSON.stringify(sessionOptions));
      } catch (_a2) {
      }
      return response || null;
    } catch (e) {
      return null;
    }
  });
}
function sendFileChunck(graph, resource, contentLength, contentRange, file) {
  return __awaiter10(this, void 0, void 0, function* () {
    try {
      const scopes = "files.readwrite";
      const header = {
        "Content-Length": contentLength,
        "Content-Range": contentRange
      };
      let response;
      try {
        response = yield graph.client.api(resource).middlewareOptions(prepScopes(scopes)).headers(header).put(file);
      } catch (_a2) {
      }
      return response || null;
    } catch (e) {
      return null;
    }
  });
}
function sendFileContent(graph, resource, file) {
  return __awaiter10(this, void 0, void 0, function* () {
    try {
      const scopes = "files.readwrite";
      let response;
      try {
        response = yield graph.client.api(resource).middlewareOptions(prepScopes(scopes)).put(file);
      } catch (_a2) {
      }
      return response || null;
    } catch (e) {
      return null;
    }
  });
}
function deleteSessionFile(graph, resource) {
  return __awaiter10(this, void 0, void 0, function* () {
    try {
      const scopes = "files.readwrite";
      let response;
      try {
        response = yield graph.client.api(resource).middlewareOptions(prepScopes(scopes)).delete((response2) => {
          return response2;
        });
      } catch (_a2) {
      }
      return response || null;
    } catch (e) {
      return null;
    }
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/styles/fluent-icons.js
var fileTypeMap = {
  PowerPoint: "pptx",
  Word: "docx",
  Excel: "xlsx",
  Pdf: "pdf",
  OneNote: "onetoc",
  OneNotePage: "one",
  InfoPath: "xsn",
  Visio: "vstx",
  Publisher: "pub",
  Project: "mpp",
  Access: "accdb",
  Mail: "email",
  Csv: "csv",
  Archive: "archive",
  Xps: "vector",
  Audio: "audio",
  Video: "video",
  Image: "photo",
  Web: "html",
  Text: "txt",
  Xml: "xml",
  Story: "genericfile",
  ExternalContent: "genericfile",
  Folder: "folder",
  Spsite: "spo",
  Other: "genericfile"
};
var baseUri = "https://spoprod-a.akamaihd.net/files/fabric-cdn-prod_20201008.001/assets/item-types";
function getFileTypeIconUriByExtension(type, size, extension) {
  const found = Object.keys(fileTypeMap).find((key) => fileTypeMap[key] === type);
  if (found) {
    return `${baseUri}/${size.toString()}/${type}.${extension}`;
  } else if (type === "jpg" || type === "png") {
    type = "photo";
    return `${baseUri}/${size.toString()}/${type}.${extension}`;
  } else {
    return null;
  }
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file/strings.js
var strings2 = {
  modifiedSubtitle: "Modified",
  sizeSubtitle: "Size"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file/mgt-file.js
var __decorate7 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata5 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtFile = class MgtFile2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles6;
  }
  get strings() {
    return strings2;
  }
  /**
   * allows developer to provide query for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get fileQuery() {
    return this._fileQuery;
  }
  set fileQuery(value) {
    if (value === this._fileQuery) {
      return;
    }
    this._fileQuery = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide site id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get siteId() {
    return this._siteId;
  }
  set siteId(value) {
    if (value === this._siteId) {
      return;
    }
    this._siteId = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide drive id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get driveId() {
    return this._driveId;
  }
  set driveId(value) {
    if (value === this._driveId) {
      return;
    }
    this._driveId = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide group id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get groupId() {
    return this._groupId;
  }
  set groupId(value) {
    if (value === this._groupId) {
      return;
    }
    this._groupId = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide list id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get listId() {
    return this._listId;
  }
  set listId(value) {
    if (value === this._listId) {
      return;
    }
    this._listId = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide user id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get userId() {
    return this._userId;
  }
  set userId(value) {
    if (value === this._userId) {
      return;
    }
    this._userId = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide item id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get itemId() {
    return this._itemId;
  }
  set itemId(value) {
    if (value === this._itemId) {
      return;
    }
    this._itemId = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide item path for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get itemPath() {
    return this._itemPath;
  }
  set itemPath(value) {
    if (value === this._itemPath) {
      return;
    }
    this._itemPath = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide insight type for a file
   * can be trending, used, or shared
   *
   * @type {OfficeGraphInsightString}
   * @memberof MgtFile
   */
  get insightType() {
    return this._insightType;
  }
  set insightType(value) {
    if (value === this._insightType) {
      return;
    }
    this._insightType = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide insight id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get insightId() {
    return this._insightId;
  }
  set insightId(value) {
    if (value === this._insightId) {
      return;
    }
    this._insightId = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide DriveItem object
   *
   * @type {MicrosoftGraph.DriveItem}
   * @memberof MgtFile
   */
  get fileDetails() {
    return this._fileDetails;
  }
  set fileDetails(value) {
    if (value === this._fileDetails) {
      return;
    }
    this._fileDetails = value;
    this.requestStateUpdate();
  }
  /**
   * allows developer to provide file type icon url
   *
   * @type {string}
   * @memberof MgtFile
   */
  get fileIcon() {
    return this._fileIcon;
  }
  set fileIcon(value) {
    if (value === this._fileIcon) {
      return;
    }
    this._fileIcon = value;
    this.requestStateUpdate();
  }
  /**
   * Get the scopes required for file
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtFile
   */
  static get requiredScopes() {
    return [.../* @__PURE__ */ new Set(["files.read", "files.read.all", "sites.read.all"])];
  }
  constructor() {
    super();
    this.line1Property = "name";
    this.line2Property = "lastModifiedDateTime";
    this.line3Property = "size";
    this.view = ViewType.threelines;
  }
  render() {
    if (!this.driveItem && this.isLoadingState) {
      return this.renderLoading();
    }
    if (!this.driveItem) {
      return this.renderNoData();
    }
    const file = this.driveItem;
    let fileTemplate;
    fileTemplate = this.renderTemplate("default", { file });
    if (!fileTemplate) {
      const fileDetailsTemplate = this.renderDetails(file);
      const fileTypeIconTemplate = this.renderFileTypeIcon();
      fileTemplate = html`
        <div class="item">
          ${fileTypeIconTemplate} ${fileDetailsTemplate}
        </div>
      `;
    }
    return html`
      <span dir=${this.direction}>
        ${fileTemplate}
      </span>
    `;
  }
  /**
   * Render the loading state
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtFile
   */
  renderLoading() {
    return this.renderTemplate("loading", null) || html``;
  }
  /**
   * Render the state when no data is available
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtFile
   */
  renderNoData() {
    return this.renderTemplate("no-data", null) || html``;
  }
  /**
   * Render the file type icon
   *
   * @protected
   * @param {string} [iconSrc]
   * @memberof MgtFile
   */
  renderFileTypeIcon() {
    if (!this.fileIcon && !this.driveItem.name) {
      return html``;
    }
    let fileIconSrc;
    if (this.fileIcon) {
      fileIconSrc = this.fileIcon;
    } else {
      const re = /(?:\.([^.]+))?$/;
      const fileType = this.driveItem.package === void 0 && this.driveItem.folder === void 0 ? re.exec(this.driveItem.name)[1] ? re.exec(this.driveItem.name)[1].toLowerCase() : "null" : this.driveItem.package !== void 0 ? this.driveItem.package.type === "oneNote" ? "onetoc" : "folder" : "folder";
      fileIconSrc = getFileTypeIconUriByExtension(fileType, 48, "svg");
    }
    return html`
      <div class="item__file-type-icon">
        ${fileIconSrc ? html`
              <img src=${fileIconSrc} alt="File icon" />
            ` : html`
              ${getSvg(SvgIcon.File)}
            `}
      </div>
    `;
  }
  /**
   * Render the file details
   *
   * @protected
   * @param {MicrosoftGraph.DriveItem} [driveItem]
   * @memberof MgtFile
   */
  renderDetails(driveItem) {
    if (!driveItem || this.view === ViewType.image) {
      return html``;
    }
    const details = [];
    if (this.view > ViewType.image) {
      const text = this.getTextFromProperty(driveItem, this.line1Property);
      if (text) {
        details.push(html`
          <div class="line1" aria-label="${text}">${text}</div>
        `);
      }
    }
    if (this.view > ViewType.oneline) {
      const text = this.getTextFromProperty(driveItem, this.line2Property);
      if (text) {
        details.push(html`
          <div class="line2" aria-label="${text}">${text}</div>
        `);
      }
    }
    if (this.view > ViewType.twolines) {
      const text = this.getTextFromProperty(driveItem, this.line3Property);
      if (text) {
        details.push(html`
          <div class="line3" aria-label="${text}">${text}</div>
        `);
      }
    }
    return html`
      <div class="item__details">
        ${details}
      </div>
    `;
  }
  /**
   * load state into the component.
   *
   * @protected
   * @returns
   * @memberof MgtFile
   */
  loadState() {
    return __awaiter11(this, void 0, void 0, function* () {
      if (this.fileDetails) {
        this.driveItem = this.fileDetails;
        return;
      }
      const provider = Providers.globalProvider;
      if (!provider || provider.state === ProviderState.Loading) {
        return;
      }
      if (provider.state === ProviderState.SignedOut) {
        this.driveItem = null;
        return;
      }
      const graph = provider.graph.forComponent(this);
      let driveItem;
      const getFromMyDrive = !this.driveId && !this.siteId && !this.groupId && !this.listId && !this.userId;
      if (
        // return null when a combination of provided properties are required
        this.driveId && !this.itemId && !this.itemPath || this.siteId && !this.itemId && !this.itemPath || this.groupId && !this.itemId && !this.itemPath || this.listId && !this.siteId && !this.itemId || this.insightType && !this.insightId || this.userId && !this.itemId && !this.itemPath && !this.insightType && !this.insightId
      ) {
        driveItem = null;
      } else if (this.fileQuery) {
        driveItem = yield getDriveItemByQuery(graph, this.fileQuery);
      } else if (this.itemId && getFromMyDrive) {
        driveItem = yield getMyDriveItemById(graph, this.itemId);
      } else if (this.itemPath && getFromMyDrive) {
        driveItem = yield getMyDriveItemByPath(graph, this.itemPath);
      } else if (this.userId) {
        if (this.itemId) {
          driveItem = yield getUserDriveItemById(graph, this.userId, this.itemId);
        } else if (this.itemPath) {
          driveItem = yield getUserDriveItemByPath(graph, this.userId, this.itemPath);
        } else if (this.insightType && this.insightId) {
          driveItem = yield getUserInsightsDriveItemById(graph, this.userId, this.insightType, this.insightId);
        }
      } else if (this.driveId) {
        if (this.itemId) {
          driveItem = yield getDriveItemById(graph, this.driveId, this.itemId);
        } else if (this.itemPath) {
          driveItem = yield getDriveItemByPath(graph, this.driveId, this.itemPath);
        }
      } else if (this.siteId && !this.listId) {
        if (this.itemId) {
          driveItem = yield getSiteDriveItemById(graph, this.siteId, this.itemId);
        } else if (this.itemPath) {
          driveItem = yield getSiteDriveItemByPath(graph, this.siteId, this.itemPath);
        }
      } else if (this.listId) {
        driveItem = yield getListDriveItemById(graph, this.siteId, this.listId, this.itemId);
      } else if (this.groupId) {
        if (this.itemId) {
          driveItem = yield getGroupDriveItemById(graph, this.groupId, this.itemId);
        } else if (this.itemPath) {
          driveItem = yield getGroupDriveItemByPath(graph, this.groupId, this.itemPath);
        }
      } else if (this.insightType && !this.userId) {
        driveItem = yield getMyInsightsDriveItemById(graph, this.insightType, this.insightId);
      }
      this.driveItem = driveItem;
    });
  }
  getTextFromProperty(driveItem, properties) {
    if (!properties || properties.length === 0) {
      return null;
    }
    const propertyList = properties.trim().split(",");
    let text;
    let i = 0;
    while (!text && i < propertyList.length) {
      const current = propertyList[i].trim();
      switch (current) {
        case "size":
          let size;
          if (driveItem.size) {
            size = this.formatBytes(driveItem.size);
          } else {
            size = "0";
          }
          text = `${this.strings.sizeSubtitle}: ${size}`;
          break;
        case "lastModifiedDateTime":
          let relativeDateString;
          let lastModifiedString;
          if (driveItem.lastModifiedDateTime) {
            const lastModifiedDateTime = new Date(driveItem.lastModifiedDateTime);
            relativeDateString = getRelativeDisplayDate(lastModifiedDateTime);
            lastModifiedString = `${this.strings.modifiedSubtitle} ${relativeDateString}`;
          } else {
            lastModifiedString = "";
          }
          text = lastModifiedString;
          break;
        default:
          text = driveItem[current];
      }
      i++;
    }
    return text;
  }
  formatBytes(bytes, decimals = 2) {
    if (bytes === 0)
      return "0 Bytes";
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
  }
};
__decorate7([
  property({
    attribute: "file-query"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "fileQuery", null);
__decorate7([
  property({
    attribute: "site-id"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "siteId", null);
__decorate7([
  property({
    attribute: "drive-id"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "driveId", null);
__decorate7([
  property({
    attribute: "group-id"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "groupId", null);
__decorate7([
  property({
    attribute: "list-id"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "listId", null);
__decorate7([
  property({
    attribute: "user-id"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "userId", null);
__decorate7([
  property({
    attribute: "item-id"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "itemId", null);
__decorate7([
  property({
    attribute: "item-path"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "itemPath", null);
__decorate7([
  property({
    attribute: "insight-type"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "insightType", null);
__decorate7([
  property({
    attribute: "insight-id"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "insightId", null);
__decorate7([
  property({
    type: Object
  }),
  __metadata5("design:type", Object),
  __metadata5("design:paramtypes", [Object])
], MgtFile.prototype, "fileDetails", null);
__decorate7([
  property({
    attribute: "file-icon"
  }),
  __metadata5("design:type", String),
  __metadata5("design:paramtypes", [String])
], MgtFile.prototype, "fileIcon", null);
__decorate7([
  property({ type: Object }),
  __metadata5("design:type", Object)
], MgtFile.prototype, "driveItem", void 0);
__decorate7([
  property({ attribute: "line1-property" }),
  __metadata5("design:type", String)
], MgtFile.prototype, "line1Property", void 0);
__decorate7([
  property({ attribute: "line2-property" }),
  __metadata5("design:type", String)
], MgtFile.prototype, "line2Property", void 0);
__decorate7([
  property({ attribute: "line3-property" }),
  __metadata5("design:type", String)
], MgtFile.prototype, "line3Property", void 0);
__decorate7([
  property({
    attribute: "view",
    converter: (value) => {
      if (!value || value.length === 0) {
        return ViewType.threelines;
      }
      value = value.toLowerCase();
      if (typeof ViewType[value] === "undefined") {
        return ViewType.threelines;
      } else {
        return ViewType[value];
      }
    }
  }),
  __metadata5("design:type", Number)
], MgtFile.prototype, "view", void 0);
MgtFile = __decorate7([
  customElement("file"),
  __metadata5("design:paramtypes", [])
], MgtFile);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/mgt-file-list.js
init_es6();
init_lit();
init_decorators();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/mgt-file-upload/mgt-file-upload.js
init_lit();
init_decorators();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/mgt-file-upload/mgt-file-upload-css.js
init_lit();
var styles7 = [
  css`
.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--file-item-background-color--hover:#f7f7f7;--file-item-background-color--active:#fbfbfb;--file-upload-button-background-color:#036ac4;--file-upload-dialog-background-color:rgba(0, 0, 0, 0.1);--file-upload-dialog-content-background-color:white;--file-upload-dialog-content-color:#323130;--file-upload-dialog-primarybutton-color:white;--file-upload-dialog-primarybutton-background-color:#006cbe}.mgt-dark{--file-item-background-color--hover:#0078d4;--file-item-background-color--active:#238ada;--file-upload-button-background-color:#006cbe;--file-upload-dialog-background-color:rgba(0, 0, 0, 0.3);--file-upload-dialog-content-background-color:#787878;--file-upload-dialog-content-color:#000;--file-upload-dialog-primarybutton-color:white;--file-upload-dialog-primarybutton-background-color:#006cbe}:host .file-upload-area-button{width:100%;--neutral-fill-hover:$file-upload-button-background-color;--neutral-fill-rest:$file-upload-button-background-color;--neutral-fill-active:$file-upload-button-background-color;--neutral-fill-focus:$file-upload-button-background-color}:host .file-upload-area-button div{float:var(--file-upload-button-float,right);text-align:center;display:table;margin-top:30px;margin-right:36px}:host .file-upload-area-button fluent-button.file-upload-button{color:var(--file-upload-button-color,#fff);vertical-align:middle;background-color:var(--file-upload-button-background-color,#036ac4);width:120px;height:32px;cursor:pointer;font-size:var(--default-font-size);font-family:var(--default-font-family);position:relative}:host .file-upload-area-button fluent-button.file-upload-button .upload-text{font-weight:400;line-height:20px}:host .file-upload-area-button input{width:.1px;height:.1px;opacity:0;overflow:hidden;position:absolute;z-index:-1}:host .file-upload-table{margin:var(--file-item-margin,0)}:host .file-upload-table .file-upload-cell{padding:1px 0 1px 1px;display:table-cell;width:50%;vertical-align:middle;position:relative}:host .file-upload-table .file-upload-cell .file-upload-filename{max-width:250px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .file-upload-table .file-upload-cell .file-upload-status{position:absolute;left:48px}:host .file-upload-table .file-upload-cell fluent-progress.file-upload-bar{width:180px;margin-top:10px}:host .file-upload-table .file-upload-cell .file-upload-cancel{cursor:pointer;margin-left:20px}:host .file-upload-table .file-upload-cell .file-upload-name{width:auto}:host .file-upload-table .file-upload-cell .cancel-icon{fill:var(--file-upload-button-color,var(--color,fileUploadIconBackground))}:host .file-upload-table.upload{display:table;width:260px}:host .mgt-file-item{--file-background-color:transparent;margin:0 0 20px 26px}:host .upload-icon{fill:var(--file-upload-button-color,#fff)}:host .file-upload-Template{clear:both}:host .file-upload-Template .file-upload-folder-tab{padding-left:20px}:host #file-upload-border{display:none}:host #file-upload-border.visible{border:var(--file-upload-border,dashed #0078d4 1px);background-color:var(--file-upload-background-color,rgba(0,120,212,.1));position:absolute;top:0;bottom:0;left:0;right:0;z-index:1;display:inline-block}:host .file-upload-dialog{display:none}:host .file-upload-dialog .file-upload-dialog-content{background-color:var(--file-upload-dialog-content-background-color,#fff);margin:auto;padding:24px;width:294px;height:auto;margin-top:165px;font-size:var(--default-font-size);font-family:var(--default-font-family);box-shadow:var(--file-list-box-shadow,0 3.2px 7.2px rgba(0,0,0,.132),0 .6px 1.8px rgba(0,0,0,.108));line-height:20px}:host .file-upload-dialog .file-upload-dialog-content div{color:var(--file-upload-dialog-content-color,#323130)}:host .file-upload-dialog .file-upload-dialog-check-wrapper{margin-top:12px}:host .file-upload-dialog fluent-checkbox.file-upload-dialog-check{--neutral-fill-input-rest:$file-upload-dialog-content-color}:host .file-upload-dialog fluent-checkbox.file-upload-dialog-check span{color:var(--file-upload-dialog-content-color,#323130)}:host .file-upload-dialog .file-upload-dialog-content-text{margin-bottom:36px}:host .file-upload-dialog .file-upload-dialog-title{margin-top:0}:host .file-upload-dialog .file-upload-dialog-editor{text-align:right}:host .file-upload-dialog .file-upload-dialog-close{float:right;cursor:pointer}:host .file-upload-dialog .file-upload-dialog-close svg{fill:var(--file-upload-button-color,var(--color,fileUploadIconBackground));padding-right:5px}:host .file-upload-dialog .file-upload-dialog-ok{height:32px;min-width:60px;border:1px solid #8a8886;background-color:var(--file-upload-button-background-color,#036ac4);color:#fff;font-size:var(--default-font-size);margin-right:5px;--neutral-fill-rest:$fileButtonColour;--neutral-fill-hover:$fileButtonColour;--neutral-fill-active:$fileButtonColour;--neutral-fill-focus:$fileButtonColour}:host .file-upload-dialog .file-upload-dialog-cancel{height:32px;min-width:82px;border:1px solid #8a8886;background-color:var(--file-upload-dialog-content-background-color,#fff);color:var(--file-upload-dialog-content-color,#323130);font-size:var(--default-font-size)}:host .file-upload-dialog.visible{position:absolute;z-index:1;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:var(--file-upload-dialog-background-color,rgba(0,0,0,.1));display:inline-block}:host fluent-checkbox.file-upload-dialog-check.hide{display:none}:host .file-upload-dialog-success{border-top:var(--file-item-border-top,none);border-left:var(--file-item-border-left,none);border-right:var(--file-item-border-right,none);border-bottom:var(--file-item-border-bottom,none);border-radius:var(--file-item-border-radius,2px);cursor:pointer}:host .file-upload-dialog-success.focused,:host .file-upload-dialog-success:hover{background-color:var(--file-item-background-color--hover,#f7f7f7)}:host .file-upload-dialog-success.focused .mgt-file-item,:host .file-upload-dialog-success:hover .mgt-file-item{--file-background-color:$file-item-background-color--hover}:host .file-upload-dialog-success.selected,:host .file-upload-dialog-success:active{background-color:var(--file-item-background-color--active,#fbfbfb)}:host .file-upload-dialog-success.selected .mgt-file-item,:host .file-upload-dialog-success:active .mgt-file-item{--file-background-color:$file-item-background-color--active}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/mgt-file-upload/strings.js
var strings3 = {
  failUploadFile: "File upload fail.",
  cancelUploadFile: "File cancel.",
  buttonUploadFile: "Upload Files",
  maximumFilesTitle: "Maximum files",
  maximumFiles: "Sorry, the maximum number of files you can upload at once is {MaxNumber}. Do you want to upload the first {MaxNumber} files or reselect?",
  maximumFileSizeTitle: "Maximum files size",
  maximumFileSize: 'Sorry, the maximum file size to upload is {FileSize}. The file "{FileName}" has ',
  fileTypeTitle: "File type",
  fileType: 'Sorry, the format of following file "{FileName}" cannot be uploaded.',
  checkAgain: "Don't show again",
  checkApplyAll: "Apply to all",
  buttonOk: "OK",
  buttonCancel: "Cancel",
  buttonUpload: "Upload",
  buttonKeep: "Keep both",
  buttonReplace: "Replace",
  buttonReselect: "Reselect",
  fileReplaceTitle: "Replace file",
  fileReplace: 'Do you want to replace the file "{FileName}" or keep both files?',
  uploadButtonLabel: "File upload button"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/mgt-file-upload/mgt-file-upload.js
init_es6();
init_FluentComponents();
init_esm3();
var __decorate8 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata6 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
registerFluentComponents(fluentProgress, fluentButton, fluentCheckbox, fluentCard);
var MgtFileUpload = class MgtFileUpload2 extends MgtBaseComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles7;
  }
  get strings() {
    return strings3;
  }
  /**
   * Get the scopes required for file upload
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtFileUpload
   */
  static get requiredScopes() {
    return [.../* @__PURE__ */ new Set(["files.readwrite", "files.readwrite.all", "sites.readwrite.all"])];
  }
  constructor() {
    super();
    this._dragCounter = 0;
    this._dropEffect = "copy";
    this._maxChunckSize = 4 * 1024 * 1024;
    this._dialogTitle = "";
    this._dialogContent = "";
    this._dialogPrimaryButton = "";
    this._dialogSecondaryButton = "";
    this._dialogCheckBox = "";
    this._applyAll = false;
    this._applyAllConflitBehavior = null;
    this._maximumFileSize = false;
    this._excludedFileType = false;
    this.handleonDragOver = (event) => __awaiter12(this, void 0, void 0, function* () {
      event.preventDefault();
      event.stopPropagation();
      if (event.dataTransfer.items && event.dataTransfer.items.length > 0) {
        event.dataTransfer.dropEffect = event.dataTransfer.dropEffect = this._dropEffect;
      }
    });
    this.handleonDragEnter = (event) => __awaiter12(this, void 0, void 0, function* () {
      event.preventDefault();
      event.stopPropagation();
      this._dragCounter++;
      if (event.dataTransfer.items && event.dataTransfer.items.length > 0) {
        event.dataTransfer.dropEffect = this._dropEffect;
        const dragFileBorder = this.renderRoot.querySelector("#file-upload-border");
        dragFileBorder.classList.add("visible");
      }
    });
    this.handleonDragLeave = (event) => {
      event.preventDefault();
      event.stopPropagation();
      this._dragCounter--;
      if (this._dragCounter === 0) {
        const dragFileBorder = this.renderRoot.querySelector("#file-upload-border");
        dragFileBorder.classList.remove("visible");
      }
    };
    this.handleonDrop = (event) => __awaiter12(this, void 0, void 0, function* () {
      event.preventDefault();
      event.stopPropagation();
      const dragFileBorder = this.renderRoot.querySelector("#file-upload-border");
      dragFileBorder.classList.remove("visible");
      if (event.dataTransfer && event.dataTransfer.items) {
        this.getSelectedFiles(yield this.getFilesFromUploadArea(event.dataTransfer.items));
      }
      event.dataTransfer.clearData();
      this._dragCounter = 0;
    });
    this.filesToUpload = [];
  }
  /**
   *
   * @returns
   */
  render() {
    if (this.parentElement !== null) {
      const root = this.parentElement;
      root.addEventListener("dragenter", this.handleonDragEnter);
      root.addEventListener("dragleave", this.handleonDragLeave);
      root.addEventListener("dragover", this.handleonDragOver);
      root.addEventListener("drop", this.handleonDrop);
    }
    return html`
        <div id="file-upload-dialog" class="file-upload-dialog">
          <!-- Modal content -->
          <fluent-card class="file-upload-dialog-content">
            <span class="file-upload-dialog-close" id="file-upload-dialog-close" >${getSvg(SvgIcon.Cancel)}</span>
            <div class="file-upload-dialog-content-text">
              <h2 class="file-upload-dialog-title">${this._dialogTitle}</h2>
              <div>${this._dialogContent}</div>
              <div class="file-upload-dialog-check-wrapper">
                <fluent-checkbox id="file-upload-dialog-check" class="file-upload-dialog-check" >
                  <span>${this._dialogCheckBox}</span>
                </fluent-checkbox>
              </div>
            </div>
            <div class="file-upload-dialog-editor">
              <fluent-button class="file-upload-dialog-ok">
              ${this._dialogPrimaryButton}
              </fluent-button>
              <fluent-button class="file-upload-dialog-cancel">
              ${this._dialogSecondaryButton}
              </fluent-button>
            </div>
          </fluent-card>
        </div>
        <div id="file-upload-border" >
        </div>
        <div class="file-upload-area-button">
        <div>
          <input
            id="file-upload-input"
            title="${this.strings.uploadButtonLabel}"
            tabindex="-1"
            aria-label="file upload input"
            type="file"
            multiple="true"
            @change="${this.onFileUploadChange}"
          />
          <fluent-button class="file-upload-button" @click=${this.onFileUploadClick} label=${this.strings.uploadButtonLabel}>
            ${getSvg(SvgIcon.Upload)} <span class="upload-text">${this.strings.buttonUploadFile}</span>
          </fluent-button>
        </div>
        </div>
        <div class="file-upload-Template">
        ${this.renderFolderTemplate(this.filesToUpload)}
        </div>
       `;
  }
  /**
   * Render Folder structure of files to upload
   * @param fileItems
   * @returns
   */
  renderFolderTemplate(fileItems) {
    const folderStructure = [];
    if (fileItems.length > 0) {
      const TemplateFileItems = fileItems.map((fileItem) => {
        if (folderStructure.indexOf(fileItem.fullPath.substring(0, fileItem.fullPath.lastIndexOf("/"))) === -1) {
          if (fileItem.fullPath.substring(0, fileItem.fullPath.lastIndexOf("/")) !== "") {
            folderStructure.push(fileItem.fullPath.substring(0, fileItem.fullPath.lastIndexOf("/")));
            return mgtHtml`
            <div class='file-upload-table'>
              <div class='file-upload-cell'>
                <mgt-file
                  .fileDetails=${{
              name: fileItem.fullPath.substring(1, fileItem.fullPath.lastIndexOf("/")),
              folder: "Folder"
            }}
                  .view=${ViewType.oneline}
                  class="mgt-file-item"
                >
                </mgt-file>
              </div>
            </div>
            ${this.renderFileTemplate(fileItem, "file-upload-folder-tab")}`;
          } else {
            return html`${this.renderFileTemplate(fileItem, "")}`;
          }
        } else {
          return html`${this.renderFileTemplate(fileItem, "file-upload-folder-tab")}`;
        }
      });
      return html`${TemplateFileItems}`;
    } else {
      return null;
    }
  }
  /**
   * Render file upload area
   *
   * @param fileItem
   * @returns
   */
  renderFileTemplate(fileItem, folderTabStyle) {
    return mgtHtml`
        <div class="${fileItem.completed ? "file-upload-table" : "file-upload-table upload"}">
          <div class="${folderTabStyle + (fileItem.fieldUploadResponse === "lastModifiedDateTime" ? " file-upload-dialog-success" : "")}">
            <div class='file-upload-cell'>
              <div style=${fileItem.fieldUploadResponse === "description" ? "opacity: 0.5;" : ""}>
                <div class="file-upload-status">
                  ${fileItem.iconStatus}
                </div>
                <mgt-file
                  .fileDetails=${fileItem.driveItem}
                  .view=${fileItem.view}
                  .line2Property=${fileItem.fieldUploadResponse}
                  class="mgt-file-item"
                  >
                </mgt-file>
              </div>
            </div>
              ${fileItem.completed === false ? this.renderFileUploadTemplate(fileItem) : null}
            </div>
          </div>
        </div>
        `;
  }
  /**
   * Render file upload progress
   *
   * @param fileItem
   * @returns
   */
  renderFileUploadTemplate(fileItem) {
    return html`
    <div class='file-upload-cell'>
      <div class='file-upload-table file-upload-name' >
        <div class='file-upload-cell'>
          <div title="${fileItem.file.name}" class='file-upload-filename'>${fileItem.file.name}</div>
        </div>
      </div>
      <div class='file-upload-table'>
        <div class='file-upload-cell'>
          <div class="${fileItem.completed ? "file-upload-table" : "file-upload-table upload"}">
            <fluent-progress class="file-upload-bar" value="${fileItem.percent}" ></fluent-progress>
            <div class='file-upload-cell' style="padding-left:5px">
              <span>${fileItem.percent}%</span>
              <span
                class="file-upload-cancel"
                @click=${(e) => this.deleteFileUploadSession(fileItem)}>
                ${getSvg(SvgIcon.Cancel)}
              </span>
            </div>
          <div>
        </div>
      </div>
    </div>
    `;
  }
  /**
   * Handle the "Upload Files" button click event to open dialog and select files.
   *
   * @param event
   * @returns
   */
  onFileUploadChange(event) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (!event || event.target.files.length < 1) {
        return;
      } else {
        this.getSelectedFiles(yield this.getFilesFromUploadArea(event.target.files));
        event.target.value = null;
      }
    });
  }
  /**
   * Handle the click event on upload file button that open select files dialog to upload.
   *
   */
  onFileUploadClick() {
    const uploadInput = this.renderRoot.querySelector("#file-upload-input");
    uploadInput.click();
  }
  /**
   * Function delete existing file upload sessions
   *
   * @param fileItem
   */
  deleteFileUploadSession(fileItem) {
    return __awaiter12(this, void 0, void 0, function* () {
      try {
        if (fileItem.uploadUrl !== void 0) {
          const response = yield deleteSessionFile(this.fileUploadList.graph, fileItem.uploadUrl);
          fileItem.uploadUrl = void 0;
          fileItem.completed = true;
          this.setUploadFail(fileItem, strings3.cancelUploadFile);
        } else {
          fileItem.uploadUrl = void 0;
          fileItem.completed = true;
          this.setUploadFail(fileItem, strings3.cancelUploadFile);
        }
      } catch (_a2) {
        fileItem.uploadUrl = void 0;
        fileItem.completed = true;
        this.setUploadFail(fileItem, strings3.cancelUploadFile);
      }
    });
  }
  /**
   * Get Files and initalize MgtFileUploadItem object life cycle to be uploaded
   *
   * @param inputFiles
   */
  getSelectedFiles(files) {
    return __awaiter12(this, void 0, void 0, function* () {
      let fileItems = [];
      const fileItemsCompleted = [];
      this._applyAll = false;
      this._applyAllConflitBehavior = null;
      this._maximumFileSize = false;
      this._excludedFileType = false;
      this.filesToUpload.forEach((fileItem) => __awaiter12(this, void 0, void 0, function* () {
        if (!fileItem.completed) {
          fileItems.push(fileItem);
        } else {
          fileItemsCompleted.push(fileItem);
        }
      }));
      for (const file of files) {
        const fullPath = file.fullPath === "" ? "/" + file.name : file.fullPath;
        if (fileItems.filter((item) => item.fullPath === fullPath).length === 0) {
          let acceptFile = true;
          if (this.fileUploadList.maxFileSize !== void 0 && acceptFile) {
            if (file.size > this.fileUploadList.maxFileSize * 1024) {
              acceptFile = false;
              if (this._maximumFileSize === false) {
                const maximumFileSize = yield this.getFileUploadStatus(file, fullPath, "MaxFileSize", this.fileUploadList);
                if (maximumFileSize !== null) {
                  if (maximumFileSize[0] === 1) {
                    this._maximumFileSize = true;
                  }
                }
              }
            }
          }
          if (this.fileUploadList.excludedFileExtensions !== void 0) {
            if (this.fileUploadList.excludedFileExtensions.length > 0 && acceptFile) {
              if (this.fileUploadList.excludedFileExtensions.filter((fileExtension) => {
                return file.name.toLowerCase().indexOf(fileExtension.toLowerCase()) > -1;
              }).length > 0) {
                acceptFile = false;
                if (this._excludedFileType === false) {
                  const excludedFileType = yield this.getFileUploadStatus(file, fullPath, "ExcludedFileType", this.fileUploadList);
                  if (excludedFileType !== null) {
                    if (excludedFileType[0] === 1) {
                      this._excludedFileType = true;
                    }
                  }
                }
              }
            }
          }
          if (acceptFile) {
            const conflictBehavior = yield this.getFileUploadStatus(file, fullPath, "Upload", this.fileUploadList);
            let _completed = false;
            if (conflictBehavior !== null) {
              if (conflictBehavior[0] === -1) {
                _completed = true;
              } else {
                this._applyAll = Boolean(conflictBehavior[0]);
                this._applyAllConflitBehavior = conflictBehavior[1] ? 1 : 0;
              }
            }
            fileItems.push({
              file,
              driveItem: {
                name: file.name
              },
              fullPath,
              conflictBehavior: conflictBehavior !== null ? conflictBehavior[1] ? 1 : 0 : null,
              iconStatus: null,
              percent: 1,
              view: ViewType.image,
              completed: _completed,
              maxSize: this._maxChunckSize,
              minSize: 0
            });
          }
        }
      }
      fileItems = fileItems.sort((firstFile, secondFile) => {
        return firstFile.fullPath.substring(0, firstFile.fullPath.lastIndexOf("/")).localeCompare(secondFile.fullPath.substring(0, secondFile.fullPath.lastIndexOf("/")));
      });
      fileItems.forEach((fileItem) => {
        if (fileItemsCompleted.filter((item) => item.fullPath === fileItem.fullPath).length !== 0) {
          const index = fileItemsCompleted.findIndex((item) => item.fullPath === fileItem.fullPath);
          fileItemsCompleted.splice(index, 1);
        }
      });
      fileItems.push(...fileItemsCompleted);
      this.filesToUpload = fileItems;
      this.filesToUpload.forEach((fileItem) => __awaiter12(this, void 0, void 0, function* () {
        yield this.sendFileItemGraph(fileItem);
      }));
    });
  }
  /**
   * Call modal dialog to replace or keep file.
   *
   * @param file
   * @returns
   */
  getFileUploadStatus(file, fullPath, DialogStatus, fileUploadList) {
    const _super = Object.create(null, {
      requestStateUpdate: { get: () => super.requestStateUpdate }
    });
    return __awaiter12(this, void 0, void 0, function* () {
      const fileUploadDialog = this.renderRoot.querySelector("#file-upload-dialog");
      switch (DialogStatus) {
        case "Upload":
          const driveItem = yield getGraphfile(this.fileUploadList.graph, `${this.getGrapQuery(fullPath)}?$select=id`);
          if (driveItem !== null) {
            if (this._applyAll === true) {
              return [this._applyAll, this._applyAllConflitBehavior];
            }
            fileUploadDialog.classList.add("visible");
            this._dialogTitle = strings3.fileReplaceTitle;
            this._dialogContent = strings3.fileReplace.replace("{FileName}", file.name);
            this._dialogCheckBox = strings3.checkApplyAll;
            this._dialogPrimaryButton = strings3.buttonReplace;
            this._dialogSecondaryButton = strings3.buttonKeep;
            _super.requestStateUpdate.call(this, true);
            return new Promise((resolve) => __awaiter12(this, void 0, void 0, function* () {
              const fileUploadDialogClose = this.renderRoot.querySelector(".file-upload-dialog-close");
              const fileUploadDialogOk = this.renderRoot.querySelector(".file-upload-dialog-ok");
              const fileUploadDialogCancel = this.renderRoot.querySelector(".file-upload-dialog-cancel");
              const fileUploadDialogCheck = this.renderRoot.querySelector("#file-upload-dialog-check");
              fileUploadDialogCheck.checked = false;
              fileUploadDialogCheck.classList.remove("hide");
              fileUploadDialogOk.removeEventListener("click", onOkDialogClick);
              fileUploadDialogCancel.removeEventListener("click", onCancelDialogClick);
              fileUploadDialogClose.removeEventListener("click", onCloseDialogClick);
              fileUploadDialogOk.addEventListener("click", onOkDialogClick);
              fileUploadDialogCancel.addEventListener("click", onCancelDialogClick);
              fileUploadDialogClose.addEventListener("click", onCloseDialogClick);
              function onOkDialogClick() {
                fileUploadDialog.classList.remove("visible");
                resolve([
                  fileUploadDialogCheck.checked ? 1 : 0,
                  1
                  /* MgtFileUploadConflictBehavior.replace */
                ]);
              }
              function onCancelDialogClick() {
                fileUploadDialog.classList.remove("visible");
                resolve([
                  fileUploadDialogCheck.checked ? 1 : 0,
                  0
                  /* MgtFileUploadConflictBehavior.rename */
                ]);
              }
              function onCloseDialogClick() {
                fileUploadDialog.classList.remove("visible");
                resolve([-1]);
              }
            }));
          } else {
            return null;
          }
          break;
        case "ExcludedFileType":
          fileUploadDialog.classList.add("visible");
          this._dialogTitle = strings3.fileTypeTitle;
          this._dialogContent = strings3.fileType.replace("{FileName}", file.name) + " (" + fileUploadList.excludedFileExtensions.join(",") + ")";
          this._dialogCheckBox = strings3.checkAgain;
          this._dialogPrimaryButton = strings3.buttonOk;
          this._dialogSecondaryButton = strings3.buttonCancel;
          _super.requestStateUpdate.call(this, true);
          return new Promise((resolve) => __awaiter12(this, void 0, void 0, function* () {
            const fileUploadDialogOk = this.renderRoot.querySelector(".file-upload-dialog-ok");
            const fileUploadDialogCancel = this.renderRoot.querySelector(".file-upload-dialog-cancel");
            const fileUploadDialogClose = this.renderRoot.querySelector(".file-upload-dialog-close");
            const fileUploadDialogCheck = this.renderRoot.querySelector("#file-upload-dialog-check");
            fileUploadDialogCheck.checked = false;
            fileUploadDialogCheck.classList.remove("hide");
            fileUploadDialogOk.removeEventListener("click", onOkDialogClick);
            fileUploadDialogCancel.removeEventListener("click", onCancelDialogClick);
            fileUploadDialogClose.removeEventListener("click", onCancelDialogClick);
            fileUploadDialogOk.addEventListener("click", onOkDialogClick);
            fileUploadDialogCancel.addEventListener("click", onCancelDialogClick);
            fileUploadDialogClose.addEventListener("click", onCancelDialogClick);
            function onOkDialogClick() {
              fileUploadDialog.classList.remove("visible");
              resolve([fileUploadDialogCheck.checked ? 1 : 0]);
            }
            function onCancelDialogClick() {
              fileUploadDialog.classList.remove("visible");
              resolve([0]);
            }
          }));
        case "MaxFileSize":
          fileUploadDialog.classList.add("visible");
          this._dialogTitle = strings3.maximumFileSizeTitle;
          this._dialogContent = strings3.maximumFileSize.replace("{FileSize}", formatBytes(fileUploadList.maxFileSize)).replace("{FileName}", file.name) + formatBytes(file.size) + ".";
          this._dialogCheckBox = strings3.checkAgain;
          this._dialogPrimaryButton = strings3.buttonOk;
          this._dialogSecondaryButton = strings3.buttonCancel;
          _super.requestStateUpdate.call(this, true);
          return new Promise((resolve) => __awaiter12(this, void 0, void 0, function* () {
            const fileUploadDialogOk = this.renderRoot.querySelector(".file-upload-dialog-ok");
            const fileUploadDialogCancel = this.renderRoot.querySelector(".file-upload-dialog-cancel");
            const fileUploadDialogClose = this.renderRoot.querySelector(".file-upload-dialog-close");
            const fileUploadDialogCheck = this.renderRoot.querySelector("#file-upload-dialog-check");
            fileUploadDialogCheck.checked = false;
            fileUploadDialogCheck.classList.remove("hide");
            fileUploadDialogOk.removeEventListener("click", onOkDialogClick);
            fileUploadDialogCancel.removeEventListener("click", onCancelDialogClick);
            fileUploadDialogClose.removeEventListener("click", onCancelDialogClick);
            fileUploadDialogOk.addEventListener("click", onOkDialogClick);
            fileUploadDialogCancel.addEventListener("click", onCancelDialogClick);
            fileUploadDialogClose.addEventListener("click", onCancelDialogClick);
            function onOkDialogClick() {
              fileUploadDialog.classList.remove("visible");
              resolve([fileUploadDialogCheck.checked ? 1 : 0]);
            }
            function onCancelDialogClick() {
              fileUploadDialog.classList.remove("visible");
              resolve([0]);
            }
          }));
        default:
          break;
      }
    });
  }
  /**
   * Get GraphQuery based on pre defined parameters.
   *
   * @param fileItem
   * @returns
   */
  getGrapQuery(fullPath) {
    let itemPath = "";
    if (this.fileUploadList.itemPath) {
      if (this.fileUploadList.itemPath.length > 0) {
        itemPath = this.fileUploadList.itemPath.substring(0, 1) === "/" ? this.fileUploadList.itemPath : "/" + this.fileUploadList.itemPath;
      }
    }
    if (this.fileUploadList.userId && this.fileUploadList.itemId) {
      return `/users/${this.fileUploadList.userId}/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
    }
    if (this.fileUploadList.userId && this.fileUploadList.itemPath) {
      return `/users/${this.fileUploadList.userId}/drive/root:${itemPath}${fullPath}`;
    }
    if (this.fileUploadList.groupId && this.fileUploadList.itemId) {
      return `/groups/${this.fileUploadList.groupId}/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
    }
    if (this.fileUploadList.groupId && this.fileUploadList.itemPath) {
      return `/groups/${this.fileUploadList.groupId}/drive/root:${itemPath}${fullPath}`;
    }
    if (this.fileUploadList.driveId && this.fileUploadList.itemId) {
      return `/drives/${this.fileUploadList.driveId}/items/${this.fileUploadList.itemId}:${fullPath}`;
    }
    if (this.fileUploadList.driveId && this.fileUploadList.itemPath) {
      return `/drives/${this.fileUploadList.driveId}/root:${itemPath}${fullPath}`;
    }
    if (this.fileUploadList.siteId && this.fileUploadList.itemId) {
      return `/sites/${this.fileUploadList.siteId}/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
    }
    if (this.fileUploadList.siteId && this.fileUploadList.itemPath) {
      return `/sites/${this.fileUploadList.siteId}/drive/root:${itemPath}${fullPath}`;
    }
    if (this.fileUploadList.itemId) {
      return `/me/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
    }
    if (this.fileUploadList.itemPath) {
      return `/me/drive/root:${itemPath}${fullPath}`;
    }
    return `/me/drive/root:${fullPath}`;
  }
  /**
   * Send file using Upload using Graph based on length
   *
   * @param fileUpload
   * @returns
   */
  sendFileItemGraph(fileItem) {
    return __awaiter12(this, void 0, void 0, function* () {
      const graph = this.fileUploadList.graph;
      let graphQuery = "";
      if (fileItem.file.size < this._maxChunckSize) {
        try {
          if (!fileItem.completed) {
            if (fileItem.conflictBehavior === null || fileItem.conflictBehavior === 1) {
              graphQuery = `${this.getGrapQuery(fileItem.fullPath)}:/content`;
            }
            if (fileItem.conflictBehavior === 0) {
              graphQuery = `${this.getGrapQuery(fileItem.fullPath)}:/content?@microsoft.graph.conflictBehavior=rename`;
            }
            fileItem.driveItem = yield sendFileContent(graph, graphQuery, fileItem.file);
            if (fileItem.driveItem !== null) {
              this.setUploadSuccess(fileItem);
            } else {
              fileItem.driveItem = {
                name: fileItem.file.name
              };
              this.setUploadFail(fileItem, strings3.failUploadFile);
            }
          }
        } catch (error) {
          this.setUploadFail(fileItem, strings3.failUploadFile);
        }
      } else {
        if (!fileItem.completed) {
          if (fileItem.uploadUrl === void 0) {
            const response = yield getUploadSession(graph, `${this.getGrapQuery(fileItem.fullPath)}:/createUploadSession`, fileItem.conflictBehavior);
            try {
              if (response !== null) {
                fileItem.uploadUrl = response.uploadUrl;
                const driveItem = yield this.sendSessionUrlGraph(graph, fileItem);
                if (driveItem !== null) {
                  fileItem.driveItem = driveItem;
                  this.setUploadSuccess(fileItem);
                } else {
                  this.setUploadFail(fileItem, strings3.failUploadFile);
                }
              } else {
                this.setUploadFail(fileItem, strings3.failUploadFile);
              }
            } catch (_a2) {
            }
          }
        }
      }
    });
  }
  /**
   * Manage slices of File to upload file by chuncks using Graph and Session Url
   *
   * @param Graph
   * @param fileItem
   * @returns
   */
  sendSessionUrlGraph(graph, fileItem) {
    const _super = Object.create(null, {
      requestStateUpdate: { get: () => super.requestStateUpdate }
    });
    return __awaiter12(this, void 0, void 0, function* () {
      while (fileItem.file.size > fileItem.minSize) {
        if (fileItem.mimeStreamString === void 0) {
          fileItem.mimeStreamString = yield this.readFileContent(fileItem.file);
        }
        const fileSlice = new Blob([fileItem.mimeStreamString.slice(fileItem.minSize, fileItem.maxSize)]);
        fileItem.percent = Math.round(fileItem.maxSize / fileItem.file.size * 100);
        _super.requestStateUpdate.call(this, true);
        if (fileItem.uploadUrl !== void 0) {
          const response = yield sendFileChunck(graph, fileItem.uploadUrl, `${fileItem.maxSize - fileItem.minSize}`, `bytes ${fileItem.minSize}-${fileItem.maxSize - 1}/${fileItem.file.size}`, fileSlice);
          if (response === null) {
            return null;
          } else if (response.id !== void 0) {
            return response;
          } else if (response.nextExpectedRanges !== void 0) {
            fileItem.minSize = parseInt(response.nextExpectedRanges[0].split("-")[0]);
            fileItem.maxSize = fileItem.minSize + this._maxChunckSize;
            if (fileItem.maxSize > fileItem.file.size) {
              fileItem.maxSize = fileItem.file.size;
            }
          }
        } else {
          return null;
        }
      }
    });
  }
  /**
   * Change the state of Mgt-File icon upload to Success
   *
   * @param fileUpload
   */
  setUploadSuccess(fileUpload) {
    fileUpload.percent = 100;
    super.requestStateUpdate(true);
    setTimeout(() => {
      fileUpload.iconStatus = getSvg(SvgIcon.Success);
      fileUpload.view = ViewType.twolines;
      fileUpload.fieldUploadResponse = "lastModifiedDateTime";
      fileUpload.completed = true;
      super.requestStateUpdate(true);
      clearFilesCache();
    }, 500);
  }
  /**
   * Change the state of Mgt-File icon upload to Fail
   *
   * @param fileUpload
   */
  setUploadFail(fileUpload, errorMessage) {
    setTimeout(() => {
      fileUpload.iconStatus = getSvg(SvgIcon.Fail);
      fileUpload.view = ViewType.twolines;
      fileUpload.driveItem.description = errorMessage;
      fileUpload.fieldUploadResponse = "description";
      fileUpload.completed = true;
      super.requestStateUpdate(true);
    }, 500);
  }
  /**
   * Retrieve File content as ArrayBuffer
   *
   * @param file
   * @returns
   */
  readFileContent(file) {
    return new Promise((resolve, reject) => {
      const myReader = new FileReader();
      myReader.onloadend = (e) => {
        resolve(myReader.result);
      };
      myReader.onerror = (e) => {
        reject(e);
      };
      myReader.readAsArrayBuffer(file);
    });
  }
  /**
   * Collect Files from Upload Area based on maxUploadFile
   *
   * @param uploadFilesItems
   * @returns
   */
  getFilesFromUploadArea(filesItems) {
    return __awaiter12(this, void 0, void 0, function* () {
      const folders = [];
      let entry;
      const collectFilesItems = [];
      for (const uploadFileItem of filesItems) {
        if (uploadFileItem.kind === "file") {
          if (uploadFileItem.getAsEntry) {
            entry = uploadFileItem.getAsEntry();
            if (entry.isDirectory) {
              folders.push(entry);
            } else {
              const file = uploadFileItem.getAsFile();
              if (file) {
                file.fullPath = "";
                collectFilesItems.push(file);
              }
            }
          } else if (uploadFileItem.webkitGetAsEntry) {
            entry = uploadFileItem.webkitGetAsEntry();
            if (entry.isDirectory) {
              folders.push(entry);
            } else {
              const file = uploadFileItem.getAsFile();
              if (file) {
                file.fullPath = "";
                collectFilesItems.push(file);
              }
            }
          } else if ("function" == typeof uploadFileItem.getAsFile) {
            const file = uploadFileItem.getAsFile();
            if (file) {
              file.fullPath = "";
              collectFilesItems.push(file);
            }
          }
          continue;
        } else {
          const fileItem = uploadFileItem;
          if (fileItem) {
            fileItem.fullPath = "";
            collectFilesItems.push(fileItem);
          }
        }
      }
      if (folders.length > 0) {
        const folderFiles = yield this.getFolderFiles(folders);
        collectFilesItems.push(...folderFiles);
      }
      return collectFilesItems;
    });
  }
  /**
   * Retrieve files from folder and subfolders to array.
   *
   * @param folders
   * @returns
   */
  getFolderFiles(folders) {
    return new Promise((resolve) => {
      let reading = 0;
      const contents = [];
      folders.forEach((entry) => {
        readEntry(entry, "");
      });
      function readEntry(entry, path) {
        if (entry.isDirectory) {
          readReaderContent(entry.createReader());
        } else {
          reading++;
          entry.file((file) => {
            reading--;
            file.fullPath = path;
            contents.push(file);
            if (reading === 0) {
              resolve(contents);
            }
          });
        }
      }
      function readReaderContent(reader) {
        reading++;
        reader.readEntries((entries) => {
          reading--;
          for (const entry of entries) {
            readEntry(entry, entry.fullPath);
          }
          if (reading === 0) {
            resolve(contents);
          }
        });
      }
    });
  }
};
__decorate8([
  property({ type: Object }),
  __metadata6("design:type", Array)
], MgtFileUpload.prototype, "filesToUpload", void 0);
__decorate8([
  property({ type: Object }),
  __metadata6("design:type", Object)
], MgtFileUpload.prototype, "fileUploadList", void 0);
MgtFileUpload = __decorate8([
  customElement("file-upload"),
  __metadata6("design:paramtypes", [])
], MgtFileUpload);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/mgt-file-list-css.js
init_lit();
var styles8 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--file-item-background-color--hover:#f7f7f7;--file-item-background-color--active:#fbfbfb;--file-list-background-color:#ffffff;--file-upload-button-background-color:#f3f2f1;--file-upload-dialog-background-color:rgba(0, 0, 0, 0.1);--file-upload-dialog-content-background-color:white;--file-upload-dialog-content-color:#323130;--file-upload-dialog-primarybutton-color:white;--file-upload-dialog-primarybutton-background-color:#006cbe}.mgt-dark{--file-item-background-color--hover:#0078d4;--file-item-background-color--active:#238ada;--file-list-background-color:#424242;--file-upload-button-background-color:#006cbe;--file-upload-dialog-background-color:rgba(0, 0, 0, 0.3);--file-upload-dialog-content-background-color:#787878;--file-upload-dialog-content-color:#000;--file-upload-dialog-primarybutton-color:white;--file-upload-dialog-primarybutton-background-color:#006cbe}:host{font-family:var(--default-font-family);font-size:var(--default-font-size)}:host .title{font-size:14px;font-weight:600;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));padding:20px 0 12px;line-height:19px}:host .root{padding-inline-start:20px}:host .file-list-wrapper{background-color:var(--file-list-background-color,#fff);box-shadow:var(--file-list-box-shadow,0 3.2px 7.2px rgba(0,0,0,.132),0 .6px 1.8px rgba(0,0,0,.108));border-radius:var(--file-list-border-radius,4px);border:var(--file-list-border,none);position:relative;color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a));display:flex;flex-direction:column;border-radius:8px}:host .file-list-wrapper .title{font-size:14px;font-weight:600;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));margin:0 20px -15px 20px}:host .file-list-wrapper .file-list{display:flex;padding:var(--file-list-padding,4px 0);margin:var(--file-list-margin,0);flex-direction:column;list-style:none}:host .file-list-wrapper .file-list .file-item{border-top:var(--file-item-border-top,none);border-left:var(--file-item-border-left,none);border-right:var(--file-item-border-right,none);border-bottom:var(--file-item-border-bottom,none);margin:var(--file-item-margin,0 4px 0 4px);padding-inline-start:var(--file-item-padding-inline-start,24px);padding-top:var(--file-item-padding-top,10px);padding-bottom:var(--file-item-padding-bottom,8px);border-radius:var(--file-item-border-radius,2px);cursor:pointer}:host .file-list-wrapper .file-list .file-item .mgt-file-item{--file-background-color:$background-color}:host .file-list-wrapper .file-list .file-item.focused,:host .file-list-wrapper .file-list .file-item:hover{background-color:var(--file-item-background-color--hover,#f7f7f7)}:host .file-list-wrapper .file-list .file-item.focused .mgt-file-item,:host .file-list-wrapper .file-list .file-item:hover .mgt-file-item{--file-background-color:$file-item-background-color--hover}:host .file-list-wrapper .file-list .file-item.selected,:host .file-list-wrapper .file-list .file-item:active{background-color:var(--file-item-background-color--active,#fbfbfb)}:host .file-list-wrapper .file-list .file-item.selected .mgt-file-item,:host .file-list-wrapper .file-list .file-item:active .mgt-file-item{--file-background-color:$file-item-background-color--active}:host .file-list-wrapper .progress-ring{margin:4px auto;width:var(--progress-ring-size,24px);height:var(--progress-ring-size,24px)}:host .file-list-wrapper .show-more{text-align:center;font-size:var(--show-more-button-font-size,12px);padding:var(--show-more-button-padding,6px);border-bottom-right-radius:var(--show-more-button-border-bottom-right-radius,8px);border-bottom-left-radius:var(--show-more-button-border-bottom-left-radius,8px);cursor:pointer}:host .file-list-wrapper .show-more:hover{background-color:var(--show-more-button-background-color--hover,#efefef)}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/strings.js
var strings4 = {
  showMoreSubtitle: "Show more items",
  filesSectionTitle: "Files",
  sharedTextSubtitle: "Shared"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-file-list/mgt-file-list.js
init_esm3();
init_FluentComponents();
var __decorate9 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata7 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
registerFluentComponents(fluentProgressRing, fluentDesignSystemProvider);
var MgtFileList = class MgtFileList2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles8;
  }
  get strings() {
    return strings4;
  }
  /**
   * allows developer to provide query for a file list
   *
   * @type {string}
   * @memberof MgtFileList
   */
  get fileListQuery() {
    return this._fileListQuery;
  }
  set fileListQuery(value) {
    if (value === this._fileListQuery) {
      return;
    }
    this._fileListQuery = value;
    this.requestStateUpdate(true);
  }
  /**
   * The name for display in the overview section.
   *
   * @readonly
   * @type {string}
   * @memberof MgtFileList
   */
  get displayName() {
    return this.strings.filesSectionTitle;
  }
  /**
   * Render the icon for display in the navigation ribbon.
   *
   * @returns {TemplateResult}
   * @memberof MgtFileList
   */
  renderIcon() {
    return getSvg(SvgIcon.Files);
  }
  /**
   * Set the section to compact view mode
   *
   * @returns
   * @memberof MgtFileList
   */
  asCompactView() {
    this._isCompact = true;
    this.requestUpdate();
    return this;
  }
  /**
   * Set the section to full view mode
   *
   * @returns
   * @memberof MgtFileList
   */
  asFullView() {
    this._isCompact = false;
    this._isFullView = true;
    this.requestUpdate();
    return this;
  }
  /**
   * allows developer to provide an array of file queries
   *
   * @type {string[]}
   * @memberof MgtFileList
   */
  get fileQueries() {
    return this._fileQueries;
  }
  set fileQueries(value) {
    if (arraysAreEqual(this._fileQueries, value)) {
      return;
    }
    this._fileQueries = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide site id for a file
   *
   * @type {string}
   * @memberof MgtFileList
   */
  get siteId() {
    return this._siteId;
  }
  set siteId(value) {
    if (value === this._siteId) {
      return;
    }
    this._siteId = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide drive id for a file
   *
   * @type {string}
   * @memberof MgtFileList
   */
  get driveId() {
    return this._driveId;
  }
  set driveId(value) {
    if (value === this._driveId) {
      return;
    }
    this._driveId = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide group id for a file
   *
   * @type {string}
   * @memberof MgtFileList
   */
  get groupId() {
    return this._groupId;
  }
  set groupId(value) {
    if (value === this._groupId) {
      return;
    }
    this._groupId = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide item id for a file
   *
   * @type {string}
   * @memberof MgtFileList
   */
  get itemId() {
    return this._itemId;
  }
  set itemId(value) {
    if (value === this._itemId) {
      return;
    }
    this._itemId = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide item path for a file
   *
   * @type {string}
   * @memberof MgtFileList
   */
  get itemPath() {
    return this._itemPath;
  }
  set itemPath(value) {
    if (value === this._itemPath) {
      return;
    }
    this._itemPath = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide user id for a file
   *
   * @type {string}
   * @memberof MgtFile
   */
  get userId() {
    return this._userId;
  }
  set userId(value) {
    if (value === this._userId) {
      return;
    }
    this._userId = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide insight type for a file
   * can be trending, used, or shared
   *
   * @type {OfficeGraphInsightString}
   * @memberof MgtFileList
   */
  get insightType() {
    return this._insightType;
  }
  set insightType(value) {
    if (value === this._insightType) {
      return;
    }
    this._insightType = value;
    this.requestStateUpdate(true);
  }
  /**
   * allows developer to provide file type to filter the list
   * can be docx
   *
   * @type {string[]}
   * @memberof MgtFileList
   */
  get fileExtensions() {
    return this._fileExtensions;
  }
  set fileExtensions(value) {
    if (arraysAreEqual(this._fileExtensions, value)) {
      return;
    }
    this._fileExtensions = value;
    this.requestStateUpdate(true);
  }
  /**
   * A number value to indicate the number of more files to load when show more button is clicked
   * @type {number}
   * @memberof MgtFileList
   */
  get pageSize() {
    return this._pageSize;
  }
  set pageSize(value) {
    if (value === this._pageSize) {
      return;
    }
    this._pageSize = value;
    this.requestStateUpdate(true);
  }
  /**
   * A number value indication for file size upload (KB)
   * @type {number}
   * @memberof MgtFileList
   */
  get maxFileSize() {
    return this._maxFileSize;
  }
  set maxFileSize(value) {
    if (value === this._maxFileSize) {
      return;
    }
    this._maxFileSize = value;
    this.requestStateUpdate(true);
  }
  /**
   * A number value to indicate the max number allowed of files to upload.
   * @type {number}
   * @memberof MgtFileList
   */
  get maxUploadFile() {
    return this._maxUploadFile;
  }
  set maxUploadFile(value) {
    if (value === this._maxUploadFile) {
      return;
    }
    this._maxUploadFile = value;
    this.requestStateUpdate(true);
  }
  /**
   * A Array of file extensions to be excluded from file upload.
   *
   * @type {string[]}
   * @memberof MgtFileList
   */
  get excludedFileExtensions() {
    return this._excludedFileExtensions;
  }
  set excludedFileExtensions(value) {
    if (arraysAreEqual(this._excludedFileExtensions, value)) {
      return;
    }
    this._excludedFileExtensions = value;
    this.requestStateUpdate(true);
  }
  /**
   * Get the scopes required for file list
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtFileList
   */
  static get requiredScopes() {
    return [.../* @__PURE__ */ new Set([...MgtFile.requiredScopes])];
  }
  constructor() {
    super();
    this._focusedItemIndex = -1;
    this.pageSize = 10;
    this.itemView = ViewType.twolines;
    this.maxUploadFile = 10;
    this.enableFileUpload = false;
    this._preloadedFiles = [];
    this._isCompact = false;
    this._isFullView = false;
  }
  /**
   * Override requestStateUpdate to include clearstate.
   *
   * @memberof MgtFileList
   */
  requestStateUpdate(force) {
    this.clearState();
    return super.requestStateUpdate(force);
  }
  /**
   * Reset state
   *
   * @memberof MgtFileList
   */
  clearState() {
    super.clearState();
    this.files = null;
  }
  render() {
    if (!this.files && this.isLoadingState) {
      return this.renderLoading();
    }
    if (!this.files || this.files.length === 0) {
      return this.renderNoData();
    }
    return this._isCompact ? this.renderCompactView() : this.renderTemplate("default", { files: this.files }) || this.renderFiles();
  }
  /**
   * Render the compact view
   *
   * @returns {TemplateResult}
   * @memberof MgtFileList
   */
  renderCompactView() {
    let contentTemplate;
    let files = this.files.slice(0, 3);
    contentTemplate = html`
      ${files.map((file) => this.renderFile(file))}
    `;
    return html`
      <div class="root compact" dir=${this.direction}>
        ${contentTemplate}
      </div>
    `;
  }
  /**
   * Render the loading state
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtFileList
   */
  renderLoading() {
    return this.renderTemplate("loading", null) || html``;
  }
  /**
   * Render the state when no data is available
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtFileList
   */
  renderNoData() {
    return this.renderTemplate("no-data", null) || (this.enableFileUpload === true && Providers.globalProvider !== void 0 ? html`
      <fluent-design-system-provider use-defaults>
        <div id="file-list-wrapper" class="file-list-wrapper" dir=${this.direction}>
          ${this.renderFileUpload()}
        </div>
      </fluent-design-system-provider>
      ` : html``);
  }
  /**
   * Render the list of files.
   *
   * @protected
   * @param {*} files
   * @returns {TemplateResult}
   * @memberof mgtFileList
   */
  renderFiles() {
    return html`
      <div id="file-list-wrapper" class="file-list-wrapper" dir=${this.direction}>
        ${this.enableFileUpload ? this.renderFileUpload() : null}
        ${this._isFullView ? html`<div class="title">${this.strings.filesSectionTitle}</div>` : null}
        <ul
          id="file-list"
          class="file-list"
          tabindex="0"
          @keydown="${this.onFileListKeyDown}"
          @keyup="${this.onFileListKeyUp}"
          @blur="${this.onFileListOut}"
        >
          ${repeat(this.files, (f) => f.id, (f) => html`
              <li class="file-item" @click=${(e) => this.handleItemSelect(f, e)}>
                ${this.renderFile(f)}
              </li>
            `)}
        </ul>
        ${!this.hideMoreFilesButton && this.pageIterator && (this.pageIterator.hasNext || this._preloadedFiles.length) ? this.renderMoreFileButton() : null}
      </div>
    `;
  }
  /**
   * Render an individual file.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof mgtFileList
   */
  renderFile(file) {
    const view = this.itemView;
    return this.renderTemplate("file", { file }, file.id) || mgtHtml`
        <mgt-file class="mgt-file-item" .fileDetails=${file} .view=${view}></mgt-file>
      `;
  }
  /**
   * Render the button when clicked will show more files.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtFileList
   */
  renderMoreFileButton() {
    if (this._isLoadingMore) {
      return html`
        <fluent-progress-ring role="progressbar" viewBox="0 0 8 8" class="progress-ring"></fluent-progress-ring>
      `;
    } else {
      return html`<a id="show-more" class="show-more" @click=${() => this.renderNextPage()} tabindex="0" @keydown=${this.onShowMoreKeyDown}><span>${this.strings.showMoreSubtitle}<span></a>`;
    }
  }
  /**
   * Render MgtFileUpload sub component
   *
   * @returns
   */
  renderFileUpload() {
    const fileUploadConfig = {
      graph: Providers.globalProvider.graph.forComponent(this),
      driveId: this.driveId,
      excludedFileExtensions: this.excludedFileExtensions,
      groupId: this.groupId,
      itemId: this.itemId,
      itemPath: this.itemPath,
      userId: this.userId,
      siteId: this.siteId,
      maxFileSize: this.maxFileSize,
      maxUploadFile: this.maxUploadFile
    };
    return mgtHtml`
        <mgt-file-upload .fileUploadList=${fileUploadConfig} ></mgt-file-upload>
      `;
  }
  /**
   * Handle accessibility keyboard enter event on 'show more items' button
   *
   * @param event
   */
  onShowMoreKeyDown(event) {
    if (event && event.code === "Enter") {
      event.preventDefault();
      this.renderNextPage();
    }
  }
  /**
   * Handle accessibility keyboard keyup events on file list
   *
   * @param event
   */
  onFileListKeyUp(event) {
    const fileList = this.renderRoot.querySelector(".file-list");
    const focusedItem = fileList.children[this._focusedItemIndex];
    if (event.code === "Enter" || event.code === "Space") {
      event.preventDefault();
      focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.classList.remove("selected");
      focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.classList.add("focused");
    }
  }
  /**
   * Handle accessibility keyboard keydown events (arrow up, arrow down, enter, tab) on file list
   *
   * @param event
   */
  onFileListKeyDown(event) {
    const fileList = this.renderRoot.querySelector(".file-list");
    let focusedItem;
    if (!fileList || !fileList.children.length) {
      return;
    }
    if (event.code === "ArrowUp" || event.code === "ArrowDown") {
      if (event.code === "ArrowUp") {
        if (this._focusedItemIndex === -1) {
          this._focusedItemIndex = fileList.children.length;
        }
        this._focusedItemIndex = (this._focusedItemIndex - 1 + fileList.children.length) % fileList.children.length;
      }
      if (event.code === "ArrowDown") {
        this._focusedItemIndex = (this._focusedItemIndex + 1) % fileList.children.length;
      }
      focusedItem = fileList.children[this._focusedItemIndex];
      this.updateItemBackgroundColor(fileList, focusedItem, "focused");
    }
    if (event.code === "Enter" || event.code === "Space") {
      focusedItem = fileList.children[this._focusedItemIndex];
      const file = focusedItem.children[0];
      event.preventDefault();
      this.fireCustomEvent("itemClick", file.fileDetails);
      this.updateItemBackgroundColor(fileList, focusedItem, "selected");
    }
    if (event.code === "Tab") {
      focusedItem = fileList.children[this._focusedItemIndex];
      focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.classList.remove("focused");
    }
  }
  /**
   * Remove accessibility keyboard focused when out of file list
   *
   */
  onFileListOut() {
    const fileList = this.renderRoot.querySelector(".file-list");
    const focusedItem = fileList.children[this._focusedItemIndex];
    focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.classList.remove("focused");
  }
  /**
   * load state into the component.
   *
   * @protected
   * @returns
   * @memberof MgtFileList
   */
  loadState() {
    return __awaiter13(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      if (!provider || provider.state === ProviderState.Loading) {
        return;
      }
      if (provider.state === ProviderState.SignedOut) {
        this.files = null;
        return;
      }
      const graph = provider.graph.forComponent(this);
      let files;
      let pageIterator;
      const getFromMyDrive = !this.driveId && !this.siteId && !this.groupId && !this.userId;
      if (this.driveId && !this.itemId && !this.itemPath || this.groupId && !this.itemId && !this.itemPath || this.siteId && !this.itemId && !this.itemPath || this.userId && !this.insightType && !this.itemId && !this.itemPath) {
        this.files = null;
      }
      if (!this.files) {
        if (this.fileListQuery) {
          pageIterator = yield getFilesByListQueryIterator(graph, this.fileListQuery, this.pageSize);
        } else if (this.fileQueries) {
          files = yield getFilesByQueries(graph, this.fileQueries);
        } else if (getFromMyDrive) {
          if (this.itemId) {
            pageIterator = yield getFilesByIdIterator(graph, this.itemId, this.pageSize);
          } else if (this.itemPath) {
            pageIterator = yield getFilesByPathIterator(graph, this.itemPath, this.pageSize);
          } else if (this.insightType) {
            files = yield getMyInsightsFiles(graph, this.insightType);
          } else {
            pageIterator = yield getFilesIterator(graph, this.pageSize);
          }
        } else if (this.driveId) {
          if (this.itemId) {
            pageIterator = yield getDriveFilesByIdIterator(graph, this.driveId, this.itemId, this.pageSize);
          } else if (this.itemPath) {
            pageIterator = yield getDriveFilesByPathIterator(graph, this.driveId, this.itemPath, this.pageSize);
          }
        } else if (this.groupId) {
          if (this.itemId) {
            pageIterator = yield getGroupFilesByIdIterator(graph, this.groupId, this.itemId, this.pageSize);
          } else if (this.itemPath) {
            pageIterator = yield getGroupFilesByPathIterator(graph, this.groupId, this.itemPath, this.pageSize);
          }
        } else if (this.siteId) {
          if (this.itemId) {
            pageIterator = yield getSiteFilesByIdIterator(graph, this.siteId, this.itemId, this.pageSize);
          } else if (this.itemPath) {
            pageIterator = yield getSiteFilesByPathIterator(graph, this.siteId, this.itemPath, this.pageSize);
          }
        } else if (this.userId) {
          if (this.itemId) {
            pageIterator = yield getUserFilesByIdIterator(graph, this.userId, this.itemId, this.pageSize);
          } else if (this.itemPath) {
            pageIterator = yield getUserFilesByPathIterator(graph, this.userId, this.itemPath, this.pageSize);
          } else if (this.insightType) {
            files = yield getUserInsightsFiles(graph, this.userId, this.insightType);
          }
        }
        if (pageIterator) {
          this.pageIterator = pageIterator;
          this._preloadedFiles = [...this.pageIterator.value];
          if (this._preloadedFiles.length >= this.pageSize) {
            files = this._preloadedFiles.splice(0, this.pageSize);
          } else {
            files = this._preloadedFiles.splice(0, this._preloadedFiles.length);
          }
        }
        let filteredByFileExtension;
        if (this.fileExtensions && this.fileExtensions !== null) {
          if (this.pageIterator && this.pageIterator.value) {
            while (this.pageIterator.hasNext) {
              yield fetchNextAndCacheForFilesPageIterator(this.pageIterator);
            }
            files = this.pageIterator.value;
            this._preloadedFiles = [];
          }
          filteredByFileExtension = files.filter((file) => {
            for (const e of this.fileExtensions) {
              if (e == this.getFileExtension(file.name)) {
                return file;
              }
            }
          });
        }
        if (filteredByFileExtension && filteredByFileExtension.length >= 0) {
          this.files = filteredByFileExtension;
          if (this.pageSize) {
            files = this.files.splice(0, this.pageSize);
            this.files = files;
          }
        } else {
          this.files = files;
        }
      }
    });
  }
  /**
   * Handle the click event on an item.
   *
   * @protected
   * @memberof MgtFileList
   */
  handleItemSelect(item, event) {
    this.handleFileClick(item);
    this.fireCustomEvent("itemClick", item);
    if (event) {
      const fileList = this.renderRoot.querySelector(".file-list");
      const nodes = Array.from(fileList.children);
      const li = event.target.closest("li");
      const index = nodes.indexOf(li);
      this._focusedItemIndex = index;
      const clickedItem = fileList.children[this._focusedItemIndex];
      this.updateItemBackgroundColor(fileList, clickedItem, "selected");
      for (let i = 0; i < fileList.children.length; i++) {
        fileList.children[i].classList.remove("focused");
      }
    }
  }
  /**
   * Handle the click event on button to show next page.
   *
   * @protected
   * @memberof MgtFileList
   */
  renderNextPage() {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this._preloadedFiles.length > 0) {
        this.files = [
          ...this.files,
          ...this._preloadedFiles.splice(0, Math.min(this.pageSize, this._preloadedFiles.length))
        ];
      } else {
        if (this.pageIterator.hasNext) {
          this._isLoadingMore = true;
          const root = this.renderRoot.querySelector("file-list-wrapper");
          if (root && root.animate) {
            root.animate([
              {
                height: "auto",
                transformOrigin: "top left"
              },
              {
                height: "auto",
                transformOrigin: "top left"
              }
            ], {
              duration: 1e3,
              easing: "ease-in-out",
              fill: "both"
            });
          }
          yield fetchNextAndCacheForFilesPageIterator(this.pageIterator);
          this._isLoadingMore = false;
          this.files = this.pageIterator.value;
        }
      }
      this.requestUpdate();
    });
  }
  handleFileClick(file) {
    if (file && file.webUrl) {
      window.open(file.webUrl, "_blank", "noreferrer");
    }
  }
  /**
   * Get file extension string from file name
   *
   * @param name file name
   * @returns {string} file extension
   */
  getFileExtension(name) {
    const re = /(?:\.([^.]+))?$/;
    const fileExtension = re.exec(name)[1] || "";
    return fileExtension;
  }
  /**
   * Handle remove and add css class on accessibility keyboard select and focus
   *
   * @param fileList HTML element
   * @param focusedItem HTML element
   * @param className background class to be applied
   */
  updateItemBackgroundColor(fileList, focusedItem, className) {
    for (let i = 0; i < fileList.children.length; i++) {
      fileList.children[i].classList.remove(className);
    }
    if (focusedItem) {
      focusedItem.classList.add(className);
      focusedItem.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" });
    }
  }
  /**
   * Handle reload of File List and condition to clear cache
   *
   * @param clearCache boolean, if true clear cache
   */
  reload(clearCache = false) {
    if (clearCache) {
      clearFilesCache();
    }
    this.requestStateUpdate(true);
  }
};
__decorate9([
  property({
    attribute: "file-list-query"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "fileListQuery", null);
__decorate9([
  property({
    attribute: "file-queries",
    converter: (value, type) => {
      if (value) {
        return value.split(",").map((v) => v.trim());
      } else {
        return null;
      }
    }
  }),
  __metadata7("design:type", Array),
  __metadata7("design:paramtypes", [Array])
], MgtFileList.prototype, "fileQueries", null);
__decorate9([
  property({ type: Object }),
  __metadata7("design:type", Array)
], MgtFileList.prototype, "files", void 0);
__decorate9([
  property({
    attribute: "site-id"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "siteId", null);
__decorate9([
  property({
    attribute: "drive-id"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "driveId", null);
__decorate9([
  property({
    attribute: "group-id"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "groupId", null);
__decorate9([
  property({
    attribute: "item-id"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "itemId", null);
__decorate9([
  property({
    attribute: "item-path"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "itemPath", null);
__decorate9([
  property({
    attribute: "user-id"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "userId", null);
__decorate9([
  property({
    attribute: "insight-type"
  }),
  __metadata7("design:type", String),
  __metadata7("design:paramtypes", [String])
], MgtFileList.prototype, "insightType", null);
__decorate9([
  property({
    attribute: "item-view",
    converter: (value) => {
      if (!value || value.length === 0) {
        return ViewType.threelines;
      }
      value = value.toLowerCase();
      if (typeof ViewType[value] === "undefined") {
        return ViewType.threelines;
      } else {
        return ViewType[value];
      }
    }
  }),
  __metadata7("design:type", Number)
], MgtFileList.prototype, "itemView", void 0);
__decorate9([
  property({
    attribute: "file-extensions",
    converter: (value, type) => {
      return value.split(",").map((v) => v.trim());
    }
  }),
  __metadata7("design:type", Array),
  __metadata7("design:paramtypes", [Array])
], MgtFileList.prototype, "fileExtensions", null);
__decorate9([
  property({
    attribute: "page-size",
    type: Number
  }),
  __metadata7("design:type", Number),
  __metadata7("design:paramtypes", [Number])
], MgtFileList.prototype, "pageSize", null);
__decorate9([
  property({
    attribute: "hide-more-files-button",
    type: Boolean
  }),
  __metadata7("design:type", Boolean)
], MgtFileList.prototype, "hideMoreFilesButton", void 0);
__decorate9([
  property({
    attribute: "max-file-size",
    type: Number
  }),
  __metadata7("design:type", Number),
  __metadata7("design:paramtypes", [Number])
], MgtFileList.prototype, "maxFileSize", null);
__decorate9([
  property({
    attribute: "enable-file-upload",
    type: Boolean
  }),
  __metadata7("design:type", Boolean)
], MgtFileList.prototype, "enableFileUpload", void 0);
__decorate9([
  property({
    attribute: "max-upload-file",
    type: Number
  }),
  __metadata7("design:type", Number),
  __metadata7("design:paramtypes", [Number])
], MgtFileList.prototype, "maxUploadFile", null);
__decorate9([
  state(),
  __metadata7("design:type", Boolean)
], MgtFileList.prototype, "_isCompact", void 0);
__decorate9([
  state(),
  __metadata7("design:type", Boolean)
], MgtFileList.prototype, "_isFullView", void 0);
__decorate9([
  property({
    attribute: "excluded-file-extensions",
    converter: (value, type) => {
      return value.split(",").map((v) => v.trim());
    }
  }),
  __metadata7("design:type", Array),
  __metadata7("design:paramtypes", [Array])
], MgtFileList.prototype, "excludedFileExtensions", null);
__decorate9([
  state(),
  __metadata7("design:type", Boolean)
], MgtFileList.prototype, "_isLoadingMore", void 0);
MgtFileList = __decorate9([
  customElement("file-list"),
  __metadata7("design:paramtypes", [])
], MgtFileList);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-picker/mgt-picker.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-picker/strings.js
var strings5 = {
  comboboxPlaceholder: "Select an item"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-picker/mgt-picker.js
init_esm3();
init_FluentComponents();
var __decorate10 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata8 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
registerFluentComponents(fluentCombobox, fluentOption);
var MgtPicker = class MgtPicker2 extends MgtTemplatedComponent {
  get strings() {
    return strings5;
  }
  constructor() {
    super();
    this.version = "v1.0";
    this.maxPages = 3;
    this.scopes = [];
    this.cacheEnabled = false;
    this.cacheInvalidationPeriod = 0;
    this.placeholder = this.strings.comboboxPlaceholder;
    this.entityType = null;
    this.keyName = null;
    this.isRefreshing = false;
  }
  /**
   * Refresh the data
   *
   * @param {boolean} [hardRefresh=false]
   * if false (default), the component will only update if the data changed
   * if true, the data will be first cleared and reloaded completely
   * @memberof MgtPicker
   */
  refresh(hardRefresh = false) {
    this.isRefreshing = true;
    if (hardRefresh) {
      this.clearState();
    }
    this.requestStateUpdate(hardRefresh);
  }
  /**
   * Clears the state of the component
   *
   * @protected
   * @memberof MgtPicker
   */
  clearState() {
    this.response = null;
    this.error = null;
  }
  /**
   * Invoked on each update to perform rendering the picker. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    var _a2;
    if (this.isLoadingState && !this.response) {
      return this.renderTemplate("loading", null);
    } else if (this.hasTemplate("error")) {
      return this.renderTemplate("error", this.error ? this.error : null, "error");
    } else if (this.hasTemplate("no-data")) {
      return this.renderTemplate("no-data", null);
    }
    return ((_a2 = this.response) === null || _a2 === void 0 ? void 0 : _a2.length) > 0 ? this.renderPicker() : this.renderGet();
  }
  /**
   * Render picker.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPicker
   */
  renderPicker() {
    return mgtHtml`
      <fluent-combobox id="combobox" autocomplete="list" placeholder=${this.placeholder}>
        ${this.response.map((item) => html`
          <fluent-option value=${item.id} @click=${(e) => this.handleClick(e, item)}> ${item[this.keyName]} </fluent-option>`)}
      </fluent-combobox>
     `;
  }
  /**
   * Render picker.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPicker
   */
  renderGet() {
    return mgtHtml`
      <mgt-get 
        resource=${this.resource}
        version=${this.version} 
        scopes=${this.scopes} 
        max-pages=${this.maxPages} 
        ?cache-enabled=${this.cacheEnabled}
        ?cache-invalidation-period=${this.cacheInvalidationPeriod}>
      </mgt-get>`;
  }
  /**
   * load state into the component.
   *
   * @protected
   * @returns
   * @memberof MgtPicker
   */
  loadState() {
    return __awaiter14(this, void 0, void 0, function* () {
      if (!this.response) {
        let parent = this.renderRoot.querySelector("mgt-get");
        parent.addEventListener("dataChange", (e) => this.handleDataChange(e));
      }
      this.isRefreshing = false;
    });
  }
  handleDataChange(e) {
    let response = e.detail.response.value;
    let error = e.detail.error ? e.detail.error : null;
    this.response = response;
    this.error = error;
  }
  handleClick(e, item) {
    this.fireCustomEvent("selectionChanged", item);
  }
};
__decorate10([
  property({
    attribute: "resource",
    type: String
  }),
  __metadata8("design:type", String)
], MgtPicker.prototype, "resource", void 0);
__decorate10([
  property({
    attribute: "version",
    type: String
  }),
  __metadata8("design:type", String)
], MgtPicker.prototype, "version", void 0);
__decorate10([
  property({
    attribute: "max-pages",
    type: Number
  }),
  __metadata8("design:type", Number)
], MgtPicker.prototype, "maxPages", void 0);
__decorate10([
  property({
    attribute: "placeholder",
    type: String
  }),
  __metadata8("design:type", String)
], MgtPicker.prototype, "placeholder", void 0);
__decorate10([
  property({
    attribute: "key-name",
    type: String
  }),
  __metadata8("design:type", String)
], MgtPicker.prototype, "keyName", void 0);
__decorate10([
  property({
    attribute: "entity-type",
    type: String
  }),
  __metadata8("design:type", String)
], MgtPicker.prototype, "entityType", void 0);
__decorate10([
  property({
    attribute: "scopes",
    converter: (value) => {
      return value ? value.toLowerCase().split(",") : null;
    }
  }),
  __metadata8("design:type", Array)
], MgtPicker.prototype, "scopes", void 0);
__decorate10([
  property({
    attribute: "cache-enabled",
    type: Boolean
  }),
  __metadata8("design:type", Boolean)
], MgtPicker.prototype, "cacheEnabled", void 0);
__decorate10([
  property({
    attribute: "cache-invalidation-period",
    type: Number
  }),
  __metadata8("design:type", Number)
], MgtPicker.prototype, "cacheInvalidationPeriod", void 0);
__decorate10([
  state(),
  __metadata8("design:type", Array)
], MgtPicker.prototype, "response", void 0);
__decorate10([
  state(),
  __metadata8("design:type", Array)
], MgtPicker.prototype, "error", void 0);
MgtPicker = __decorate10([
  customElement("picker"),
  __metadata8("design:paramtypes", [])
], MgtPicker);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-get/mgt-get.js
init_lit();
init_decorators();
init_es6();
var __decorate11 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata9 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ResponseType2;
(function(ResponseType3) {
  ResponseType3["json"] = "json";
  ResponseType3["image"] = "image";
})(ResponseType2 || (ResponseType2 = {}));
var getResponseInvalidationTime = (currentInvalidationPeriod) => currentInvalidationPeriod || CacheService.config.response.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsResponseCacheEnabled = () => CacheService.config.response.isEnabled && CacheService.config.isEnabled;
var MgtGet = class MgtGet2 extends MgtTemplatedComponent {
  constructor() {
    super(...arguments);
    this.scopes = [];
    this.version = "v1.0";
    this.type = ResponseType2.json;
    this.maxPages = 3;
    this.pollingRate = 0;
    this.cacheEnabled = false;
    this.cacheInvalidationPeriod = 0;
    this.isPolling = false;
    this.isRefreshing = false;
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * @param {*} name
   * @param {*} oldValue
   * @param {*} newValue
   * @memberof MgtPersonCard
   */
  attributeChangedCallback(name, oldval, newval) {
    super.attributeChangedCallback(name, oldval, newval);
    this.requestStateUpdate();
  }
  /**
   * Refresh the data
   *
   * @param {boolean} [hardRefresh=false]
   * if false (default), the component will only update if the data changed
   * if true, the data will be first cleared and reloaded completely
   * @memberof MgtGet
   */
  refresh(hardRefresh = false) {
    this.isRefreshing = true;
    if (hardRefresh) {
      this.clearState();
    }
    this.requestStateUpdate(hardRefresh);
  }
  /**
   * Clears state of the component
   *
   * @protected
   * @memberof MgtGet
   */
  clearState() {
    this.response = null;
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    if (this.isLoadingState && !this.response) {
      return this.renderTemplate("loading", null);
    } else if (this.error) {
      return this.renderTemplate("error", this.error);
    } else if (this.hasTemplate("value") && this.response && this.response.value) {
      let valueContent;
      if (Array.isArray(this.response.value)) {
        let loading = null;
        if (this.isLoadingState && !this.isPolling) {
          loading = this.renderTemplate("loading", null);
        }
        valueContent = html`
          ${this.response.value.map((v) => this.renderTemplate("value", v, v.id))} ${loading}
        `;
      } else {
        valueContent = this.renderTemplate("value", this.response);
      }
      if (this.hasTemplate("default")) {
        const defaultContent = this.renderTemplate("default", this.response);
        if (this.templates["value"].templateOrder > this.templates["default"].templateOrder) {
          return html`
            ${defaultContent}${valueContent}
          `;
        } else {
          return html`
            ${valueContent}${defaultContent}
          `;
        }
      } else {
        return valueContent;
      }
    } else if (this.response) {
      return this.renderTemplate("default", this.response) || html``;
    } else if (this.hasTemplate("no-data")) {
      return this.renderTemplate("no-data", null);
    } else {
      return html``;
    }
  }
  /**
   * load state into the component.
   *
   * @protected
   * @returns
   * @memberof MgtGet
   */
  loadState() {
    return __awaiter15(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      this.error = null;
      if (!provider || provider.state !== ProviderState.SignedIn) {
        return;
      }
      if (this.resource) {
        try {
          let cache2;
          const key = `${this.version}${this.resource}`;
          let response = null;
          if (this.shouldRetrieveCache()) {
            cache2 = CacheService.getCache(schemas.get, schemas.get.stores.responses);
            const result = getIsResponseCacheEnabled() ? yield cache2.getValue(key) : null;
            if (result && getResponseInvalidationTime(this.cacheInvalidationPeriod) > Date.now() - result.timeCached) {
              response = JSON.parse(result.response);
            }
          }
          if (!response) {
            let uri = this.resource;
            let isDeltaLink = false;
            if (this.response && this.response["@odata.deltaLink"]) {
              uri = this.response["@odata.deltaLink"];
              isDeltaLink = true;
            } else {
              isDeltaLink = new URL(uri, "https://graph.microsoft.com").pathname.endsWith("delta");
            }
            const graph = provider.graph.forComponent(this);
            let request = graph.api(uri).version(this.version);
            if (this.scopes && this.scopes.length) {
              request = request.middlewareOptions(prepScopes(...this.scopes));
            }
            if (this.type === ResponseType2.json) {
              response = yield request.get();
              if (isDeltaLink && this.response && Array.isArray(this.response.value) && Array.isArray(response.value)) {
                response.value = this.response.value.concat(response.value);
              }
              if (!this.isPolling && !equals(this.response, response)) {
                this.response = response;
              }
              if (response && Array.isArray(response.value) && response["@odata.nextLink"]) {
                let pageCount = 1;
                let page = response;
                while ((pageCount < this.maxPages || this.maxPages <= 0 || isDeltaLink && this.pollingRate) && page && page["@odata.nextLink"]) {
                  pageCount++;
                  const nextResource = page["@odata.nextLink"].split(this.version)[1];
                  page = yield graph.client.api(nextResource).version(this.version).get();
                  if (page && page.value && page.value.length) {
                    page.value = response.value.concat(page.value);
                    response = page;
                    if (!this.isPolling) {
                      this.response = response;
                    }
                  }
                }
              }
            } else {
              if (this.resource.indexOf("/photo/$value") === -1 && this.resource.indexOf("/thumbnails/") === -1) {
                throw new Error("Only /photo/$value and /thumbnails/ endpoints support the image type");
              }
              let image;
              if (this.resource.indexOf("/photo/$value") > -1) {
                const sanitizedResource = this.resource.replace("/photo/$value", "");
                const photoResponse = yield getPhotoForResource(graph, sanitizedResource, this.scopes);
                if (photoResponse) {
                  image = photoResponse.photo;
                }
              } else if (this.resource.indexOf("/thumbnails/") > -1) {
                const imageResponse = yield getDocumentThumbnail(graph, this.resource, this.scopes);
                if (imageResponse) {
                  image = imageResponse.thumbnail;
                }
              }
              if (image) {
                response = {
                  image
                };
              }
            }
            if (this.shouldUpdateCache() && response) {
              cache2 = CacheService.getCache(schemas.get, schemas.get.stores.responses);
              cache2.putValue(key, { response: JSON.stringify(response) });
            }
          }
          if (!equals(this.response, response)) {
            this.response = response;
          }
        } catch (e) {
          this.error = e;
        }
        if (this.response) {
          this.error = null;
          if (this.pollingRate) {
            setTimeout(() => __awaiter15(this, void 0, void 0, function* () {
              this.isPolling = true;
              yield this.loadState();
              this.isPolling = false;
            }), this.pollingRate);
          }
        }
      } else {
        this.response = null;
      }
      this.isRefreshing = false;
      this.fireCustomEvent("dataChange", { response: this.response, error: this.error });
    });
  }
  shouldRetrieveCache() {
    return getIsResponseCacheEnabled() && this.cacheEnabled && !(this.isRefreshing || this.isPolling);
  }
  shouldUpdateCache() {
    return getIsResponseCacheEnabled() && this.cacheEnabled;
  }
};
__decorate11([
  property({
    attribute: "resource",
    reflect: true,
    type: String
  }),
  __metadata9("design:type", String)
], MgtGet.prototype, "resource", void 0);
__decorate11([
  property({
    attribute: "scopes",
    converter: (value, type) => {
      return value ? value.toLowerCase().split(",") : null;
    },
    reflect: true
  }),
  __metadata9("design:type", Array)
], MgtGet.prototype, "scopes", void 0);
__decorate11([
  property({
    attribute: "version",
    reflect: true,
    type: String
  }),
  __metadata9("design:type", String)
], MgtGet.prototype, "version", void 0);
__decorate11([
  property({
    attribute: "type",
    reflect: true,
    type: ResponseType2
  }),
  __metadata9("design:type", String)
], MgtGet.prototype, "type", void 0);
__decorate11([
  property({
    attribute: "max-pages",
    reflect: true,
    type: Number
  }),
  __metadata9("design:type", Number)
], MgtGet.prototype, "maxPages", void 0);
__decorate11([
  property({
    attribute: "polling-rate",
    reflect: true,
    type: Number
  }),
  __metadata9("design:type", Number)
], MgtGet.prototype, "pollingRate", void 0);
__decorate11([
  property({
    attribute: "cache-enabled",
    reflect: true,
    type: Boolean
  }),
  __metadata9("design:type", Boolean)
], MgtGet.prototype, "cacheEnabled", void 0);
__decorate11([
  property({
    attribute: "cache-invalidation-period",
    type: Number
  }),
  __metadata9("design:type", Number)
], MgtGet.prototype, "cacheInvalidationPeriod", void 0);
__decorate11([
  property({ attribute: false }),
  __metadata9("design:type", Object)
], MgtGet.prototype, "response", void 0);
__decorate11([
  property({ attribute: false }),
  __metadata9("design:type", Object)
], MgtGet.prototype, "error", void 0);
MgtGet = __decorate11([
  customElement("get")
  // @customElement('mgt-get')
], MgtGet);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-login/mgt-login.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-login/mgt-login-css.js
init_lit();
var styles9 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--button-color:var(--neutral-foreground-rest, #1a1a1a);--popup-color:var(--neutral-foreground-rest, #1a1a1a)}.mgt-dark{--button-color:#f3f2f1;--popup-color:#f3f2f1}:host,mgt-login{--font-size:14px;--font-weight:600;--margin:0;--popup-command-font-size:14px;--popup-command-margin:16px 0 0;--popup-padding:10px 4px 16px 4px;--box-shadow:none;--popup-padding:12px 4px;--profile-spacing:12px 0 28px 0;--profile-spacing-full:21px 0 28px 0}:host .root,mgt-login .root{position:relative;display:inline-block}:host .root.vertical-layout,mgt-login .root.vertical-layout{--profile-spacing:var(--profile-spacing-full)}:host .login-button,mgt-login .login-button{display:flex;align-items:center;font-family:var(--default-font-family);font-size:var(--font-size);font-weight:var(--font-weight);width:var(--width);height:var(--height);margin:var(--margin);color:var(--button-color,var(--neutral-foreground-rest,#1a1a1a));background-color:var(--button-background-color,transparent);border:none;cursor:pointer;transition:color .3s,background-color .3s;word-spacing:inherit;text-indent:inherit;letter-spacing:inherit}:host .login-button:hover,mgt-login .login-button:hover{color:var(--button-color--hover,#023b8f);--color:var(--button-color--hover, #023b8f);background-color:var(--button-background-color--hover,var(--background-color--hover,var(--neutral-fill-hover,#f7f7f7)));--color-sub1:var(--button-color--hover, #023b8f);border-radius:4px}:host .login-button:focus,mgt-login .login-button:focus{outline:0}:host .login-button:disabled,mgt-login .login-button:disabled{opacity:.4;pointer-events:none}:host .login-button.no-click,mgt-login .login-button.no-click{pointer-events:none}:host .login-button.signed-in,mgt-login .login-button.signed-in{padding:7px 11px}:host .login-button.signed-in:hover,mgt-login .login-button.signed-in:hover{color:inherit;--color:inherit;--color-sub1:inherit}:host .login-button.signed-in.small,mgt-login .login-button.signed-in.small{padding:0}:host .login-button.signed-in.small:hover,mgt-login .login-button.signed-in.small:hover{background-color:inherit}:host .login-button.signed-in.small>.person,mgt-login .login-button.signed-in.small>.person{--focus-offset:2px}:host .login-button.signed-in.full-size,mgt-login .login-button.signed-in.full-size{padding:9px 11px}:host .login-button>.person,mgt-login .login-button>.person{--focus-offset:8px}:host fluent-button.login-button::part(content){margin:5px 0}:host .login-icon+span,mgt-login .login-icon+span{margin-left:6px}:host .popup,mgt-login .popup{font-family:var(--default-font-family);background-color:var(--popup-background-color,var(--neutral-fill-rest,var(--background-color,#fff)));width:300px;max-width:300px;z-index:1;color:var(--popup-color,var(--neutral-foreground-rest,#1a1a1a));border-radius:8px}:host .popup .person,mgt-login .popup .person{--color-sub1:set-var(popup__color, $theme-default, $login)}:host .popup-content,mgt-login .popup-content{display:flex;flex-direction:column;padding:var(--popup-padding);border-radius:8px;background-color:var(--popup-background-color,var(--neutral-fill-rest,var(--background-color,#fff)))}:host .popup-content .inside-content,mgt-login .popup-content .inside-content{overflow-y:auto;overflow-x:clip;max-height:400px}:host .popup-content .inside-content .list-box,mgt-login .popup-content .inside-content .list-box{margin-bottom:25px;margin-top:6px;background-color:var(--popup-background-color,var(--neutral-fill-rest,var(--background-color,#fff)));--accent-fill-hover:$popup__background-color;--accent-fill-active:$popup__background-color;--accent-foreground-cut-rest:black;--stroke-width:0}:host .popup-content .inside-content .list-box .list-box-option,mgt-login .popup-content .inside-content .list-box .list-box-option{margin:8px 1px}:host .popup-content .inside-content .list-box .list-box-option .person,mgt-login .popup-content .inside-content .list-box .list-box-option .person{max-width:246px;width:246px;margin:0 22px;--avatar-size:40px;--focus-offset:4px}:host .popup-content .inside-content .list-box .list-box-option:hover,mgt-login .popup-content .inside-content .list-box .list-box-option:hover{background-color:var(--login-hover-fill,var(--background-color--hover,var(--neutral-fill-hover,#f7f7f7)));cursor:pointer}:host .popup-content .inside-content .list-box:focus .list-box-option.selected,mgt-login .popup-content .inside-content .list-box:focus .list-box-option.selected{border-radius:4px;background:rgba(0,0,0,.1)}:host .popup-content .inside-content .list-box:focus .person:after,mgt-login .popup-content .inside-content .list-box:focus .person:after{background-image:none}:host .popup-content .inside-content:after,mgt-login .popup-content .inside-content:after{content:"";position:absolute;bottom:0;background:linear-gradient(to bottom,rgba(255,255,255,0),var(--popup-background-color,var(--neutral-fill-rest,var(--background-color,#fff))));height:25%;width:100%}:host .popup-content .inside-content::-webkit-scrollbar,mgt-login .popup-content .inside-content::-webkit-scrollbar{height:4em;width:4px;border-radius:11px}:host .popup-content .inside-content::-webkit-scrollbar-button,mgt-login .popup-content .inside-content::-webkit-scrollbar-button{background:#fff}:host .popup-content .inside-content::-webkit-scrollbar-track,mgt-login .popup-content .inside-content::-webkit-scrollbar-track{background:#fff;border-radius:10px}:host .popup-content .inside-content::-webkit-scrollbar-track-piece,mgt-login .popup-content .inside-content::-webkit-scrollbar-track-piece{background:#fff}:host .popup-content .inside-content::-webkit-scrollbar-thumb,mgt-login .popup-content .inside-content::-webkit-scrollbar-thumb{background:grey;border-radius:10px;height:4px}:host .popup-content .add-account,mgt-login .popup-content .add-account{margin:0 8px}:host .popup-content .add-account .add-account-button,mgt-login .popup-content .add-account .add-account-button{position:relative;color:var(--add-account-button-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));border:none;background-color:var(--popup-background-color,var(--neutral-fill-rest,var(--background-color,#fff)));cursor:pointer;padding:0;--neutral-fill-stealth-rest:var(--popup-background-color, var(--neutral-fill-rest, var(--background-color, #ffffff)));--neutral-fill-stealth-hover:var(--popup-button-color--hover, var(--neutral-fill-stealth-hover, #efefef))}:host .popup-content .add-account .add-account-button:hover,mgt-login .popup-content .add-account .add-account-button:hover{--accent-foreground-hover:var(--add-account-button-color, var(--color-sub2, var(--neutral-foreground-hint, #717171)));background-color:var(--popup-button-color--hover,var(--neutral-fill-stealth-hover,#efefef))}:host .popup-content .add-account .add-account-button .account-switch-icon,mgt-login .popup-content .add-account .add-account-button .account-switch-icon{vertical-align:middle;display:inline-flex}:host .popup-content .add-account .add-account-button .account-switch-icon svg path,mgt-login .popup-content .add-account .add-account-button .account-switch-icon svg path{fill:var(--add-account-button-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)))}:host .popup-content .main-profile,mgt-login .popup-content .main-profile{padding:0 21px;margin:var(--profile-spacing)}:host .popup-commands ul,mgt-login .popup-commands ul{list-style-type:none;margin:var(--popup-command-margin);padding:0 8px;margin:0;text-align:right}:host .popup-command,mgt-login .popup-command{font-family:var(--default-font-family);font-size:var(--popup-command-font-size);color:#023b8f;background-color:var(--popup-background-color,var(--neutral-fill-rest,var(--background-color,#fff)));border:none;cursor:pointer;transition:color .3s;word-spacing:inherit;text-indent:inherit;letter-spacing:inherit;--neutral-fill-stealth-rest:var(--popup-background-color, var(--neutral-fill-rest, var(--background-color, #ffffff)));--neutral-fill-stealth-hover:var(--popup-button-color--hover, var(--neutral-fill-stealth-hover, #efefef))}:host .popup-command:hover,mgt-login .popup-command:hover{--accent-foreground-hover:--accent-foreground-rest;background-color:var(--popup-button-color--hover,var(--neutral-fill-stealth-hover,#efefef))}[dir=rtl]{--popup-padding:24px 24px 16px 48px}[dir=rtl] .person .details{--details-spacing:0px 12px 0px 0px}[dir=rtl] .person .details.small{--details-spacing:0px 6px 0px 0px}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-login/strings.js
var strings6 = {
  signInLinkSubtitle: "Sign In",
  signOutLinkSubtitle: "Sign Out"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-login/mgt-login.js
init_esm3();
init_FluentComponents();
var __decorate12 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata10 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
registerFluentComponents(fluentListbox, fluentProgressRing, fluentButton, fluentCard);
var MgtLogin = class MgtLogin2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles9;
  }
  /**
   * Returns the object of strings for localization
   *
   * @readonly
   * @protected
   * @memberof MgtLogin
   */
  get strings() {
    return strings6;
  }
  /**
   * Gets the flyout element
   *
   * @protected
   * @type {MgtFlyout}
   * @memberof MgtLogin
   */
  get flyout() {
    return this.renderRoot.querySelector(".flyout");
  }
  /**
   * Get the scopes required for login
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtLogin
   */
  static get requiredScopes() {
    return [.../* @__PURE__ */ new Set(["user.read", ...MgtPerson.requiredScopes])];
  }
  constructor() {
    super();
    this.showPresence = false;
    this.loginView = "full";
    this._userDetailsKey = "-userDetails";
    this.flyoutOpened = () => {
      this._isFlyoutOpen = true;
    };
    this.flyoutClosed = () => {
      this._isFlyoutOpen = false;
    };
    this._isFlyoutOpen = false;
  }
  /**
   * Invoked each time the custom element is appended into a document-connected element
   *
   * @memberof MgtLogin
   */
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", (e) => e.stopPropagation());
  }
  /**
   * Initiate login
   *
   * @returns {Promise<void>}
   * @memberof MgtLogin
   */
  login() {
    return __awaiter16(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      if (!provider.isMultiAccountSupportedAndEnabled && (this.userDetails || !this.fireCustomEvent("loginInitiated"))) {
        return;
      }
      if (provider && provider.login) {
        yield provider.login();
        if (provider.state === ProviderState.SignedIn) {
          this.fireCustomEvent("loginCompleted");
        } else {
          this.fireCustomEvent("loginFailed");
        }
      }
    });
  }
  /**
   * Initiate logout
   *
   * @returns {Promise<void>}
   * @memberof MgtLogin
   */
  logout() {
    return __awaiter16(this, void 0, void 0, function* () {
      if (!this.fireCustomEvent("logoutInitiated")) {
        return;
      }
      const provider = Providers.globalProvider;
      if (provider && provider.isMultiAccountSupportedAndEnabled) {
        localStorage.removeItem(provider.getActiveAccount().id + this._userDetailsKey);
      }
      if (provider && provider.logout) {
        yield provider.logout();
        this.userDetails = null;
        if (provider.isMultiAccountSupportedAndEnabled) {
          localStorage.removeItem(provider.getActiveAccount().id + this._userDetailsKey);
        }
        this.hideFlyout();
        this.fireCustomEvent("logoutCompleted");
      }
    });
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    const classes = {
      root: true,
      "vertical-layout": this.usesVerticalPersonCard
    };
    return html`
       <div class=${classMap(classes)} dir=${this.direction}>
         <div>
           ${this.renderButton()}
         </div>
         ${this.renderFlyout()}
       </div>
     `;
  }
  /**
   * Load state into the component.
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  loadState() {
    return __awaiter16(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      if (provider && !this.userDetails) {
        if (provider.state === ProviderState.SignedIn) {
          this.userDetails = yield getUserWithPhoto(provider.graph.forComponent(this));
          if (this.userDetails.personImage) {
            this._image = this.userDetails.personImage;
          }
          if (provider.isMultiAccountSupportedAndEnabled) {
            localStorage.setItem(Providers.globalProvider.getActiveAccount().id + this._userDetailsKey, JSON.stringify(this.userDetails));
          }
          this.fireCustomEvent("loginCompleted");
        } else {
          this.userDetails = null;
        }
      }
    });
  }
  buildAriaLabel(isSignedIn, defaultLabel) {
    if (!isSignedIn)
      return defaultLabel;
    return defaultLabel = this.userDetails ? this.userDetails.displayName : this.strings.signInLinkSubtitle;
  }
  /**
   * Render the button.
   *
   * @protected
   * @memberof MgtLogin
   */
  renderButton() {
    var _a2;
    const isSignedIn = ((_a2 = Providers.globalProvider) === null || _a2 === void 0 ? void 0 : _a2.state) === ProviderState.SignedIn;
    const ariaLabel = this.buildAriaLabel(isSignedIn, this.strings.signInLinkSubtitle);
    const classes = {
      "login-button": true,
      "signed-in": isSignedIn,
      small: this.loginView === "avatar",
      "full-size": this.loginView === "full",
      "no-click": this._isFlyoutOpen
    };
    return isSignedIn && this.userDetails ? html`
        <button
          aria-label=${ariaLabel}
          @click=${this.onClick}
          class=${classMap(classes)}
        >
          ${this.renderSignedInButtonContent(this.userDetails, this._image)}
        </button>
      ` : html`
        <fluent-button
          appearance="neutral"
          aria-label=${ariaLabel}
          ?disabled=${this.isLoadingState}
          @click=${this.onClick}
          class=${classMap(classes)}
        >
          ${this.renderSignedOutButtonContent()}
        </fluent-button>
      `;
  }
  /**
   * Render the details flyout.
   *
   * @protected
   * @memberof MgtLogin
   */
  renderFlyout() {
    return mgtHtml`
      <mgt-flyout
        class="flyout"
        light-dismiss
        @opened=${this.flyoutOpened}
        @closed=${this.flyoutClosed}
      >
        <div slot="flyout">
          <!-- Setting the card fill ensures the correct colors on hover states -->
          <fluent-card card-fill-color="#fbfbfb">
            ${this.renderFlyoutContent()}
          </fluent-card>
        </div>
      </mgt-flyout>
      `;
  }
  /**
   * Render the flyout menu content.
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  renderFlyoutContent() {
    if (!this.userDetails) {
      return;
    }
    return html`
       <div class="popup">
         <div class="popup-content">
           <div class="popup-commands">
             ${this.renderFlyoutCommands()}
           </div>
           <div class="inside-content">
             <div class="main-profile">
               ${this.renderFlyoutPersonDetails(this.userDetails, this._image)}
             </div>
             ${this.renderAccounts()}
           </div>
           ${this.renderAddAccountContent()}
         </div>
       </div>
     `;
  }
  get hasMultipleAccounts() {
    var _a2, _b2, _c, _d;
    return ((_a2 = Providers.globalProvider) === null || _a2 === void 0 ? void 0 : _a2.isMultiAccountSupportedAndEnabled) && ((_d = (_c = (_b2 = Providers.globalProvider) === null || _b2 === void 0 ? void 0 : _b2.getAllAccounts) === null || _c === void 0 ? void 0 : _c.call(_b2)) === null || _d === void 0 ? void 0 : _d.length) > 1;
  }
  get usesVerticalPersonCard() {
    return this.loginView === "full" || this.hasMultipleAccounts;
  }
  /**
   * Render the flyout person details.
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  renderFlyoutPersonDetails(personDetails, personImage) {
    const template = this.renderTemplate("flyout-person-details", { personDetails, personImage });
    return template || mgtHtml`
        <mgt-person
          .personDetails=${personDetails}
          .personImage=${personImage}
          .view=${ViewType.twolines}
          .line2Property=${"email"}
          ?vertical-layout=${this.usesVerticalPersonCard}
          class="person"
        />
        `;
  }
  /**
   * Render the flyout commands.
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  renderFlyoutCommands() {
    const template = this.renderTemplate("flyout-commands", { handleSignOut: () => this.logout() });
    return template || html`
        <ul>
          <li>
            <fluent-button
              appearance="lightweight"
              class="popup-command"
              @click=${this.logout}
              aria-label=${this.strings.signOutLinkSubtitle}
            >
              ${this.strings.signOutLinkSubtitle}
            </fluent-button>
          </li>
        </ul>
      `;
  }
  /**
   * Render the button content.
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  renderButtonContent() {
    if (this.userDetails) {
      return this.renderSignedInButtonContent(this.userDetails, this._image);
    } else {
      return this.renderSignedOutButtonContent();
    }
  }
  /**
   * Renders multi account content to add additional users
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  renderAddAccountContent() {
    if (Providers.globalProvider.isMultiAccountSupportedAndEnabled) {
      return html`
          <div class="add-account">
             <fluent-button
               appearance="lightweight"
               class="add-account-button"
               aria-label="Sign in with different account"
               @click=${() => {
        this.login();
      }}
             >
               <i class="account-switch-icon">${getSvg(SvgIcon.SelectAccount, "#000000")}</i>
               Sign in with a different account
             </fluent-button>
           </div>
       `;
    }
  }
  parsePersonDisplayConfiguration() {
    const displayConfig = { view: ViewType.twolines, avatarSize: "small" };
    switch (this.loginView) {
      case "avatar":
        displayConfig.view = ViewType.image;
        displayConfig.avatarSize = "small";
        break;
      case "compact":
        displayConfig.view = ViewType.oneline;
        displayConfig.avatarSize = "small";
        break;
      case "full":
      default:
        displayConfig.view = ViewType.twolines;
        displayConfig.avatarSize = "large";
        break;
    }
    return displayConfig;
  }
  /**
   * Render the button content when the user is signed in.
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  renderSignedInButtonContent(personDetails, personImage) {
    const template = this.renderTemplate("signed-in-button-content", { personDetails, personImage });
    const displayConfig = this.parsePersonDisplayConfiguration();
    return template || mgtHtml`
        <mgt-person
          .personDetails=${this.userDetails}
          .personImage=${this._image}
          .view=${displayConfig.view}
          .showPresence=${this.showPresence}
          .avatarSize=${displayConfig.avatarSize}
          line2-property="email"
          class="person"
        />
       `;
  }
  /**
   * POC for multi accounts - temporary
   *
   * @return {*}
   * @memberof MgtLogin
   */
  renderAccounts() {
    if (Providers.globalProvider.state === ProviderState.SignedIn && Providers.globalProvider.isMultiAccountSupportedAndEnabled) {
      const provider = Providers.globalProvider;
      const list = provider.getAllAccounts();
      if (list && list.length > 1) {
        return html`
         <div id="accounts">
           <fluent-design-system-provider>
             <fluent-listbox class="list-box" name="Account list">
              ${list.map((account) => {
          if (account.id !== provider.getActiveAccount().id) {
            const details = localStorage.getItem(account.id + this._userDetailsKey);
            return mgtHtml`
                    <fluent-option class="list-box-option" value="${account.name}" role="option">
                      <mgt-person
                        @click=${() => this.setActiveAccount(account)}
                        @keyup=${(e) => {
              if (e.key === "Enter") {
                this.setActiveAccount(account);
              }
            }}
                        .personDetails=${details ? JSON.parse(details) : null}
                        .fallbackDetails=${{ displayName: account.name, mail: account.mail }}
                        .view=${PersonViewType.twolines}
                        class="person"
                      />
                    </fluent-option>
                  `;
          }
        })}
             </fluent-listbox>
           </fluent-design-system-provider>
         </div>
       `;
      }
    }
  }
  /**
   * Set one of the non-active accounts as the active account
   *
   * @param {*} account
   * @memberof MgtLogin
   */
  setActiveAccount(account) {
    Providers.globalProvider.setActiveAccount(account);
  }
  /**
   * Clears state of the component
   *
   * @protected
   * @memberof MgtLogin
   */
  clearState() {
    this.userDetails = null;
    this._image = null;
  }
  /**
   * Render the button content when the user is not signed in.
   *
   * @protected
   * @returns
   * @memberof MgtLogin
   */
  renderSignedOutButtonContent() {
    const template = this.renderTemplate("signed-out-button-content", null);
    return template || html`
        <span>${this.strings.signInLinkSubtitle}</span>
      `;
  }
  /**
   * Show the flyout and its content.
   *
   * @protected
   * @memberof MgtLogin
   */
  showFlyout() {
    const flyout = this.flyout;
    if (flyout) {
      flyout.open();
    }
  }
  /**
   * Dismiss the flyout.
   *
   * @protected
   * @memberof MgtLogin
   */
  hideFlyout() {
    const flyout = this.flyout;
    if (flyout) {
      flyout.close();
    }
  }
  onClick() {
    if (this.userDetails && this._isFlyoutOpen) {
      this.hideFlyout();
    } else if (this.userDetails) {
      this.showFlyout();
    } else {
      this.login();
    }
  }
};
__decorate12([
  property({
    attribute: "user-details",
    type: Object
  }),
  __metadata10("design:type", Object)
], MgtLogin.prototype, "userDetails", void 0);
__decorate12([
  property({
    attribute: "show-presence",
    type: Boolean
  }),
  __metadata10("design:type", Object)
], MgtLogin.prototype, "showPresence", void 0);
__decorate12([
  property({
    attribute: "login-view",
    type: String
  }),
  __metadata10("design:type", String)
], MgtLogin.prototype, "loginView", void 0);
__decorate12([
  property({ attribute: false }),
  __metadata10("design:type", Boolean)
], MgtLogin.prototype, "_isFlyoutOpen", void 0);
MgtLogin = __decorate12([
  customElement("login"),
  __metadata10("design:paramtypes", [])
], MgtLogin);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people-picker/mgt-people-picker.js
init_lit();
init_decorators();

// node_modules/@microsoft/mgt-components/dist/es6/graph/graph.groups.js
init_es6();
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var GroupType;
(function(GroupType2) {
  GroupType2[GroupType2["any"] = 0] = "any";
  GroupType2[GroupType2["unified"] = 1] = "unified";
  GroupType2[GroupType2["security"] = 2] = "security";
  GroupType2[GroupType2["mailenabledsecurity"] = 4] = "mailenabledsecurity";
  GroupType2[GroupType2["distribution"] = 8] = "distribution";
})(GroupType || (GroupType = {}));
var getGroupsInvalidationTime = () => CacheService.config.groups.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
var getIsGroupsCacheEnabled = () => CacheService.config.groups.isEnabled && CacheService.config.isEnabled;
function findGroups(graph, query, top = 10, groupTypes = GroupType.any, groupFilters = "") {
  return __awaiter17(this, void 0, void 0, function* () {
    const scopes = "Group.Read.All";
    let cache2;
    const key = `${query ? query : "*"}*${groupTypes}*${groupFilters}`;
    if (getIsGroupsCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);
      const cacheGroupQuery = yield cache2.getValue(key);
      if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {
        if (cacheGroupQuery.top >= top) {
          return cacheGroupQuery.groups.map((x) => JSON.parse(x)).slice(0, top + 1);
        }
      }
    }
    let filterQuery = "";
    let responses;
    const batchedResult = [];
    if (query !== "") {
      filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;
    }
    if (groupFilters) {
      filterQuery += `${query ? " and " : ""}${groupFilters}`;
    }
    if (groupTypes !== GroupType.any) {
      const batch = graph.createBatch();
      const filterGroups = [];
      if (GroupType.unified === (groupTypes & GroupType.unified)) {
        filterGroups.push("groupTypes/any(c:c+eq+'Unified')");
      }
      if (GroupType.security === (groupTypes & GroupType.security)) {
        filterGroups.push("(mailEnabled eq false and securityEnabled eq true)");
      }
      if (GroupType.mailenabledsecurity === (groupTypes & GroupType.mailenabledsecurity)) {
        filterGroups.push("(mailEnabled eq true and securityEnabled eq true)");
      }
      if (GroupType.distribution === (groupTypes & GroupType.distribution)) {
        filterGroups.push("(mailEnabled eq true and securityEnabled eq false)");
      }
      filterQuery = filterQuery ? `${filterQuery} and ` : "";
      for (const filter of filterGroups) {
        batch.get(filter, `/groups?$filter=${filterQuery + filter}`, ["Group.Read.All"]);
      }
      try {
        responses = yield batch.executeAll();
        for (const filterGroup of filterGroups) {
          if (responses.get(filterGroup).content.value) {
            for (const group of responses.get(filterGroup).content.value) {
              let repeat3 = batchedResult.filter((batchedGroup) => batchedGroup.id === group.id);
              if (repeat3.length === 0) {
                batchedResult.push(group);
              }
              repeat3 = [];
            }
          }
        }
      } catch (_) {
        try {
          const queries = [];
          for (const filter of filterGroups) {
            queries.push(yield graph.api("groups").filter(`${filterQuery} and ${filter}`).top(top).count(true).header("ConsistencyLevel", "eventual").middlewareOptions(prepScopes(scopes)).get());
          }
          return Promise.all(queries);
        } catch (_2) {
          return [];
        }
      }
    } else {
      if (batchedResult.length === 0) {
        const result = yield graph.api("groups").filter(filterQuery).top(top).count(true).header("ConsistencyLevel", "eventual").middlewareOptions(prepScopes(scopes)).get();
        if (getIsGroupsCacheEnabled() && result) {
          cache2.putValue(key, { groups: result.value.map((x) => JSON.stringify(x)), top });
        }
        return result ? result.value : null;
      }
    }
    return batchedResult;
  });
}
function getGroup(graph, id, requestedProps) {
  return __awaiter17(this, void 0, void 0, function* () {
    const scopes = "Group.Read.All";
    let cache2;
    if (getIsGroupsCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);
      const group = yield cache2.getValue(id);
      if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {
        const cachedData = group.group ? JSON.parse(group.group) : null;
        const uniqueProps = requestedProps && cachedData ? requestedProps.filter((prop) => !Object.keys(cachedData).includes(prop)) : null;
        if (!uniqueProps || uniqueProps.length <= 1) {
          return cachedData;
        }
      }
    }
    let apiString = `/groups/${id}`;
    if (requestedProps) {
      apiString = apiString + "?$select=" + requestedProps.toString();
    }
    const response = yield graph.api(apiString).middlewareOptions(prepScopes(scopes)).get();
    if (getIsGroupsCacheEnabled()) {
      cache2.putValue(id, { group: JSON.stringify(response) });
    }
    return response;
  });
}
function getGroupsForGroupIds(graph, groupIds, filters = "") {
  return __awaiter17(this, void 0, void 0, function* () {
    if (!groupIds || groupIds.length === 0) {
      return [];
    }
    const batch = graph.createBatch();
    const groupDict = {};
    const notInCache = [];
    let cache2;
    if (getIsGroupsCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);
    }
    for (const id of groupIds) {
      groupDict[id] = null;
      let group = null;
      if (getIsGroupsCacheEnabled()) {
        group = yield cache2.getValue(id);
      }
      if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {
        groupDict[id] = group.group ? JSON.parse(group.group) : null;
      } else if (id !== "") {
        let apiUrl = `/groups/${id}`;
        if (filters) {
          apiUrl = `${apiUrl}?$filters=${filters}`;
        }
        batch.get(id, apiUrl, ["Group.Read.All"]);
        notInCache.push(id);
      }
    }
    try {
      const responses = yield batch.executeAll();
      for (const id of groupIds) {
        const response = responses.get(id);
        if (response && response.content) {
          groupDict[id] = response.content;
          if (getIsGroupsCacheEnabled()) {
            cache2.putValue(id, { group: JSON.stringify(response.content) });
          }
        }
      }
      return Promise.all(Object.values(groupDict));
    } catch (_) {
      try {
        groupIds.filter((id) => notInCache.includes(id)).forEach((id) => groupDict[id] = getGroup(graph, id));
        if (getIsGroupsCacheEnabled()) {
          groupIds.filter((id) => notInCache.includes(id)).forEach((id) => __awaiter17(this, void 0, void 0, function* () {
            return cache2.putValue(id, { group: JSON.stringify(yield groupDict[id]) });
          }));
        }
        return Promise.all(Object.values(groupDict));
      } catch (_2) {
        return [];
      }
    }
  });
}
function findGroupsFromGroupIds(graph, query, groupIds, top = 10, groupTypes = GroupType.any, filters = "") {
  return __awaiter17(this, void 0, void 0, function* () {
    const foundGroups = [];
    const graphGroups = yield findGroups(graph, query, top, groupTypes, filters);
    if (graphGroups) {
      for (let i = 0; i < graphGroups.length; i++) {
        const group = graphGroups[i];
        if (group.id && groupIds.includes(group.id)) {
          foundGroups.push(group);
        }
      }
    }
    return foundGroups;
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people-picker/mgt-people-picker.js
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-spinner/mgt-spinner.js
init_lit();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-spinner/mgt-spinner-css.js
init_lit();
var styles10 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-spinner/mgt-spinner.js
var __decorate13 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var MgtSpinner = class MgtSpinner2 extends MgtBaseComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * user the `css` tag function.
   */
  static get styles() {
    return styles10;
  }
  /**
   * Render the loading spinner
   *
   * @returns
   * @memberof MgtSpinner
   */
  render() {
    return html`<fluent-progress-ring title="spinner"></fluent-progress-ring>`;
  }
};
MgtSpinner = __decorate13([
  customElement("spinner")
  // @customElement('mgt-spinner')
], MgtSpinner);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people-picker/mgt-people-picker-css.js
init_lit();
var styles11 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--selected-person-background-color:#f0f0f0}.mgt-dark{--selected-person-background-color:#4f4f4f}:host{font-family:var(--default-font-family);font-size:14px;height:24px;display:contents;overflow:hidden;position:absolute;width:135px;left:0;top:0;border-radius:12px;--dropdown-item-hover-background:#f7f7f7}:host .root,mgt-people-picker .root{display:block}.people-picker{background-color:var(--input-background-color,#fff);box-sizing:border-box;background:padding-box linear-gradient(var(--neutral-fill-input-rest),var(--neutral-fill-input-rest)),border-box var(--neutral-stroke-input-rest);border:calc(var(--stroke-width) * 1px) solid transparent;border-radius:calc(var(--control-corner-radius) * 1px);min-height:calc((var(--base-height-multiplier) + var(--density)) * var(--design-unit) * 1px);padding:3px}.people-picker:hover{background:padding-box linear-gradient(var(--neutral-fill-input-focus),var(--neutral-fill-input-focus)),border-box var(--neutral-stroke-input-rest)}.people-picker.focused{border-bottom:calc(var(--focus-stroke-width) * 1px) solid var(--accent-fill-rest);border-bottom-left-radius:calc(var(--control-corner-radius) * 1px);border-bottom-right-radius:calc(var(--control-corner-radius) * 1px)}.people-picker.disabled{pointer-events:none}.people-picker .people-picker-inner{flex:1 1 auto;display:flex;flex-wrap:wrap;vertical-align:middle;list-style-type:none;font-style:normal;font-weight:400;overflow:hidden}.people-picker .flyout .search-box{display:flex;height:23px}.people-picker .flyout .search-box .search-icon{padding:5px}.people-picker .flyout .search-box.search-box-start{line-height:normal;margin-inline-start:0;margin-inline-end:0}.people-picker .flyout .search-box__input{box-sizing:border-box;border-width:0;border-style:none;display:flex;flex:1 0 auto;font-family:var(--default-font-family);position:relative;outline:0;font-style:normal;font-weight:400;font-size:14px;background-color:var(--input-background-color,#fff);color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a));word-spacing:inherit;text-indent:inherit;letter-spacing:inherit}.people-picker .flyout .search-box__input::placeholder{color:var(--placeholder-color,#605e5c)}.people-picker .flyout .flyout-root{position:relative;top:8px;padding:unset;border-radius:2px;min-width:260px;overflow-y:auto;text-align:left;list-style-type:none;background-color:var(--dropdown-background-color,var(--list-background-color,#fff));max-height:var(--mgt-flyout-set-height,unset);border-radius:8px}.people-picker .flyout .flyout-root li{cursor:pointer}.people-picker .flyout .flyout-root .people-list{list-style:none;padding:unset;margin:unset}.people-picker .flyout .flyout-root .people-list .list-person{display:flex;flex-direction:row;align-items:center;padding:12px;font-style:normal;font-weight:600;font-size:14px;margin:var(--file-item-margin,4px);border-radius:4px}.people-picker .flyout .flyout-root .people-list .list-person:hover{background-color:var(--dropdown-item-hover-background,var(--input-background-color--hover,var(--neutral-fill-hover,#f7f7f7)))}.people-picker .flyout .flyout-root .people-list .list-person:hover .people-person-text-area{color:var(--dropdown-item-text-hover-color,#000)}.people-picker .flyout .flyout-root .people-list .list-person.focused{background-color:var(--dropdown-item-hover-background,var(--input-background-color--hover,var(--neutral-fill-hover,#f7f7f7)))}.people-picker .flyout .flyout-root .people-list .list-person.focused .people-person-text-area{color:var(--dropdown-item-text-hover-color,#000)}.people-picker .flyout .flyout-root .people-list .list-person .people-person-text-area{margin-left:13px;flex:1 1 0;max-height:40px;overflow:hidden;color:var(--dropdown-item-text-color,#000)}.people-picker .flyout .flyout-root .people-list .list-person .people-person-text-area .people-person-text{font-size:14px;font-weight:400;margin:0;padding:0}.people-picker .flyout .flyout-root .people-list .list-person .people-person-text-area .people-person-text.highlight-search-text{font-weight:700}.people-picker .selected-list{list-style:none;padding:0;display:contents}.people-picker .selected-list__person-wrapper,.people-picker .selected-list__person-wrapper-highlighted,.people-picker .selected-list__person-wrapper-highlighted:hover{display:flex;margin:1px;align-items:center;border-radius:12px;height:23px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;position:relative;background-color:var(--selected-person-background-color,#f0f0f0)}.people-picker .selected-list__person-wrapper-highlighted:hover,.people-picker .selected-list__person-wrapper:hover{background-color:#fafafa}.people-picker .selected-list__person-wrapper-highlighted__person,.people-picker .selected-list__person-wrapper__person{overflow:hidden;min-width:100%;--avatar-size-s:24px;margin-left:0;--color:var(--color-sub1, var(--neutral-foreground-rest, #1a1a1a));color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a))}.people-picker .selected-list__person-wrapper-highlighted__overflow,.people-picker .selected-list__person-wrapper__overflow{margin-left:25px}.people-picker .selected-list__person-wrapper-highlighted__overflow__gradient,.people-picker .selected-list__person-wrapper__overflow__gradient{content:"";position:absolute;margin-right:23px;width:10px;height:90%;top:0;right:0;background-image:linear-gradient(to right,rgba(255,255,255,0) 0,rgba(255,255,255,0) 60%,var(--selected-person-background-color,#f0f0f0) 100%);background-image:-moz-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,0) 60%,var(--selected-person-background-color,#f0f0f0) 100%);background-image:-o-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,0) 60%,var(--selected-person-background-color,#f0f0f0) 100%);background-image:-ms-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,0) 60%,var(--selected-person-background-color,#f0f0f0) 100%);background-image:-webkit-linear-gradient(left,rgba(255,255,255,0) 0,rgba(255,255,255,0) 60%,var(--selected-person-background-color,#f0f0f0) 100%);background-image:none}.people-picker .selected-list__person-wrapper-highlighted__overflow__close-icon,.people-picker .selected-list__person-wrapper__overflow__close-icon{font-family:FabricMDL2Icons;cursor:pointer;color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a));display:flex;flex-direction:column;align-items:center;position:absolute;height:24px;width:24px;right:0;top:0;border-radius:12px;line-height:24px}.people-picker .selected-list__person-wrapper-highlighted__overflow__close-icon:hover,.people-picker .selected-list__person-wrapper__overflow__close-icon:hover{color:#023b8f}.people-picker .selected-list__person-wrapper-highlighted__overflow__close-icon:focus,.people-picker .selected-list__person-wrapper-highlighted__overflow__close-icon:focus-visible,.people-picker .selected-list__person-wrapper__overflow__close-icon:focus,.people-picker .selected-list__person-wrapper__overflow__close-icon:focus-visible{outline-offset:-4px;outline-width:1px;outline-style:solid}.people-picker .selected-list__person-wrapper-highlighted,.people-picker .selected-list__person-wrapper-highlighted:hover{background:#005393}.people-picker .selected-list__person-wrapper-highlighted__person{color:#fff;--color:white}.people-picker .selected-list__person-wrapper-highlighted__overflow__gradient{background-image:none}.people-picker .selected-list__person-wrapper-highlighted__overflow__close-icon{background:#005393;color:#fff;line-height:24px}.people-picker .selected-list__person-wrapper-highlighted:hover{background-color:#006cbe}.person{margin-left:6px;width:100%;cursor:default;--avatar-size-s:32px;--line2-color:#717171;--font-size:14px;--font-weight:600}:host .loading-text,:host .search-error-text,mgt-people-picker .loading-text,mgt-people-picker .search-error-text{font-family:var(--default-font-family);font-style:normal;font-weight:600;font-size:14px;line-height:19px;text-align:center;margin-left:50px;margin-right:50px;color:#023b8f}:host .message-parent,mgt-people-picker .message-parent{padding:2px;margin-top:30px;margin-bottom:30px;display:flex;flex-direction:column;align-items:center;justify-content:center;vertical-align:middle}:host .people-person-job-title,mgt-people-picker .people-person-job-title{flex:100%;order:3;font-weight:400;font-size:12px}:host .people-person-job-title.uppercase,mgt-people-picker .people-person-job-title.uppercase{text-transform:uppercase}mgt-flyout{flex:1 0 auto;--box-shadow:none;--mgt-flyout-border-radius:var(--layer-corner-radius)}[dir=rtl] .person{margin-right:6px;--details-spacing:0px 12px 0 0;width:100%}[dir=rtl] .selected-list{margin-right:8px!important}.people-picker [dir=rtl] .selected-list__person-wrapper-highlighted,[dir=rtl] .people-picker .selected-list__person-wrapper-highlighted,[dir=rtl] .selected-list__person-wrapper{margin-left:6px!important}.people-picker [dir=rtl] .selected-list__person-wrapper-highlighted__person,[dir=rtl] .people-picker .selected-list__person-wrapper-highlighted__person,[dir=rtl] .selected-list__person-wrapper__person{margin-right:0!important;margin-left:4px!important}.people-picker [dir=rtl] .selected-list__person-wrapper-highlighted__overflow__gradient,[dir=rtl] .people-picker .selected-list__person-wrapper-highlighted__overflow__gradient,[dir=rtl] .selected-list__person-wrapper__overflow__gradient{right:auto!important;position:absolute!important;margin-right:0!important;width:10px!important;height:90%;top:0}.people-picker [dir=rtl] .selected-list__person-wrapper-highlighted__overflow__close-icon,[dir=rtl] .people-picker .selected-list__person-wrapper-highlighted__overflow__close-icon,[dir=rtl] .selected-list__person-wrapper__overflow__close-icon{right:auto!important;margin-left:5px!important;left:0!important}[dir=rtl] .selected-list__person-wrapper-highlighted__overflow__close-icon{right:auto!important;left:0!important}[dir=rtl] .people-person-text-area{margin-right:13px;margin-left:0!important}[dir=rtl] .flyout-root{text-align:right!important}@media (forced-colors:active) and (prefers-color-scheme:dark){svg,svg>path{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important;color:#fff!important}.flyout-root{border:1px solid #fff}.people-list .list-person{border:solid 1px #fff}}@media (forced-colors:active) and (prefers-color-scheme:light){svg,svg>path{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important;color:#000!important}.flyout-root{border:1px solid #000}.people-list .list-person{border:solid 1px #000}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people-picker/strings.js
var strings7 = {
  inputPlaceholderText: "Start typing a name",
  noResultsFound: `We didn't find any matches.`,
  loadingMessage: "Loading...",
  suggestedContact: "suggested contact",
  suggestedContacts: "suggested contacts",
  selected: "selected",
  removeSelectedItem: "remove selected item"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-people-picker/mgt-people-picker.js
var __decorate14 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata11 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtPeoplePicker = class MgtPeoplePicker2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * user the `css` tag function.
   */
  static get styles() {
    return styles11;
  }
  /**
   * The strings to be used for localizing the component.
   *
   * @readonly
   * @protected
   * @memberof MgtPeoplePicker
   */
  get strings() {
    return strings7;
  }
  /**
   * Gets the flyout element
   *
   * @protected
   * @type {MgtFlyout}
   * @memberof MgtLogin
   */
  get flyout() {
    return this.renderRoot.querySelector(".flyout");
  }
  /**
   * Gets the input element
   *
   * @protected
   * @type {MgtFlyout}
   * @memberof MgtLogin
   */
  get input() {
    return this.renderRoot.querySelector(".search-box__input");
  }
  /**
   * value determining if search is filtered to a group.
   * @type {string}
   */
  get groupId() {
    return this._groupId;
  }
  set groupId(value) {
    if (this._groupId === value) {
      return;
    }
    this._groupId = value;
    this.requestStateUpdate(true);
  }
  /**
   * array of groups for search to be filtered by.
   * @type {string[]}
   */
  get groupIds() {
    return this._groupIds;
  }
  set groupIds(value) {
    if (arraysAreEqual(this._groupIds, value)) {
      return;
    }
    this._groupIds = value;
    this.requestStateUpdate(true);
  }
  /**
   * value determining if search is filtered to a group.
   * @type {PersonType}
   */
  get type() {
    return this._type;
  }
  set type(value) {
    if (this._type === value) {
      return;
    }
    this._type = value;
    this.requestStateUpdate(true);
  }
  /**
   * type of group to search for - requires personType to be
   * set to "Group" or "All"
   * @type {GroupType}
   */
  get groupType() {
    return this._groupType;
  }
  set groupType(value) {
    if (this._groupType === value) {
      return;
    }
    this._groupType = value;
    this.requestStateUpdate(true);
  }
  /**
   * The type of user to search for. Default is any.
   *
   * @readonly
   * @type {UserType}
   * @memberof MgtPeoplePicker
   */
  get userType() {
    return this._userType;
  }
  set userType(value) {
    if (this._userType === value) {
      return;
    }
    this._userType = value;
    this.requestStateUpdate(true);
  }
  /**
   * whether the return should contain a flat list of all nested members
   * @type {boolean}
   */
  get transitiveSearch() {
    return this._transitiveSearch;
  }
  set transitiveSearch(value) {
    if (this.transitiveSearch !== value) {
      this._transitiveSearch = value;
      this.requestStateUpdate(true);
    }
  }
  /**
   * containing object of IDynamicPerson.
   * @type {IDynamicPerson[]}
   */
  get people() {
    return this._people;
  }
  set people(value) {
    if (!arraysAreEqual(this._people, value)) {
      this._people = value;
      this.requestStateUpdate(true);
    }
  }
  /**
   * determining how many people to show in list.
   * @type {number}
   */
  get showMax() {
    return this._showMax;
  }
  set showMax(value) {
    if (value !== this._showMax) {
      this._showMax = value;
      this.requestStateUpdate(true);
    }
  }
  /**
   * array of user picked people.
   * @type {IDynamicPerson[]}
   */
  get selectedPeople() {
    return this._selectedPeople;
  }
  set selectedPeople(value) {
    if (!value)
      value = [];
    if (!arraysAreEqual(this._selectedPeople, value)) {
      this._selectedPeople = value;
    }
  }
  /**
   * array of people to be selected upon initialization
   *
   * @type {string[]}
   * @memberof MgtPeoplePicker
   */
  get defaultSelectedUserIds() {
    return this._defaultSelectedUserIds;
  }
  set defaultSelectedUserIds(value) {
    if (!arraysAreEqual(this._defaultSelectedUserIds, value)) {
      this._defaultSelectedUserIds = value;
      this.requestStateUpdate(true);
    }
  }
  /**
   * array of groups to be selected upon initialization
   *
   * @type {string[]}
   * @memberof MgtPeoplePicker
   */
  get defaultSelectedGroupIds() {
    return this._defaultSelectedGroupIds;
  }
  set defaultSelectedGroupIds(value) {
    if (!arraysAreEqual(this._defaultSelectedGroupIds, value)) {
      this._defaultSelectedGroupIds = value;
      this.requestStateUpdate(true);
    }
  }
  /**
   * Array of the only users to be searched.
   *
   * @type {string[]}
   * @memberof MgtPeoplePicker
   */
  get userIds() {
    return this._userIds;
  }
  set userIds(value) {
    if (arraysAreEqual(this._userIds, value)) {
      return;
    }
    this._userIds = value;
    this.requestStateUpdate(true);
  }
  /**
   * Filters that can be set on the user properties query.
   */
  get userFilters() {
    return this._userFilters;
  }
  set userFilters(value) {
    this._userFilters = value;
    this.requestStateUpdate(true);
  }
  /**
   * Filters that can be set on the people query properties.
   */
  get peopleFilters() {
    return this._peopleFilters;
  }
  set peopleFilters(value) {
    this._peopleFilters = value;
    this.requestStateUpdate(true);
  }
  /**
   * Filters that can be set on the group query properties.
   */
  get groupFilters() {
    return this._groupFilters;
  }
  set groupFilters(value) {
    this._groupFilters = value;
    this.requestStateUpdate(true);
  }
  /**
   * Get the scopes required for people picker
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtPeoplePicker
   */
  static get requiredScopes() {
    return [
      .../* @__PURE__ */ new Set(["user.read.all", "people.read", "group.read.all", "user.readbasic.all", ...MgtPerson.requiredScopes])
    ];
  }
  constructor() {
    super();
    this._type = PersonType.person;
    this._groupType = GroupType.any;
    this._userType = UserType.any;
    this._selectedPeople = [];
    this._arrowSelectionCount = -1;
    this._highlightedUsers = [];
    this._currentHighlightedUserPos = 0;
    this._isFocused = false;
    this._setAnyEmail = false;
    this._isKeyboardFocus = true;
    this._dir = this.direction;
    this.clearState();
    this._showLoading = true;
    this.showMax = 6;
    this.disableImages = false;
    this.disabled = false;
    this.allowAnyEmail = false;
    this.addEventListener("copy", this.handleCopy);
    this.addEventListener("cut", this.handleCut);
    this.addEventListener("paste", this.handlePaste);
  }
  /**
   * Focuses the input element when focus is called
   *
   * @param {FocusOptions} [options]
   * @memberof MgtPeoplePicker
   */
  focus(options) {
    if (!this.input) {
      return;
    }
    this.input.focus(options);
    this.input.select();
  }
  /**
   * Queries the microsoft graph for a user based on the user id and adds them to the selectedPeople array
   *
   * @param {readonly string []} an array of user ids to add to selectedPeople
   * @returns {Promise<void>}
   * @memberof MgtPeoplePicker
   */
  selectUsersById(userIds) {
    return __awaiter18(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      const graph = Providers.globalProvider.graph;
      if (provider && provider.state === ProviderState.SignedIn) {
        for (const id in userIds) {
          const userId = userIds[id];
          try {
            const personDetails = yield getUser(graph, userId);
            this.addPerson(personDetails);
          } catch (e) {
            if (e.message && e.message.includes("does not exist") && this.allowAnyEmail) {
              if (isValidEmail(userId)) {
                const anyMailUser = {
                  mail: userId,
                  displayName: userId
                };
                this.addPerson(anyMailUser);
              }
            }
          }
        }
      }
    });
  }
  /**
   * Queries the microsoft graph for a group of users from a group id, and adds them to the selectedPeople
   *
   * @param {readonly string []} an array of group ids to add to selectedPeople
   * @returns {Promise<void>}
   * @memberof MgtPeoplePicker
   */
  selectGroupsById(groupIds) {
    return __awaiter18(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      const graph = Providers.globalProvider.graph;
      if (provider && provider.state === ProviderState.SignedIn) {
        for (const id in groupIds) {
          try {
            const groupDetails = yield getGroup(graph, groupIds[id]);
            this.addPerson(groupDetails);
          } catch (e) {
          }
        }
      }
    });
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return a lit-html TemplateResult.
   * Setting properties inside this method will not trigger the element to update.
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  render() {
    const defaultTemplate = this.renderTemplate("default", { people: this._foundPeople });
    if (defaultTemplate) {
      return defaultTemplate;
    }
    const selectedPeopleTemplate = this.renderSelectedPeople(this.selectedPeople);
    const inputTemplate = this.renderInput();
    const flyoutTemplate = this.renderFlyout(inputTemplate);
    const inputClasses = {
      focused: this._isFocused,
      "people-picker": true,
      disabled: this.disabled
    };
    return html`
      <div dir=${this._dir} class=${classMap(inputClasses)}>
          <div class="people-picker-inner">${selectedPeopleTemplate} ${flyoutTemplate}</div>
      </div>
    `;
  }
  /**
   * Clears state of the component
   *
   * @protected
   * @memberof MgtPeoplePicker
   */
  clearState() {
    this.selectedPeople = [];
    this.userInput = "";
    this._highlightedUsers = [];
    this._currentHighlightedUserPos = 0;
  }
  /**
   * Request to reload the state.
   * Use reload instead of load to ensure loading events are fired.
   *
   * @protected
   * @memberof MgtBaseComponent
   */
  requestStateUpdate(force) {
    if (force) {
      this._groupPeople = null;
      this._foundPeople = null;
      this.selectedPeople = [];
      this.defaultPeople = null;
    }
    return super.requestStateUpdate(force);
  }
  /**
   * Render the input text box.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  renderInput() {
    var _a2;
    const hasSelectedPeople = ((_a2 = this.selectedPeople) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    const placeholder = !this.disabled ? this.placeholder ? this.placeholder : this.strings.inputPlaceholderText : this.placeholder || "";
    const selectionMode = this.selectionMode ? this.selectionMode : "multiple";
    const inputClasses = {
      "search-box": true,
      "search-box-start": hasSelectedPeople
    };
    if (selectionMode === "single" && this.selectedPeople.length >= 1) {
      this.lostFocus();
      return html``;
    }
    return html`
       <div class="${classMap(inputClasses)}">
         <span class="search-icon">${getSvg(SvgIcon.Search)}</span>
         <input
           id="people-picker-input"
           class="search-box__input"
           type="text"
           role="combobox"
           placeholder=${placeholder}
           autocomplete="off"
           aria-label=${this.ariaLabel || ""}
           aria-controls="suggestions-list"
           aria-haspopup="listbox"
           aria-autocomplete="list"
           aria-expanded="false"
           @click="${this.handleInputClick}"
           @focus="${this.gainedFocus}"
           @keydown="${this.onUserKeyDown}"
           @keyup="${this.onUserKeyUp}"
           @input="${this.onUserInput}"
           @blur=${this.lostFocus}
           ?disabled=${this.disabled}
         />
       </div>
     `;
  }
  /**
   * Render the selected people tokens.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  renderSelectedPeople(selectedPeople) {
    if (!selectedPeople || !selectedPeople.length) {
      return html``;
    }
    this.hideSearchIcon();
    return html`
       <ul
        id="selected-list"
        aria-label="${this.strings.selected}"
        class="selected-list"
        >${selectedPeople.slice(0, selectedPeople.length).map((person) => html`
             <li
             class="selected-list__person-wrapper">
               ${this.renderTemplate("selected-person", { person }, `selected-${person.id ? person.id : person.displayName}`) || this.renderSelectedPerson(person)}

               <div class="selected-list__person-wrapper__overflow">
                 <div class="selected-list__person-wrapper__overflow__gradient"></div>
                 <div
                   tabindex="0"
                   role="button"
                   aria-label="${this.strings.removeSelectedItem} ${person.displayName}"
                   class="selected-list__person-wrapper__overflow__close-icon"
                   @click="${(e) => this.removePerson(person, e)}"
                   @keydown="${(e) => this.handleRemovePersonKeyDown(person, e)}"
                 >
                   \uE711
                 </div>
               </div>
              </li>
           `)}</ul>
     `;
  }
  /**
   * Render the flyout chrome.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  renderFlyout(anchor) {
    return mgtHtml`
       <mgt-flyout light-dismiss class="flyout">
         ${anchor}
         <fluent-card
          slot="flyout"
          class="flyout-root"
          @wheel=${(e) => this.handleSectionScroll(e)}
          class="custom">
           ${this.renderFlyoutContent()}
         </fluent-card>
       </mgt-flyout>
     `;
  }
  /**
   * Render the appropriate state in the results flyout.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  renderFlyoutContent() {
    if (this.isLoadingState || this._showLoading) {
      return this.renderLoading();
    }
    const people = this._foundPeople;
    if (!people || people.length === 0 || this.showMax === 0) {
      return this.renderNoData();
    } else {
      return this.renderSearchResults(people);
    }
  }
  /**
   * Render the loading state.
   *
   * @protected
   * @returns
   * @memberof MgtPeoplePicker
   */
  renderLoading() {
    return this.renderTemplate("loading", null) || mgtHtml`
         <div class="message-parent">
           <mgt-spinner></mgt-spinner>
           <div label="loading-text" aria-label="loading" class="loading-text">
             ${this.strings.loadingMessage}
           </div>
         </div>
       `;
  }
  /**
   * Render the state when no results are found for the search query.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  renderNoData() {
    if (!this._isFocused) {
      return;
    }
    return this.renderTemplate("error", null) || this.renderTemplate("no-data", null) || html`
         <div class="message-parent">
           <div label="search-error-text" aria-label=${this.strings.noResultsFound} class="search-error-text">
             ${this.strings.noResultsFound}
           </div>
         </div>
       `;
  }
  /**
   * Render the list of search results.
   *
   * @protected
   * @param {IDynamicPerson[]} people
   * @returns
   * @memberof MgtPeoplePicker
   */
  renderSearchResults(people) {
    const filteredPeople = people.filter((person) => person.id);
    return html`
      <ul
        id="suggestions-list"
        aria-label="${this.strings.suggestedContacts}"
        class="people-list"
        role="listbox">
          ${repeat(filteredPeople, (person) => person.id, (person) => html`
              <li
              id="${person.id}"
              aria-label=" ${this.strings.suggestedContact} ${person.displayName}"
              class="list-person"
              role="option"
              @click="${(e) => this.handleSuggestionClick(person)}">
                ${this.renderPersonResult(person)}
              </li>
            `)}
       </ul>
     `;
  }
  /**
   * Render an individual person search result.
   *
   * @protected
   * @param {IDynamicPerson} person
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  renderPersonResult(person) {
    const user = person;
    const subTitle = user.jobTitle || user.mail;
    const classes = {
      "people-person-job-title": true,
      uppercase: !!user.jobTitle
    };
    return this.renderTemplate("person", { person }, person.id) || mgtHtml`
         <mgt-person
          class="person"
          show-presence
          view="twoLines"
          line2-property="jobTitle,mail"
          dir=${this._dir}
          .personDetails=${person}
          .fetchImage=${!this.disableImages}>
          .personCardInteraction=${PersonCardInteraction.none}
        </mgt-person>`;
  }
  /**
   * Render an individual selected person token.
   *
   * @protected
   * @param {IDynamicPerson} person
   * @returns {TemplateResult}
   * @memberof MgtPeoplePicker
   */
  renderSelectedPerson(person) {
    return mgtHtml`
       <mgt-person
         tabindex="-1"
         class="person selected-list__person-wrapper__person"
         .personDetails=${person}
         .fetchImage=${!this.disableImages}
         .view=${ViewType.oneline}
         .personCardInteraction=${PersonCardInteraction.click}
       ></mgt-person>
     `;
  }
  /**
   * Async query to Graph for members of group if determined by developer.
   * set's `this.groupPeople` to those members.
   */
  loadState() {
    var _a2, _b2;
    return __awaiter18(this, void 0, void 0, function* () {
      let people = this.people;
      const input = this.userInput.toLowerCase();
      const provider = Providers.globalProvider;
      if (people) {
        if (input) {
          const displayNameMatch = people.filter((person) => person === null || person === void 0 ? void 0 : person.displayName.toLowerCase().includes(input));
          people = displayNameMatch;
        }
        this._showLoading = false;
      } else if (!people && provider && provider.state === ProviderState.SignedIn) {
        const graph = provider.graph.forComponent(this);
        if (!input.length) {
          if (this.defaultPeople) {
            people = this.defaultPeople;
          } else {
            if (this.groupId || this.groupIds) {
              if (this._groupPeople === null) {
                if (this.groupId) {
                  try {
                    if (this.type === PersonType.group) {
                      this._groupPeople = yield findGroupMembers(graph, null, this.groupId, this.showMax, this.type, this.transitiveSearch);
                    } else {
                      this._groupPeople = yield findGroupMembers(graph, null, this.groupId, this.showMax, this.type, this.transitiveSearch, this.userFilters, this.peopleFilters);
                    }
                  } catch (_) {
                    this._groupPeople = [];
                  }
                } else if (this.groupIds) {
                  if (this.type === PersonType.group) {
                    try {
                      this._groupPeople = yield getGroupsForGroupIds(graph, this.groupIds, this.groupFilters);
                    } catch (_) {
                      this._groupPeople = [];
                    }
                  } else {
                    try {
                      const peopleInGroups = yield findUsersFromGroupIds(graph, "", this.groupIds, this.showMax, this.type, this.transitiveSearch, this.userFilters);
                      this._groupPeople = peopleInGroups;
                    } catch (_) {
                      this._groupPeople = [];
                    }
                  }
                }
              }
              people = this._groupPeople || [];
            } else if (this.type === PersonType.person || this.type === PersonType.any) {
              if (this.userIds) {
                people = yield getUsersForUserIds(graph, this.userIds, "", this.userFilters);
              } else {
                const isUserOrContactType = this.userType === UserType.user || this.userType === UserType.contact;
                if (this._userFilters && isUserOrContactType) {
                  people = yield getUsers(graph, this._userFilters, this.showMax);
                } else {
                  people = yield getPeople(graph, this.userType, this._peopleFilters);
                }
              }
            } else if (this.type === PersonType.group) {
              if (this.groupIds) {
                try {
                  people = yield this.getGroupsForGroupIds(graph, people);
                } catch (_) {
                }
              } else {
                let groups = (yield findGroups(graph, "", this.showMax, this.groupType, this._groupFilters)) || [];
                if (groups.length > 0 && groups[0]["value"]) {
                  groups = groups[0]["value"];
                }
                people = groups;
              }
            }
            this.defaultPeople = people;
          }
          if (this._isFocused) {
            this._showLoading = false;
          }
        }
        if ((((_a2 = this.defaultSelectedUserIds) === null || _a2 === void 0 ? void 0 : _a2.length) > 0 || ((_b2 = this.defaultSelectedGroupIds) === null || _b2 === void 0 ? void 0 : _b2.length) > 0) && !this.selectedPeople.length && !this.defaultSelectedUsers) {
          this.defaultSelectedUsers = yield getUsersForUserIds(graph, this.defaultSelectedUserIds, "", this.userFilters);
          this.defaultSelectedGroups = yield getGroupsForGroupIds(graph, this.defaultSelectedGroupIds, this.peopleFilters);
          this.defaultSelectedGroups = this.defaultSelectedGroups.filter((group) => {
            return group !== null;
          });
          this.defaultSelectedUsers = this.defaultSelectedUsers.filter((user) => {
            return user !== null;
          });
          this.selectedPeople = [...this.defaultSelectedUsers, ...this.defaultSelectedGroups];
          this.requestUpdate();
          this.fireCustomEvent("selectionChanged", this.selectedPeople);
        }
        if (input) {
          people = [];
          if (this.groupId) {
            people = (yield findGroupMembers(graph, input, this.groupId, this.showMax, this.type, this.transitiveSearch, this.userFilters, this.peopleFilters)) || [];
          } else {
            if (this.type === PersonType.person || this.type === PersonType.any) {
              try {
                if (this.userType === UserType.contact || this.userType === UserType.user) {
                  if (this.userIds && this.userIds.length) {
                    people = yield getUsersForUserIds(graph, this.userIds, input, this._userFilters);
                  } else {
                    people = yield findUsers(graph, input, this.showMax, this._userFilters);
                  }
                } else {
                  if (!this.groupIds) {
                    if (this.userIds && this.userIds.length) {
                      people = yield getUsersForUserIds(graph, this.userIds, input, this._userFilters);
                    } else {
                      people = (yield findPeople(graph, input, this.showMax, this.userType, this._peopleFilters)) || [];
                    }
                  } else {
                    try {
                      people = yield findUsersFromGroupIds(graph, input, this.groupIds, this.showMax, this.type, this.transitiveSearch, this.userFilters);
                    } catch (_) {
                    }
                  }
                }
              } catch (e) {
              }
              if (people && people.length < this.showMax && this.userType !== UserType.contact && this.type !== PersonType.person) {
                try {
                  const users = (yield findUsers(graph, input, this.showMax, this._userFilters)) || [];
                  const peopleIds = new Set(people.map((p) => p.id));
                  for (const user of users) {
                    if (!peopleIds.has(user.id)) {
                      people.push(user);
                    }
                  }
                } catch (e) {
                }
              }
            }
            if ((this.type === PersonType.group || this.type === PersonType.any) && people.length < this.showMax) {
              if (this.groupIds) {
                try {
                  people = yield findGroupsFromGroupIds(graph, input, this.groupIds, this.showMax, this.groupType, this.userFilters);
                } catch (_) {
                }
              } else {
                let groups = [];
                try {
                  groups = (yield findGroups(graph, input, this.showMax, this.groupType, this._groupFilters)) || [];
                  people = people.concat(groups);
                } catch (e) {
                }
              }
            }
          }
        }
      }
      this._foundPeople = this.filterPeople(people);
    });
  }
  /**
   * Gets the Groups in a list of group IDs.
   *
   * @param graph the graph object
   * @param people already found groups
   * @returns groups found
   */
  getGroupsForGroupIds(graph, people) {
    return __awaiter18(this, void 0, void 0, function* () {
      const groups = yield getGroupsForGroupIds(graph, this.groupIds, this.groupFilters);
      for (const group of groups) {
        people = people.concat(group);
      }
      people = people.filter((person) => person);
      return people;
    });
  }
  /**
   * Hide the results flyout.
   *
   * @protected
   * @memberof MgtPeoplePicker
   */
  hideFlyout() {
    const flyout = this.flyout;
    if (flyout) {
      flyout.close();
    }
    if (this.input) {
      this.input.setAttribute("aria-expanded", "false");
      this.input.setAttribute("aria-activedescendant", "");
    }
    this._arrowSelectionCount = -1;
  }
  /**
   * Show the results flyout.
   *
   * @protected
   * @memberof MgtPeoplePicker
   */
  showFlyout() {
    const flyout = this.flyout;
    if (flyout) {
      flyout.open();
    }
    if (this.input) {
      this.input.setAttribute("aria-expanded", "true");
    }
  }
  /**
   * Removes person from selected people
   * @param person - person and details pertaining to user selected
   */
  removePerson(person, e) {
    var _a2;
    e.stopPropagation();
    const filteredPersonArr = this.selectedPeople.filter((p) => {
      if (!person.id && p.displayName) {
        return p.displayName !== person.displayName;
      }
      return p.id !== person.id;
    });
    this.selectedPeople = filteredPersonArr;
    this.loadState();
    this.fireCustomEvent("selectionChanged", this.selectedPeople);
    if (this.selectedPeople.length <= 0)
      this.showSearchIcon();
    (_a2 = this.input) === null || _a2 === void 0 ? void 0 : _a2.focus();
  }
  /**
   * Checks if key pressed is an `Enter` key before removing person
   * @param person
   * @param e
   */
  handleRemovePersonKeyDown(person, e) {
    if (e.key === "Enter") {
      this.removePerson(person, e);
    }
  }
  /**
   * Tracks when user selects person from picker
   * @param person - contains details pertaining to selected user
   * @param event - tracks user event
   */
  addPerson(person) {
    if (person) {
      setTimeout(() => {
        this.clearInput();
      }, 50);
      const duplicatePeople = this.selectedPeople.filter((p) => {
        if (!person.id && p.displayName) {
          return p.displayName === person.displayName;
        }
        return p.id === person.id;
      });
      if (duplicatePeople.length === 0) {
        this.selectedPeople = [...this.selectedPeople, person];
        this.fireCustomEvent("selectionChanged", this.selectedPeople);
        if (this.selectedPeople.length <= 0) {
          this.showSearchIcon();
        } else {
          this.hideSearchIcon();
        }
        this.loadState();
        this._foundPeople = [];
        this._arrowSelectionCount = -1;
      }
    }
  }
  clearInput() {
    this.clearHighlighted();
    if (this.selectionMode !== "single") {
      this.input.value = "";
    }
    this.userInput = "";
  }
  // handle input click
  handleInputClick() {
    if (!this.flyout.isOpen) {
      this.handleUserSearch();
    }
  }
  // handle input focus
  gainedFocus() {
    this.clearHighlighted();
    this._isFocused = true;
    this.loadState();
  }
  // handle input blur
  lostFocus() {
    this._isFocused = false;
    this._arrowSelectionCount = -1;
    if (this.input) {
      this.input.setAttribute("aria-expanded", "false");
      this.input.setAttribute("aria-activedescendant", "");
    }
    const peopleList = this.renderRoot.querySelector(".people-list");
    if (peopleList) {
      for (let i = 0; i < peopleList.children.length; i++) {
        peopleList.children[i].classList.remove("focused");
        peopleList.children[i].setAttribute("aria-selected", "false");
      }
    }
    this.requestUpdate();
  }
  /**
   * Handles input from the key up events on the keyboard.
   */
  onUserKeyUp(event) {
    const isPaste = (event.ctrlKey || event.metaKey) && event.key === "v";
    const isCmdOrCtrlKey = ["ControlLeft", "ControlRight"].includes(event.code) || event.ctrlKey || event.metaKey;
    const isArrowKey = ["ArrowDown", "ArrowRight", "ArrowUp", "ArrowLeft"].includes(event.code);
    if (!isPaste && isCmdOrCtrlKey || isArrowKey) {
      if (isCmdOrCtrlKey || ["ArrowLeft", "ArrowRight"].includes(event.code)) {
        this.hideFlyout();
      }
      if (["ArrowDown"].includes(event.code)) {
        if (!this.flyout.isOpen && this._isFocused) {
          this.handleUserSearch();
        }
      }
      return;
    }
    if (event.shiftKey) {
      return;
    }
    if (event.code === "ShiftLeft") {
      return;
    }
    if (event.code === "Tab") {
      return;
    }
    if (event.code === "Enter") {
      return;
    }
    if (event.code === "Escape") {
      this.clearInput();
      this._foundPeople = [];
      this._arrowSelectionCount = -1;
      return;
    }
    if (event.code === "Backspace" && this.userInput.length === 0 && this.selectedPeople.length > 0) {
      this.clearHighlighted();
      this.selectedPeople = this.selectedPeople.splice(0, this.selectedPeople.length - 1);
      this.loadState();
      this.hideFlyout();
      if (this.selectedPeople.length <= 0) {
        this.showSearchIcon();
      }
      this.fireCustomEvent("selectionChanged", this.selectedPeople);
      return;
    }
    if (event.code === "Comma" || event.code === "Semicolon") {
      if (this.allowAnyEmail) {
        this._setAnyEmail = true;
        event.preventDefault();
        event.stopPropagation();
      }
      return;
    }
  }
  onUserInput(event) {
    const input = event.target;
    this.userInput = input.value;
    if (this.userInput) {
      const validEmail = isValidEmail(this.userInput);
      if (validEmail && this.allowAnyEmail) {
        if (this._setAnyEmail) {
          this.handleAnyEmail();
        }
      } else {
        this.handleUserSearch();
      }
      this._setAnyEmail = false;
    }
  }
  handleAnyEmail() {
    this._showLoading = false;
    this._arrowSelectionCount = -1;
    if (isValidEmail(this.userInput)) {
      const anyMailUser = {
        mail: this.userInput,
        displayName: this.userInput
      };
      this.addPerson(anyMailUser);
    }
    this.hideFlyout();
    if (this.input) {
      this.input.focus();
      this._isFocused = true;
    }
  }
  // handle suggestion list item click
  handleSuggestionClick(person) {
    this.addPerson(person);
    this.hideFlyout();
    this.input.focus();
  }
  /**
   * Tracks event on user input in search
   * @param input - input text
   */
  handleUserSearch() {
    if (!this._debouncedSearch) {
      this._debouncedSearch = debounce(() => __awaiter18(this, void 0, void 0, function* () {
        const loadingTimeout = setTimeout(() => {
          this._showLoading = true;
        }, 50);
        yield this.loadState();
        clearTimeout(loadingTimeout);
        this._showLoading = false;
        this._arrowSelectionCount = -1;
        this.showFlyout();
      }), 400);
    }
    this._debouncedSearch();
  }
  /**
   * Displays the search icon.
   */
  showSearchIcon() {
    var _a2;
    const searchIcon = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".search-icon");
    if (searchIcon !== void 0 || searchIcon !== null) {
      searchIcon.style.display = null;
    }
  }
  hideSearchIcon() {
    var _a2;
    const searchIcon = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".search-icon");
    if (searchIcon !== void 0 || searchIcon !== null) {
      searchIcon.style.display = "none";
    }
  }
  /**
   * Tracks event on user search (keydown)
   * @param event - event tracked on user input (keydown)
   */
  onUserKeyDown(event) {
    const selectedList = this.renderRoot.querySelector(".selected-list");
    const isCmdOrCtrlKey = event.ctrlKey || event.metaKey;
    if (isCmdOrCtrlKey && selectedList) {
      const selectedPeople = selectedList.querySelectorAll("mgt-person.selected-list__person-wrapper__person");
      this.hideFlyout();
      if (isCmdOrCtrlKey && event.code === "ArrowLeft") {
        this._currentHighlightedUserPos = (this._currentHighlightedUserPos - 1 + selectedPeople.length) % selectedPeople.length;
        if (this._currentHighlightedUserPos >= 0 && !Number.isNaN(this._currentHighlightedUserPos)) {
          this._highlightedUsers.push(selectedPeople[this._currentHighlightedUserPos]);
        } else {
          this._currentHighlightedUserPos = 0;
        }
      } else if (isCmdOrCtrlKey && event.code === "ArrowRight") {
        const person = this._highlightedUsers.pop();
        if (person) {
          const personParent = person.parentElement;
          if (personParent) {
            this.clearHighlighted(personParent);
            this._currentHighlightedUserPos++;
          }
        }
      } else if (isCmdOrCtrlKey && event.code === "KeyA") {
        this._highlightedUsers = [];
        selectedPeople.forEach((person) => this._highlightedUsers.push(person));
      }
      if (this._highlightedUsers) {
        this.highlightSelectedPeople(this._highlightedUsers);
      }
      return;
    }
    this.clearHighlighted();
    if (!this.flyout.isOpen) {
      return;
    }
    const input = event.target;
    if (event.key === "ArrowUp" || event.key === "ArrowDown") {
      this.handleArrowSelection(event);
      if (input.value.length > 0) {
        event.preventDefault();
      }
    }
    if (event.code === "Enter") {
      if (!event.shiftKey && this._foundPeople) {
        event.preventDefault();
        event.stopPropagation();
        const foundPerson = this._foundPeople[this._arrowSelectionCount];
        if (foundPerson) {
          this.addPerson(foundPerson);
          this.hideFlyout();
          this.input.value = "";
        }
      } else if (this.allowAnyEmail) {
        this.handleAnyEmail();
      }
    }
    if (event.code === "Escape") {
      event.stopPropagation();
    }
    if (event.code === "Tab") {
      this.hideFlyout();
    }
    if (event.code === "Comma" || event.code === "Semicolon") {
      if (this.allowAnyEmail) {
        event.preventDefault();
        event.stopPropagation();
        this.userInput = input.value;
        this.handleAnyEmail();
      }
    }
  }
  /**
   * Gets the text of the highlighed people and writes it to the clipboard
   */
  writeHighlightedText() {
    return __awaiter18(this, void 0, void 0, function* () {
      const copyText = [];
      for (const element of this._highlightedUsers) {
        const { id, displayName, email, userPrincipalName, scoredEmailAddresses } = element["_personDetails"];
        let emailAddress;
        if (scoredEmailAddresses && scoredEmailAddresses.length > 0) {
          emailAddress = scoredEmailAddresses.pop().address;
        } else {
          emailAddress = userPrincipalName || email;
        }
        copyText.push({ id, displayName, email: emailAddress });
      }
      let copiedTextStr = "";
      if (copyText.length > 0) {
        copiedTextStr = JSON.stringify(copyText);
      }
      yield navigator.clipboard.writeText(copiedTextStr);
    });
  }
  /**
   * Handles the cut event when it is fired
   */
  handleCut() {
    return __awaiter18(this, void 0, void 0, function* () {
      yield this.writeHighlightedText();
      this.removeHighlightedOnCut();
    });
  }
  /**
   * Handles the copy event when it is fired
   */
  handleCopy() {
    return __awaiter18(this, void 0, void 0, function* () {
      yield this.writeHighlightedText();
    });
  }
  /**
   * Parses the copied people text and adds them when you paste
   */
  handlePaste() {
    return __awaiter18(this, void 0, void 0, function* () {
      try {
        const copiedText = yield navigator.clipboard.readText();
        if (copiedText) {
          try {
            const people = JSON.parse(copiedText);
            if (people && people.length > 0) {
              for (const person of people) {
                this.addPerson(person);
              }
            }
          } catch (error) {
            if (error instanceof SyntaxError) {
              const _delimeters = [",", ";"];
              let listOfUsers;
              try {
                for (let i = 0; i < _delimeters.length; i++) {
                  listOfUsers = copiedText.split(_delimeters[i]);
                  if (listOfUsers.length > 1) {
                    this.hideFlyout();
                    this.selectUsersById(listOfUsers);
                    break;
                  }
                }
              } catch (error2) {
              }
            }
          }
        }
      } catch (error) {
      }
    });
  }
  /**
   * Removes only the highlighted elements from the peoplePicker during cut operations.
   */
  removeHighlightedOnCut() {
    this.selectedPeople = this.selectedPeople.splice(0, this.selectedPeople.length - this._highlightedUsers.length);
    this._highlightedUsers = [];
    this._currentHighlightedUserPos = 0;
    this.loadState();
    this.hideFlyout();
    this.fireCustomEvent("selectionChanged", this.selectedPeople);
  }
  /**
   * Changes the color class to show which people are selected for copy/cut-paste
   * @param people list of selected people classes
   */
  highlightSelectedPeople(people) {
    for (let i = 0; i < people.length; i++) {
      const person = people[i];
      const parentElement = person.parentElement;
      parentElement.setAttribute("class", "selected-list__person-wrapper-highlighted");
      const personNodes = Array.from(parentElement.getElementsByClassName("selected-list__person-wrapper__person"));
      if (personNodes && personNodes.length > 0) {
        const personNode = personNodes.pop();
        personNode.setAttribute("class", "selected-list__person-wrapper-highlighted__person");
      }
      const gradientNodes = Array.from(parentElement.getElementsByClassName("selected-list__person-wrapper__overflow__gradient"));
      if (gradientNodes && gradientNodes.length > 0) {
        const gradientNode = gradientNodes.pop();
        gradientNode.setAttribute("class", "selected-list__person-wrapper-highlighted__overflow__gradient");
      }
      const closeIconNodes = Array.from(parentElement.getElementsByClassName("selected-list__person-wrapper__overflow__close-icon"));
      if (closeIconNodes && closeIconNodes.length > 0) {
        const closeIconNode = closeIconNodes.pop();
        closeIconNode.setAttribute("class", "selected-list__person-wrapper-highlighted__overflow__close-icon");
      }
    }
  }
  /**
   * Defaults the people class back to the normal view
   */
  clearHighlighted(node) {
    if (node) {
      this.clearNodeHighlights(node);
    } else {
      for (let i = 0; i < this._highlightedUsers.length; i++) {
        const person = this._highlightedUsers[i];
        const parentElement = person.parentElement;
        if (parentElement) {
          this.clearNodeHighlights(parentElement);
        }
      }
      this._highlightedUsers = [];
      this._currentHighlightedUserPos = 0;
    }
  }
  /**
   * Returns the original classes of a highlighted person element
   * @param node a highlighted node element
   */
  clearNodeHighlights(node) {
    node.setAttribute("class", "selected-list__person-wrapper");
    const personNodes = Array.from(node.getElementsByClassName("selected-list__person-wrapper-highlighted__person"));
    if (personNodes && personNodes.length > 0) {
      const personNode = personNodes.pop();
      personNode.setAttribute("class", "selected-list__person-wrapper__person");
    }
    const gradientNodes = Array.from(node.getElementsByClassName("selected-list__person-wrapper-highlighted__overflow__gradient"));
    if (gradientNodes && gradientNodes.length > 0) {
      const gradientNode = gradientNodes.pop();
      gradientNode.setAttribute("class", "selected-list__person-wrapper__overflow__gradient");
    }
    const closeIconNodes = Array.from(node.getElementsByClassName("selected-list__person-wrapper-highlighted__overflow__close-icon"));
    if (closeIconNodes && closeIconNodes.length > 0) {
      const closeIconNode = closeIconNodes.pop();
      closeIconNode.setAttribute("class", "selected-list__person-wrapper__overflow__close-icon");
    }
  }
  /**
   * Tracks user key selection for arrow key selection of people
   * @param event - tracks user key selection
   */
  handleArrowSelection(event) {
    const peopleList = this.renderRoot.querySelector(".people-list");
    if (peopleList && peopleList.children.length) {
      if (event) {
        if (event.key === "ArrowUp") {
          if (this._arrowSelectionCount === -1) {
            this._arrowSelectionCount = 0;
          } else {
            this._arrowSelectionCount = (this._arrowSelectionCount - 1 + peopleList.children.length) % peopleList.children.length;
          }
        }
        if (event.key === "ArrowDown") {
          if (this._arrowSelectionCount === -1) {
            this._arrowSelectionCount = 0;
          } else {
            this._arrowSelectionCount = (this._arrowSelectionCount + 1) % peopleList.children.length;
          }
        }
      }
      for (let i = 0; i < peopleList.children.length; i++) {
        peopleList.children[i].classList.remove("focused");
        peopleList.children[i].setAttribute("aria-selected", "false");
      }
      const focusedItem = peopleList.children[this._arrowSelectionCount];
      if (focusedItem) {
        focusedItem.classList.add("focused");
        focusedItem.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
        focusedItem.setAttribute("aria-selected", "true");
        this.input.setAttribute("aria-activedescendant", peopleList.children[this._arrowSelectionCount].id);
      }
    }
  }
  /**
   * Filters people searched from already selected people
   * @param people - array of people returned from query to Graph
   */
  filterPeople(people) {
    const uniquePeople = [];
    if (people && people.length > 0) {
      people = people.filter((person) => person);
      const idFilter = this.selectedPeople.map((el) => {
        return el.id ? el.id : el.displayName;
      });
      const filtered = people.filter((person) => {
        if (person === null || person === void 0 ? void 0 : person.id) {
          return idFilter.indexOf(person.id) === -1;
        } else {
          return idFilter.indexOf(person === null || person === void 0 ? void 0 : person.displayName) === -1;
        }
      });
      const dupsSet = /* @__PURE__ */ new Set();
      for (let i = 0; i < filtered.length; i++) {
        const person = JSON.stringify(filtered[i]);
        dupsSet.add(person);
      }
      dupsSet.forEach((person) => {
        const p = JSON.parse(person);
        uniquePeople.push(p);
      });
    }
    return uniquePeople;
  }
  // stop propagating wheel event to flyout so mouse scrolling works
  handleSectionScroll(e) {
    const target2 = this.renderRoot.querySelector(".flyout-root");
    if (target2) {
      if (!(e.deltaY < 0 && target2.scrollTop === 0) && !(e.deltaY > 0 && target2.clientHeight + target2.scrollTop >= target2.scrollHeight - 1)) {
        e.stopPropagation();
      }
    }
  }
};
__decorate14([
  property({ attribute: "group-id", converter: (value) => value.trim() }),
  __metadata11("design:type", String),
  __metadata11("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "groupId", null);
__decorate14([
  property({
    attribute: "group-ids",
    converter: (value) => {
      return value.split(",").map((v) => v.trim());
    }
  }),
  __metadata11("design:type", Array),
  __metadata11("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "groupIds", null);
__decorate14([
  property({
    attribute: "type",
    converter: (value, type) => {
      value = value.toLowerCase();
      if (!value || value.length === 0) {
        return PersonType.any;
      }
      if (typeof PersonType[value] === "undefined") {
        return PersonType.any;
      } else {
        return PersonType[value];
      }
    }
  }),
  __metadata11("design:type", Object),
  __metadata11("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "type", null);
__decorate14([
  property({
    attribute: "group-type",
    converter: (value, type) => {
      if (!value || value.length === 0) {
        return GroupType.any;
      }
      const values = value.split(",");
      const groupTypes = [];
      for (let v of values) {
        v = v.trim();
        if (typeof GroupType[v] !== "undefined") {
          groupTypes.push(GroupType[v]);
        }
      }
      if (groupTypes.length === 0) {
        return GroupType.any;
      }
      const gt = groupTypes.reduce((a, c) => a | c);
      return gt;
    }
  }),
  __metadata11("design:type", Number),
  __metadata11("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "groupType", null);
__decorate14([
  property({
    attribute: "user-type",
    converter: (value, type) => {
      value = value.toLowerCase();
      return !value || typeof UserType[value] === "undefined" ? UserType.any : UserType[value];
    }
  }),
  __metadata11("design:type", String),
  __metadata11("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "userType", null);
__decorate14([
  property({
    attribute: "transitive-search",
    type: Boolean
  }),
  __metadata11("design:type", Boolean),
  __metadata11("design:paramtypes", [Boolean])
], MgtPeoplePicker.prototype, "transitiveSearch", null);
__decorate14([
  property({
    attribute: "people",
    type: Object
  }),
  __metadata11("design:type", Array),
  __metadata11("design:paramtypes", [Array])
], MgtPeoplePicker.prototype, "people", null);
__decorate14([
  property({
    attribute: "show-max",
    type: Number
  }),
  __metadata11("design:type", Number),
  __metadata11("design:paramtypes", [Number])
], MgtPeoplePicker.prototype, "showMax", null);
__decorate14([
  property({
    attribute: "disable-images",
    type: Boolean
  }),
  __metadata11("design:type", Boolean)
], MgtPeoplePicker.prototype, "disableImages", void 0);
__decorate14([
  property({
    attribute: "selected-people",
    type: Array
  }),
  __metadata11("design:type", Array),
  __metadata11("design:paramtypes", [Array])
], MgtPeoplePicker.prototype, "selectedPeople", null);
__decorate14([
  property({
    attribute: "default-selected-user-ids",
    converter: (value) => {
      return value.split(",").map((v) => v.trim());
    },
    type: String
  }),
  __metadata11("design:type", Array),
  __metadata11("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "defaultSelectedUserIds", null);
__decorate14([
  property({
    attribute: "default-selected-group-ids",
    converter: (value) => {
      return value.split(",").map((v) => v.trim());
    },
    type: String
  }),
  __metadata11("design:type", Array),
  __metadata11("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "defaultSelectedGroupIds", null);
__decorate14([
  property({
    attribute: "placeholder",
    type: String
  }),
  __metadata11("design:type", String)
], MgtPeoplePicker.prototype, "placeholder", void 0);
__decorate14([
  property({
    attribute: "disabled",
    type: Boolean
  }),
  __metadata11("design:type", Boolean)
], MgtPeoplePicker.prototype, "disabled", void 0);
__decorate14([
  property({
    attribute: "allow-any-email",
    type: Boolean
  }),
  __metadata11("design:type", Boolean)
], MgtPeoplePicker.prototype, "allowAnyEmail", void 0);
__decorate14([
  property({
    attribute: "selection-mode",
    type: String
  }),
  __metadata11("design:type", String)
], MgtPeoplePicker.prototype, "selectionMode", void 0);
__decorate14([
  property({
    attribute: "user-ids",
    converter: (value) => {
      return value.split(",").map((v) => v.trim());
    },
    type: String
  }),
  __metadata11("design:type", Array),
  __metadata11("design:paramtypes", [Array])
], MgtPeoplePicker.prototype, "userIds", null);
__decorate14([
  property({ attribute: "user-filters" }),
  __metadata11("design:type", String),
  __metadata11("design:paramtypes", [String])
], MgtPeoplePicker.prototype, "userFilters", null);
__decorate14([
  property({ attribute: "people-filters" }),
  __metadata11("design:type", String),
  __metadata11("design:paramtypes", [String])
], MgtPeoplePicker.prototype, "peopleFilters", null);
__decorate14([
  property({ attribute: "group-filters" }),
  __metadata11("design:type", String),
  __metadata11("design:paramtypes", [String])
], MgtPeoplePicker.prototype, "groupFilters", null);
__decorate14([
  property({
    attribute: "aria-label",
    type: String
  }),
  __metadata11("design:type", String)
], MgtPeoplePicker.prototype, "ariaLabel", void 0);
__decorate14([
  state(),
  __metadata11("design:type", Boolean)
], MgtPeoplePicker.prototype, "_showLoading", void 0);
__decorate14([
  state(),
  __metadata11("design:type", Object)
], MgtPeoplePicker.prototype, "_isFocused", void 0);
__decorate14([
  state(),
  __metadata11("design:type", Boolean)
], MgtPeoplePicker.prototype, "_setAnyEmail", void 0);
__decorate14([
  state(),
  __metadata11("design:type", Array)
], MgtPeoplePicker.prototype, "_foundPeople", void 0);
MgtPeoplePicker = __decorate14([
  customElement("people-picker"),
  __metadata11("design:paramtypes", [])
], MgtPeoplePicker);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person-card/mgt-person-card.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person-card/mgt-person-card.graph.js
init_es6();
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var userProperties = "businessPhones,companyName,department,displayName,givenName,jobTitle,mail,mobilePhone,officeLocation,preferredLanguage,surname,userPrincipalName,id,accountEnabled";
var batchKeys = {
  directReports: "directReports",
  files: "files",
  messages: "messages",
  people: "people",
  person: "person"
};
function getPersonCardGraphData(graph, personDetails, isMe, config) {
  return __awaiter19(this, void 0, void 0, function* () {
    const userId = personDetails.id;
    const email = getEmailFromGraphEntity(personDetails);
    const isContactOrGroup = "classification" in personDetails || "personType" in personDetails && (personDetails.personType.subclass === "PersonalContact" || personDetails.personType.class === "Group");
    const batch = graph.createBatch();
    if (!isContactOrGroup) {
      if (config.sections.organization) {
        buildOrgStructureRequest(batch, userId);
        if (typeof config.sections.organization !== "boolean" && config.sections.organization.showWorksWith) {
          buildWorksWithRequest(batch, userId);
        }
      }
    }
    if (config.sections.mailMessages && email) {
      buildMessagesWithUserRequest(batch, email);
    }
    if (config.sections.files) {
      buildFilesRequest(batch, isMe ? null : email);
    }
    let response;
    const data = {};
    try {
      response = yield batch.executeAll();
    } catch (_a2) {
    }
    if (response) {
      for (const [key, value] of response) {
        data[key] = value.content.value || value.content;
      }
    }
    if (!isContactOrGroup && config.sections.profile) {
      try {
        const profile = yield getProfile(graph, userId);
        if (profile) {
          data.profile = profile;
        }
      } catch (_b2) {
      }
    }
    if (data.directReports && data.directReports.length > 0) {
      data.directReports = data.directReports.filter((report) => report.accountEnabled);
    }
    return data;
  });
}
function buildOrgStructureRequest(batch, userId) {
  const expandManagers = `manager($levels=max;$select=${userProperties})`;
  batch.get(batchKeys.person, `users/${userId}?$expand=${expandManagers}&$select=${userProperties}&$count=true`, ["user.read.all"], {
    ConsistencyLevel: "eventual"
  });
  batch.get(batchKeys.directReports, `users/${userId}/directReports?$select=${userProperties}`);
}
function buildWorksWithRequest(batch, userId) {
  batch.get(batchKeys.people, `users/${userId}/people?$filter=personType/class eq 'Person'`, ["People.Read.All"]);
}
function buildMessagesWithUserRequest(batch, emailAddress) {
  batch.get(batchKeys.messages, `me/messages?$search="from:${emailAddress}"`, ["Mail.ReadBasic"]);
}
function buildFilesRequest(batch, emailAddress) {
  let request;
  if (emailAddress) {
    request = `me/insights/shared?$filter=lastshared/sharedby/address eq '${emailAddress}'`;
  } else {
    request = "me/insights/used";
  }
  batch.get(batchKeys.files, request, ["Sites.Read.All"]);
}
function getProfile(graph, userId) {
  return __awaiter19(this, void 0, void 0, function* () {
    const profile = yield graph.api(`/users/${userId}/profile`).version("beta").get();
    return profile;
  });
}
function createChat(graph, person, user) {
  return __awaiter19(this, void 0, void 0, function* () {
    const chatData = {
      chatType: "oneonOne",
      members: [
        {
          "@odata.type": "#microsoft.graph.aadUserConversationMember",
          roles: ["owner"],
          "user@odata.bind": `https://graph.microsoft.com/v1.0/users('${user}')`
        },
        {
          "@odata.type": "#microsoft.graph.aadUserConversationMember",
          roles: ["owner"],
          "user@odata.bind": `https://graph.microsoft.com/v1.0/users('${person}')`
        }
      ]
    };
    const chat = yield graph.api(`/chats`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Chat.Create", "Chat.ReadWrite")).post(chatData);
    return chat;
  });
}
function sendMessage(graph, chatId, messageData) {
  return __awaiter19(this, void 0, void 0, function* () {
    const message = yield graph.api(`/chats/${chatId}/messages`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Chat.ReadWrite", "ChatMessage.Send")).post(messageData);
    return message;
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person-card/mgt-person-card-css.js
init_lit();
var styles12 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--presence-background-color:#ffffff;--presence-icon-color:#ffffff;--line1-color:#000000;--line2-color:var(--neutral-foreground-hint, #717171);--line3-color:var(--neutral-foreground-hint, #717171);--line4-color:var(--neutral-foreground-hint, #717171);--initials-color:black;--initials-background-color:white}.mgt-dark{--presence-background-color:#000000;--presence-icon-color:#000000;--line1-color:#ffffff;--line2-color:#c8c6c4;--line3-color:#c8c6c4;--line4-color:#c8c6c4;--initials-color:white;--initials-background-color:black}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--person-card-contact-link-color:#023b8f;--person-card-contact-link-hover-color:#106ebe}.mgt-dark{--person-card-contact-link-color:#ffffff;--person-card-contact-link-hover-color:#f3f2f1}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--person-card-active-org-member-color:#023b8f}.mgt-dark{--person-card-active-org-member-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--token-overflow-color:#023b8f}.mgt-dark{--token-overflow-color:#f3f2f1}.mgt-light{--person-card-background-color:#ffffff;--person-card-display-name-color:#000000;--person-card-title-color:var(--neutral-foreground-hint, #717171);--person-card-subtitle-color:var(--neutral-foreground-hint, #717171);--person-card-nav-back-arrow-color:#023b8f;--person-card-nav-back-arrow-color:#000000;--person-card-show-more-color:#023b8f;--person-card-show-more-hover-color:#106ebe}.mgt-dark{--person-card-background-color:#000000;--person-card-display-name-color:#ffffff;--person-card-title-color:#c8c6c4;--person-card-subtitle-color:#c8c6c4;--person-card-nav-back-arrow-color:#106ebe;--person-card-nav-back-arrow-color:#ffffff;--person-card-show-more-color:#ffffff;--person-card-show-more-hover-color:#f3f2f1}:host{box-shadow:var(--box-shadow,0 3.2px 7.2px 0 rgba(0,0,0,.132));background-color:var(--person-card-background-color,#fff);width:var(--mgt-flyout-set-width,375px);font-family:var(--default-font-family);overflow:hidden;user-select:none;border-radius:8px;border:1px solid var(--background-color-sub1,#faf9f8)}:host .small{max-height:100vh;overflow-y:auto;overflow-x:hidden}:host .nav{height:0;position:relative;z-index:100}:host .nav__back{padding-top:18px;padding-inline-start:12px;height:32px;width:32px}:host .nav__back svg{fill:var(--person-card-nav-back-arrow-color,#023b8f)}:host .nav__back:hover{cursor:pointer}:host .nav__back:hover svg{fill:var(--person-card-nav-back-arrow-color,#000)}:host .close-card-container{position:relative;z-index:100}:host .close-card-container .close-button{--focus-stroke-width:none;--control-corner-radius:2;--accent-foreground-active:none;--accent-foreground-hover:none;--neutral-fill-stealth-rest:transparent;--neutral-fill-stealth-hover:var(--background-color--hover, var(--neutral-fill-hover, #f7f7f7));position:absolute;right:10px;margin-top:9px;z-index:1;border:1px solid transparent}:host .close-card-container .close-button svg{width:9px;height:9px}:host .close-card-container .close-button svg path{fill:var(--icon-color-sub3,#023b8f)}:host .person-details-container{display:flex;flex-direction:column;padding-inline-start:23px;padding-top:23px;border-bottom:1px solid var(--line-seperator-color-sub1,#ebebeb)}:host .person-details-container .person-image{--presence-background-color:var(--presence-background-color, #ffffff);--presence-icon-color:var(--presence-icon-color, #ffffff);--line1-font-size:var(--person-card-display-name-font-size, 20px);--line1-line-height:var(--person-card-display-name-line-height, 28px);--line1-color:var(--person-card-display-name-color, #000000);--line2-font-size:var(--person-card-title-font-size, 14px);--line2-line-height:var(--person-card-title-line-height, 20px);--line2-color:var(--person-card-title-color, var(--neutral-foreground-hint, #717171));--line3-font-size:var(--person-card-subtitle-font-size, 14px);--line3-line-height:var(--person-card-subtitle-line-height, 19px);--line3-color:var(--person-card-subtitle-color, var(--neutral-foreground-hint, #717171));--avatar-size:75px;--details-cta-spacing:30px;--user-presence-margin-offset:5px}:host .person-details-container .base-icons{display:flex;-webkit-align-items:center;align-items:center;position:relative;left:91px;bottom:25px;z-index:1;width:fit-content}:host .person-details-container .base-icons .icon{display:flex;align-items:center;cursor:pointer;font-size:13px;white-space:nowrap}:host .person-details-container .base-icons .icon:not(:last-child){margin-inline-end:38px}:host .person-details-container .base-icons .icon svg path{fill:var(--icon-color-sub3,#023b8f)}:host .person-details-container .base-icons .icon:active svg path,:host .person-details-container .base-icons .icon:hover svg path{fill:var(--icon-color__sub3--hover,#023b8f)}:host .expanded-details-container{display:flex;flex-direction:column;position:relative}:host .expanded-details-container .expanded-details-button{display:flex;justify-content:center;align-items:center;height:32px}:host .expanded-details-container .expanded-details-button svg path{stroke:var(--icon-color-sub3,#023b8f)}:host .expanded-details-container .expanded-details-button:hover{cursor:pointer;background-color:var(--background-color--hover,var(--neutral-fill-hover,#f7f7f7))}:host .expanded-details-container .sections .section{padding:20px 0;display:flex;flex-direction:column;position:relative}:host .expanded-details-container .sections .section:not(:last-child):after{position:absolute;content:"";width:90%;transform:translateX(-50%);border-bottom:1px solid var(--line-seperator-color-sub1,#ebebeb);left:50%;bottom:0}:host .expanded-details-container .sections .section__header{display:flex;flex-direction:row;padding:0 20px}:host .expanded-details-container .sections .section__title{flex-grow:1;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));font-size:14px;font-weight:600;line-height:19px}:host .expanded-details-container .sections .section__show-more{color:var(--person-card-show-more-color,#023b8f);font-size:12px;font-weight:600;align-self:center;vertical-align:top;--neutral-fill-stealth-rest:transparent;--neutral-fill-stealth-hover:var(--background-color--active, #e1dfdd);--base-height-multiplier:6}:host .expanded-details-container .sections .section__show-more:hover{cursor:pointer;color:var(--person-card-show-more-hover-color,#106ebe)}:host .expanded-details-container .sections .section__content{margin-top:14px}:host .expanded-details-container .sections .section .additional-details{padding:0 20px}:host .expanded-details-container .section-nav{border-bottom:1px solid var(--line-seperator-color-sub1,#ebebeb);height:36px;padding-bottom:2px}:host .expanded-details-container .section-nav fluent-tabs{grid-template-columns:minmax(1px,.1fr);--accent-fill-rest:var(--icon-color-sub3, #023b8f)}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel{max-height:360px;min-height:360px;overflow-y:auto;overflow-x:hidden;padding:0;scrollbar-width:thin}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel .inserted{max-width:var(--mgt-flyout-set-width,375px);min-width:var(--mgt-flyout-set-width,360px)}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel .overview-panel{max-width:var(--mgt-flyout-set-width,375px)}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel::-webkit-scrollbar{height:4em;width:4px;border-radius:11px}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel::-webkit-scrollbar-button{background:var(--person-card-background-color,#fff);height:1px}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel::-webkit-scrollbar-track{background:var(--person-card-background-color,#fff);border-radius:10px}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel::-webkit-scrollbar-track-piece{background:var(--person-card-background-color,#fff)}:host .expanded-details-container .section-nav fluent-tabs fluent-tab-panel::-webkit-scrollbar-thumb{background:grey;border-radius:10px;height:4px}:host .expanded-details-container .section-nav fluent-tabs fluent-tab{padding-bottom:1px!important;border:1px solid transparent!important}:host .expanded-details-container .section-nav fluent-tabs fluent-tab:focus-visible{border:1px solid #2b2b2b!important}:host .expanded-details-container .section-nav fluent-tabs fluent-tab.section-nav__icon{cursor:pointer;box-sizing:border-box;width:48px;display:flex;align-items:center;justify-content:center}:host .expanded-details-container .section-nav fluent-tabs fluent-tab.section-nav__icon svg{fill:var(--icon-color,#605e5c)}:host .expanded-details-container .section-nav fluent-tabs fluent-tab.section-nav__icon:hover{background:var(--tab-background-color--hover,var(--neutral-fill-hover,#f7f7f7));border-radius:4px}:host .expanded-details-container .section-host{min-height:360px;overflow-y:auto;overflow-x:hidden}:host .expanded-details-container .section-host::-webkit-scrollbar{height:4em;width:4px;border-radius:11px}:host .expanded-details-container .section-host::-webkit-scrollbar-button{background:#fff}:host .expanded-details-container .section-host::-webkit-scrollbar-track{background:#fff;border-radius:10px}:host .expanded-details-container .section-host::-webkit-scrollbar-track-piece{background:#fff}:host .expanded-details-container .section-host::-webkit-scrollbar-thumb{background:grey;border-radius:10px;height:4px}:host .expanded-details-container .section-host.small{overflow-y:hidden}:host .loading{margin:40px 20px;display:flex;justify-content:center;height:360px}:host .message-section{border-bottom:1px solid var(--tab-line-color,#d6d6d6);display:flex}:host .message-section fluent-text-field{margin:10px 10px 10px 16px;--neutral-fill-input-rest:var(--input-background-color, #ffffff);--neutral-fill-input-hover:var(--input-background-color--hover, var(--neutral-fill-hover, #f7f7f7));--neutral-fill-input-focus:var(--input-background-color--focus, #ffffff);width:300px;margin-inline-start:16px;border-radius:4px}:host .message-section fluent-text-field:focus-within{--neutral-fill-secondary-rest:var(--person-card-background-color, #ffffff)}:host .message-section .send-message-icon{max-width:15px;margin-top:10px}:host .message-section svg{height:17px;width:16px;fill:var(--icon-color,#605e5c)}:host .message-section svg:hover{filter:brightness(.5)}:host .message-section svg:disabled{filter:none}[dir=rtl] .base-icons{right:91px}[dir=rtl] .nav__back{width:20px!important;-moz-transform:scaleX(-1);-o-transform:scaleX(-1);-webkit-transform:scaleX(-1);transform:scaleX(-1);filter:FlipH;-ms-filter:FlipH}[dir=rtl] .close-card-container .close-button{right:auto;left:10px}[dir=rtl] .message-section svg{transform:scale(-1,1)}@media (forced-colors:active) and (prefers-color-scheme:dark){.root{border:1px solid #fff;border-radius:inherit}.root svg,.root svg>path{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}.expanded-details-container>svg,.expanded-details-container>svg>path,svg,svg>path{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}@media (forced-colors:active) and (prefers-color-scheme:light){.root{border:1px solid #000;border-radius:inherit}.root svg,.root svg>path{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}.expanded-details-container>svg,.expanded-details-container>svg>path,svg,svg>path{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-contact/mgt-contact.js
init_lit();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/BasePersonCardSection.js
init_es6();
init_lit();
init_decorators();
var __decorate15 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata12 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var BasePersonCardSection = class extends MgtTemplatedComponent {
  /**
   * Set the person details to render
   *
   * @type {IDynamicPerson}
   * @memberof BasePersonCardSection
   */
  get personDetails() {
    return this._personDetails;
  }
  set personDetails(value) {
    if (this._personDetails === value) {
      return;
    }
    this._personDetails = value;
    this.requestStateUpdate();
  }
  /**
   * Determines the appropriate view state: full or compact
   *
   * @protected
   * @type {boolean}
   * @memberof BasePersonCardSection
   */
  get isCompact() {
    return this._isCompact;
  }
  constructor() {
    super();
    this._isCompact = false;
    this._personDetails = null;
  }
  /**
   * Set the section to compact view mode
   *
   * @returns
   * @memberof BasePersonCardSection
   */
  asCompactView() {
    this._isCompact = true;
    this.requestUpdate();
    return this;
  }
  /**
   * Set the section to full view mode
   *
   * @returns
   * @memberof BasePersonCardSection
   */
  asFullView() {
    this._isCompact = false;
    this.requestUpdate();
    return this;
  }
  /**
   * Reset any state in the section
   *
   * @protected
   * @abstract
   * @memberof BasePersonCardSection
   */
  clearState() {
    this._isCompact = false;
    this._personDetails = null;
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    return this.isCompact ? this.renderCompactView() : this.renderFullView();
  }
  /**
   * Render a spinner while the component loads state
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof BasePersonCardSection
   */
  renderLoading() {
    return mgtHtml`
      <div class="loading">
        <mgt-spinner></mgt-spinner>
      </div>
    `;
  }
  /**
   * Render the section in a empty data state
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCardContact
   */
  renderNoData() {
    return html`
      <div class="no-data">No data</div>
    `;
  }
  /**
   * Navigate the card to a different user.
   *
   * @protected
   * @memberof BasePersonCardSection
   */
  navigateCard(person) {
    let parent = this.parentNode;
    while (parent) {
      parent = parent.parentNode;
      if (parent && parent.host && parent.host.tagName === "MGT-PERSON-CARD") {
        parent = parent.host;
        break;
      }
    }
    const personCard = parent;
    personCard.navigate(person);
  }
};
__decorate15([
  property({
    attribute: "person-details",
    type: Object
  }),
  __metadata12("design:type", Object),
  __metadata12("design:paramtypes", [Object])
], BasePersonCardSection.prototype, "personDetails", null);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-contact/mgt-contact-css.js
init_lit();
var styles13 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}:host .loading,:host .no-data{margin:0 20px;display:flex;justify-content:center}:host .no-data{font-family:var(--default-font-family, "Segoe UI");font-style:normal;font-weight:600;font-size:14px;color:var(--font-color,#323130);line-height:19px}:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--person-card-contact-link-color:#023b8f;--person-card-contact-link-hover-color:#106ebe}.mgt-dark{--person-card-contact-link-color:#ffffff;--person-card-contact-link-hover-color:#f3f2f1}:host{position:relative;user-select:none}:host .root{padding:20px 0}:host .root .title{font-size:14px;font-weight:600;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));margin:0 20px 12px 20px}:host .root .part{display:grid;grid-template-columns:auto 1fr auto}:host .root .part .part__icon{display:flex;min-width:20px;width:20px;height:20px;align-items:center;justify-content:center;margin-left:20px;margin-top:10px;line-height:20px}:host .root .part .part__details{margin:10px 14px;overflow:hidden}:host .root .part .part__details .part__title{font-size:12px;color:var(--title-color-sub2,var(--neutral-foreground-hint,#717171));line-height:16px}:host .root .part .part__details .part__value{grid-column:2;color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a));font-size:14px;font-weight:400;line-height:19px}:host .root .part .part__details .part__value .part__link{color:var(--person-card-contact-link-color,#023b8f);font-family:var(--default-font-family);font-size:14px;cursor:pointer;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;width:100%;display:inline-block}:host .root .part .part__details .part__value .part__link:hover{color:var(--person-card-contact-link-hover-color,#106ebe)}:host .root .part .part__copy{width:32px;height:100%;background-color:var(--background-color-sub2,#f3f2f1);visibility:hidden;display:flex;align-items:center;justify-content:center}:host .root .part .part__copy svg{fill:var(--icon-color,#605e5c);cursor:pointer}:host .root .part:hover .part__copy{visibility:visible}:host .root.compact{padding:0}:host .root.compact .part{height:30px;align-items:center}:host .root.compact .part__details{margin:0}:host .root.compact .part__title{display:none}:host .root.compact .part__icon{margin-top:0;margin-right:6px;margin-bottom:2px}[dir=rtl] .part__link.phone{text-align:right;direction:ltr}[dir=rtl] .part__icon{margin:10px 20px 0 0!important}[dir=rtl].compact .part__icon{margin-left:6px!important;margin-top:0!important}@media (forced-colors:active) and (prefers-color-scheme:dark){.root svg{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}.root svg path,.root svg rect{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}@media (forced-colors:active) and (prefers-color-scheme:light){.root svg{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}.root svg path,.root svg rect{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-contact/strings.js
var strings8 = {
  contactSectionTitle: "Contact",
  emailTitle: "Email",
  chatTitle: "Teams",
  businessPhoneTitle: "Business Phone",
  cellPhoneTitle: "Mobile Phone",
  departmentTitle: "Department",
  titleTitle: "Title",
  officeLocationTitle: "Office Location",
  copyToClipboardButton: "Copy to clipboard"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-contact/mgt-contact.js
var __decorate16 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata13 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtContact = class MgtContact2 extends BasePersonCardSection {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles13;
  }
  get strings() {
    return strings8;
  }
  /**
   * Returns true if the component has data it can render
   *
   * @readonly
   * @abstract
   * @type {boolean}
   * @memberof BasePersonCardSection
   */
  get hasData() {
    if (!this._contactParts) {
      return false;
    }
    const availableParts = Object.values(this._contactParts).filter((p) => !!p.value);
    return !!availableParts.length;
  }
  // tslint:enable: object-literal-sort-keys
  constructor(person) {
    super();
    this._contactParts = {
      email: {
        icon: getSvg(SvgIcon.Email, "#605e5c"),
        onClick: () => this.sendEmail(getEmailFromGraphEntity(this._person)),
        showCompact: true,
        title: this.strings.emailTitle
      },
      chat: {
        icon: getSvg(SvgIcon.Chat, "#605e5c"),
        onClick: () => {
          var _a2;
          return this.sendChat((_a2 = this._person) === null || _a2 === void 0 ? void 0 : _a2.userPrincipalName);
        },
        showCompact: false,
        title: this.strings.chatTitle
      },
      businessPhone: {
        icon: getSvg(SvgIcon.Phone, "#605e5c"),
        onClick: () => {
          var _a2, _b2;
          return this.sendCall(((_b2 = (_a2 = this._person) === null || _a2 === void 0 ? void 0 : _a2.businessPhones) === null || _b2 === void 0 ? void 0 : _b2.length) > 0 ? this._person.businessPhones[0] : null);
        },
        showCompact: true,
        title: this.strings.businessPhoneTitle
      },
      cellPhone: {
        icon: getSvg(SvgIcon.CellPhone, "#605e5c"),
        onClick: () => {
          var _a2;
          return this.sendCall((_a2 = this._person) === null || _a2 === void 0 ? void 0 : _a2.mobilePhone);
        },
        showCompact: true,
        title: this.strings.cellPhoneTitle
      },
      department: {
        icon: getSvg(SvgIcon.Department, "#605e5c"),
        showCompact: false,
        title: this.strings.departmentTitle
      },
      title: {
        icon: getSvg(SvgIcon.Person, "#605e5c"),
        showCompact: false,
        title: this.strings.titleTitle
      },
      officeLocation: {
        icon: getSvg(SvgIcon.OfficeLocation, "#605e5c"),
        showCompact: true,
        title: this.strings.officeLocationTitle
      }
    };
    this.sendCall = (phone) => {
      this.sendLink("tel:", phone);
    };
    this._person = person;
    this._contactParts.email.value = getEmailFromGraphEntity(this._person);
    this._contactParts.chat.value = this._person.userPrincipalName;
    this._contactParts.cellPhone.value = this._person.mobilePhone;
    this._contactParts.department.value = this._person.department;
    this._contactParts.title.value = this._person.jobTitle;
    this._contactParts.officeLocation.value = this._person.officeLocation;
    if (this._person.businessPhones && this._person.businessPhones.length) {
      this._contactParts.businessPhone.value = this._person.businessPhones[0];
    }
  }
  /**
   * The name for display in the overview section.
   *
   * @readonly
   * @type {string}
   * @memberof MgtContact
   */
  get displayName() {
    return this.strings.contactSectionTitle;
  }
  // Defines the skeleton for what contact fields are available and what they do.
  /**
   * Render the icon for display in the navigation ribbon.
   *
   * @returns {TemplateResult}
   * @memberof MgtContact
   */
  renderIcon() {
    return getSvg(SvgIcon.Contact);
  }
  /**
   * Reset any state in the section
   *
   * @protected
   * @memberof MgtContact
   */
  clearState() {
    super.clearState();
    for (const key of Object.keys(this._contactParts)) {
      this._contactParts[key].value = null;
    }
  }
  /**
   * Render the compact view
   *
   * @returns {TemplateResult}
   * @memberof MgtContact
   */
  renderCompactView() {
    let contentTemplate;
    if (!this.hasData) {
      return null;
    }
    const availableParts = Object.values(this._contactParts).filter((p) => !!p.value);
    let compactParts = Object.values(availableParts).filter((p) => !!p.value && p.showCompact);
    if (!compactParts || !compactParts.length) {
      compactParts = Object.values(availableParts).slice(0, 2);
    }
    contentTemplate = html`
      ${compactParts.map((p) => this.renderContactPart(p))}
    `;
    return html`
      <div class="root compact" dir=${this.direction}>
        ${contentTemplate}
      </div>
    `;
  }
  /**
   * Render the full view
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtContact
   */
  renderFullView() {
    let contentTemplate;
    if (this.hasData) {
      const availableParts = Object.values(this._contactParts).filter((p) => !!p.value);
      contentTemplate = html`
        ${availableParts.map((part) => this.renderContactPart(part))}
      `;
    }
    return html`
      <div class="root" dir=${this.direction}>
        <div class="title" tabindex="0">${this.displayName}</div>
        ${contentTemplate}
      </div>
    `;
  }
  /**
   * Render a specific contact part
   *
   * @protected
   * @param {IContactPart} part
   * @returns {TemplateResult}
   * @memberof MgtContact
   */
  renderContactPart(part) {
    let isPhone = false;
    if (part.title === "Mobile Phone" || part.title === "Business Phone") {
      isPhone = true;
    }
    const partLinkClasses = {
      part__link: true,
      phone: isPhone
    };
    const valueTemplate = part.onClick ? html`
          <span class=${classMap(partLinkClasses)} @click=${(e) => part.onClick(e)}>${part.value}</span>
        ` : html`
          ${part.value}
        `;
    return html`
      <div class="part" @click=${(e) => this.handlePartClick(e, part.value)} tabindex="0">
        <div class="part__icon" aria-label=${part.title} title=${part.title}>${part.icon}</div>
        <div class="part__details">
          <div class="part__title">${part.title}</div>
          <div class="part__value" title=${part.title}>${valueTemplate}</div>
        </div>
        <div
          class="part__copy"
          aria-role="button" 
          aria-label=${this.strings.copyToClipboardButton}
          title=${this.strings.copyToClipboardButton}
        >
          ${getSvg(SvgIcon.Copy)}
        </div>
      </div>
    `;
  }
  /**
   * Handle the click event for contact parts
   *
   * @protected
   * @memberof MgtContact
   */
  handlePartClick(e, value) {
    if (value) {
      navigator.clipboard.writeText(value);
    }
  }
  sendLink(protocol, resource) {
    if (resource) {
      window.open(`${protocol}${resource}`, "_blank", "noreferrer");
    } else {
      console.error(`Target resource for ${protocol} link was not provided: resource: ${resource}`);
    }
  }
  /**
   * Send a chat message to the user
   *
   * @protected
   * @memberof MgtContact
   */
  sendChat(upn) {
    if (!upn) {
      console.error("Can't send chat when upn is not provided");
      return;
    }
    const url = `https://teams.microsoft.com/l/chat/0/0?users=${upn}`;
    const openWindow = () => window.open(url, "_blank", "noreferrer");
    if (TeamsHelper.isAvailable) {
      TeamsHelper.executeDeepLink(url, (status) => {
        if (!status) {
          openWindow();
        }
      });
    } else {
      openWindow();
    }
  }
  /**
   * Send an email to the user
   *
   * @protected
   * @memberof MgtContact
   */
  sendEmail(email) {
    this.sendLink("mailto:", email);
  }
};
MgtContact = __decorate16([
  customElement("contact"),
  __metadata13("design:paramtypes", [Object])
], MgtContact);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-messages/mgt-messages.js
init_lit();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-messages/mgt-messages-css.js
init_lit();
var styles14 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}:host .loading,:host .no-data{margin:0 20px;display:flex;justify-content:center}:host .no-data{font-family:var(--default-font-family, "Segoe UI");font-style:normal;font-weight:600;font-size:14px;color:var(--font-color,#323130);line-height:19px}:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}:host{position:relative;user-select:none}:host .root{padding:20px 0}:host .root.compact{padding:0}:host .root .title{font-size:14px;font-weight:600;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));margin:0 20px 12px 20px}:host .root .message{padding:8px 20px;display:flex;align-items:center;justify-content:space-between}:host .root .message:hover{background-color:#f7f7f7;cursor:pointer}:host .root .message:last-child{margin-bottom:unset}:host .root .message .message__detail{min-width:0;line-height:normal}:host .root .message .message__detail .message__subject{color:var(--color,#000);font-size:var(--message-subject-font-size,14px);font-weight:var(--message-subject-font-weight,600);line-height:var(--message-subject-line-height,20px)}:host .root .message .message__detail .message__from{font-size:var(--message-subject-font-size,12px);color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a));line-height:var(--message-subject-line-height,16px);font-weight:var(--message-subject-font-weight,400)}:host .root .message .message__detail .message__message{font-size:var(--message-subject-font-size,12px);color:var(--color-sub2,var(--neutral-foreground-hint,#717171));line-height:var(--message-subject-line-height,16px);font-weight:var(--message-subject-font-weight,400)}:host .root .message .message__detail>div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}:host .root .message .message__date{margin-top:8px;font-size:12px;color:var(--color-sub2,var(--neutral-foreground-hint,#717171));margin-left:10px;white-space:nowrap}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-messages/strings.js
var strings9 = {
  emailsSectionTitle: "Emails"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-messages/mgt-messages.js
init_es6();
var __decorate17 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata14 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtMessages = class MgtMessages2 extends BasePersonCardSection {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles14;
  }
  get strings() {
    return strings9;
  }
  constructor(messages) {
    super();
    this._messages = messages;
  }
  /**
   * The name for display in the overview section.
   *
   * @readonly
   * @type {string}
   * @memberof MgtMessages
   */
  get displayName() {
    return this.strings.emailsSectionTitle;
  }
  /**
   * Reset any state in the section
   *
   * @protected
   * @memberof MgtMessages
   */
  clearState() {
    super.clearState();
    this._messages = [];
  }
  /**
   * Render the icon for display in the navigation ribbon.
   *
   * @returns {TemplateResult}
   * @memberof MgtMessages
   */
  renderIcon() {
    return getSvg(SvgIcon.Messages);
  }
  /**
   * Render the compact view
   *
   * @returns {TemplateResult}
   * @memberof MgtMessages
   */
  renderCompactView() {
    let contentTemplate;
    if (this.isLoadingState) {
      contentTemplate = this.renderLoading();
    } else if (!this._messages || !this._messages.length) {
      contentTemplate = this.renderNoData();
    } else {
      const messageTemplates = this._messages ? this._messages.slice(0, 3).map((message) => this.renderMessage(message)) : [];
      contentTemplate = html`
         ${messageTemplates}
       `;
    }
    return html`
       <div class="root compact">
         ${contentTemplate}
       </div>
     `;
  }
  /**
   * Render the full view
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtMessages
   */
  renderFullView() {
    let contentTemplate;
    if (this.isLoadingState) {
      contentTemplate = this.renderLoading();
    } else if (!this._messages || !this._messages.length) {
      contentTemplate = this.renderNoData();
    } else {
      contentTemplate = html`
         ${this._messages.slice(0, 5).map((message) => this.renderMessage(message))}
       `;
    }
    return html`
       <div class="root">
         <div class="title" tabindex="0">${this.strings.emailsSectionTitle}</div>
         ${contentTemplate}
       </div>
     `;
  }
  /**
   * Render a message item
   *
   * @protected
   * @param {IMessage} message
   * @returns {TemplateResult}
   * @memberof MgtMessages
   */
  renderMessage(message) {
    return html`
       <div class="message" @click=${() => this.handleMessageClick(message)}>
         <div class="message__detail">
           <div class="message__subject">${message.subject}</div>
           <div class="message__from">${message.from.emailAddress.name}</div>
           <div class="message__message">${message.bodyPreview}</div>
         </div>
         <div class="message__date">${getRelativeDisplayDate(new Date(message.receivedDateTime))}</div>
       </div>
     `;
  }
  handleMessageClick(message) {
    window.open(message.webLink, "_blank", "noreferrer");
  }
};
MgtMessages = __decorate17([
  customElement("messages"),
  __metadata14("design:paramtypes", [Array])
], MgtMessages);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-organization/mgt-organization.js
init_lit();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-organization/mgt-organization-css.js
init_lit();
var styles15 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}:host .loading,:host .no-data{margin:0 20px;display:flex;justify-content:center}:host .no-data{font-family:var(--default-font-family, "Segoe UI");font-style:normal;font-weight:600;font-size:14px;color:var(--font-color,#323130);line-height:19px}:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--person-card-active-org-member-color:#023b8f}.mgt-dark{--person-card-active-org-member-color:#ffffff}:host{position:relative;user-select:none}:host .root{padding:20px 0}:host .root.compact{padding:0}:host .root.compact .coworker .coworker__image{height:40px;width:40px;border-radius:40px;--avatar-size:40px;--avatar-size-s:40px;margin-right:12px}:host .root.compact .coworker .coworker__name{font-size:14px}:host .root.compact .coworker .coworker__title{font-size:12px}:host .root .title{font-size:14px;font-weight:600;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));margin:0 20px 20px 20px;line-height:19px}:host .root .subtitle{color:var(--title-color-sub2,var(--neutral-foreground-hint,#717171));font-size:14px;margin:0 20px 8px 20px}:host .root .divider{display:flex;background:var(--line-seperator-color,#d6d6d6);height:1px;margin-top:26px;margin-bottom:18px;margin-left:20px;margin-right:20px}:host .root .org-member{height:74px;box-sizing:border-box;border-radius:2px;padding:12px;display:flex;align-items:center;margin-left:20px;margin-right:20px}:host .root .org-member.org-member--target{background-color:var(--background-color--active,#e1dfdd);border:1px solid var(--person-card-active-org-member-color,#023b8f)}:host .root .org-member:not(.org-member--target){border:1px solid var(--line-seperator-color,#d6d6d6)}:host .root .org-member:not(.org-member--target):hover{cursor:pointer;background-color:var(--background-color--hover,var(--neutral-fill-hover,#f7f7f7))}:host .root .org-member .org-member__person{flex-grow:1}:host .root .org-member .org-member__details{flex-grow:1}:host .root .org-member .org-member__details .org-member__name{font-size:16px;color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a));font-weight:600}:host .root .org-member .org-member__details .org-member__department,:host .root .org-member .org-member__details .org-member__title{font-weight:14px;color:var(--color-sub2,var(--neutral-foreground-hint,#717171))}:host .root .org-member__separator:not(:last-child){border:1px solid var(--line-seperator-color,#d6d6d6);box-sizing:border-box;width:0;margin:0 50%;height:14px}:host .root .coworker{display:flex;align-items:center;padding:10px 20px}:host .root .coworker:hover{cursor:pointer;background-color:var(--background-color--hover,var(--neutral-fill-hover,#f7f7f7))}:host .root .coworker .coworker__person{height:46px;border-radius:46px;margin-right:8px}:host .root .direct-report__compact{padding:12px 20px}:host .root .direct-report__compact .direct-report{cursor:pointer;width:38px;margin-right:4px;display:inline;--avatar-size:38px}[dir=rtl] .org-member .org-member__more{-moz-transform:scaleX(-1);-o-transform:scaleX(-1);-webkit-transform:scaleX(-1);transform:scaleX(-1);filter:FlipH;-ms-filter:FlipH}@media (forced-colors:active) and (prefers-color-scheme:dark){:host svg,:host svg>path{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}@media (forced-colors:active) and (prefers-color-scheme:light){:host svg,:host svg>path{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-organization/strings.js
var strings10 = {
  reportsToSectionTitle: "Reports to",
  directReportsSectionTitle: "Direct reports",
  organizationSectionTitle: "Organization",
  youWorkWithSubSectionTitle: "You work with",
  userWorksWithSubSectionTitle: "works with"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-organization/mgt-organization.js
init_es6();
var __decorate18 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata15 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtOrganization = class MgtOrganization2 extends BasePersonCardSection {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles15;
  }
  /**
   * returns component strings
   *
   * @readonly
   * @protected
   * @memberof MgtBaseComponent
   */
  get strings() {
    return strings10;
  }
  constructor(state2, me) {
    super();
    this._state = state2;
    this._me = me;
  }
  /**
   * Reset any state in the section
   *
   * @protected
   * @memberof MgtPersonCardMessages
   */
  clearState() {
    super.clearState();
    this._state = null;
    this._me = null;
  }
  /**
   * The name for display in the overview section.
   *
   * @readonly
   * @type {string}
   * @memberof MgtOrganization
   */
  get displayName() {
    const { person, directReports } = this._state;
    if (!person.manager && directReports && directReports.length) {
      return `${this.strings.directReportsSectionTitle} (${directReports.length})`;
    }
    return this.strings.reportsToSectionTitle;
  }
  /**
   * Render the icon for display in the navigation ribbon.
   *
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderIcon() {
    return getSvg(SvgIcon.Organization);
  }
  /**
   * Render the compact view
   *
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderCompactView() {
    let contentTemplate;
    if (!this._state || !this._state.person) {
      return null;
    }
    const { person, directReports } = this._state;
    if (!person) {
      return null;
    } else if (person.manager) {
      contentTemplate = this.renderCoworker(person.manager);
    } else if (directReports && directReports.length) {
      contentTemplate = this.renderCompactDirectReports();
    }
    return html`
        <div class="root compact">
          ${contentTemplate}
        </div>
      `;
  }
  /**
   * Render the full view
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderFullView() {
    let contentTemplate;
    if (!this._state || !this._state.person) {
      return null;
    }
    const { person, directReports, people } = this._state;
    if (!person && !directReports && !people) {
      return null;
    } else {
      const managerTemplates = this.renderManagers();
      const currentUserTemplate = this.renderCurrentUser();
      const directReportsTemplate = this.renderDirectReports();
      const coworkersTemplate = this.renderCoworkers();
      contentTemplate = html`
          ${managerTemplates} ${currentUserTemplate} ${directReportsTemplate} ${coworkersTemplate}
        `;
    }
    return html`
       <div class="root" dir=${this.direction}>
         <div class="title" tabindex="0">${this.strings.organizationSectionTitle}</div>
         ${contentTemplate}
       </div>
     `;
  }
  /**
   * Render a manager org member
   *
   * @protected
   * @param {User} person
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderManager(person) {
    return mgtHtml`
       <div class="org-member" @keydown=${(e) => {
      e.code === "Enter" ? this.navigateCard(person) : "";
    }} @click=${() => this.navigateCard(person)}>
         <div class="org-member__person">
           <mgt-person
             .personDetails=${person}
             .fetchImage=${true}
             .view=${ViewType.twolines}
             .showPresence=${true}
           ></mgt-person>
         </div>
         <div tabindex="0" class="org-member__more">
           ${getSvg(SvgIcon.ExpandRight)}
         </div>
       </div>
       <div class="org-member__separator"></div>
     `;
  }
  /**
   * Render a manager org member
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderManagers() {
    const { person } = this._state;
    if (!person || !person.manager) {
      return null;
    }
    const managers = [];
    let currentManager = person;
    while (currentManager.manager) {
      managers.push(currentManager.manager);
      currentManager = currentManager.manager;
    }
    if (!managers.length) {
      return null;
    }
    return managers.reverse().map((manager) => this.renderManager(manager));
  }
  /**
   * Render a direct report
   *
   * @protected
   * @param {User} person
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderDirectReports() {
    const { directReports } = this._state;
    if (!directReports || !directReports.length) {
      return null;
    }
    return html`
       <div class="org-member__separator"></div>
       <div>
         ${directReports.map((person) => mgtHtml`
             <div class="org-member org-member--direct-report" @keydown=${(e) => {
      e.code === "Enter" ? this.navigateCard(person) : "";
    }} @click=${() => this.navigateCard(person)}>
               <div class="org-member__person">
                 <mgt-person
                   .personDetails=${person}
                   .fetchImage=${true}
                   .showPresence=${true}
                   .view=${ViewType.twolines}
                 ></mgt-person>
               </div>
               <div tabindex="0" class="org-member__more">
                 ${getSvg(SvgIcon.ExpandRight)}
               </div>
             </div>
             <div class="org-member__separator"></div>
           `)}
       </div>
     `;
  }
  /**
   * Render direct reports in compact view
   *
   * @protected
   * @param {User} person
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderCompactDirectReports() {
    const { directReports } = this._state;
    return html`
       <div class="direct-report__compact">
         ${directReports.slice(0, 6).map((person) => mgtHtml`
             <div
               class="direct-report"
               @keydown=${(e) => {
      e.code === "Enter" ? this.navigateCard(person) : "";
    }}
               @click=${() => this.navigateCard(person)}
             >
               <mgt-person
                 .personDetails=${person}
                 .fetchImage=${true}
                 .showPresence=${true}
                 .view=${ViewType.twolines}
               ></mgt-person>
             </div>
           `)}
       </div>
     `;
  }
  /**
   * Render the user/self member
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderCurrentUser() {
    const { person } = this._state;
    return mgtHtml`
       <div class="org-member org-member--target">
         <div class="org-member__person">
           <mgt-person
             .personDetails=${person}
             .fetchImage=${true}
             .showPresence=${true}
             .view=${ViewType.twolines}
           ></mgt-person>
         </div>
       </div>
     `;
  }
  /**
   * Render a coworker org member
   *
   * @protected
   * @param {User} person
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderCoworker(person) {
    return mgtHtml`
       <div class="coworker" @keydown=${(e) => {
      e.code === "Enter" ? this.navigateCard(person) : "";
    }} @click=${() => this.navigateCard(person)}>
         <div class="coworker__person">
           <mgt-person
             .personDetails=${person}
             .fetchImage=${true}
             .showPresence=${true}
             .view=${ViewType.twolines}
           ></mgt-person>
         </div>
       </div>
     `;
  }
  /**
   * Render a coworker org member
   *
   * @protected
   * @param {User} person
   * @returns {TemplateResult}
   * @memberof MgtOrganization
   */
  renderCoworkers() {
    const { people } = this._state;
    if (!people || !people.length) {
      return null;
    }
    const subtitle = this._me.id === this._state.person.id ? this.strings.youWorkWithSubSectionTitle : `${this._state.person.givenName} ${this.strings.userWorksWithSubSectionTitle}`;
    return html`
       <div class="divider"></div>
       <div class="subtitle" tabindex="0">${subtitle}</div>
       <div>
         ${people.slice(0, 6).map((person) => this.renderCoworker(person))}
       </div>
     `;
  }
};
MgtOrganization = __decorate18([
  customElement("organization"),
  __metadata15("design:paramtypes", [Object, Object])
], MgtOrganization);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-profile/mgt-profile.js
init_lit();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-profile/mgt-profile-css.js
init_lit();
var styles16 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}:host .loading,:host .no-data{margin:0 20px;display:flex;justify-content:center}:host .no-data{font-family:var(--default-font-family, "Segoe UI");font-style:normal;font-weight:600;font-size:14px;color:var(--font-color,#323130);line-height:19px}:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--token-overflow-color:#023b8f}.mgt-dark{--token-overflow-color:#f3f2f1}:host{position:relative;user-select:none}:host .root{padding:20px 0}:host .root.compact{padding:0}:host .root .title{font-size:14px;font-weight:600;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));margin:0 20px 12px 20px}:host .root section{margin-bottom:24px;padding:0 20px}:host .root section:last-child{margin:0}:host .root section .section__title{font-size:14px;color:var(--title-color-sub2,var(--neutral-foreground-hint,#717171))}:host .root section .section__content{display:flex;flex-direction:column;margin-top:10px}:host .root .token-list{display:flex;flex-direction:row;flex-wrap:wrap;margin-top:-10px}:host .root .token-list .token-list__item{text-overflow:ellipsis;white-space:nowrap;display:inline-block;overflow:hidden;font-size:14px;align-items:center;background:var(--background-color-sub2,#f3f2f1);border-radius:2px;max-height:28px;padding:4px 8px;margin-right:10px;margin-top:10px;color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a))}:host .root .token-list .token-list__item:last-child{margin-right:initial}:host .root .token-list .token-list__item.overflow{display:none}:host .root .token-list .token-list__item:hover{color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a))}:host .root .token-list .token-list__item.token-list__item--show-overflow{cursor:pointer;user-select:unset;background:0 0;color:var(--token-overflow-color,#023b8f)}:host .root .data-list__item{margin-bottom:20px}:host .root .data-list__item:last-child{margin-bottom:initial}:host .root .data-list__item .data-list__item__header{display:flex;justify-content:space-between;align-items:center}:host .root .data-list__item .data-list__item__content{font-size:12px;line-height:16px;color:var(--color-sub2,var(--neutral-foreground-hint,#717171));margin-top:4px}:host .root .data-list__item .data-list__item__title{font-size:14px;line-height:16px;color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a))}:host .root .data-list__item .data-list__item__date-range{color:var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a));font-size:10px;line-height:12px}:host .root .language__proficiency{opacity:.77}:host .root .work-position .work-position__company{color:#023b8f}:host .root .work-position .work-position__location{font-size:10px;color:var(--color-sub2,var(--neutral-foreground-hint,#717171));line-height:16px}:host .root .educational-activity .educational-activity__degree{font-size:12px;line-height:14px;color:var(--color-sub3,#727170)}:host .root .birthday{display:flex;align-items:center;margin-top:-6px}:host .root .birthday .birthday__icon{margin-right:8px}:host .root .birthday .birthday__date{font-size:12px;color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a))}[dir=rtl] .token-list__item{margin-right:0!important}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-profile/strings.js
var strings11 = {
  SkillsAndExperienceSectionTitle: "Skills & Experience",
  AboutCompactSectionTitle: "About",
  SkillsSubSectionTitle: "Skills",
  LanguagesSubSectionTitle: "Languages",
  WorkExperienceSubSectionTitle: "Work Experience",
  EducationSubSectionTitle: "Education",
  professionalInterestsSubSectionTitle: "Professional Interests",
  personalInterestsSubSectionTitle: "Personal Interests",
  birthdaySubSectionTitle: "Birthday",
  currentYearSubtitle: "Current",
  socialMediaSubSectionTitle: "Social Media"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-profile/mgt-profile.js
init_es6();
var __decorate19 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata16 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtProfile = class MgtProfile2 extends BasePersonCardSection {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles16;
  }
  get strings() {
    return strings11;
  }
  /**
   * The name for display in the overview section.
   *
   * @readonly
   * @type {string}
   * @memberof MgtProfile
   */
  get displayName() {
    return this.strings.SkillsAndExperienceSectionTitle;
  }
  /**
   * Returns true if the profile contains data
   * that can be rendered
   *
   * @readonly
   * @type {boolean}
   * @memberof MgtProfile
   */
  get hasData() {
    if (!this.profile) {
      return false;
    }
    const { languages, skills, positions, educationalActivities } = this.profile;
    return [
      this._birthdayAnniversary,
      this._personalInterests && this._personalInterests.length,
      this._professionalInterests && this._professionalInterests.length,
      languages && languages.length,
      skills && skills.length,
      positions && positions.length,
      educationalActivities && educationalActivities.length
    ].filter((v) => !!v).length > 0;
  }
  /**
   * The user's profile metadata
   *
   * @protected
   * @type {IProfile}
   * @memberof MgtProfile
   */
  get profile() {
    return this._profile;
  }
  set profile(value) {
    if (value === this._profile) {
      return;
    }
    this._profile = value;
    this._birthdayAnniversary = value && value.anniversaries ? value.anniversaries.find(this.isBirthdayAnniversary) : null;
    this._personalInterests = value && value.interests ? value.interests.filter(this.isPersonalInterest) : null;
    this._professionalInterests = value && value.interests ? value.interests.filter(this.isProfessionalInterest) : null;
  }
  constructor(profile) {
    super();
    this.profile = profile;
  }
  /**
   * Render the icon for display in the navigation ribbon.
   *
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderIcon() {
    return getSvg(SvgIcon.Profile);
  }
  /**
   * Reset any state in the section
   *
   * @protected
   * @memberof MgtProfile
   */
  clearState() {
    super.clearState();
    this.profile = null;
  }
  /**
   * Render the compact view
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderCompactView() {
    return html`
       <div class="root compact" dir=${this.direction}>
         ${this.renderSubSections().slice(0, 2)}
       </div>
     `;
  }
  /**
   * Render the full view
   *
   * @protected
   * @returns
   * @memberof MgtProfile
   */
  renderFullView() {
    this.initPostRenderOperations();
    return html`
       <div class="root" dir=${this.direction}>
         <div class="title">${this.strings.AboutCompactSectionTitle}</div>
         ${this.renderSubSections()}
       </div>
     `;
  }
  /**
   * Renders all subSections of the profile
   * Defines order of how they render
   *
   * @protected
   * @return {*}
   * @memberof MgtProfile
   */
  renderSubSections() {
    const subSections = [
      this.renderSkills(),
      this.renderBirthday(),
      this.renderLanguages(),
      this.renderWorkExperience(),
      this.renderEducation(),
      this.renderProfessionalInterests(),
      this.renderPersonalInterests()
    ];
    return subSections.filter((s) => !!s);
  }
  /**
   * Render the user's known languages
   *
   * @protected
   * @returns
   * @memberof MgtProfile
   */
  renderLanguages() {
    const { languages } = this._profile;
    if (!(languages && languages.length)) {
      return null;
    }
    const languageItems = [];
    for (const language of languages) {
      let proficiency = null;
      if (language.proficiency && language.proficiency.length) {
        proficiency = html`
           <span class="language__proficiency" tabindex="0">
             &nbsp;(${language.proficiency})
           </span>
         `;
      }
      languageItems.push(html`
         <div class="token-list__item language">
           <span class="language__title" tabindex="0">${language.displayName}</span>
           ${proficiency}
         </div>
       `);
    }
    const languageTitle = languageItems.length ? this.strings.LanguagesSubSectionTitle : "";
    return html`
       <section>
         <div class="section__title" tabindex="0">${languageTitle}</div>
         <div class="section__content">
           <div class="token-list">
             ${languageItems}
           </div>
         </div>
       </section>
     `;
  }
  /**
   * Render the user's skills
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderSkills() {
    const { skills } = this._profile;
    if (!(skills && skills.length)) {
      return null;
    }
    const skillItems = [];
    for (const skill of skills) {
      skillItems.push(html`
         <div class="token-list__item skill" tabindex="0">
           ${skill.displayName}
         </div>
       `);
    }
    const skillsTitle = skillItems.length ? this.strings.SkillsSubSectionTitle : "";
    return html`
       <section>
         <div class="section__title" tabindex="0">${skillsTitle}</div>
         <div class="section__content">
           <div class="token-list">
             ${skillItems}
           </div>
         </div>
       </section>
     `;
  }
  /**
   * Render the user's work experience timeline
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderWorkExperience() {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _j;
    const { positions } = this._profile;
    if (!(positions && positions.length)) {
      return null;
    }
    const positionItems = [];
    for (const position of this._profile.positions) {
      if (position.detail.description || position.detail.jobTitle !== "") {
        positionItems.push(html`
           <div class="data-list__item work-position">
             <div class="data-list__item__header">
               <div class="data-list__item__title" tabindex="0">${(_a2 = position.detail) === null || _a2 === void 0 ? void 0 : _a2.jobTitle}</div>
               <div class="data-list__item__date-range" tabindex="0">
                 ${this.getDisplayDateRange(position.detail)}
               </div>
             </div>
             <div class="data-list__item__content">
               <div class="work-position__company" tabindex="0">
                 ${(_c = (_b2 = position === null || position === void 0 ? void 0 : position.detail) === null || _b2 === void 0 ? void 0 : _b2.company) === null || _c === void 0 ? void 0 : _c.displayName}
               </div>
               <div class="work-position__location" tabindex="0">
                 ${(_f = (_e = (_d = position === null || position === void 0 ? void 0 : position.detail) === null || _d === void 0 ? void 0 : _d.company) === null || _e === void 0 ? void 0 : _e.address) === null || _f === void 0 ? void 0 : _f.city}, ${(_j = (_h = (_g = position === null || position === void 0 ? void 0 : position.detail) === null || _g === void 0 ? void 0 : _g.company) === null || _h === void 0 ? void 0 : _h.address) === null || _j === void 0 ? void 0 : _j.state}
               </div>
             </div>
           </div>
         `);
      }
    }
    const workExperienceTitle = positionItems.length ? this.strings.WorkExperienceSubSectionTitle : "";
    return html`
       <section>
         <div class="section__title" tabindex="0">${workExperienceTitle}</div>
         <div class="section__content">
           <div class="data-list">
             ${positionItems}
           </div>
         </div>
       </section>
     `;
  }
  /**
   * Render the user's education timeline
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderEducation() {
    const { educationalActivities } = this._profile;
    if (!(educationalActivities && educationalActivities.length)) {
      return null;
    }
    const positionItems = [];
    for (const educationalActivity of educationalActivities) {
      positionItems.push(html`
         <div class="data-list__item educational-activity">
           <div class="data-list__item__header">
             <div class="data-list__item__title" tabindex="0">${educationalActivity.institution.displayName}</div>
             <div class="data-list__item__date-range" tabindex="0">
               ${this.getDisplayDateRange(educationalActivity)}
             </div>
           </div>
           <div class="data-list__item__content">
             <div class="educational-activity__degree" tabindex="0">
               ${educationalActivity.program.displayName || "Bachelors Degree"}
             </div>
           </div>
         </div>
       `);
    }
    const educationTitle = positionItems.length ? this.strings.EducationSubSectionTitle : "";
    return html`
       <section>
         <div class="section__title" tabindex="0">${educationTitle}</div>
         <div class="section__content">
           <div class="data-list">
             ${positionItems}
           </div>
         </div>
       </section>
     `;
  }
  /**
   * Render the user's professional interests
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderProfessionalInterests() {
    if (!this._professionalInterests || !this._professionalInterests.length) {
      return null;
    }
    const interestItems = [];
    for (const interest of this._professionalInterests) {
      interestItems.push(html`
         <div class="token-list__item interest interest--professional" tabindex="0">
           ${interest.displayName}
         </div>
       `);
    }
    const professionalInterests = interestItems.length ? this.strings.professionalInterestsSubSectionTitle : "";
    return html`
       <section>
         <div class="section__title" tabindex="0">${professionalInterests}</div>
         <div class="section__content">
           <div class="token-list">
             ${interestItems}
           </div>
         </div>
       </section>
     `;
  }
  /**
   * Render the user's personal interests
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderPersonalInterests() {
    if (!this._personalInterests || !this._personalInterests.length) {
      return null;
    }
    const interestItems = [];
    for (const interest of this._personalInterests) {
      interestItems.push(html`
         <div class="token-list__item interest interest--personal" tabindex="0">
           ${interest.displayName}
         </div>
       `);
    }
    const personalInterests = interestItems.length ? this.strings.personalInterestsSubSectionTitle : "";
    return html`
       <section>
         <div class="section__title" tabindex="0">${personalInterests}</div>
         <div class="section__content">
           <div class="token-list">
             ${interestItems}
           </div>
         </div>
       </section>
     `;
  }
  /**
   * Render the user's birthday
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtProfile
   */
  renderBirthday() {
    if (!this._birthdayAnniversary || !this._birthdayAnniversary.date) {
      return null;
    }
    return html`
       <section>
         <div class="section__title" tabindex="0">Birthday</div>
         <div class="section__content">
           <div class="birthday">
             <div class="birthday__icon">
               ${getSvg(SvgIcon.Birthday)}
             </div>
             <div class="birthday__date" tabindex="0">
               ${this.getDisplayDate(new Date(this._birthdayAnniversary.date))}
             </div>
           </div>
         </div>
       </section>
     `;
  }
  isPersonalInterest(interest) {
    return interest.categories && interest.categories.includes("personal");
  }
  isProfessionalInterest(interest) {
    return interest.categories && interest.categories.includes("professional");
  }
  isBirthdayAnniversary(anniversary) {
    return anniversary.type === "birthday";
  }
  getDisplayDate(date) {
    return date.toLocaleString("default", {
      day: "numeric",
      month: "long"
    });
  }
  // tslint:disable-next-line: completed-docs
  getDisplayDateRange(event) {
    const start = new Date(event.startMonthYear).getFullYear();
    if (start === 0) {
      return null;
    }
    const end = event.endMonthYear ? new Date(event.endMonthYear).getFullYear() : this.strings.currentYearSubtitle;
    return `${start}  ${end}`;
  }
  initPostRenderOperations() {
    setTimeout(() => {
      try {
        const sections = this.shadowRoot.querySelectorAll("section");
        sections.forEach((section) => {
          this.handleTokenOverflow(section);
        });
      } catch (_a2) {
      }
    }, 0);
  }
  handleTokenOverflow(section) {
    const tokenLists = section.querySelectorAll(".token-list");
    if (!tokenLists || !tokenLists.length) {
      return;
    }
    for (const tokenList of Array.from(tokenLists)) {
      const items = tokenList.querySelectorAll(".token-list__item");
      if (!items || !items.length) {
        continue;
      }
      let overflowItems = null;
      let itemRect = items[0].getBoundingClientRect();
      const tokenListRect = tokenList.getBoundingClientRect();
      const maxtop = itemRect.height * 2 + tokenListRect.top;
      for (let i = 0; i < items.length - 1; i++) {
        itemRect = items[i].getBoundingClientRect();
        if (itemRect.top > maxtop) {
          overflowItems = Array.from(items).slice(i, items.length);
          break;
        }
      }
      if (overflowItems) {
        overflowItems.forEach((i) => i.classList.add("overflow"));
        const overflowToken = document.createElement("div");
        overflowToken.classList.add("token-list__item");
        overflowToken.classList.add("token-list__item--show-overflow");
        overflowToken.tabIndex = 0;
        overflowToken.innerText = `+ ${overflowItems.length} more`;
        const revealOverflow = () => {
          overflowToken.remove();
          overflowItems.forEach((i) => i.classList.remove("overflow"));
        };
        overflowToken.addEventListener("click", (e) => {
          revealOverflow();
        });
        overflowToken.addEventListener("keydown", (e) => {
          if (e.code === "Enter") {
            revealOverflow();
          }
        });
        tokenList.appendChild(overflowToken);
      }
    }
  }
};
MgtProfile = __decorate19([
  customElement("profile"),
  __metadata16("design:paramtypes", [Object])
], MgtProfile);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person-card/strings.js
var strings12 = {
  showMoreSectionButton: "Show more",
  endOfCard: "End of the card",
  quickMessage: "Send a quick message"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-person-card/mgt-person-card.js
init_esm3();
init_FluentComponents();
var __decorate20 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata17 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtPersonCard_1;
registerFluentComponents(fluentTabs, fluentTab, fluentTabPanel, fluentButton, fluentTextField);
var MgtPersonCard = MgtPersonCard_1 = class MgtPersonCard2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles12;
  }
  get strings() {
    return strings12;
  }
  /**
   * Get the scopes required for the person card
   * The scopes depend on what sections are shown
   *
   * Use the `MgtPersonCard.config` object to configure
   * what sections are shown
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtPersonCard
   */
  static get requiredScopes() {
    return MgtPersonCard_1.getScopes();
  }
  static getScopes() {
    const scopes = [];
    if (this.config.sections.files) {
      scopes.push("Sites.Read.All");
    }
    if (this.config.sections.mailMessages) {
      scopes.push("Mail.Read");
      scopes.push("Mail.ReadBasic");
    }
    if (this.config.sections.organization) {
      scopes.push("User.Read.All");
      if (typeof this.config.sections.organization !== "boolean" && this.config.sections.organization.showWorksWith) {
        scopes.push("People.Read.All");
      }
    }
    if (this.config.sections.profile) {
      scopes.push("User.Read.All");
    }
    if (this.config.useContactApis) {
      scopes.push("Contacts.Read");
    }
    if (scopes.indexOf("User.Read.All") < 0) {
      scopes.push("User.ReadBasic.All");
      scopes.push("User.Read");
    }
    if (scopes.indexOf("People.Read.All") < 0) {
      scopes.push("People.Read");
    }
    scopes.push("Chat.Create", "Chat.ReadWrite");
    return [...new Set(scopes)];
  }
  /**
   * Global configuration object for
   * all person card components
   *
   * @static
   * @type {MgtPersonCardConfig}
   * @memberof MgtPersonCard
   */
  static get config() {
    return this._config;
  }
  /**
   * Set the person details to render
   *
   * @type {IDynamicPerson}
   * @memberof MgtPersonCard
   */
  get personDetails() {
    return this._personDetails;
  }
  set personDetails(value) {
    if (this._personDetails === value) {
      return;
    }
    this._personDetails = value;
    this.personImage = this.getImage();
    this.requestStateUpdate();
  }
  /**
   * user-id property allows developer to use id value for component
   * @type {string}
   */
  get userId() {
    return this._userId;
  }
  set userId(value) {
    if (value === this._userId) {
      return;
    }
    this._userId = value;
    this.personDetails = null;
    this._cardState = null;
    this.requestStateUpdate();
  }
  get internalPersonDetails() {
    return this._cardState && this._cardState.person || this.personDetails;
  }
  constructor() {
    super();
    this.isSending = false;
    this.hoverStates = {
      // triggers a re-render when hovering on the CTA icons
      email: false,
      chat: false,
      video: false,
      call: false
    };
    this.setHoveredState = (icon, hoverState) => {
      this.hoverStates[icon] = hoverState;
      this.hoverStates = Object.assign({}, this.hoverStates);
    };
    this.isHovered = (icon) => {
      return this.hoverStates[icon];
    };
    this._chatInput = "";
    this._currentSection = null;
    this._history = [];
    this.sections = [];
    this._graph = null;
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * @param {*} name
   * @param {*} oldValue
   * @param {*} newValue
   * @memberof MgtPersonCard
   */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) {
      return;
    }
    switch (name) {
      case "person-query":
        this.personDetails = null;
        this._cardState = null;
        this.requestStateUpdate();
        break;
    }
  }
  /**
   * Navigate the card to a different person.
   *
   * @protected
   * @memberof MgtPersonCard
   */
  navigate(person) {
    this._history.push({
      personDetails: this.personDetails,
      personImage: this.getImage(),
      state: this._cardState
    });
    this._personDetails = person;
    this._cardState = null;
    this.personImage = null;
    this._currentSection = null;
    this.sections = [];
    this._chatInput = "";
    this.requestStateUpdate();
  }
  /**
   * Navigate the card back to the previous person
   *
   * @returns {void}
   * @memberof MgtPersonCard
   */
  goBack() {
    if (!this._history || !this._history.length) {
      return;
    }
    const historyState = this._history.pop();
    this._currentSection = null;
    const firstTab = this.renderRoot.querySelector("fluent-tab");
    if (firstTab) {
      firstTab.click();
    }
    this._cardState = historyState.state;
    this._personDetails = historyState.state.person;
    this.personImage = historyState.personImage;
    this.loadSections();
  }
  /**
   * Navigate the card back to first person and clear history
   *
   * @returns {void}
   * @memberof MgtPersonCard
   */
  clearHistory() {
    this._currentSection = null;
    if (!this._history || !this._history.length) {
      return;
    }
    const historyState = this._history[0];
    this._history = [];
    this._cardState = historyState.state;
    this._personDetails = historyState.state;
    this.personImage = historyState.personImage;
    this.loadSections();
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    if (!this.internalPersonDetails) {
      return this.renderNoData();
    }
    const person = this.internalPersonDetails;
    const image = this.getImage();
    if (this.hasTemplate("default")) {
      return this.renderTemplate("default", {
        person: this.internalPersonDetails,
        personImage: image
      });
    }
    const closeCardTemplate = this.isExpanded ? html`
           <div class="close-card-container">
             <fluent-button appearance="lightweight" class="close-button" @click=${() => this.closeCard()} >
               ${getSvg(SvgIcon.Close)}
             </fluent-button>
           </div>
         ` : null;
    const navigationTemplate = this._history && this._history.length ? html`
            <div class="nav">
              <div class="nav__back" tabindex="0" @keydown=${(e) => {
      e.code === "Enter" ? this.goBack() : "";
    }} @click=${() => this.goBack()}>${getSvg(SvgIcon.Back)}</div>
            </div>
          ` : null;
    let personDetailsTemplate = this.renderTemplate("person-details", {
      person: this.internalPersonDetails,
      personImage: image
    });
    if (!personDetailsTemplate) {
      const personTemplate = this.renderPerson();
      const contactIconsTemplate = this.renderContactIcons(person);
      personDetailsTemplate = html`
         ${personTemplate} ${contactIconsTemplate}
       `;
    }
    const expandedDetailsTemplate = this.isExpanded ? this.renderExpandedDetails() : this.renderExpandedDetailsButton();
    this._windowHeight = window.innerHeight && document.documentElement.clientHeight ? Math.min(window.innerHeight, document.documentElement.clientHeight) : window.innerHeight || document.documentElement.clientHeight;
    if (this._windowHeight < 250) {
      this._smallView = true;
    }
    const tabLocker = this.lockTabNavigation ? html`<div @keydown=${this.handleEndOfCard} aria-label=${this.strings.endOfCard} tabindex="0" id="end-of-container"></div>` : html``;
    return html`
      <div class="root" dir=${this.direction}>
        <div class=${this._smallView ? "small" : ""}>
          ${navigationTemplate}
          ${closeCardTemplate}
          <div class="person-details-container">${personDetailsTemplate}</div>
          <div class="expanded-details-container">${expandedDetailsTemplate}</div>
          ${tabLocker}
        </div>
      </div>
     `;
  }
  handleEndOfCard(e) {
    if (e && e.code === "Tab") {
      const endOfCardEl = this.renderRoot.querySelector("#end-of-container");
      if (endOfCardEl) {
        endOfCardEl.blur();
        const imageCardEl = this.renderRoot.querySelector("mgt-person");
        if (imageCardEl) {
          imageCardEl.focus();
        }
      }
    }
  }
  /**
   * Render the state when no data is available.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  closeCard() {
    this.updateCurrentSection(null);
    this.isExpanded = false;
  }
  /**
   * Render the state when no data is available.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderNoData() {
    return this.renderTemplate("no-data", null) || html``;
  }
  /**
   * Render a display image for the person.
   *
   * @protected
   * @param {*} image
   * @memberof MgtPersonCard
   */
  renderPerson() {
    const avatarSize = "large";
    return mgtHtml`
      <mgt-person
        tabindex="0"
        class="person-image"
        .personDetails=${this.internalPersonDetails}
        .personImage=${this.getImage()}
        .personPresence=${this.personPresence}
        .showPresence=${this.showPresence}
        .avatarSize=${avatarSize}
        .view=${ViewType.threelines}
      ></mgt-person>
    `;
  }
  /**
   * Render person subtitle.
   *
   * @protected
   * @param {IDynamicPerson} person
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderPersonSubtitle(person) {
    person = person || this.internalPersonDetails;
    if (!person.department) {
      return;
    }
    return html`
       <div class="department">${person.department}</div>
     `;
  }
  /**
   * Render the various icons for contacting the person.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderContactIcons(person) {
    person = person || this.internalPersonDetails;
    const userPerson = person;
    let email;
    if (getEmailFromGraphEntity(person)) {
      email = html`
         <div class="icon"
           @click=${() => this.emailUser()}
           @mouseenter=${() => this.setHoveredState("email", true)}
           @mouseleave=${() => this.setHoveredState("email", false)}
           tabindex=0
           role="button">
           ${this.isHovered("email") ? getSvg(SvgIcon.SmallEmailHovered) : getSvg(SvgIcon.SmallEmail)}
         </div>
       `;
    }
    let chat;
    if (userPerson === null || userPerson === void 0 ? void 0 : userPerson.userPrincipalName) {
      chat = html`
         <div class="icon"
           @click=${() => this.chatUser()}
           @mouseenter=${() => this.setHoveredState("chat", true)}
           @mouseleave=${() => this.setHoveredState("chat", false)}
           tabindex=0
           role="button">
           ${this.isHovered("chat") ? getSvg(SvgIcon.SmallChatHovered) : getSvg(SvgIcon.SmallChat)}
         </div>
       `;
    }
    let video;
    video = html`
        <div class="icon"
           @click=${() => this.videoCallUser()}
           @mouseenter=${() => this.setHoveredState("video", true)}
           @mouseleave=${() => this.setHoveredState("video", false)}
           tabindex=0
           role="button">
           ${this.isHovered("video") ? getSvg(SvgIcon.VideoHovered) : getSvg(SvgIcon.Video)}
         </div>
      `;
    let call;
    if (userPerson.userPrincipalName) {
      call = html`
         <div class="icon"
           @click=${() => this.callUser()}
           @mouseenter=${() => this.setHoveredState("call", true)}
           @mouseleave=${() => this.setHoveredState("call", false)}
           tabindex=0
           role="button">
           ${this.isHovered("call") ? getSvg(SvgIcon.CallHovered) : getSvg(SvgIcon.Call)}
         </div>
       `;
    }
    return html`
       <div class="base-icons">
         ${email} ${chat} ${video} ${call}
       </div>
     `;
  }
  /**
   * Render the button used to expand the expanded details.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderExpandedDetailsButton() {
    return html`
      <div
        class="expanded-details-button"
        @click=${this.showExpandedDetails}
        @keydown=${this.handleKeyDown}
        tabindex=0
      >
        ${getSvg(SvgIcon.ExpandDown)}
      </div>
     `;
  }
  /**
   * Render expanded details.
   *
   * @protected
   * @param {IDynamicPerson} [person]
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderExpandedDetails(person) {
    if (!this._cardState && this._isStateLoading) {
      return mgtHtml`
         <div class="loading">
           <mgt-spinner></mgt-spinner>
         </div>
       `;
    }
    const provider = Providers.globalProvider;
    if (provider.state === ProviderState.SignedOut) {
      this.loadSections();
    }
    person = person || this.internalPersonDetails;
    const sectionNavTemplate = this.renderSectionNavigation();
    return html`
      <div class="section-nav">
        ${sectionNavTemplate}
      </div>
      <div
        class="section-host ${this._smallView ? "small" : ""} ${this._smallView ? "small" : ""}"
        @wheel=${(e) => this.handleSectionScroll(e)}
        tabindex=0
      ></div>
    `;
  }
  /**
   * Render the navigation ribbon for subsections
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderSectionNavigation() {
    if (!this.sections || this.sections.length < 2 && !this.hasTemplate("additional-details")) {
      return;
    }
    const currentSectionIndex = this._currentSection ? this.sections.indexOf(this._currentSection) : -1;
    const additionalSectionTemplates = this.sections.map((section, i) => {
      const name = section.tagName.toLowerCase();
      const classes = classMap({
        active: i === currentSectionIndex,
        "section-nav__icon": true
      });
      return html`
        <fluent-tab
          id="${name}-Tab"
          class=${classes}
          slot="tab"
          @keyup="${() => this.updateCurrentSection(section)}"
          @click=${() => this.updateCurrentSection(section)}
        >
          ${section.renderIcon()}
        </fluent-tab>
      `;
    });
    const additionalPanelTemplates = this.sections.map((section, i) => {
      return html`
        <fluent-tab-panel slot="tabpanel">
          <div class="inserted">${this._currentSection ? section.asFullView() : null}</div>
        </fluent-tab-panel>
      `;
    });
    const overviewClasses = classMap({
      active: currentSectionIndex === -1,
      "section-nav__icon": true,
      overviewTab: true
    });
    return html`
      <fluent-tabs
        orientation="horizontal"
        activeindicator
        @wheel=${(e) => this.handleSectionScroll(e)}
      >
        <fluent-tab
          class="${overviewClasses}"
          slot="tab"
          @keyup="${() => this.updateCurrentSection(null)}"
          @click=${() => this.updateCurrentSection(null)}
        >
          <div>${getSvg(SvgIcon.Overview)}</div>
        </fluent-tab>
        ${additionalSectionTemplates}
        <fluent-tab-panel slot="tabpanel" >
          <div class="overview-panel">${!this._currentSection ? this.renderOverviewSection() : null}</div>
        </fluent-tab-panel>
        ${additionalPanelTemplates}
      </fluent-tabs>
    `;
  }
  /**
   * Render the default section with compact views for each subsection.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderOverviewSection() {
    const compactTemplates = this.sections.map((section) => html`
        <div class="section">
          <div class="section__header">
            <div class="section__title" tabindex=0>${section.displayName}</div>
              <fluent-button
                appearance="lightweight"
                class="section__show-more"
                @click=${() => this.updateCurrentSection(section)}
              >
                ${this.strings.showMoreSectionButton}
              </fluent-button>
          </div>
          <div class="section__content">${section.asCompactView()}</div>
        </div>
      `);
    const additionalDetails = this.renderTemplate("additional-details", {
      person: this.internalPersonDetails,
      personImage: this.getImage(),
      state: this._cardState
    });
    if (additionalDetails) {
      compactTemplates.splice(1, 0, html`
           <div class="section">
             <div class="additional-details">${additionalDetails}</div>
           </div>
         `);
    }
    return html`
       <div class="sections">
          ${this.renderMessagingSection()}
          ${compactTemplates}
       </div>
     `;
  }
  /**
   * Render the actively selected section.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderCurrentSection() {
    if ((!this.sections || !this.sections.length) && !this.hasTemplate("additional-details")) {
      return;
    }
    if (this.sections.length === 1 && !this.hasTemplate("additional-details")) {
      return html`
         ${this.sections[0].asFullView()}
       `;
    }
    if (!this._currentSection) {
      return this.renderOverviewSection();
    }
    return html`
       ${this._currentSection.asFullView()}
     `;
  }
  /**
   * Render the messaging section.
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtPersonCard
   */
  renderMessagingSection() {
    const person = this.personDetails;
    const user = this._me.userPrincipalName;
    const chatInput = this._chatInput;
    if ((person === null || person === void 0 ? void 0 : person.userPrincipalName) === user) {
      return;
    } else {
      return html`
      <div class="message-section">
        <fluent-text-field appearance="outline" placeholder="${this.strings.quickMessage}"
          .value=${chatInput}
          @input=${(e) => {
        this._chatInput = e.target.value;
        this.requestUpdate();
      }}
          @keydown="${(e) => this.sendQuickMessageOnEnter(e)}">
        </fluent-text-field>
        <fluent-button class="send-message-icon" 
          @click=${() => this.sendQuickMessage()}
          ?disabled=${this.isSending}>
          ${!this.isSending ? getSvg(SvgIcon.Send) : getSvg(SvgIcon.Confirmation)}
        </fluent-button>
      </div>
      `;
    }
  }
  /**
   * load state into the component
   *
   * @protected
   * @returns
   * @memberof MgtPersonCard
   */
  loadState() {
    var _a2;
    return __awaiter20(this, void 0, void 0, function* () {
      if (this._cardState) {
        return;
      }
      if (!this.personDetails && this.inheritDetails) {
        let parent = this.parentElement;
        while (parent && parent.tagName !== "MGT-PERSON") {
          parent = parent.parentElement;
        }
        const parentPerson = parent.personDetails || parent["personDetailsInternal"];
        if (parent && parentPerson) {
          this.personDetails = parentPerson;
          this.personImage = parent.personImage;
        }
      }
      const provider = Providers.globalProvider;
      if (!provider || provider.state !== ProviderState.SignedIn) {
        return;
      }
      const graph = provider.graph.forComponent(this);
      this._graph = graph;
      this._isStateLoading = true;
      if (!this._me) {
        this._me = yield Providers.me();
      }
      if (this.personDetails) {
        const user = this.personDetails;
        const id = user.userPrincipalName || user.id;
        if (id && !getEmailFromGraphEntity(user)) {
          const person = yield getUserWithPhoto(graph, id);
          this.personDetails = person;
          this.personImage = this.getImage();
        }
      } else if (this.userId || this.personQuery === "me") {
        const person = yield getUserWithPhoto(graph, this.userId);
        this.personDetails = person;
        this.personImage = this.getImage();
      } else if (this.personQuery) {
        const people = yield findPeople(graph, this.personQuery, 1);
        if (people && people.length) {
          this.personDetails = people[0];
          getPersonImage(graph, this.personDetails, MgtPersonCard_1.config.useContactApis).then((image) => {
            if (image) {
              this.personDetails.personImage = image;
              this.personImage = image;
            }
          });
        }
      }
      const defaultPresence = {
        activity: "Offline",
        availability: "Offline",
        id: null
      };
      if (!this.personPresence && this.showPresence) {
        try {
          if (this.personDetails && this.personDetails.id) {
            getUserPresence(graph, this.personDetails.id).then((presence) => {
              this.personPresence = presence;
            });
          } else {
            this.personPresence = defaultPresence;
          }
        } catch (_) {
          this.personPresence = defaultPresence;
        }
      }
      if ((_a2 = this.personDetails) === null || _a2 === void 0 ? void 0 : _a2.id) {
        this._cardState = yield getPersonCardGraphData(graph, this.personDetails, this._me === this.personDetails.id, MgtPersonCard_1.config);
      }
      this.loadSections();
      this._isStateLoading = false;
    });
  }
  /**
   * Send a chat message to the user from the quick message input.
   *
   * @protected
   * @returns {void}
   * @memberof MgtPersonCard
   */
  sendQuickMessage() {
    return __awaiter20(this, void 0, void 0, function* () {
      const message = this._chatInput.trim();
      if (!message || !message.length) {
        return;
      }
      const person = this.personDetails;
      const user = this._me.userPrincipalName;
      this.isSending = true;
      const chat = yield createChat(this._graph, person.userPrincipalName, user);
      const messageData = {
        body: {
          content: message
        }
      };
      yield sendMessage(this._graph, chat.id, messageData);
      this.isSending = false;
      this.clearInputData();
    });
  }
  /**
   * Use the mailto: protocol to initiate a new email to the user.
   *
   * @protected
   * @memberof MgtPersonCard
   */
  emailUser() {
    const user = this.internalPersonDetails;
    if (user) {
      const email = getEmailFromGraphEntity(user);
      if (email) {
        window.open("mailto:" + email, "_blank", "noreferrer");
      }
    }
  }
  get hasPhone() {
    var _a2, _b2;
    const user = this.personDetails;
    const person = this.personDetails;
    return Boolean((_a2 = user === null || user === void 0 ? void 0 : user.businessPhones) === null || _a2 === void 0 ? void 0 : _a2.length) || Boolean((_b2 = person === null || person === void 0 ? void 0 : person.phones) === null || _b2 === void 0 ? void 0 : _b2.length);
  }
  /**
   * Use the tel: protocol to initiate a new call to the user.
   *
   * @protected
   * @memberof MgtPersonCard
   */
  callUser() {
    const user = this.personDetails;
    const person = this.personDetails;
    if (user && user.businessPhones && user.businessPhones.length) {
      const phone = user.businessPhones[0];
      if (phone) {
        window.open("tel:" + phone, "_blank", "noreferrer");
      }
    } else if (person && person.phones && person.phones.length) {
      const businessPhones = this.getPersonBusinessPhones(person);
      const phone = businessPhones[0];
      if (phone) {
        window.open("tel:" + phone, "_blank", "noreferrer");
      }
    }
  }
  /**
   * Initiate a chat message to the user via deeplink.
   *
   * @protected
   * @memberof MgtPersonCard
   */
  chatUser(message = null) {
    const user = this.personDetails;
    if (user && user.userPrincipalName) {
      const users = user.userPrincipalName;
      let url = `https://teams.microsoft.com/l/chat/0/0?users=${users}`;
      if (message && message.length) {
        url += `&message=${message}`;
      }
      const openWindow = () => window.open(url, "_blank", "noreferrer");
      if (TeamsHelper.isAvailable) {
        TeamsHelper.executeDeepLink(url, (status) => {
          if (!status) {
            openWindow();
          }
        });
      } else {
        openWindow();
      }
    }
  }
  /**
   * Initiate a teams call with video with a user via deeplink.
   *
   * @protected
   * @memberof MgtPersonCard
   */
  videoCallUser() {
    const user = this.personDetails;
    if (user && user.userPrincipalName) {
      const users = user.userPrincipalName;
      const url = `https://teams.microsoft.com/l/call/0/0?users=${users}&withVideo=true`;
      const openWindow = () => window.open(url, "_blank");
      if (TeamsHelper.isAvailable) {
        TeamsHelper.executeDeepLink(url, (status) => {
          if (!status) {
            openWindow();
          }
        });
      } else {
        openWindow();
      }
    }
  }
  /**
   * Display the expanded details panel.
   *
   * @protected
   * @memberof MgtPersonCard
   */
  showExpandedDetails() {
    const root = this.renderRoot.querySelector(".root");
    if (root && root.animate) {
      root.animate([
        {
          height: "auto",
          transformOrigin: "top left"
        },
        {
          height: "auto",
          transformOrigin: "top left"
        }
      ], {
        duration: 1e3,
        easing: "ease-in-out",
        fill: "both"
      });
    }
    this.isExpanded = true;
    this.fireCustomEvent("expanded", null, true);
  }
  loadSections() {
    this.sections = [];
    if (!this.internalPersonDetails) {
      return;
    }
    const contactSections = new MgtContact(this.internalPersonDetails);
    if (contactSections.hasData) {
      this.sections.push(contactSections);
    }
    if (!this._cardState) {
      return;
    }
    const { person, directReports, messages, files, profile } = this._cardState;
    if (MgtPersonCard_1.config.sections.organization && (person && person.manager || directReports && directReports.length)) {
      this.sections.push(new MgtOrganization(this._cardState, this._me));
    }
    if (MgtPersonCard_1.config.sections.mailMessages && messages && messages.length) {
      this.sections.push(new MgtMessages(messages));
    }
    if (MgtPersonCard_1.config.sections.files && files && files.length) {
      this.sections.push(new MgtFileList());
    }
    if (MgtPersonCard_1.config.sections.profile && profile) {
      const profileSection = new MgtProfile(profile);
      if (profileSection.hasData) {
        this.sections.push(profileSection);
      }
    }
  }
  getImage() {
    if (this.personImage) {
      return this.personImage;
    }
    const person = this.personDetails;
    return person && person.personImage ? person.personImage : null;
  }
  clearInputData() {
    this._chatInput = "";
    this.requestUpdate();
  }
  getPersonBusinessPhones(person) {
    const phones = person.phones;
    const businessPhones = [];
    for (const p of phones) {
      if (p.type === "business") {
        businessPhones.push(p.number);
      }
    }
    return businessPhones;
  }
  updateCurrentSection(section) {
    if (section) {
      const sectionName = section.tagName.toLowerCase();
      const tabs = this.renderRoot.querySelector(`#${sectionName}-Tab`);
      tabs.click();
    }
    const panels = this.renderRoot.querySelectorAll("fluent-tab-panel");
    for (const target2 of panels) {
      target2.scrollTop = 0;
    }
    this._currentSection = section;
    this.requestUpdate();
  }
  handleSectionScroll(e) {
    const panels = this.renderRoot.querySelectorAll("fluent-tab-panel");
    for (const target2 of panels) {
      if (target2) {
        if (!(e.deltaY < 0 && target2.scrollTop === 0) && !(e.deltaY > 0 && target2.clientHeight + target2.scrollTop >= target2.scrollHeight - 1)) {
          e.stopPropagation();
        }
      }
    }
  }
  handleKeyDown(e) {
    if (e) {
      if (e.code === "Enter") {
        this.showExpandedDetails();
      }
    }
  }
  sendQuickMessageOnEnter(e) {
    if (e.code === "Enter") {
      this.sendQuickMessage();
    }
  }
};
MgtPersonCard._config = {
  sections: {
    files: true,
    mailMessages: true,
    organization: { showWorksWith: true },
    profile: true
  },
  useContactApis: true,
  isSendMessageVisible: true
};
__decorate20([
  property({
    attribute: "person-details",
    type: Object
  }),
  __metadata17("design:type", Object),
  __metadata17("design:paramtypes", [Object])
], MgtPersonCard.prototype, "personDetails", null);
__decorate20([
  property({
    attribute: "person-query"
  }),
  __metadata17("design:type", String)
], MgtPersonCard.prototype, "personQuery", void 0);
__decorate20([
  property({
    attribute: "lock-tab-navigation",
    type: Boolean
  }),
  __metadata17("design:type", Boolean)
], MgtPersonCard.prototype, "lockTabNavigation", void 0);
__decorate20([
  property({
    attribute: "user-id"
  }),
  __metadata17("design:type", String),
  __metadata17("design:paramtypes", [String])
], MgtPersonCard.prototype, "userId", null);
__decorate20([
  property({
    attribute: "person-image",
    type: String
  }),
  __metadata17("design:type", String)
], MgtPersonCard.prototype, "personImage", void 0);
__decorate20([
  property({
    attribute: "fetch-image",
    type: Boolean
  }),
  __metadata17("design:type", Boolean)
], MgtPersonCard.prototype, "fetchImage", void 0);
__decorate20([
  property({
    attribute: "is-expanded",
    type: Boolean
  }),
  __metadata17("design:type", Boolean)
], MgtPersonCard.prototype, "isExpanded", void 0);
__decorate20([
  property({
    attribute: "inherit-details",
    type: Boolean
  }),
  __metadata17("design:type", Boolean)
], MgtPersonCard.prototype, "inheritDetails", void 0);
__decorate20([
  property({
    attribute: "show-presence",
    type: Boolean
  }),
  __metadata17("design:type", Boolean)
], MgtPersonCard.prototype, "showPresence", void 0);
__decorate20([
  property({
    attribute: "person-presence",
    type: Object
  }),
  __metadata17("design:type", Object)
], MgtPersonCard.prototype, "personPresence", void 0);
__decorate20([
  state(),
  __metadata17("design:type", Boolean)
], MgtPersonCard.prototype, "isSending", void 0);
__decorate20([
  state(),
  __metadata17("design:type", Object)
], MgtPersonCard.prototype, "_cardState", void 0);
__decorate20([
  state(),
  __metadata17("design:type", Boolean)
], MgtPersonCard.prototype, "_isStateLoading", void 0);
__decorate20([
  state(),
  __metadata17("design:type", Object)
], MgtPersonCard.prototype, "hoverStates", void 0);
MgtPersonCard = MgtPersonCard_1 = __decorate20([
  customElement("person-card"),
  __metadata17("design:paramtypes", [])
], MgtPersonCard);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/mgt-tasks.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/mgt-tasks-css.js
init_lit();
var styles17 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--task-border:1px solid #e1dfdd;--task-complete-border:2px dotted #e1dfdd;--task-new-add-button-disabled-background:#ebebeb;--task-icon-color:#000000}.mgt-dark{--task-border:1px solid #717171;--task-complete-border:2px dotted #717171;--task-new-add-button-disabled-background:#4f4f4f;--task-icon-color:#ffffff}:host{font-family:var(--default-font-family);display:flex;flex-direction:column;background-color:var(--background-color-sub1,#faf9f8);padding:var(--tasks-padding,12px);color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a))}:host input[type=date]::-webkit-calendar-picker-indicator,:host input[type=date]::-webkit-inner-spin-button{display:none;-webkit-appearance:none}:host .TaskIcon{font-family:FabricMDL2Icons;user-select:none;-moz-user-select:none;-ms-user-select:none}:host .TaskIcon.Divider{vertical-align:initial;margin:0 12px;font-size:16px}:host .Header{padding:var(--tasks-header-padding,0);margin:var(--tasks-header-margin,0 0 12px 0);padding:var(--tasks-title-padding,0);display:flex;align-items:center;justify-content:space-between}:host .Header .header__loading{max-width:90px;width:100%;height:20px;background:#f2f2f2}:host .Header select{font-family:var(--default-font-family, "Segoe UI");font-size:var(--tasks-plan-title-font-size,1.1em);padding:var(--tasks-plan-title-padding,5px);border:none;-moz-appearance:none;-webkit-appearance:none;cursor:pointer}:host .Header select::-ms-expand{display:none}:host .Header .PlanTitle{font-family:var(--default-font-family, "Segoe UI");font-size:var(--tasks-plan-title-font-size,1.1em);padding:var(--tasks-plan-title-padding,5px)}:host .Header .AddBar{display:flex}:host .Header .AddBar .AddBarItem{flex:1 1 auto}:host .Header .NewTaskDue{display:flex}:host .Header .NewTaskDue input{flex:1 1 auto;background-color:var(--background-color-sub1,#faf9f8)}:host .Header .TitleCont{flex:1 1 auto;display:flex;align-items:center;height:var(--tasks-new-button-height,34px)}:host .Header .NewTaskButton{flex:0 0 auto;display:flex;justify-content:center;align-items:center;width:var(--tasks-new-button-width,auto);height:var(--tasks-new-button-height,32px);border-radius:2px;padding:0 20px;background:var(--tasks-new-button-background,#0078d4);border:var(--tasks-new-button-border,solid 1px transparent);color:var(--tasks-new-button-color,#fff);user-select:none;-moz-user-select:none;-ms-user-select:none;cursor:pointer}:host .Header .NewTaskButton span{font-size:14px;font-weight:600;letter-spacing:.1px;line-height:14px}:host .Header .NewTaskButton .TaskIcon{margin-right:8px}:host .Header .NewTaskButton.hidden{visibility:hidden}:host .Header .NewTaskButton:hover{background:var(--tasks-new-button-hover-background,#106ebe)}:host .Header .NewTaskButton:active{background:var(--tasks-new-button-active-background,#005a9e)}:host .Task{position:relative;margin:var(--task-margin,0 0 18px 0);padding:var(--task-padding,0 0 0 0);background-color:var(--tasks-background-color,var(--background-color,#fff));border:var(--task-border,1px solid #e1dfdd);border-radius:8px}:host .Task .TaskContent{display:flex}:host .Task .TaskContent .Divider{position:absolute;height:2px;left:0;right:0;bottom:0;background-color:var(--background-color-sub1,#faf9f8)}:host .Task .TaskContent .TaskDetailsContainer{flex:1;display:grid;display:-ms-grid;grid-template-columns:auto 1fr;-ms-grid-columns:auto 1fr;grid-template-rows:auto auto auto auto;-ms-grid-rows:auto auto auto auto;justify-content:space-between;align-items:flex-start;color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:12px;font-weight:600;white-space:normal;margin-bottom:12px}:host .Task .TaskContent .TaskDetailsContainer .TaskDetail{width:100%;height:100%;margin:4px 24px 6px 0;display:flex;justify-content:flex-start;align-items:center}:host .Task .TaskContent .TaskDetailsContainer .TaskTitle{color:var(--task-title-color,var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a)));font-size:14px;font-weight:600;grid-row:1;-ms-grid-row:1;grid-column:1/3;-ms-grid-column:1;-ms-grid-column-span:2;margin:22px 0 4px}:host .Task .TaskContent .TaskDetailsContainer .TaskGroup{min-height:24px;grid-row:2;-ms-grid-row:2;grid-column:1;-ms-grid-column:1}:host .Task .TaskContent .TaskDetailsContainer .TaskBucket{min-height:24px;grid-row:2;-ms-grid-row:2;grid-column:2;-ms-grid-column:2}:host .Task .TaskContent .TaskDetailsContainer .TaskDue{justify-content:flex-end;align-items:flex-start;grid-row:4;-ms-grid-row:4;grid-column:1/3;-ms-grid-column:1;-ms-grid-column-span:2}:host .Task .TaskContent .TaskDetailsContainer.tablet{grid-template-columns:1fr .5fr 1fr .5fr;-ms-grid-columns:1fr .5fr 1fr .5fr;grid-template-rows:auto auto;-ms-grid-rows:auto auto}:host .Task .TaskContent .TaskDetailsContainer.tablet.NoPlan{grid-template-columns:0 1fr 1fr 1fr;-ms-grid-columns:0 1fr 1fr 1fr}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskDetail{margin:4px 24px 6px 0}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskTitle{grid-row:1;-ms-grid-row:1;grid-column:1/5;-ms-grid-column:1;-ms-grid-column-span:4}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskGroup{grid-row:2;-ms-grid-row:2;grid-column:1;-ms-grid-column:1}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskBucket{grid-row:2;-ms-grid-row:2;grid-column:2;-ms-grid-column:2}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskAssignee{grid-row:2;-ms-grid-row:2;grid-column:3;-ms-grid-column:3}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskDue{justify-content:flex-start;align-items:center;grid-row:2;-ms-grid-row:2;grid-column:4;-ms-grid-column:4}:host .Task .TaskContent .TaskDetailsContainer.desktop{grid-template-columns:2fr 1fr .5fr 1fr .5fr;-ms-grid-columns:2fr 1fr .5fr 1fr .5fr;grid-template-rows:auto;-ms-grid-rows:auto;margin:0}:host .Task .TaskContent .TaskDetailsContainer.desktop.NoPlan{grid-template-columns:2fr 0 1fr 1fr 1fr;-ms-grid-columns:2fr 0 1fr 1fr 1fr}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskDetail{margin:0 24px 0 0}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskTitle{padding:0;grid-row:1;-ms-grid-row:1;grid-column:1;-ms-grid-column:1}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskGroup{min-height:61px;grid-row:1;-ms-grid-row:1;grid-column:2;-ms-grid-column:2}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskBucket{grid-row:1;-ms-grid-row:1;grid-column:3;-ms-grid-column:3}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskAssignee{grid-row:1;-ms-grid-row:1;grid-column:4;-ms-grid-column:4}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskDue{justify-content:flex-start;align-items:center;grid-row:1;-ms-grid-row:1;grid-column:5;-ms-grid-column:5}:host .Task .TaskContent .TaskDetailsContainer svg{vertical-align:middle;margin-right:4px}:host .Task .TaskContent .TaskDetailsContainer svg path{fill:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)))}:host .Task .TaskContent .TaskDetailsContainer select,:host .Task .TaskContent .TaskDetailsContainer span{vertical-align:middle;color:var(--color-sub2,var(--neutral-foreground-hint,#717171))}:host .Task .TaskContent .TaskDetailsContainer .TaskIcon{color:#797775;margin-right:8px}:host .Task .TaskContent .TaskDetailsContainer .people{color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:16px}:host .Task .TaskContent .TaskDetailsContainer .person{display:inline-block}:host .Task .TaskContent .TaskDetailsContainer .Picker{background-color:var(--background-color-sub1,#faf9f8);-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box;width:var(--mgt-flyout-set-width,350px);color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)))}:host .Task .TaskContent .TaskDetailsContainer .Picker .people-picker{--separator-margin:0px 10px 0px 10px}:host .Task .TaskContent .TaskDetailsContainer input,:host .Task .TaskContent .TaskDetailsContainer select{color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:.9em;background-color:var(--background-color-sub1,#faf9f8)}:host .Task .TaskCheckContainer{font-family:FabricMDL2Icons;display:inline-block;border-radius:50%;color:#fff;cursor:pointer;display:flex;align-items:var(--task-icon-alignment,flex-start);margin:21px 10px 20px 20px;user-select:none;-moz-user-select:none;-ms-user-select:none}:host .Task .TaskCheckContainer.Complete .TaskCheck{background-color:var(--task-icon-background-completed,#00ad56);border:var(--task-icon-border-completed,solid 1px #fff);color:var(--task-icon-color-completed,#fff)}:host .Task .TaskCheckContainer.Complete .TaskContent .TaskDetailsContainer .TaskTitle{text-decoration:line-through;color:var(--color-sub3,#727170)}:host .Task .TaskCheckContainer .TaskCheck{font-family:FabricMDL2Icons;font-size:12px;display:inline-block;width:18px;height:18px;border-radius:var(--task-icon-border-radius,50%);border:var(--task-icon-border,solid 1px #797775);color:var(--task-icon-color,#000);display:flex;justify-content:center;align-items:center;background-color:var(--task-icon-background,transparent);user-select:none;-moz-user-select:none;-ms-user-select:none}:host .Task .TaskCheckContainer .TaskCheck.Loading .TaskCheckContent{animation:rotateIcon 2s infinite linear}:host .Task .TaskOptions{cursor:pointer;user-select:none;-moz-user-select:none;-ms-user-select:none;margin:16px 8px 0 0}:host .Task.ReadOnly .TaskCheckContainer{cursor:default}:host .Task.Complete{background:var(--task-complete-background,var(--background-color-sub1,#faf9f8));border:var(--task-complete-border,2px dotted #e1dfdd)}:host .Task.Complete .TaskContent .TaskDetailsContainer .TaskTitle{text-decoration:line-through;color:var(--color-sub3,#727170)}:host .Task.NewTask{margin:var(--task-new-margin,var(--task-margin,0 0 24px 0));display:flex;flex-direction:row}:host .Task.NewTask .SelfAssign{display:none}:host .Task.NewTask .AssignTo{border:0;background:0 0}:host .Task.NewTask .FakeCheckBox{width:15px;height:15px;cursor:pointer;margin:0 5px 0 5px}:host .Task.NewTask .FakeCheckBox::after{font-family:FabricMDL2Icons;content:"uE739"}:host .Task.NewTask .FakeCheckBox~:checked{font-family:FabricMDL2Icons;content:"uE73A"}:host .Task.NewTask .TaskContent{flex:1 1 auto;align-content:center;vertical-align:middle;margin:0 0 0 12px}:host .Task.NewTask .TaskContent .TaskDetailsContainer{display:flex;flex-direction:column;align-items:stretch;margin:0}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle{display:flex;height:32px;padding:2px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input{flex:1;font-family:var(--default-font-family, "Segoe UI");margin:var(--task-new-input-margin,0 24px 0 16px);padding:var(--task-new-input-padding,6px);font-size:var(--task-new-input-font-size,14px);font-weight:600;border:var(--task-new-border,none);border-bottom:1px solid #e1dfdd;outline:0;border-radius:0;background-color:var(--background-color-sub1,#faf9f8)}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input:hover{border-bottom:1px solid #106ebe}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input:active{border-bottom:1px solid #005a9e}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input:focus{border-bottom:1px solid #0078d4}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails{display:flex;justify-content:stretch;align-items:center;flex-wrap:wrap;margin:14px 0 14px 4px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskGroup{margin:8px 16px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskBucket{margin:8px 16px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskDue{margin:8px 16px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskAssignee{margin:8px 16px;min-width:80px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .TaskPeople label{display:flex;align-content:center;align-items:center}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select{font-family:var(--default-font-family);font-size:12px;font-weight:600;border:var(--task-new-select-border,none);border-bottom:1px solid #e1dfdd}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input:hover,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select:hover{border-bottom:1px solid #106ebe}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input:active,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select:active{border-bottom:1px solid #005a9e}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input:focus,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select:focus{border-bottom:1px solid #0078d4}:host .Task.NewTask .TaskAddButtonContainer{margin-right:28px}:host .Task.NewTask .TaskAddButtonContainer .TaskAdd,:host .Task.NewTask .TaskAddButtonContainer .TaskCancel{justify-content:center;align-items:center;cursor:pointer;flex:0 0 auto;display:flex;width:var(--tasks-new-button-width,100px);height:var(--tasks-new-button-height,32px);border-radius:4px;border:var(--tasks-new-button-border,solid 1px #e5e5e5);font-family:var(--default-font-family, "Segoe UI");font-size:14px;line-height:20px}:host .Task.NewTask .TaskAddButtonContainer .TaskAdd{color:#fff;background:var(--task-new-add-button-background,#0078d4);margin:22px 0 12px auto}:host .Task.NewTask .TaskAddButtonContainer .TaskCancel{color:var(--task-new-cancel-button-color,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)))}:host .Task.NewTask .TaskAddButtonContainer.Disabled .TaskAdd{color:var(--task-new-cancel-button-color,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)));background:var(--task-new-add-button-disabled-background,#fff);cursor:default}:host .Task.LoadingTask .TaskCheckContainer{cursor:default}:host .Task.LoadingTask .TaskDetails{display:flex}:host .Task.LoadingTask .TaskCheck{background:#f2f2f2;border-color:#f2f2f2;cursor:default}:host .Task.LoadingTask .TaskDetailIcon{width:16px;height:16px;margin:5px;background:#f2f2f2}:host .Task.LoadingTask .TaskTitle{background:#f2f2f2;max-width:400px;height:20px;margin-right:20px!important}:host .Task.LoadingTask .TaskDetail{margin-right:12px;display:flex;flex-direction:row;align-items:center}:host .Task.LoadingTask .TaskDetailName{width:81px;height:10px;background:#f2f2f2}@keyframes rotateIcon{from{transform:rotate(0)}to{transform:rotate(360deg)}}[dir=rtl] .arrow-options{--arrow-options-left:auto}[dir=rtl] .dot-options{--dot-options-translateX:translateX(60px)}[dir=rtl] .TaskDetails{margin-right:14px!important}[dir=rtl] .TaskIcon{margin-left:8px}[dir=rtl] .TaskDetail svg{margin-left:4px}@media (forced-colors:active) and (prefers-color-scheme:dark){:host svg{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}:host svg path{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}@media (forced-colors:active) and (prefers-color-scheme:light){:host svg{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}:host svg path{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/task-sources.js
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/mgt-tasks.graph.planner.js
init_es6();
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function addPlannerTask(graph, newTask) {
  return graph.api("/planner/tasks").header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.ReadWrite.All")).post(newTask);
}
function assignPeopleToPlannerTask(graph, taskId, people, eTag) {
  return setPlannerTaskDetails(graph, taskId, {
    assignments: people
  }, eTag);
}
function removePlannerTask(graph, taskId, eTag) {
  return graph.api(`/planner/tasks/${taskId}`).header("Cache-Control", "no-store").header("If-Match", eTag).middlewareOptions(prepScopes("Group.ReadWrite.All")).delete();
}
function setPlannerTaskComplete(graph, taskId, eTag) {
  return setPlannerTaskDetails(graph, taskId, {
    percentComplete: 100
  }, eTag);
}
function setPlannerTaskIncomplete(graph, taskId, eTag) {
  return setPlannerTaskDetails(graph, taskId, {
    percentComplete: 0
  }, eTag);
}
function setPlannerTaskDetails(graph, taskId, details, eTag) {
  return __awaiter21(this, void 0, void 0, function* () {
    return yield graph.api(`/planner/tasks/${taskId}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.ReadWrite.All")).header("If-Match", eTag).patch(JSON.stringify(details));
  });
}
function getPlansForGroup(graph, groupId) {
  return __awaiter21(this, void 0, void 0, function* () {
    const scopes = "Group.Read.All";
    const uri = `/groups/${groupId}/planner/plans`;
    const plans = yield graph.api(uri).header("Cache-Control", "no-store").middlewareOptions(prepScopes(scopes)).get();
    return plans ? plans.value : null;
  });
}
function getSinglePlannerPlan(graph, planId) {
  return __awaiter21(this, void 0, void 0, function* () {
    const plan = yield graph.api(`/planner/plans/${planId}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get();
    return plan;
  });
}
function getBucketsForPlannerPlan(graph, planId) {
  return __awaiter21(this, void 0, void 0, function* () {
    const buckets = yield graph.api(`/planner/plans/${planId}/buckets`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get();
    return buckets && buckets.value;
  });
}
function getAllMyPlannerPlans(graph) {
  return __awaiter21(this, void 0, void 0, function* () {
    const plans = yield graph.api("/me/planner/plans").header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get();
    return plans && plans.value;
  });
}
function getTasksForPlannerBucket(graph, bucketId) {
  return __awaiter21(this, void 0, void 0, function* () {
    const tasks = yield graph.api(`/planner/buckets/${bucketId}/tasks`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get();
    return tasks && tasks.value;
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/mgt-tasks.graph.todo.js
init_es6();
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function addTodoTask(graph, newTask) {
  return __awaiter22(this, void 0, void 0, function* () {
    const { parentFolderId = null } = newTask;
    if (parentFolderId) {
      return yield graph.api(`/me/outlook/taskFolders/${parentFolderId}/tasks`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.ReadWrite")).post(newTask);
    } else {
      return yield graph.api("/me/outlook/tasks").header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.ReadWrite")).post(newTask);
    }
  });
}
function getAllMyTodoGroups(graph) {
  return __awaiter22(this, void 0, void 0, function* () {
    const groups = yield graph.api("/me/outlook/taskGroups").header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.Read")).get();
    return groups && groups.value;
  });
}
function getAllTodoTasksForFolder(graph, folderId) {
  return __awaiter22(this, void 0, void 0, function* () {
    const tasks = yield graph.api(`/me/outlook/taskFolders/${folderId}/tasks`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.Read")).get();
    return tasks && tasks.value;
  });
}
function getFoldersForTodoGroup(graph, groupId) {
  return __awaiter22(this, void 0, void 0, function* () {
    const folders = yield graph.api(`/me/outlook/taskGroups/${groupId}/taskFolders`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.Read")).get();
    return folders && folders.value;
  });
}
function getSingleTodoGroup(graph, groupId) {
  return __awaiter22(this, void 0, void 0, function* () {
    const group = yield graph.api(`/me/outlook/taskGroups/${groupId}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.Read")).get();
    return group;
  });
}
function removeTodoTask(graph, taskId, eTag) {
  return __awaiter22(this, void 0, void 0, function* () {
    return yield graph.api(`/me/outlook/tasks/${taskId}`).header("Cache-Control", "no-store").header("If-Match", eTag).middlewareOptions(prepScopes("Tasks.ReadWrite")).delete();
  });
}
function setTodoTaskComplete(graph, taskId, eTag) {
  return __awaiter22(this, void 0, void 0, function* () {
    return yield setTodoTaskDetails(graph, taskId, {
      isReminderOn: false,
      status: "completed"
    }, eTag);
  });
}
function setTodoTaskIncomplete(graph, taskId, eTag) {
  return __awaiter22(this, void 0, void 0, function* () {
    return yield setTodoTaskDetails(graph, taskId, {
      isReminderOn: true,
      status: "notStarted"
    }, eTag);
  });
}
function setTodoTaskDetails(graph, taskId, task, eTag) {
  return __awaiter22(this, void 0, void 0, function* () {
    return yield graph.api(`/me/outlook/tasks/${taskId}`).header("Cache-Control", "no-store").header("If-Match", eTag).middlewareOptions(prepScopes("Tasks.ReadWrite")).patch(task);
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/task-sources.js
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TaskSourceBase = class {
  constructor(graph) {
    this.graph = BetaGraph.fromGraph(graph);
  }
};
var PlannerTaskSource = class extends TaskSourceBase {
  /**
   * returns promise with all of users plans
   *
   * @returns {Promise<ITaskGroup[]>}
   * @memberof PlannerTaskSource
   */
  getTaskGroups() {
    return __awaiter23(this, void 0, void 0, function* () {
      const plans = yield getAllMyPlannerPlans(this.graph);
      return plans.map((plan) => ({ id: plan.id, title: plan.title }));
    });
  }
  /**
   * returns promise with all of plans for group id
   *
   * @param {string} id
   * @returns {Promise<ITaskGroup[]>}
   * @memberof PlannerTaskSource
   */
  getTaskGroupsForGroup(id) {
    return __awaiter23(this, void 0, void 0, function* () {
      const plans = yield getPlansForGroup(this.graph, id);
      return plans.map((plan) => ({ id: plan.id, title: plan.title }));
    });
  }
  /**
   * returns promise single TaskGroup or plan from plan.id
   *
   * @param {string} id
   * @returns {Promise<ITaskGroup>}
   * @memberof PlannerTaskSource
   */
  getTaskGroup(id) {
    return __awaiter23(this, void 0, void 0, function* () {
      const plan = yield getSinglePlannerPlan(this.graph, id);
      return { id: plan.id, title: plan.title, _raw: plan };
    });
  }
  /**
   * returns promise with Bucket for a plan from bucket.id
   *
   * @param {string} id
   * @returns {Promise<ITaskFolder[]>}
   * @memberof PlannerTaskSource
   */
  getTaskFoldersForTaskGroup(id) {
    return __awaiter23(this, void 0, void 0, function* () {
      const buckets = yield getBucketsForPlannerPlan(this.graph, id);
      return buckets.map((bucket) => ({
        _raw: bucket,
        id: bucket.id,
        name: bucket.name,
        parentId: bucket.planId
      }));
    });
  }
  /**
   * get all task from a Bucket given task id
   *
   * @param {string} id
   * @returns {Promise<ITask[]>}
   * @memberof PlannerTaskSource
   */
  getTasksForTaskFolder(id) {
    return __awaiter23(this, void 0, void 0, function* () {
      const tasks = yield getTasksForPlannerBucket(this.graph, id);
      return tasks.map((task) => ({
        _raw: task,
        assignments: task.assignments,
        completed: task.percentComplete === 100,
        dueDate: task.dueDateTime && new Date(task.dueDateTime),
        eTag: task["@odata.etag"],
        id: task.id,
        immediateParentId: task.bucketId,
        name: task.title,
        topParentId: task.planId
      }));
    });
  }
  /**
   * set task in planner to complete state by id
   *
   * @param {string} id
   * @param {string} eTag
   * @returns {Promise<any>}
   * @memberof PlannerTaskSource
   */
  setTaskComplete(id, eTag) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield setPlannerTaskComplete(this.graph, id, eTag);
    });
  }
  /**
   * set task in planner to incomplete state by id
   *
   * @param {string} id
   * @param {string} eTag
   * @returns {Promise<any>}
   * @memberof PlannerTaskSource
   */
  setTaskIncomplete(id, eTag) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield setPlannerTaskIncomplete(this.graph, id, eTag);
    });
  }
  /**
   * add new task to bucket
   *
   * @param {ITask} newTask
   * @returns {Promise<any>}
   * @memberof PlannerTaskSource
   */
  addTask(newTask) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield addPlannerTask(this.graph, {
        assignments: newTask.assignments,
        bucketId: newTask.immediateParentId,
        dueDateTime: newTask.dueDate && newTask.dueDate.toISOString(),
        planId: newTask.topParentId,
        title: newTask.name
      });
    });
  }
  /**
   * Assigns people to task
   *
   * @param {string} id
   * @param {string} eTag
   * @param {*} people
   * @returns {Promise<any>}
   * @memberof PlannerTaskSource
   */
  assignPeopleToTask(id, eTag, people) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield assignPeopleToPlannerTask(this.graph, id, eTag, people);
    });
  }
  /**
   * remove task from bucket
   *
   * @param {string} id
   * @param {string} eTag
   * @returns {Promise<any>}
   * @memberof PlannerTaskSource
   */
  removeTask(id, eTag) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield removePlannerTask(this.graph, id, eTag);
    });
  }
  /**
   * assigns task to the signed in user
   *
   * @param {ITask} task
   * @param {string} myId
   * @returns {boolean}
   * @memberof PlannerTaskSource
   */
  isAssignedToMe(task, myId) {
    const keys = Object.keys(task.assignments);
    return keys.includes(myId);
  }
};
var TodoTaskSource = class extends TaskSourceBase {
  /**
   * get all Outlook task groups
   *
   * @returns {Promise<ITaskGroup[]>}
   * @memberof TodoTaskSource
   */
  getTaskGroups() {
    return __awaiter23(this, void 0, void 0, function* () {
      const groups = yield getAllMyTodoGroups(this.graph);
      return groups.map((group) => ({
        _raw: group,
        id: group.id,
        secondaryId: group.groupKey,
        title: group.name
      }));
    });
  }
  /**
   * get a single OutlookTaskGroup from id
   *
   * @param {string} id
   * @returns {Promise<ITaskGroup>}
   * @memberof TodoTaskSource
   */
  getTaskGroup(id) {
    return __awaiter23(this, void 0, void 0, function* () {
      const group = yield getSingleTodoGroup(this.graph, id);
      return { id: group.id, secondaryId: group.groupKey, title: group.name, _raw: group };
    });
  }
  /**
   * get all OutlookTaskFolder for group by id
   *
   * @param {string} id
   * @returns {Promise<ITaskFolder[]>}
   * @memberof TodoTaskSource
   */
  getTaskFoldersForTaskGroup(id) {
    return __awaiter23(this, void 0, void 0, function* () {
      const folders = yield getFoldersForTodoGroup(this.graph, id);
      return folders.map((folder) => ({
        _raw: folder,
        id: folder.id,
        name: folder.name,
        parentId: id
      }));
    });
  }
  /**
   * gets all tasks for OutLook Task Folder by id
   *
   * @param {string} id
   * @param {string} parId
   * @returns {Promise<ITask[]>}
   * @memberof TodoTaskSource
   */
  getTasksForTaskFolder(id, parId) {
    return __awaiter23(this, void 0, void 0, function* () {
      const tasks = yield getAllTodoTasksForFolder(this.graph, id);
      return tasks.map((task) => ({
        _raw: task,
        assignments: {},
        completed: !!task.completedDateTime,
        dueDate: task.dueDateTime && /* @__PURE__ */ new Date(task.dueDateTime.dateTime + "Z"),
        eTag: task["@odata.etag"],
        id: task.id,
        immediateParentId: id,
        name: task.subject,
        topParentId: parId
      }));
    });
  }
  /**
   * set task in planner to complete state by id
   *
   * @param {string} id
   * @param {string} eTag
   * @returns {Promise<any>}
   * @memberof TodoTaskSource
   */
  setTaskComplete(id, eTag) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield setTodoTaskComplete(this.graph, id, eTag);
    });
  }
  /**
   * Assigns people to task
   *
   * @param {string} id
   * @param {string} eTag
   * @param {*} people
   * @returns {Promise<any>}
   * @memberof PlannerTaskSource
   */
  assignPeopleToTask(id, eTag, people) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield assignPeopleToPlannerTask(this.graph, id, eTag, people);
    });
  }
  /**
   * set task in planner to incomplete state by id
   *
   * @param {string} id
   * @param {string} eTag
   * @returns {Promise<any>}
   * @memberof TodoTaskSource
   */
  setTaskIncomplete(id, eTag) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield setTodoTaskIncomplete(this.graph, id, eTag);
    });
  }
  /**
   * add new task to planner
   *
   * @param {ITask} newTask
   * @returns {Promise<any>}
   * @memberof TodoTaskSource
   */
  addTask(newTask) {
    return __awaiter23(this, void 0, void 0, function* () {
      const task = {
        parentFolderId: newTask.immediateParentId,
        subject: newTask.name
      };
      if (newTask.dueDate) {
        task.dueDateTime = {
          dateTime: newTask.dueDate.toISOString(),
          timeZone: "UTC"
        };
      }
      return yield addTodoTask(this.graph, task);
    });
  }
  /**
   * remove task from planner by id
   *
   * @param {string} id
   * @param {string} eTag
   * @returns {Promise<any>}
   * @memberof TodoTaskSource
   */
  removeTask(id, eTag) {
    return __awaiter23(this, void 0, void 0, function* () {
      return yield removeTodoTask(this.graph, id, eTag);
    });
  }
  /**
   * if task is assigned in to user logged in
   *
   * @param {ITask} task
   * @param {string} myId
   * @returns {boolean}
   * @memberof TodoTaskSource
   */
  isAssignedToMe(task, myId) {
    return true;
  }
  /**
   * returns promise with all of plans for group id
   *
   * @param {string} id
   * @returns {Promise<ITaskGroup[]>}
   * @memberof PlannerTaskSource
   */
  getTaskGroupsForGroup(id) {
    return __awaiter23(this, void 0, void 0, function* () {
      return void 0;
    });
  }
};

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-arrow-options/mgt-arrow-options.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-arrow-options/mgt-arrow-options-css.js
init_lit();
var styles18 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}:host,mgt-arrow-options{position:relative;font-family:var(--default-font-family)}:host .ArrowIcon,mgt-arrow-options .ArrowIcon{font-family:FabricMDL2Icons;margin:0 0 0 20px;user-select:none;-moz-user-select:none;-ms-user-select:none}:host .Header,mgt-arrow-options .Header{cursor:pointer}:host .Header:hover,mgt-arrow-options .Header:hover{color:var(--theme-primary-color)}:host .Menu,mgt-arrow-options .Menu{position:absolute;left:var(--arrow-options-left,0);box-shadow:var(--box-shadow-color,rgba(0,0,0,.092)) 0 0 40px 5px;background:var(--background-color,#fff);z-index:1;display:none;color:var(--color,#000);white-space:nowrap}:host .Menu.Open,mgt-arrow-options .Menu.Open{display:block}:host .MenuOption,mgt-arrow-options .MenuOption{padding:20px;cursor:pointer;user-select:none;-moz-user-select:none;-ms-user-select:none;display:flex;align-items:center;justify-content:stretch;justify-items:stretch}:host .MenuOption:first,mgt-arrow-options .MenuOption:first{padding:12px 20px 20px 20px}:host .MenuOption:hover,mgt-arrow-options .MenuOption:hover{background-color:var(--background-color--hover,var(--neutral-fill-hover,#f7f7f7))}:host .MenuOption:active,mgt-arrow-options .MenuOption:active{background-color:var(--background-color--active,#e1dfdd)}:host .MenuOptionCheck,mgt-arrow-options .MenuOptionCheck{font-family:FabricMDL2Icons;color:transparent;margin-right:10px}:host .MenuOptionCheck.CurrentValue,mgt-arrow-options .MenuOptionCheck.CurrentValue{color:#023b8f}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-arrow-options/mgt-arrow-options.js
var __decorate21 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata18 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtArrowOptions = class MgtArrowOptions2 extends MgtBaseComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * user the `css` tag function.
   */
  static get styles() {
    return styles18;
  }
  constructor() {
    super();
    this.value = "";
    this.options = {};
    this._clickHandler = (e) => this.open = false;
  }
  // tslint:disable-next-line: completed-docs
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("click", this._clickHandler);
  }
  // tslint:disable-next-line: completed-docs
  disconnectedCallback() {
    window.removeEventListener("click", this._clickHandler);
    super.disconnectedCallback();
  }
  /**
   * Handles clicking for header menu, utilizing boolean switch open
   *
   * @param {MouseEvent} e attaches to Header to open menu
   * @memberof MgtArrowOptions
   */
  onHeaderClick(e) {
    const keys = Object.keys(this.options);
    if (keys.length > 1) {
      e.preventDefault();
      e.stopPropagation();
      this.open = !this.open;
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    return html`
      <span class="Header" @click=${(e) => this.onHeaderClick(e)}>
        <span class="CurrentValue">${this.value}</span>
      </span>
      <div class=${classMap({ Menu: true, Open: this.open, Closed: !this.open })}>
        ${this.getMenuOptions()}
      </div>
    `;
  }
  getMenuOptions() {
    const keys = Object.keys(this.options);
    const funcs = this.options;
    return keys.map((opt) => html`
        <div
          class="MenuOption"
          @click="${(e) => {
      this.open = false;
      funcs[opt](e);
    }}"
        >
          <span class=${classMap({ MenuOptionCheck: true, CurrentValue: this.value === opt })}>
            \uE73E
          </span>
          <span class="MenuOptionName">${opt}</span>
        </div>
      `);
  }
};
__decorate21([
  property({ type: Boolean }),
  __metadata18("design:type", Boolean)
], MgtArrowOptions.prototype, "open", void 0);
__decorate21([
  property({ type: String }),
  __metadata18("design:type", String)
], MgtArrowOptions.prototype, "value", void 0);
__decorate21([
  property({ type: Object }),
  __metadata18("design:type", Object)
], MgtArrowOptions.prototype, "options", void 0);
MgtArrowOptions = __decorate21([
  customElement("arrow-options"),
  __metadata18("design:paramtypes", [])
], MgtArrowOptions);

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-dot-options/mgt-dot-options.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-dot-options/mgt-dot-options-css.js
init_lit();
var styles19 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}:host,mgt-dot-options{font-family:var(--default-font-family)}:host .DotIcon,mgt-dot-options .DotIcon{display:inline-block;font-family:FabricMDL2Icons;min-width:40px;min-height:30px;text-align:center;line-height:30px}:host .Menu,mgt-dot-options .Menu{position:absolute;box-shadow:var(--box-shadow-color,rgba(0,0,0,.092)) 0 0 40px 5px;background:var(--background-color,#fff);z-index:1;display:none;color:var(--color,#000);white-space:nowrap;transform:var(--dot-options-translateX,translateX(-50px))}:host .DotMenu.Open .Menu,mgt-dot-options .DotMenu.Open .Menu{display:block}:host .DotMenu .DotItem,mgt-dot-options .DotMenu .DotItem{direction:ltr;text-align:left;padding:10px 10px 8px 10px}:host .DotMenu .DotItem:hover,mgt-dot-options .DotMenu .DotItem:hover{background:var(--background-color--hover,var(--neutral-fill-hover,#f7f7f7))}:host .DotMenu .DotItem:active,mgt-dot-options .DotMenu .DotItem:active{background:var(--background-color--active,#e1dfdd)}:host .DotMenu .DotItemName,mgt-dot-options .DotMenu .DotItemName{direction:rtl}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/sub-components/mgt-dot-options/mgt-dot-options.js
var __decorate22 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata19 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtDotOptions = class MgtDotOptions2 extends MgtBaseComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * user the `css` tag function.
   */
  static get styles() {
    return styles19;
  }
  constructor() {
    super();
    this._clickHandler = null;
    this._clickHandler = (e) => this.open = false;
  }
  // tslint:disable-next-line: completed-docs
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("click", this._clickHandler);
  }
  // tslint:disable-next-line: completed-docs
  disconnectedCallback() {
    window.removeEventListener("click", this._clickHandler);
    super.disconnectedCallback();
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    return html`
      <div tabindex="0" class=${classMap({ DotMenu: true, Open: this.open })}
        @click=${(e) => this.onDotClick(e)}
        @keydown=${(e) => this.onDotKeydown(e)}>
        <span class="DotIcon">\uE712</span>
        <div tabindex="0" class="Menu">
          ${Object.keys(this.options).map((prop) => this.getMenuOption(prop, this.options[prop]))}
        </div>
      </div>
    `;
  }
  /**
   * Used by the render method to attach click handler to each dot item
   *
   * @param {string} name
   * @param {((e: Event) => void | any)} click
   * @returns
   * @memberof MgtDotOptions
   */
  getMenuOption(name, click) {
    return html`
      <div
        class="DotItem"
        @click="${(e) => {
      e.preventDefault();
      e.stopPropagation();
      click(e);
      this.open = false;
    }}"
        @keydown="${(e) => {
      this.handleKeydownMenuOption;
      click(e);
      this.open = false;
    }}"
      >
        <span class="DotItemName">
          ${name}
        </span>
      </div>
    `;
  }
  onDotClick(e) {
    e.preventDefault();
    e.stopPropagation();
    this.open = !this.open;
  }
  onDotKeydown(e) {
    if (e.code === "Enter") {
      e.preventDefault();
      e.stopPropagation();
      this.open = !this.open;
    }
  }
  handleKeydownMenuOption(e) {
    if (e.code === "Enter") {
      e.preventDefault();
      e.stopPropagation();
    }
  }
};
__decorate22([
  property({ type: Boolean }),
  __metadata19("design:type", Boolean)
], MgtDotOptions.prototype, "open", void 0);
__decorate22([
  property({ type: Object }),
  __metadata19("design:type", Object)
], MgtDotOptions.prototype, "options", void 0);
MgtDotOptions = __decorate22([
  customElement("dot-options"),
  __metadata19("design:paramtypes", [])
], MgtDotOptions);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/strings.js
var strings13 = {
  removeTaskSubtitle: "Delete Task",
  cancelNewTaskSubtitle: "Cancel",
  newTaskPlaceholder: "Adding task...",
  addTaskButtonSubtitle: "Add"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks/mgt-tasks.js
var __decorate23 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata20 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TasksSource;
(function(TasksSource2) {
  TasksSource2[TasksSource2["planner"] = 0] = "planner";
  TasksSource2[TasksSource2["todo"] = 1] = "todo";
})(TasksSource || (TasksSource = {}));
var TASK_RES = {
  todo: {
    BASE_SELF_ASSIGNED: "All Tasks",
    BUCKETS_SELF_ASSIGNED: "All Tasks",
    BUCKET_NOT_FOUND: "Folder not found",
    PLANS_SELF_ASSIGNED: "All groups",
    PLAN_NOT_FOUND: "Group not found"
  },
  // tslint:disable-next-line: object-literal-sort-keys
  planner: {
    BASE_SELF_ASSIGNED: "Assigned to Me",
    BUCKETS_SELF_ASSIGNED: "All Tasks",
    BUCKET_NOT_FOUND: "Bucket not found",
    PLANS_SELF_ASSIGNED: "All Plans",
    PLAN_NOT_FOUND: "Plan not found"
  }
};
var plannerAssignment = {
  "@odata.type": "microsoft.graph.plannerAssignment",
  orderHint: "string !"
};
var MgtTasks = class MgtTasks2 extends MgtTemplatedComponent {
  /**
   * determines whether todo, or planner functionality for task component
   *
   * @readonly
   * @type {TasksStringResource}
   * @memberof MgtTasks
   */
  get res() {
    switch (this.dataSource) {
      case TasksSource.todo:
        return TASK_RES.todo;
      case TasksSource.planner:
      default:
        return TASK_RES.planner;
    }
  }
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles17;
  }
  get strings() {
    return strings13;
  }
  /**
   * Get whether new task view is visible
   *
   * @memberof MgtTasks
   */
  get isNewTaskVisible() {
    return this._isNewTaskVisible;
  }
  /**
   * Set whether new task is visible
   *
   * @memberof MgtTasks
   */
  set isNewTaskVisible(value) {
    this._isNewTaskVisible = value;
    if (!value) {
      this._newTaskDueDate = null;
      this._newTaskName = "";
      this._newTaskGroupId = "";
    }
  }
  /**
   * Get the scopes required for tasks
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtTasks
   */
  static get requiredScopes() {
    return [
      .../* @__PURE__ */ new Set([
        "group.read.all",
        "group.readwrite.all",
        "tasks.read",
        "tasks.readwrite",
        ...MgtPeople.requiredScopes,
        ...MgtPeoplePicker.requiredScopes
      ])
    ];
  }
  constructor() {
    super();
    this.dataSource = TasksSource.planner;
    this._me = null;
    this.clearState();
    this.previousMediaQuery = this.mediaQuery;
    this.onResize = this.onResize.bind(this);
  }
  /**
   * updates provider state
   *
   * @memberof MgtTasks
   */
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("resize", this.onResize);
  }
  /**
   * removes updates on provider state
   *
   * @memberof MgtTasks
   */
  disconnectedCallback() {
    window.removeEventListener("resize", this.onResize);
    super.disconnectedCallback();
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * @param {*} name
   * @param {*} oldValue
   * @param {*} newValue
   * @memberof MgtTasks
   */
  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);
    if (name === "data-source") {
      if (this.dataSource === TasksSource.planner) {
        this._currentGroup = this.initialId;
        this._currentFolder = this.initialBucketId;
      } else if (this.dataSource === TasksSource.todo) {
        this._currentGroup = null;
        this._currentFolder = this.initialId;
      }
      this.clearState();
      this.requestStateUpdate();
    }
  }
  clearState() {
    this._newTaskFolderId = "";
    this._newTaskGroupId = "";
    this._newTaskDueDate = null;
    this._newTaskName = "";
    this._newTaskBeingAdded = false;
    this._tasks = [];
    this._folders = [];
    this._groups = [];
    this._hiddenTasks = [];
    this._loadingTasks = [];
    this._hasDoneInitialLoad = false;
    this._inTaskLoad = false;
    this._todoDefaultSet = false;
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    if (this.initialId && !this._currentGroup) {
      if (this.dataSource === TasksSource.planner) {
        this._currentGroup = this.initialId;
      } else if (this.dataSource === TasksSource.todo) {
        this._currentFolder = this.initialId;
      }
    }
    if (this.dataSource === TasksSource.planner && this.initialBucketId && !this._currentFolder) {
      this._currentFolder = this.initialBucketId;
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    let tasks = this._tasks.filter((task) => this.isTaskInSelectedGroupFilter(task)).filter((task) => this.isTaskInSelectedFolderFilter(task)).filter((task) => !this._hiddenTasks.includes(task.id));
    if (this.taskFilter) {
      tasks = tasks.filter((task) => this.taskFilter(task._raw));
    }
    const loadingTask = this._inTaskLoad && !this._hasDoneInitialLoad ? this.renderLoadingTask() : null;
    let header;
    if (!this.hideHeader) {
      header = html`
        <div class="Header" dir=${this.direction}>
          ${this.renderPlanOptions()}
        </div>
      `;
    }
    return html`
      ${header}
      <div class="Tasks" dir=${this.direction}>
        ${this._isNewTaskVisible ? this.renderNewTask() : null} ${loadingTask}
        ${repeat(tasks, (task) => task.id, (task) => this.renderTask(task))}
      </div>
    `;
  }
  /**
   * loads tasks from dataSource
   *
   * @returns
   * @memberof MgtTasks
   */
  loadState() {
    return __awaiter24(this, void 0, void 0, function* () {
      const ts = this.getTaskSource();
      if (!ts) {
        return;
      }
      const provider = Providers.globalProvider;
      if (!provider || provider.state !== ProviderState.SignedIn) {
        return;
      }
      this._inTaskLoad = true;
      let meTask;
      if (!this._me) {
        const graph = provider.graph.forComponent(this);
        meTask = getMe(graph);
      }
      if (this.groupId && this.dataSource === TasksSource.planner) {
        yield this._loadTasksForGroup(ts);
      } else if (this.targetId) {
        if (this.dataSource === TasksSource.todo) {
          yield this._loadTargetTodoTasks(ts);
        } else {
          yield this._loadTargetPlannerTasks(ts);
        }
      } else {
        yield this._loadAllTasks(ts);
      }
      if (meTask) {
        this._me = yield meTask;
      }
      this._inTaskLoad = false;
      this._hasDoneInitialLoad = true;
    });
  }
  onResize() {
    if (this.mediaQuery !== this.previousMediaQuery) {
      this.previousMediaQuery = this.mediaQuery;
      this.requestUpdate();
    }
  }
  _loadTargetTodoTasks(ts) {
    return __awaiter24(this, void 0, void 0, function* () {
      const groups = yield ts.getTaskGroups();
      const folders = (yield Promise.all(groups.map((group) => ts.getTaskFoldersForTaskGroup(group.id)))).reduce((cur, ret) => [...cur, ...ret], []);
      const tasks = (yield Promise.all(folders.map((folder) => ts.getTasksForTaskFolder(folder.id, folder.parentId)))).reduce((cur, ret) => [...cur, ...ret], []);
      this._tasks = tasks;
      this._folders = folders;
      this._groups = groups;
      this._currentGroup = null;
    });
  }
  _loadTargetPlannerTasks(ts) {
    return __awaiter24(this, void 0, void 0, function* () {
      const group = yield ts.getTaskGroup(this.targetId);
      let folders = yield ts.getTaskFoldersForTaskGroup(group.id);
      if (this.targetBucketId) {
        folders = folders.filter((folder) => folder.id === this.targetBucketId);
      }
      const tasks = (yield Promise.all(folders.map((folder) => ts.getTasksForTaskFolder(folder.id, folder.parentId)))).reduce((cur, ret) => [...cur, ...ret], []);
      this._tasks = tasks;
      this._folders = folders;
      this._groups = [group];
    });
  }
  _loadAllTasks(ts) {
    return __awaiter24(this, void 0, void 0, function* () {
      const groups = yield ts.getTaskGroups();
      const folders = (yield Promise.all(groups.map((group) => ts.getTaskFoldersForTaskGroup(group.id)))).reduce((cur, ret) => [...cur, ...ret], []);
      if (!this.initialId && this.dataSource === TasksSource.todo && !this._todoDefaultSet) {
        this._todoDefaultSet = true;
        const defaultFolder = folders.find((d) => d._raw.isDefaultFolder);
        if (defaultFolder) {
          this._currentFolder = defaultFolder.id;
        }
      }
      const tasks = (yield Promise.all(folders.map((folder) => ts.getTasksForTaskFolder(folder.id, folder.parentId)))).reduce((cur, ret) => [...cur, ...ret], []);
      this._tasks = tasks;
      this._folders = folders;
      this._groups = groups;
    });
  }
  _loadTasksForGroup(ts) {
    return __awaiter24(this, void 0, void 0, function* () {
      const groups = yield ts.getTaskGroupsForGroup(this.groupId);
      const folders = (yield Promise.all(groups.map((group) => ts.getTaskFoldersForTaskGroup(group.id)))).reduce((cur, ret) => [...cur, ...ret], []);
      const tasks = (yield Promise.all(folders.map((folder) => ts.getTasksForTaskFolder(folder.id, folder.parentId)))).reduce((cur, ret) => [...cur, ...ret], []);
      this._tasks = tasks;
      this._folders = folders;
      this._groups = groups;
    });
  }
  addTask(name, dueDate, topParentId, immediateParentId, assignments = {}) {
    return __awaiter24(this, void 0, void 0, function* () {
      const ts = this.getTaskSource();
      if (!ts) {
        return;
      }
      const newTask = {
        assignments,
        dueDate,
        immediateParentId,
        name,
        topParentId
      };
      this._newTaskBeingAdded = true;
      newTask._raw = yield ts.addTask(newTask);
      this.fireCustomEvent("taskAdded", newTask);
      yield this.requestStateUpdate();
      this._newTaskBeingAdded = false;
      this.isNewTaskVisible = false;
    });
  }
  completeTask(task) {
    return __awaiter24(this, void 0, void 0, function* () {
      const ts = this.getTaskSource();
      if (!ts) {
        return;
      }
      this._loadingTasks = [...this._loadingTasks, task.id];
      yield ts.setTaskComplete(task.id, task.eTag);
      this.fireCustomEvent("taskChanged", task);
      yield this.requestStateUpdate();
      this._loadingTasks = this._loadingTasks.filter((id) => id !== task.id);
    });
  }
  uncompleteTask(task) {
    return __awaiter24(this, void 0, void 0, function* () {
      const ts = this.getTaskSource();
      if (!ts) {
        return;
      }
      this._loadingTasks = [...this._loadingTasks, task.id];
      yield ts.setTaskIncomplete(task.id, task.eTag);
      this.fireCustomEvent("taskChanged", task);
      yield this.requestStateUpdate();
      this._loadingTasks = this._loadingTasks.filter((id) => id !== task.id);
    });
  }
  removeTask(task) {
    return __awaiter24(this, void 0, void 0, function* () {
      const ts = this.getTaskSource();
      if (!ts) {
        return;
      }
      this._hiddenTasks = [...this._hiddenTasks, task.id];
      yield ts.removeTask(task.id, task.eTag);
      this.fireCustomEvent("taskRemoved", task);
      yield this.requestStateUpdate();
      this._hiddenTasks = this._hiddenTasks.filter((id) => id !== task.id);
    });
  }
  assignPeople(task, people) {
    return __awaiter24(this, void 0, void 0, function* () {
      const ts = this.getTaskSource();
      if (!ts) {
        return;
      }
      let savedSelectedPeople = [];
      if (task) {
        if (task.assignments) {
          savedSelectedPeople = Object.keys(task.assignments).sort();
        }
      }
      const newPeopleIds = people.map((person) => {
        return person.id;
      });
      const isEqual = newPeopleIds.length === savedSelectedPeople.length && newPeopleIds.sort().every((value, index) => {
        return value === savedSelectedPeople[index];
      });
      if (isEqual) {
        return;
      }
      const peopleObj = {};
      if (people.length === 0) {
        for (let i = 0; i < savedSelectedPeople.length; i++) {
          peopleObj[savedSelectedPeople[i]] = null;
        }
      }
      if (people) {
        for (let i = 0; i < savedSelectedPeople.length; i++) {
          for (let j = 0; j < people.length; j++) {
            if (savedSelectedPeople[i] !== people[j].id) {
              peopleObj[savedSelectedPeople[i]] = null;
              break;
            } else {
              peopleObj[savedSelectedPeople[i]] = plannerAssignment;
            }
          }
        }
        for (let i = 0; i < people.length; i++) {
          peopleObj[people[i].id] = plannerAssignment;
        }
      }
      if (task) {
        this._loadingTasks = [...this._loadingTasks, task.id];
        yield ts.assignPeopleToTask(task.id, peopleObj, task.eTag);
        yield this.requestStateUpdate();
        this._loadingTasks = this._loadingTasks.filter((id) => id !== task.id);
      }
    });
  }
  onAddTaskClick(e) {
    const picker = this.getPeoplePicker(null);
    const peopleObj = {};
    if (picker) {
      for (const person of picker.selectedPeople) {
        if (picker.selectedPeople.length) {
          peopleObj[person.id] = plannerAssignment;
        }
      }
    }
    if (!this._newTaskBeingAdded && this._newTaskName && (this._currentGroup || this._newTaskGroupId)) {
      this.addTask(this._newTaskName, this._newTaskDueDate, !this._currentGroup ? this._newTaskGroupId : this._currentGroup, !this._currentFolder ? this._newTaskFolderId : this._currentFolder, peopleObj);
    }
  }
  onAddTaskKeyDown(e) {
    if (e.code === "Enter") {
      this.onAddTaskClick;
    }
  }
  newTaskButtonKeydown(e) {
    if (e.code === "Enter") {
      this.isNewTaskVisible = !this.isNewTaskVisible;
    }
  }
  newTaskVisible(e) {
    if (e.code === "Enter") {
      this.isNewTaskVisible = false;
    }
  }
  renderPlanOptions() {
    const p = Providers.globalProvider;
    if (!p || p.state !== ProviderState.SignedIn) {
      return null;
    }
    if (this._inTaskLoad && !this._hasDoneInitialLoad) {
      return html`
        <span class="LoadingHeader"></span>
      `;
    }
    const addButton = this.readOnly || this._isNewTaskVisible ? null : html`
            <div
              tabindex="0"
              class="AddBarItem NewTaskButton"
              @click="${() => {
      this.isNewTaskVisible = !this.isNewTaskVisible;
    }}"
              @keydown="${this.newTaskButtonKeydown}"
            >
              <span class="TaskIcon"></span>
              <span>${this.strings.addTaskButtonSubtitle}</span>
            </div>
          `;
    if (this.dataSource === TasksSource.planner) {
      const currentGroup = this._groups.find((d) => d.id === this._currentGroup) || {
        title: this.res.BASE_SELF_ASSIGNED
      };
      const groupOptions = {
        [this.res.BASE_SELF_ASSIGNED]: (e) => {
          this._currentGroup = null;
          this._currentFolder = null;
        }
      };
      for (const group of this._groups) {
        groupOptions[group.title] = (e) => {
          this._currentGroup = group.id;
          this._currentFolder = null;
        };
      }
      const groupSelect = mgtHtml`
        <mgt-arrow-options class="arrow-options" .options="${groupOptions}" .value="${currentGroup.title}"></mgt-arrow-options>
      `;
      const divider = !this._currentGroup ? null : html`
            <span class="TaskIcon Divider">/</span>
          `;
      const currentFolder = this._folders.find((d) => d.id === this._currentFolder) || {
        name: this.res.BUCKETS_SELF_ASSIGNED
      };
      const folderOptions = {
        [this.res.BUCKETS_SELF_ASSIGNED]: (e) => {
          this._currentFolder = null;
        }
      };
      for (const folder of this._folders.filter((d) => d.parentId === this._currentGroup)) {
        folderOptions[folder.name] = (e) => {
          this._currentFolder = folder.id;
        };
      }
      const folderSelect = this.targetBucketId ? html`
            <span class="PlanTitle">
              ${this._folders[0] && this._folders[0].name}
            </span>
          ` : mgtHtml`
            <mgt-arrow-options class="arrow-options" .options="${folderOptions}" .value="${currentFolder.name}"></mgt-arrow-options>
          `;
      return html`
        <div class="TitleCont">
          ${groupSelect} ${divider} ${!this._currentGroup ? null : folderSelect}
        </div>
        ${addButton}
      `;
    } else {
      const folder = this._folders.find((d) => d.id === this.targetId) || { name: this.res.BUCKETS_SELF_ASSIGNED };
      const currentFolder = this._folders.find((d) => d.id === this._currentFolder) || {
        name: this.res.BUCKETS_SELF_ASSIGNED
      };
      const folderOptions = {};
      for (const d of this._folders) {
        folderOptions[d.name] = () => {
          this._currentFolder = d.id;
        };
      }
      folderOptions[this.res.BUCKETS_SELF_ASSIGNED] = (e) => {
        this._currentFolder = null;
      };
      const folderSelect = this.targetId ? html`
            <span class="PlanTitle">
              ${folder.name}
            </span>
          ` : mgtHtml`
            <mgt-arrow-options class="arrow-options" .value="${currentFolder.name}" .options="${folderOptions}"></mgt-arrow-options>
          `;
      return html`
        <span class="TitleCont">
          ${folderSelect}
        </span>
        ${addButton}
      `;
    }
  }
  renderNewTask() {
    const taskTitle = html`
      <input
        type="text"
        placeholder=${this.strings.newTaskPlaceholder}
        .value="${this._newTaskName}"
        label="new-taskName-input"
        aria-label="new-taskName-input"
        role="textbox"
        @input="${(e) => {
      this._newTaskName = e.target.value;
    }}"
      />
    `;
    const groups = this._groups;
    if (groups.length > 0 && !this._newTaskGroupId) {
      this._newTaskGroupId = groups[0].id;
    }
    const group = this.dataSource === TasksSource.todo ? null : this._currentGroup ? html`
            <span class="NewTaskGroup">
              ${this.renderPlannerIcon()}
              <span>${this.getPlanTitle(this._currentGroup)}</span>
            </span>
          ` : html`
            <span class="NewTaskGroup">
              ${this.renderPlannerIcon()}
              <select aria-label="new task group"
                .value="${this._newTaskGroupId}"
                @change="${(e) => {
      this._newTaskGroupId = e.target.value;
    }}"
              >
                ${this._groups.map((plan) => html`
                    <option value="${plan.id}">${plan.title}</option>
                  `)}
              </select>
            </span>
          `;
    const folders = this._folders.filter((folder) => this._currentGroup && folder.parentId === this._currentGroup || !this._currentGroup && folder.parentId === this._newTaskGroupId);
    if (folders.length > 0 && !this._newTaskFolderId) {
      this._newTaskFolderId = folders[0].id;
    }
    const taskFolder = this._currentFolder ? html`
          <span class="NewTaskBucket">
            ${this.renderBucketIcon()}
            <span>${this.getFolderName(this._currentFolder)}</span>
          </span>
        ` : html`
          <span class="NewTaskBucket">
            ${this.renderBucketIcon()}
            <select aria-label="new task bucket"
              .value="${this._newTaskFolderId}"
              @change="${(e) => {
      this._newTaskFolderId = e.target.value;
    }}"
            >
              ${folders.map((folder) => html`
                  <option value="${folder.id}">${folder.name}</option>
                `)}
            </select>
          </span>
        `;
    const taskDue = html`
      <span class="NewTaskDue">
      ${this.renderCalendarIcon()}
        <input
          type="date"
          label="new-taskDate-input"
          aria-label="new-taskDate-input"
          role="textbox"
          .value="${this.dateToInputValue(this._newTaskDueDate)}"
          @change="${(e) => {
      const value = e.target.value;
      if (value) {
        this._newTaskDueDate = /* @__PURE__ */ new Date(value + "T17:00");
      } else {
        this._newTaskDueDate = null;
      }
    }}"
        />
      </span>
    `;
    const taskPeople = this.dataSource === TasksSource.todo ? null : this.renderAssignedPeople(null);
    const taskAdd = this._newTaskBeingAdded ? html`
          <div class="TaskAddButtonContainer"></div>
        ` : html`
          <div class="TaskAddButtonContainer ${this._newTaskName === "" ? "Disabled" : ""}">
            <div tabindex="0" class="TaskIcon TaskAdd"
              @click="${this.onAddTaskClick}"
              @keydown="${this.onAddTaskKeyDown}">
              <span>${this.strings.addTaskButtonSubtitle}</span>
            </div>
            <div tabindex="0" class="TaskIcon TaskCancel"
              @click="${() => this.isNewTaskVisible = false}"
              @keydown="${this.newTaskVisible}">
              <span>${this.strings.cancelNewTaskSubtitle}</span>
            </div>
          </div>
        `;
    return html`
      <div class="Task NewTask Incomplete">
        <div class="TaskContent">
          <div class="TaskDetailsContainer">
            <div class="TaskTitle">
              ${taskTitle}
            </div>
            <div class="TaskDetails">
              ${group} ${taskFolder} ${taskDue} ${taskPeople}
            </div>
          </div>
        </div>
        ${taskAdd}
      </div>
    `;
  }
  togglePeoplePicker(task) {
    const picker = this.getPeoplePicker(task);
    const mgtPeople = this.getMgtPeople(task);
    const flyout = this.getFlyout(task);
    if (picker && mgtPeople && flyout) {
      if (flyout.isOpen) {
        flyout.close();
      } else {
        picker.selectedPeople = mgtPeople.people;
        flyout.open();
        window.requestAnimationFrame(() => {
          picker.focus();
        });
      }
    }
  }
  updateAssignedPeople(task) {
    const picker = this.getPeoplePicker(task);
    const mgtPeople = this.getMgtPeople(task);
    if (picker && picker.selectedPeople !== mgtPeople.people) {
      mgtPeople.people = picker.selectedPeople;
      this.assignPeople(task, picker.selectedPeople);
    }
  }
  getPeoplePicker(task) {
    const taskId = task ? task.id : "newTask";
    const picker = this.renderRoot.querySelector(`.picker-${taskId}`);
    return picker;
  }
  getMgtPeople(task) {
    const taskId = task ? task.id : "newTask";
    const mgtPeople = this.renderRoot.querySelector(`.people-${taskId}`);
    return mgtPeople;
  }
  getFlyout(task) {
    const taskId = task ? task.id : "newTask";
    const flyout = this.renderRoot.querySelector(`.flyout-${taskId}`);
    return flyout;
  }
  renderTask(task) {
    const { name = "Task", completed = false, dueDate } = task;
    const isLoading = this._loadingTasks.includes(task.id);
    const taskCheckClasses = {
      Complete: !isLoading && completed,
      Loading: isLoading,
      TaskCheck: true,
      TaskIcon: true
    };
    const taskCheckContent = isLoading ? html`
          
        ` : completed ? html`
          
        ` : null;
    const taskCheck = html`
      <span tabindex="0" class=${classMap(taskCheckClasses)}><span class="TaskCheckContent">${taskCheckContent}</span></span>
    `;
    const groupTitle = this._currentGroup ? null : this.getPlanTitle(task.topParentId);
    const folderTitle = this._currentFolder ? null : this.getFolderName(task.immediateParentId);
    const context = { task: Object.assign(Object.assign({}, task._raw), { groupTitle, folderTitle }) };
    const taskTemplate = this.renderTemplate("task", context, task.id);
    if (taskTemplate) {
      return taskTemplate;
    }
    let taskDetails = this.renderTemplate("task-details", context, `task-details-${task.id}`);
    if (!taskDetails) {
      const group = this.dataSource === TasksSource.todo || this._currentGroup ? null : html`
              <div class="TaskDetail TaskGroup">
                ${this.renderPlannerIcon()}
                <span>${this.getPlanTitle(task.topParentId)}</span>
              </div>
            `;
      const folder = this._currentFolder ? null : html`
            <div class="TaskDetail TaskBucket">
              ${this.renderBucketIcon()}
              <span>${this.getFolderName(task.immediateParentId)}</span>
            </div>
          `;
      const taskDue = !dueDate ? null : html`
            <div class="TaskDetail TaskDue">
              <span>Due ${getShortDateString(dueDate)}</span>
            </div>
          `;
      const taskPeople = this.dataSource !== TasksSource.todo ? this.renderAssignedPeople(task) : null;
      taskDetails = html`
        <div class="TaskTitle">
          ${name}
        </div>
        ${group} ${folder} ${taskPeople} ${taskDue}
      `;
    }
    const taskOptions = this.readOnly || this.hideOptions ? null : mgtHtml`
            <div class="TaskOptions">
              <mgt-dot-options
                class="dot-options"
                .options="${{
      [this.strings.removeTaskSubtitle]: () => this.removeTask(task)
    }}"
              ></mgt-dot-options>
            </div>
          `;
    return html`
      <div
        class=${classMap({
      Complete: completed,
      Incomplete: !completed,
      ReadOnly: this.readOnly,
      Task: true
    })}
      >
        <div
          class="TaskContent"
          @click=${() => {
      this.handleTaskClick(task);
    }}
        >
          <span
            class=${classMap({
      Complete: completed,
      Incomplete: !completed,
      TaskCheckContainer: true
    })}
            @click="${(e) => {
      if (!this.readOnly) {
        if (!task.completed) {
          this.completeTask(task);
        } else {
          this.uncompleteTask(task);
        }
        e.stopPropagation();
        e.preventDefault();
      }
    }}"
            @keydown="${(e) => {
      if (e.code === "Enter") {
        if (!this.readOnly) {
          if (!task.completed) {
            this.completeTask(task);
          } else {
            this.uncompleteTask(task);
          }
          e.stopPropagation();
          e.preventDefault();
        }
      }
    }}"
          >
            ${taskCheck}
          </span>
          <div class="TaskDetailsContainer ${this.mediaQuery} ${this._currentGroup ? "NoPlan" : ""}">
            ${taskDetails}
          </div>
          ${taskOptions}

        </div>
      </div>
    `;
  }
  renderAssignedPeople(task) {
    let assignedPeopleHTML = null;
    const taskAssigneeClasses = {
      NewTaskAssignee: task === null,
      TaskAssignee: task !== null,
      TaskDetail: task !== null
    };
    const assignedPeople = task ? Object.keys(task.assignments).map((key) => {
      return key;
    }) : [];
    const noPeopleTemplate = html`
      <template data-type="no-data">
        <i class="login-icon ms-Icon ms-Icon--Contact"></i>
      </template>
    `;
    const taskId = task ? task.id : "newTask";
    taskAssigneeClasses[`flyout-${taskId}`] = true;
    assignedPeopleHTML = mgtHtml`
      <mgt-people
        class="people people-${taskId}"
        .userIds="${assignedPeople}"
        .personCardInteraction=${PersonCardInteraction.none}
        @click=${(e) => {
      this.togglePeoplePicker(task);
      e.stopPropagation();
    }}
        @keydown=${(e) => {
      if (e.code === "Enter") {
        this.togglePeoplePicker(task);
        e.stopPropagation();
      }
    }}
        >${noPeopleTemplate}
      </mgt-people>
    `;
    const picker = mgtHtml`
      <mgt-people-picker
        class="people-picker picker-${taskId}"
        @click=${(e) => e.stopPropagation()}
        @keydown=${(e) => {
      if (e.code === "Enter") {
        e.stopPropagation();
      }
    }}
      ></mgt-people-picker>
    `;
    return mgtHtml`
      <mgt-flyout light-dismiss class=${classMap(taskAssigneeClasses)} @closed=${(e) => this.updateAssignedPeople(task)}>
        ${assignedPeopleHTML}
        <div slot="flyout" class=${classMap({ Picker: true })}>
          ${picker}
        </div>
      </mgt-flyout>
    `;
  }
  handleTaskClick(task) {
    if (task) {
      this.fireCustomEvent("taskClick", task);
    }
  }
  renderLoadingTask() {
    return html`
      <div class="Task LoadingTask">
        <div class="TaskContent">
          <div class="TaskCheckContainer">
            <div class="TaskCheck"></div>
          </div>
          <div class="TaskDetailsContainer">
            <div class="TaskTitle"></div>
            <div class="TaskDetails">
              <span class="TaskDetail">
                <div class="TaskDetailIcon"></div>
                <div class="TaskDetailName"></div>
              </span>
              <span class="TaskDetail">
                <div class="TaskDetailIcon"></div>
                <div class="TaskDetailName"></div>
              </span>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  renderPlannerIcon() {
    return html`
      <svg width="16" height="18" viewBox="0 0 16 18" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M7.223 1.156C6.98 1.26 6.769 1.404 6.586 1.586C6.403 1.768 6.261 1.98 6.157 2.223C6.052 2.465 6 2.724 6 3H2V17H14V3H10C10 2.724 9.948 2.465 9.844 2.223C9.74 1.98 9.596 1.768 9.414 1.586C9.231 1.404 9.02 1.26 8.777 1.156C8.535 1.053 8.276 1 8 1C7.723 1 7.465 1.053 7.223 1.156ZM5 4H7V3C7 2.86 7.026 2.729 7.078 2.609C7.13 2.49 7.202 2.385 7.293 2.293C7.384 2.202 7.49 2.131 7.609 2.079C7.73 2.026 7.859 2 8 2C8.14 2 8.271 2.026 8.39 2.079C8.511 2.131 8.616 2.202 8.707 2.293C8.798 2.385 8.87 2.49 8.922 2.609C8.974 2.729 9 2.86 9 3V4H11V5H5V4ZM12 6V4H13V16H3V4H4V6H12Z"
          fill="#3C3C3C"
        />
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M7.35156 12.3517L5.49956 14.2037L4.14856 12.8517L4.85156 12.1487L5.49956 12.7967L6.64856 11.6487L7.35156 12.3517Z"
          fill="#3C3C3C"
        />
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M7.35156 8.35168L5.49956 10.2037L4.14856 8.85168L4.85156 8.14868L5.49956 8.79668L6.64856 7.64868L7.35156 8.35168Z"
          fill="#3C3C3C"
        />
        <path fill-rule="evenodd" clip-rule="evenodd" d="M8 14H12.001V13H8V14Z" fill="#3C3C3C" />
        <path fill-rule="evenodd" clip-rule="evenodd" d="M8 10H12.001V9H8V10Z" fill="#3C3C3C" />
      </svg>
    `;
  }
  renderBucketIcon() {
    return html`
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M14 2H2V4H3H5H6H10H11H13H14V2ZM10 5H6V6H10V5ZM5 5H3V14H13V5H11V6C11 6.55228 10.5523 7 10 7H6C5.44772 7 5 6.55228 5 6V5ZM1 5H2V14V15H3H13H14V14V5H15V4V2V1H14H2H1V2V4V5Z"
          fill="#3C3C3C"
        />
      </svg>
    `;
  }
  /**
   * Render a calendar icon.
   *
   * @protected
   * @returns
   * @memberof MgtTodo
   */
  renderCalendarIcon() {
    return html`
          <svg width="16" height="20" viewBox="0 0 16 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 11C5.55228 11 6 10.5523 6 10C6 9.44771 5.55228 9 5 9C4.44772 9 4 9.44771 4 10C4 10.5523 4.44772 11 5 11ZM6 13C6 13.5523 5.55228 14 5 14C4.44772 14 4 13.5523 4 13C4 12.4477 4.44772 12 5 12C5.55228 12 6 12.4477 6 13ZM8 11C8.55229 11 9 10.5523 9 10C9 9.44771 8.55229 9 8 9C7.44771 9 7 9.44771 7 10C7 10.5523 7.44771 11 8 11ZM9 13C9 13.5523 8.55229 14 8 14C7.44771 14 7 13.5523 7 13C7 12.4477 7.44771 12 8 12C8.55229 12 9 12.4477 9 13ZM11 11C11.5523 11 12 10.5523 12 10C12 9.44771 11.5523 9 11 9C10.4477 9 10 9.44771 10 10C10 10.5523 10.4477 11 11 11ZM15 5.5C15 4.11929 13.8807 3 12.5 3H3.5C2.11929 3 1 4.11929 1 5.5V14.5C1 15.8807 2.11929 17 3.5 17H12.5C13.8807 17 15 15.8807 15 14.5V5.5ZM2 7H14V14.5C14 15.3284 13.3284 16 12.5 16H3.5C2.67157 16 2 15.3284 2 14.5V7ZM3.5 4H12.5C13.3284 4 14 4.67157 14 5.5V6H2V5.5C2 4.67157 2.67157 4 3.5 4Z" fill="#717171"/>
          </svg>
        `;
  }
  getTaskSource() {
    const p = Providers.globalProvider;
    if (!p || p.state !== ProviderState.SignedIn) {
      return null;
    }
    const graph = p.graph.forComponent(this);
    if (this.dataSource === TasksSource.planner) {
      return new PlannerTaskSource(graph);
    } else if (this.dataSource === TasksSource.todo) {
      return new TodoTaskSource(graph);
    } else {
      return null;
    }
  }
  getPlanTitle(planId) {
    if (!planId) {
      return this.res.BASE_SELF_ASSIGNED;
    } else if (planId === this.res.PLANS_SELF_ASSIGNED) {
      return this.res.PLANS_SELF_ASSIGNED;
    } else {
      return (this._groups.find((plan) => plan.id === planId) || {
        title: this.res.PLAN_NOT_FOUND
      }).title;
    }
  }
  getFolderName(bucketId) {
    if (!bucketId) {
      return this.res.BUCKETS_SELF_ASSIGNED;
    }
    return (this._folders.find((buck) => buck.id === bucketId) || {
      name: this.res.BUCKET_NOT_FOUND
    }).name;
  }
  isTaskInSelectedGroupFilter(task) {
    return task.topParentId === this._currentGroup || !this._currentGroup && this.getTaskSource().isAssignedToMe(task, this._me.id);
  }
  isTaskInSelectedFolderFilter(task) {
    return task.immediateParentId === this._currentFolder || !this._currentFolder;
  }
  dateToInputValue(date) {
    if (date) {
      return new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().split("T")[0];
    }
    return null;
  }
};
__decorate23([
  property({ attribute: "read-only", type: Boolean }),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "readOnly", void 0);
__decorate23([
  property({
    attribute: "data-source",
    converter: (value, type) => {
      value = value.toLowerCase();
      return TasksSource[value] || TasksSource.planner;
    }
  }),
  __metadata20("design:type", Number)
], MgtTasks.prototype, "dataSource", void 0);
__decorate23([
  property({ attribute: "target-id", type: String }),
  __metadata20("design:type", String)
], MgtTasks.prototype, "targetId", void 0);
__decorate23([
  property({ attribute: "target-bucket-id", type: String }),
  __metadata20("design:type", String)
], MgtTasks.prototype, "targetBucketId", void 0);
__decorate23([
  property({ attribute: "initial-id", type: String }),
  __metadata20("design:type", String)
], MgtTasks.prototype, "initialId", void 0);
__decorate23([
  property({ attribute: "initial-bucket-id", type: String }),
  __metadata20("design:type", String)
], MgtTasks.prototype, "initialBucketId", void 0);
__decorate23([
  property({ attribute: "hide-header", type: Boolean }),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "hideHeader", void 0);
__decorate23([
  property({ attribute: "hide-options", type: Boolean }),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "hideOptions", void 0);
__decorate23([
  property({ attribute: "group-id", type: String }),
  __metadata20("design:type", String)
], MgtTasks.prototype, "groupId", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "_isNewTaskVisible", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "_newTaskBeingAdded", void 0);
__decorate23([
  property(),
  __metadata20("design:type", String)
], MgtTasks.prototype, "_newTaskName", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Date)
], MgtTasks.prototype, "_newTaskDueDate", void 0);
__decorate23([
  property(),
  __metadata20("design:type", String)
], MgtTasks.prototype, "_newTaskGroupId", void 0);
__decorate23([
  property(),
  __metadata20("design:type", String)
], MgtTasks.prototype, "_newTaskFolderId", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Array)
], MgtTasks.prototype, "_groups", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Array)
], MgtTasks.prototype, "_folders", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Array)
], MgtTasks.prototype, "_tasks", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Array)
], MgtTasks.prototype, "_hiddenTasks", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Array)
], MgtTasks.prototype, "_loadingTasks", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "_inTaskLoad", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "_hasDoneInitialLoad", void 0);
__decorate23([
  property(),
  __metadata20("design:type", Boolean)
], MgtTasks.prototype, "_todoDefaultSet", void 0);
__decorate23([
  property(),
  __metadata20("design:type", String)
], MgtTasks.prototype, "_currentGroup", void 0);
__decorate23([
  property(),
  __metadata20("design:type", String)
], MgtTasks.prototype, "_currentFolder", void 0);
MgtTasks = __decorate23([
  customElement("tasks"),
  __metadata20("design:paramtypes", [])
], MgtTasks);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-teams-channel-picker/mgt-teams-channel-picker.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-teams-channel-picker/mgt-teams-channel-picker-css.js
init_lit();
var styles20 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--dropdown-item-selected-background:#deecf9;--arrow-fill:#000000}.mgt-dark{--dropdown-item-selected-background:#333d47;--arrow-fill:#605e5c}:host,:host mgt-teams-channel-picker{font-family:var(--default-font-family)}:host .container,:host mgt-teams-channel-picker .container{display:flex;flex-direction:column}:host .dropdown,:host mgt-teams-channel-picker .dropdown{z-index:1;display:none;margin-top:4px}:host .dropdown.visible,:host mgt-teams-channel-picker .dropdown.visible{display:flex}:host .dropdown .team-photo,:host mgt-teams-channel-picker .dropdown .team-photo{width:24px;position:inherit;border-radius:50%;margin:0 6px}:host .dropdown .team-start-slot,:host mgt-teams-channel-picker .dropdown .team-start-slot{width:max-content}:host .dropdown .team-parent-name,:host mgt-teams-channel-picker .dropdown .team-parent-name{width:auto}:host .loading-text,:host .search-error-text,:host mgt-teams-channel-picker .loading-text,:host mgt-teams-channel-picker .search-error-text{font-family:var(--default-font-family);font-style:normal;font-weight:400;font-size:14px;line-height:20px}:host .message-parent,:host mgt-teams-channel-picker .message-parent{display:flex;flex-direction:row;gap:5px;padding:5px}:host .message-parent .loading-text,:host mgt-teams-channel-picker .message-parent .loading-text{color:var(--color,#0078d4);margin:auto}:host fluent-card{--fill-color:var(--dropdown-background-color, --fill-color);--card-height:auto;--width:var(--card-width)}:host fluent-text-field{width:100%;--fill-color:var(--color, $color);--neutral-fill-input-rest:var(--input-background-color, #ffffff);--input-placeholder-rest:var(--placeholder-color, --input-placeholder-rest);--input-placeholder-hover:var(--placeholder-color--focus, --input-placeholder-hover)}:host fluent-tree-view{--tree-item-nested-width:2em}:host fluent-tree-item{--tree-item-nested-width:2em;--neutral-foreground-rest:var(--color, $color);--neutral-fill-stealth-hover:var(--dropdown-item-hover-background, --neutral-fill-stealth-hover);--neutral-fill-secondary-rest:var(--dropdown-item-selected-background, --neutral-fill-secondary-rest);--neutral-fill-stealth-rest:var(--dropdown-background-color, --neutral-fill-stealth-rest)}:host fluent-tree-view{min-width:100%}:host fluent-breadcrumb-item .team-parent-name{font-weight:700}:host fluent-breadcrumb-item .team-photo{width:19px;position:inherit;border-radius:50%}:host fluent-breadcrumb-item .arrow{margin-left:8px;margin-right:8px}:host fluent-breadcrumb-item .arrow svg{stroke:var(--arrow-fill,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)))}[dir=rtl] :host{--direction:rtl}[dir=rtl] .dropdown{text-align:right}[dir=rtl] .arrow{-moz-transform:scaleX(-1);-o-transform:scaleX(-1);-webkit-transform:scaleX(-1);transform:scaleX(-1);filter:FlipH;-ms-filter:FlipH;margin-right:0;margin-left:5px}[dir=rtl] .selected-team{padding-left:10px}[dir=rtl] .message-parent .loading-text{right:auto;left:10px;padding-right:8px;text-align:right}@media (forced-colors:active) and (prefers-color-scheme:dark){:host fluent-text-field svg{stroke:#fff!important}}@media (forced-colors:active) and (prefers-color-scheme:light){:host fluent-text-field svg{stroke:#000!important}}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-teams-channel-picker/mgt-teams-channel-picker.graph.js
init_es6();
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getAllMyTeams(graph) {
  return __awaiter25(this, void 0, void 0, function* () {
    const teams = yield graph.api("/me/joinedTeams").select(["displayName", "id", "isArchived"]).get();
    return teams ? teams.value : null;
  });
}
function getTeamsPhotosforPhotoIds(graph, teamIds) {
  return __awaiter25(this, void 0, void 0, function* () {
    let cache2;
    let photos = {};
    if (getIsPhotosCacheEnabled()) {
      cache2 = CacheService.getCache(schemas.photos, schemas.photos.stores.teams);
      for (const id of teamIds) {
        try {
          const photoDetail = yield cache2.getValue(id);
          if (photoDetail && getPhotoInvalidationTime() > Date.now() - photoDetail.timeCached) {
            photos[id] = photoDetail;
          }
        } catch (_) {
        }
      }
      if (Object.keys(photos).length) {
        return photos;
      }
    }
    let scopes = ["team.readbasic.all"];
    photos = {};
    for (const id of teamIds) {
      try {
        const photoDetail = yield getPhotoForResource(graph, `/teams/${id}`, scopes);
        if (getIsPhotosCacheEnabled() && photoDetail) {
          cache2.putValue(id, photoDetail);
        }
        photos[id] = photoDetail;
      } catch (_) {
      }
    }
    return photos;
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-teams-channel-picker/strings.js
var strings14 = {
  inputPlaceholderText: "Select a channel",
  noResultsFound: `We didn't find any matches.`,
  loadingMessage: "Loading..."
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-teams-channel-picker/mgt-teams-channel-picker.js
init_FluentComponents();
init_esm3();
var __decorate24 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata21 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtTeamsChannelPicker_1;
registerFluentComponents(fluentBreadcrumb, fluentBreadcrumbItem, fluentCard, fluentTreeView, fluentTreeItem, fluentTextField);
var MgtTeamsChannelPicker = MgtTeamsChannelPicker_1 = class MgtTeamsChannelPicker2 extends MgtTemplatedComponent {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * user the `css` tag function.
   */
  static get styles() {
    return styles20;
  }
  get strings() {
    return strings14;
  }
  /**
   * Global Configuration object for all
   * teams channel picker components
   *
   * @static
   * @type {MgtTeamsChannelPickerConfig}
   * @memberof MgtTeamsChannelPicker
   */
  static get config() {
    return this._config;
  }
  /**
   * Gets Selected item to be used
   *
   * @readonly
   * @type {SelectedChannel}
   * @memberof MgtTeamsChannelPicker
   */
  get selectedItem() {
    if (this._selectedItemState) {
      return { channel: this._selectedItemState.item, team: this._selectedItemState.parent.item };
    } else {
      return null;
    }
  }
  /**
   * Get the scopes required for teams channel picker
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtTeamsChannelPicker
   */
  static get requiredScopes() {
    if (this.config.useTeamsBasedScopes) {
      return ["team.readbasic.all", "channel.readbasic.all"];
    } else {
      return ["user.read.all", "group.read.all"];
    }
  }
  set items(value) {
    if (this._items === value) {
      return;
    }
    this._items = value;
    this._treeViewState = value ? this.generateTreeViewState(value) : [];
    this.resetFocusState();
  }
  get items() {
    return this._items;
  }
  // User input in search
  get _input() {
    const wrapper = this.renderRoot.querySelector("fluent-text-field");
    const input = wrapper.shadowRoot.querySelector("input");
    return input;
  }
  constructor() {
    super();
    this.teamsPhotos = {};
    this._inputValue = "";
    this._treeViewState = [];
    this._focusList = [];
    this.handleWindowClick = this.handleWindowClick.bind(this);
    this.addEventListener("focus", (_) => this.loadTeamsIfNotLoaded());
    this.addEventListener("mouseover", (_) => this.loadTeamsIfNotLoaded());
    this.addEventListener("blur", (_) => this.lostFocus());
    this.clearState();
  }
  /**
   * Invoked each time the custom element is appended into a document-connected element
   *
   * @memberof MgtTeamsChannelPicker
   */
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("click", this.handleWindowClick);
    const ownerDocument = this.renderRoot.ownerDocument;
    if (ownerDocument) {
      ownerDocument.documentElement.setAttribute("dir", this.direction);
    }
  }
  /**
   * Invoked each time the custom element is disconnected from the document's DOM
   *
   * @memberof MgtTeamsChannelPicker
   */
  disconnectedCallback() {
    window.removeEventListener("click", this.handleWindowClick);
    super.disconnectedCallback();
  }
  /**
   * selects a channel by looking up the id in the Graph
   *
   * @param {string} channelId MicrosoftGraph.Channel.id
   * @returns {Promise<return>} A promise that will resolve to true if channel was selected
   * @memberof MgtTeamsChannelPicker
   */
  selectChannelById(channelId) {
    return __awaiter26(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      if (provider && provider.state === ProviderState.SignedIn) {
        if (!this.items) {
          yield this.requestStateUpdate();
        }
        for (const item of this._treeViewState) {
          for (const channel of item.channels) {
            if (channel.item.id === channelId) {
              item.isExpanded = true;
              this.selectChannel(channel);
              this.markSelectedChannelInDropdown(channelId);
              return true;
            }
          }
        }
      }
      return false;
    });
  }
  /**
   * Marks a channel selected by ID as selected in the dropdown menu.
   * It ensures the parent team is set to as expanded to show the channel.
   * @param channelId ID string of the selected channel
   */
  markSelectedChannelInDropdown(channelId) {
    const treeItem = this.renderRoot.querySelector(`[id='${channelId}']`);
    if (treeItem) {
      treeItem.setAttribute("selected", "true");
      if (treeItem.parentElement) {
        treeItem.parentElement.setAttribute("expanded", "true");
      }
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return a lit-html TemplateResult.
   * Setting properties inside this method will not trigger the element to update.
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  render() {
    const dropdownClasses = {
      dropdown: true,
      visible: this._isDropdownVisible
    };
    return this.renderTemplate("default", { teams: this.items }) || html`
        <div class="container" @blur=${this.lostFocus}>
          <fluent-text-field
            appearance="outline"
            id="teams-channel-picker-input"
            aria-label="Select a channel"
            placeholder="${!!this._selectedItemState ? "" : this.strings.inputPlaceholderText} "
            label="teams-channel-picker-input"
            @click=${this.gainedFocus}
            @keyup=${(e) => this.handleInputChanged(e)}>
              <div slot="start" style="width: max-content;">${this.renderSelected()}</div>
              <div slot="end">${this.renderChevrons()}${this.renderCloseButton()}</div>
          </fluent-text-field>
          <fluent-card class=${classMap(dropdownClasses)}>
            ${this.renderDropdown()}
          </fluent-card>
        </div>`;
  }
  /**
   * Renders selected channel
   *
   * @protected
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderSelected() {
    var _a2, _b2, _c, _d, _e, _f;
    if (!this._selectedItemState) {
      return this.renderSearchIcon();
    }
    let icon;
    if (this._selectedItemState.parent.channels) {
      icon = html`<img
        class="team-photo"
        alt="${this._selectedItemState.parent.item.displayName}"
        src=${(_a2 = this.teamsPhotos[this._selectedItemState.parent.item.id]) === null || _a2 === void 0 ? void 0 : _a2.photo} />`;
    }
    const parentName = (_d = (_c = (_b2 = this._selectedItemState) === null || _b2 === void 0 ? void 0 : _b2.parent) === null || _c === void 0 ? void 0 : _c.item) === null || _d === void 0 ? void 0 : _d.displayName.trim();
    const channelName = (_f = (_e = this._selectedItemState) === null || _e === void 0 ? void 0 : _e.item) === null || _f === void 0 ? void 0 : _f.displayName.trim();
    return html`
      <fluent-breadcrumb title=${this._selectedItemState.item.displayName}>
        <fluent-breadcrumb-item>
          <span slot="start">${icon}</span>
          <span class="team-parent-name">${parentName}</span>
          <span slot="separator" class="arrow">${getSvg(SvgIcon.TeamSeparator, "#000000")}</span>
        </fluent-breadcrumb-item>
        <fluent-breadcrumb-item>${channelName}</fluent-breadcrumb-item>
      </fluent-breadcrumb>`;
  }
  /**
   * Clears the state of the component
   *
   * @protected
   * @memberof MgtTeamsChannelPicker
   */
  clearState() {
    this._items = [];
    this._inputValue = "";
    this._treeViewState = [];
    this._focusList = [];
    this._isDropdownVisible = false;
  }
  /**
   * Renders search icon
   *
   * @protected
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderSearchIcon() {
    return html`
      <div class="search-icon">
        ${getSvg(SvgIcon.Search, "#252424")}
      </div>
    `;
  }
  /**
   * Renders close button
   *
   * @protected
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderCloseButton() {
    return html`
      <div
        class="close-icon"
        style="display:none"
        @click="${() => this.removeSelectedChannel(null)}">
        <svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M0.0885911 0.215694L0.146447 0.146447C0.320013 -0.0271197 0.589437 -0.046405 0.784306 0.0885911L0.853553 0.146447L4 3.293L7.14645 0.146447C7.34171 -0.0488154 7.65829 -0.0488154 7.85355 0.146447C8.04882 0.341709 8.04882 0.658291 7.85355 0.853553L4.707 4L7.85355 7.14645C8.02712 7.32001 8.0464 7.58944 7.91141 7.78431L7.85355 7.85355C7.67999 8.02712 7.41056 8.0464 7.21569 7.91141L7.14645 7.85355L4 4.707L0.853553 7.85355C0.658291 8.04882 0.341709 8.04882 0.146447 7.85355C-0.0488154 7.65829 -0.0488154 7.34171 0.146447 7.14645L3.293 4L0.146447 0.853553C-0.0271197 0.679987 -0.046405 0.410563 0.0885911 0.215694L0.146447 0.146447L0.0885911 0.215694Z" fill="#212121"/>
        </svg>
      </div>
    `;
  }
  /**
   * Displays the close button after selecting a channel.
   */
  showCloseIcon() {
    const downChevron = this.renderRoot.querySelector(".down-chevron");
    const upChevron = this.renderRoot.querySelector(".up-chevron");
    const closeIcon = this.renderRoot.querySelector(".close-icon");
    if (downChevron) {
      downChevron.style.display = "none";
    }
    if (upChevron) {
      upChevron.style.display = "none";
    }
    if (closeIcon) {
      closeIcon.style.display = null;
    }
  }
  /**
   * Renders down chevron icon
   *
   * @protected
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderDownChevron() {
    return html`
      <div class="down-chevron" @click=${this.gainedFocus}>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2.21967 4.46967C2.51256 4.17678 2.98744 4.17678 3.28033 4.46967L6 7.18934L8.71967 4.46967C9.01256 4.17678 9.48744 4.17678 9.78033 4.46967C10.0732 4.76256 10.0732 5.23744 9.78033 5.53033L6.53033 8.78033C6.23744 9.07322 5.76256 9.07322 5.46967 8.78033L2.21967 5.53033C1.92678 5.23744 1.92678 4.76256 2.21967 4.46967Z" fill="#212121" />
        </svg>
      </div>`;
  }
  /**
   * Renders up chevron icon
   *
   * @protected
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderUpChevron() {
    return html`
      <div style="display:none" class="up-chevron" @click=${(e) => this.handleUpChevronClick(e)}>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2.21967 7.53033C2.51256 7.82322 2.98744 7.82322 3.28033 7.53033L6 4.81066L8.71967 7.53033C9.01256 7.82322 9.48744 7.82322 9.78033 7.53033C10.0732 7.23744 10.0732 6.76256 9.78033 6.46967L6.53033 3.21967C6.23744 2.92678 5.76256 2.92678 5.46967 3.21967L2.21967 6.46967C1.92678 6.76256 1.92678 7.23744 2.21967 7.53033Z" fill="#212121" />
        </svg>
      </div>`;
  }
  /**
   * Renders both chevrons
   */
  renderChevrons() {
    return html`${this.renderUpChevron()}${this.renderDownChevron()}`;
  }
  /**
   * Renders dropdown content
   *
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderDropdown() {
    if (this.isLoadingState || !this._treeViewState) {
      return this.renderLoading();
    }
    if (this._treeViewState) {
      if (!this.isLoadingState && this._treeViewState.length === 0 && this._inputValue.length > 0) {
        return this.renderError();
      }
      return this.renderDropdownList(this._treeViewState);
    }
    return html``;
  }
  /**
   * Renders the dropdown list recursively
   *
   * @protected
   * @param {ChannelPickerItemState[]} items
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderDropdownList(items) {
    if (items && items.length > 0) {
      let icon = null;
      return html`
        <fluent-tree-view
          class="tree-view"
          dir=${this.direction}>
          ${repeat(items, (itemObj) => itemObj === null || itemObj === void 0 ? void 0 : itemObj.item, (obj) => {
        if (obj.channels) {
          icon = html`<img
                  class="team-photo"
                  alt="${obj.item.displayName}"
                  src=${this.teamsPhotos[obj.item.id].photo} />`;
        }
        return html`
                <fluent-tree-item
                  ?expanded=${obj === null || obj === void 0 ? void 0 : obj.isExpanded}
                  @click=${(e) => this.handleTeamTreeItemClick(e)}>
                    ${icon}${obj.item.displayName}
                    ${repeat(obj === null || obj === void 0 ? void 0 : obj.channels, (channels) => channels.item, (channel) => {
          return this.renderItem(channel);
        })}
                </fluent-tree-item>`;
      })}
        </fluent-tree-view>`;
    }
    return null;
  }
  /**
   * Renders each Channel or Team
   *
   * @param {ChannelPickerItemState} itemState
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderItem(itemState) {
    var _a2;
    return html`
      <fluent-tree-item
        id=${(_a2 = itemState === null || itemState === void 0 ? void 0 : itemState.item) === null || _a2 === void 0 ? void 0 : _a2.id}
        @keydown=${(e) => this.onUserKeyDown(e, itemState)}
        @click=${() => this.handleItemClick(itemState)}>
          ${itemState === null || itemState === void 0 ? void 0 : itemState.item.displayName}
      </fluent-tree-item>`;
  }
  /**
   * Renders an error message when no channel or teams match the query
   *
   * @protected
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderError() {
    const template = this.renderTemplate("error", null, "error");
    return template || html`
        <div class="message-parent">
          <div
            label="search-error-text"
            aria-label="We didn't find any matches."
            class="search-error-text">
            ${this.strings.noResultsFound}
          </div>
        </div>
      `;
  }
  /**
   * Renders loading spinner while channels are fetched from the Graph
   *
   * @protected
   * @returns
   * @memberof MgtTeamsChannelPicker
   */
  renderLoading() {
    const template = this.renderTemplate("loading", null, "loading");
    return template || mgtHtml`
        <div class="message-parent">
          <mgt-spinner></mgt-spinner>
          <div label="loading-text" aria-label="loading" class="loading-text">
            ${this.strings.loadingMessage}
          </div>
        </div>
      `;
  }
  /**
   * Queries Microsoft Graph for Teams & respective channels then sets to items list
   *
   * @protected
   * @memberof MgtTeamsChannelPicker
   */
  loadState() {
    return __awaiter26(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      let teams;
      if (provider && provider.state === ProviderState.SignedIn) {
        const graph = provider.graph.forComponent(this);
        if (!(yield provider.getAccessTokenForScopes(...MgtTeamsChannelPicker_1.requiredScopes))) {
          return;
        }
        teams = yield getAllMyTeams(graph);
        teams = teams.filter((t) => !t.isArchived);
        let teamsIds = teams.map((t) => t.id);
        const beta = BetaGraph.fromGraph(graph);
        this.teamsPhotos = yield getTeamsPhotosforPhotoIds(beta, teamsIds);
        const batch = graph.createBatch();
        const scopes = ["team.readbasic.all"];
        for (const team of teams) {
          batch.get(team.id, `teams/${team.id}/channels`, scopes);
        }
        const responses = yield batch.executeAll();
        for (const team of teams) {
          const response = responses.get(team.id);
          if (response && response.content && response.content.value) {
            team.channels = response.content.value.map((c) => {
              return {
                item: c
              };
            });
          }
        }
        this.items = teams.map((t) => {
          return {
            channels: t.channels,
            item: t
          };
        });
      }
      this.filterList();
      this.resetFocusState();
    });
  }
  /**
   * Handles operations that are performed on the DOM when you remove a
   * channel. For example on clicking the X button.
   * @param item a selected channel item
   */
  removeSelectedChannel(item) {
    this.selectChannel(item);
    const treeItems = this.renderRoot.querySelectorAll("fluent-tree-item");
    if (treeItems) {
      treeItems.forEach((treeItem) => {
        treeItem.removeAttribute("expanded");
        treeItem.removeAttribute("selected");
      });
    }
  }
  handleItemClick(item) {
    if (item.channels) {
      item.isExpanded = !item.isExpanded;
    } else {
      this.selectChannel(item);
      this.lostFocus();
    }
  }
  handleTeamTreeItemClick(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    const element = event.target;
    if (element) {
      const expanded = element.getAttribute("expanded");
      if (!!expanded) {
        element.removeAttribute("expanded");
      } else {
        element.setAttribute("expanded", "true");
      }
      element.removeAttribute("selected");
      const hasId = element.getAttribute("id");
      if (hasId) {
        element.setAttribute("selected", "true");
      }
    }
  }
  handleInputChanged(e) {
    const target2 = e.target;
    if (this._inputValue !== (target2 === null || target2 === void 0 ? void 0 : target2.value)) {
      this._inputValue = target2 === null || target2 === void 0 ? void 0 : target2.value;
    } else {
      return;
    }
    this.gainedFocus();
    if (!this.debouncedSearch) {
      this.debouncedSearch = debounce(() => {
        this.filterList();
      }, 400);
    }
    this.debouncedSearch();
  }
  onUserKeyDown(e, item) {
    const key = e.code;
    switch (key) {
      case "Enter":
        this.selectChannel(item);
        this.resetFocusState();
        this.lostFocus();
        e.preventDefault();
        break;
      case "Backspace":
        if (this._inputValue.length === 0 && this._selectedItemState) {
          this.selectChannel(null);
          this.resetFocusState();
          e.preventDefault();
        }
        break;
    }
  }
  filterList() {
    if (this.items) {
      this._treeViewState = this.generateTreeViewState(this.items, this._inputValue);
      this.resetFocusState();
    }
  }
  generateTreeViewState(tree, filterString = "", parent = null) {
    const treeView = [];
    filterString = filterString.toLowerCase();
    if (tree) {
      for (const state2 of tree) {
        let stateItem;
        if (filterString.length === 0 || state2.item.displayName.toLowerCase().includes(filterString)) {
          stateItem = { item: state2.item, parent };
          if (state2.channels) {
            stateItem.channels = this.generateTreeViewState(state2.channels, "", stateItem);
            stateItem.isExpanded = filterString.length > 0;
          }
        } else if (state2.channels) {
          const newStateItem = { item: state2.item, parent };
          const channels = this.generateTreeViewState(state2.channels, filterString, newStateItem);
          if (channels.length > 0) {
            stateItem = newStateItem;
            stateItem.channels = channels;
            stateItem.isExpanded = true;
          }
        }
        if (stateItem) {
          treeView.push(stateItem);
        }
      }
    }
    return treeView;
  }
  // generates a flat list from a tree to facilitate easier focus
  // navigation
  generateFocusList(items) {
    if (!items || items.length === 0) {
      return [];
    }
    let array = [];
    for (const item of items) {
      array.push(item);
      if (item.channels && item.isExpanded) {
        array = [...array, ...this.generateFocusList(item.channels)];
      }
    }
    return array;
  }
  resetFocusState() {
    this._focusList = this.generateFocusList(this._treeViewState);
    this.requestUpdate();
  }
  loadTeamsIfNotLoaded() {
    if (!this.items && !this.isLoadingState) {
      this.requestStateUpdate();
    }
  }
  handleWindowClick(e) {
    if (e.target !== this) {
      this.lostFocus();
    }
  }
  gainedFocus() {
    this._isFocused = true;
    const input = this._input;
    if (input) {
      input.focus();
    }
    this._isDropdownVisible = true;
    this.toggleChevron();
    this.resetFocusState();
  }
  lostFocus() {
    const input = this._input;
    if (input) {
      input.value = this._inputValue = "";
      input.textContent = "";
    }
    this._isFocused = false;
    this._isDropdownVisible = false;
    this.filterList();
    this.toggleChevron();
    this.requestUpdate();
    if (this._selectedItemState !== void 0) {
      this.showCloseIcon();
    }
  }
  selectChannel(item) {
    if (item && this._selectedItemState !== item) {
      this._input.setAttribute("disabled", "true");
    } else {
      this._input.removeAttribute("disabled");
    }
    this._selectedItemState = item;
    this.lostFocus();
    this.fireCustomEvent("selectionChanged", this.selectedItem);
  }
  /**
   * Hides the close icon.
   */
  hideCloseIcon() {
    const closeIcon = this.renderRoot.querySelector(".close-icon");
    if (closeIcon) {
      closeIcon.style.display = "none";
    }
  }
  /**
   * Toggles the up and down chevron depending on the dropdown
   * visibility.
   */
  toggleChevron() {
    const downChevron = this.renderRoot.querySelector(".down-chevron");
    const upChevron = this.renderRoot.querySelector(".up-chevron");
    if (this._isDropdownVisible) {
      if (downChevron) {
        downChevron.style.display = "none";
      }
      if (upChevron) {
        upChevron.style.display = null;
      }
    } else {
      if (downChevron) {
        downChevron.style.display = null;
        this.hideCloseIcon();
      }
      if (upChevron) {
        upChevron.style.display = "none";
      }
    }
    this.hideCloseIcon();
  }
  handleUpChevronClick(e) {
    e.stopPropagation();
    this.lostFocus();
  }
};
MgtTeamsChannelPicker._config = {
  useTeamsBasedScopes: false
};
__decorate24([
  state(),
  __metadata21("design:type", Object)
], MgtTeamsChannelPicker.prototype, "_selectedItemState", void 0);
__decorate24([
  state(),
  __metadata21("design:type", Boolean)
], MgtTeamsChannelPicker.prototype, "_isDropdownVisible", void 0);
__decorate24([
  state(),
  __metadata21("design:type", Boolean)
], MgtTeamsChannelPicker.prototype, "_isFocused", void 0);
MgtTeamsChannelPicker = MgtTeamsChannelPicker_1 = __decorate24([
  customElement("teams-channel-picker"),
  __metadata21("design:paramtypes", [])
], MgtTeamsChannelPicker);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-todo/mgt-todo.js
init_lit();
init_es6();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks-base/mgt-tasks-base.js
init_lit();
init_decorators();
init_es6();

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks-base/strings.js
var strings15 = {
  cancelNewTaskSubtitle: "Cancel",
  newTaskPlaceholder: "Adding task...",
  addTaskButtonSubtitle: "Add",
  removeTaskSubtitle: "Delete Task"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-tasks-base/mgt-tasks-base.js
var __decorate25 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata22 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtTasksBase = class extends MgtTemplatedComponent {
  /**
   * The name of a potential new task
   *
   * @readonly
   * @protected
   * @type {string}
   * @memberof MgtTasksBase
   */
  get newTaskName() {
    return this._newTaskName;
  }
  get strings() {
    return strings15;
  }
  constructor() {
    super();
    this.clearState();
    this._previousMediaQuery = this.mediaQuery;
    this.onResize = this.onResize.bind(this);
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * @param {*} name
   * @param {*} oldValue
   * @param {*} newValue
   * @memberof MgtTasks
   */
  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);
    switch (name) {
      case "target-id":
      case "initial-id":
        this.clearState();
        this.requestStateUpdate();
        break;
    }
  }
  /**
   * updates provider state
   *
   * @memberof MgtTasks
   */
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("resize", this.onResize);
  }
  /**
   * removes updates on provider state
   *
   * @memberof MgtTasks
   */
  disconnectedCallback() {
    window.removeEventListener("resize", this.onResize);
    super.disconnectedCallback();
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */
  render() {
    const provider = Providers.globalProvider;
    if (!provider || provider.state !== ProviderState.SignedIn) {
      return html``;
    }
    if (this.isLoadingState) {
      return this.renderLoadingTask();
    }
    const headerTemplate = !this.hideHeader ? this.renderHeader() : null;
    const newTaskTemplate = this._isNewTaskVisible ? this.renderNewTaskPanel() : null;
    const tasksTemplate = this.isLoadingState ? this.renderLoadingTask() : this.renderTasks();
    return html`
      ${headerTemplate} ${newTaskTemplate}
      <div class="Tasks" dir=${this.direction}>
        ${tasksTemplate}
      </div>
    `;
  }
  /**
   * Render the header part of the component.
   *
   * @protected
   * @returns
   * @memberof MgtTodo
   */
  renderHeader() {
    const headerContentTemplate = this.renderHeaderContent();
    const addClasses = classMap({
      AddBarItem: true,
      NewTaskButton: true,
      hidden: this.readOnly || this._isNewTaskVisible
    });
    return html`
      <div class="Header" dir=${this.direction}>
        ${headerContentTemplate}
        <button class="${addClasses}" @click="${() => this.showNewTaskPanel()}">
          <span class="TaskIcon"></span>
          <span>${this.strings.addTaskButtonSubtitle}</span>
        </button>
      </div>
    `;
  }
  /**
   * Render a task in a loading state.
   *
   * @protected
   * @returns
   * @memberof MgtTodo
   */
  renderLoadingTask() {
    return html`
      <div class="Task LoadingTask">
        <div class="TaskContent">
          <div class="TaskCheckContainer">
            <div class="TaskCheck"></div>
          </div>
          <div class="TaskDetailsContainer">
            <div class="TaskTitle"></div>
            <div class="TaskDetails">
              <span class="TaskDetail">
                <div class="TaskDetailIcon"></div>
                <div class="TaskDetailName"></div>
              </span>
              <span class="TaskDetail">
                <div class="TaskDetailIcon"></div>
                <div class="TaskDetailName"></div>
              </span>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  /**
   * Render the panel for creating a new task
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtTasksBase
   */
  renderNewTaskPanel() {
    const newTaskName = this._newTaskName;
    const taskTitle = html`
      <input
        type="text"
        placeholder="${this.strings.newTaskPlaceholder}"
        .value="${newTaskName}"
        label="new-taskName-input"
        aria-label="new-taskName-input"
        role="textbox"
        @input="${(e) => {
      this._newTaskName = e.target.value;
      this.requestUpdate();
    }}"
      />
    `;
    const taskAddClasses = classMap({
      Disabled: !this._isNewTaskBeingAdded && (!newTaskName || !newTaskName.length),
      TaskAddButtonContainer: true
    });
    const taskAddTemplate = !this._isNewTaskBeingAdded ? html`
          <div
            tabindex='0'
            class="TaskIcon TaskAdd"
            @click="${() => this.addTask()}"
            @keypress="${(e) => {
      if (e.key === "Enter" || e.key === " ")
        this.addTask();
    }}"
          >
          <span>${this.strings.addTaskButtonSubtitle}</span>
          </div>
          <div
            role='button'
            tabindex='0'
            class="TaskIcon TaskCancel"
            @click="${() => this.hideNewTaskPanel()}"
            @keypress="${(e) => {
      if (e.key === "Enter" || e.key === " ")
        this.hideNewTaskPanel();
    }}">
            <span>${this.strings.cancelNewTaskSubtitle}</span>
          </div>
        ` : null;
    const newTaskDetailsTemplate = this.renderNewTaskDetails();
    return html`
      <div dir=${this.direction} class="Task NewTask Incomplete">
        <div class="TaskContent">
          <div class="TaskDetailsContainer">
            <div class="TaskTitle">
              ${taskTitle}
            </div>
            <div class="TaskDetails">
              ${newTaskDetailsTemplate}
            </div>
          </div>
        </div>
        <div class="${taskAddClasses}">
          ${taskAddTemplate}
        </div>
      </div>
    `;
  }
  /**
   * Render a bucket icon.
   *
   * @protected
   * @returns
   * @memberof MgtTodo
   */
  renderBucketIcon() {
    return html`
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M14 2H2V4H3H5H6H10H11H13H14V2ZM10 5H6V6H10V5ZM5 5H3V14H13V5H11V6C11 6.55228 10.5523 7 10 7H6C5.44772 7 5 6.55228 5 6V5ZM1 5H2V14V15H3H13H14V14V5H15V4V2V1H14H2H1V2V4V5Z"
          fill="#3C3C3C"
        />
      </svg>
    `;
  }
  /**
   * Render a calendar icon.
   *
   * @protected
   * @returns
   * @memberof MgtTodo
   */
  renderCalendarIcon() {
    return html`
        <svg width="16" height="20" viewBox="0 0 16 20" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M5 11C5.55228 11 6 10.5523 6 10C6 9.44771 5.55228 9 5 9C4.44772 9 4 9.44771 4 10C4 10.5523 4.44772 11 5 11ZM6 13C6 13.5523 5.55228 14 5 14C4.44772 14 4 13.5523 4 13C4 12.4477 4.44772 12 5 12C5.55228 12 6 12.4477 6 13ZM8 11C8.55229 11 9 10.5523 9 10C9 9.44771 8.55229 9 8 9C7.44771 9 7 9.44771 7 10C7 10.5523 7.44771 11 8 11ZM9 13C9 13.5523 8.55229 14 8 14C7.44771 14 7 13.5523 7 13C7 12.4477 7.44771 12 8 12C8.55229 12 9 12.4477 9 13ZM11 11C11.5523 11 12 10.5523 12 10C12 9.44771 11.5523 9 11 9C10.4477 9 10 9.44771 10 10C10 10.5523 10.4477 11 11 11ZM15 5.5C15 4.11929 13.8807 3 12.5 3H3.5C2.11929 3 1 4.11929 1 5.5V14.5C1 15.8807 2.11929 17 3.5 17H12.5C13.8807 17 15 15.8807 15 14.5V5.5ZM2 7H14V14.5C14 15.3284 13.3284 16 12.5 16H3.5C2.67157 16 2 15.3284 2 14.5V7ZM3.5 4H12.5C13.3284 4 14 4.67157 14 5.5V6H2V5.5C2 4.67157 2.67157 4 3.5 4Z" fill="#717171"/>
        </svg>
      `;
  }
  /**
   * Create a new todo task and add it to the list
   *
   * @protected
   * @returns
   * @memberof MgtTasksBase
   */
  addTask() {
    return __awaiter27(this, void 0, void 0, function* () {
      if (this._isNewTaskBeingAdded || !this.newTaskName) {
        return;
      }
      this._isNewTaskBeingAdded = true;
      this.requestUpdate();
      try {
        yield this.createNewTask();
      } finally {
        this._isNewTaskBeingAdded = false;
        this._isNewTaskVisible = false;
        this.requestUpdate();
      }
    });
  }
  /**
   * Clear the form data from the new task panel.
   *
   * @protected
   * @memberof MgtTasksBase
   */
  clearNewTaskData() {
    this._newTaskName = "";
  }
  /**
   * Clear the component state.
   *
   * @protected
   * @memberof MgtTasksBase
   */
  clearState() {
    this.clearNewTaskData();
    this._isNewTaskVisible = false;
    this.requestUpdate();
  }
  /**
   * Handle when a task is clicked
   *
   * @protected
   * @param {Event} e
   * @param {TodoTask} task
   * @memberof MgtTasksBase
   */
  handleTaskClick(e, task) {
    this.fireCustomEvent("taskClick", { task });
  }
  /**
   * Convert a date to a properly formatted string
   *
   * @protected
   * @param {Date} date
   * @returns
   * @memberof MgtTasksBase
   */
  dateToInputValue(date) {
    if (date) {
      return new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().split("T")[0];
    }
    return null;
  }
  showNewTaskPanel() {
    this._isNewTaskVisible = true;
    this.requestUpdate();
  }
  hideNewTaskPanel() {
    this._isNewTaskVisible = false;
    this.clearNewTaskData();
    this.requestUpdate();
  }
  onResize() {
    if (this.mediaQuery !== this._previousMediaQuery) {
      this._previousMediaQuery = this.mediaQuery;
      this.requestUpdate();
    }
  }
};
__decorate25([
  property({ attribute: "read-only", type: Boolean }),
  __metadata22("design:type", Boolean)
], MgtTasksBase.prototype, "readOnly", void 0);
__decorate25([
  property({ attribute: "hide-header", type: Boolean }),
  __metadata22("design:type", Boolean)
], MgtTasksBase.prototype, "hideHeader", void 0);
__decorate25([
  property({ attribute: "hide-options", type: Boolean }),
  __metadata22("design:type", Boolean)
], MgtTasksBase.prototype, "hideOptions", void 0);
__decorate25([
  property({ attribute: "target-id", type: String }),
  __metadata22("design:type", String)
], MgtTasksBase.prototype, "targetId", void 0);
__decorate25([
  property({ attribute: "initial-id", type: String }),
  __metadata22("design:type", String)
], MgtTasksBase.prototype, "initialId", void 0);

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-todo/graph.todo.js
init_es6();
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TaskStatus;
(function(TaskStatus2) {
  TaskStatus2[TaskStatus2["notStarted"] = 0] = "notStarted";
  TaskStatus2[TaskStatus2["inProgress"] = 1] = "inProgress";
  TaskStatus2[TaskStatus2["completed"] = 2] = "completed";
  TaskStatus2[TaskStatus2["deferred"] = 3] = "deferred";
  TaskStatus2[TaskStatus2["waitingOnOthers"] = 4] = "waitingOnOthers";
})(TaskStatus || (TaskStatus = {}));
var TaskImportance;
(function(TaskImportance2) {
  TaskImportance2[TaskImportance2["low"] = 0] = "low";
  TaskImportance2[TaskImportance2["normal"] = 1] = "normal";
  TaskImportance2[TaskImportance2["high"] = 2] = "high";
})(TaskImportance || (TaskImportance = {}));
var WellknownListName;
(function(WellknownListName2) {
  WellknownListName2[WellknownListName2["none"] = 0] = "none";
  WellknownListName2[WellknownListName2["default"] = 1] = "default";
  WellknownListName2[WellknownListName2["flaggedEmails"] = 2] = "flaggedEmails";
  WellknownListName2[WellknownListName2["unknownFutureValue"] = 3] = "unknownFutureValue";
})(WellknownListName || (WellknownListName = {}));
function getTodoTasks(graph, listId) {
  return __awaiter28(this, void 0, void 0, function* () {
    const tasks = yield graph.api(`/me/todo/lists/${listId}/tasks`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.Read")).get();
    return tasks && tasks.value;
  });
}
function getTodoTaskLists(graph) {
  return __awaiter28(this, void 0, void 0, function* () {
    const taskLists = yield graph.api("/me/todo/lists").header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.Read")).get();
    return taskLists && taskLists.value;
  });
}
function getTodoTaskList(graph, listId) {
  return __awaiter28(this, void 0, void 0, function* () {
    const taskList = yield graph.api(`/me/todo/lists/${listId}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.Read")).get();
    return taskList;
  });
}
function createTodoTask(graph, listId, taskData) {
  return __awaiter28(this, void 0, void 0, function* () {
    const task = yield graph.api(`/me/todo/lists/${listId}/tasks`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.ReadWrite")).post(taskData);
    return task;
  });
}
function deleteTodoTask(graph, listId, taskId) {
  return __awaiter28(this, void 0, void 0, function* () {
    yield graph.api(`/me/todo/lists/${listId}/tasks/${taskId}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.ReadWrite")).delete();
  });
}
function updateTodoTask(graph, listId, taskId, taskData) {
  return __awaiter28(this, void 0, void 0, function* () {
    const task = yield graph.api(`/me/todo/lists/${listId}/tasks/${taskId}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Tasks.ReadWrite")).patch(taskData);
    return task;
  });
}

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-todo/mgt-todo-css.js
init_lit();
var styles21 = [
  css`
:host([hidden]){display:none}:host{display:block;--default-font-family:"Segoe UI","Segoe UI Web (West European)","Segoe UI",-apple-system,BlinkMacSystemFont,Roboto,"Helvetica Neue",sans-serif;--default-font-size:14px;--theme-primary-color:#0078d7;--theme-dark-color:#005a9e}.ms-Icon{display:inline-block;font-family:FabricMDL2Icons;font-style:normal;font-weight:400;font-size:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:4px 0}.ms-Icon--ChevronDown::before{content:"\\\e70d"}.ms-Icon--ChevronUp::before{content:"\\\e70e"}.ms-Icon--Contact::before{content:"\\\e77b"}.ms-Icon--AddFriend::before{content:"\\\e8fa"}.ms-Icon--OutlookLogoInverse::before{content:"\\\eb6d"}.mgt-light{--color:#000000;--color-sub1:var(--neutral-foreground-rest, #1a1a1a);--color-sub2:var(--neutral-foreground-hint, #717171);--color-sub3:#727170;--background-color:#ffffff;--background-color--hover:var(--neutral-fill-hover, #f7f7f7);--background-color--active:#e1dfdd;--background-color-sub1:#faf9f8;--background-color-sub2:#f3f2f1;--box-shadow:0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132);--box-shadow-color:rgba(0, 0, 0, 0.092);--icon-color:#605e5c;--icon-color-sub3:#023b8f;--icon-color--hover:#605e5c;--icon-color__sub3--hover:#023b8f;--tab-line-color:#d6d6d6;--tab-line-color--hover:#727170;--tab-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--title-color-main:#000000;--title-color-subtitle:var(--neutral-foreground-rest, #1a1a1a);--title-color-sub2:var(--neutral-foreground-hint, #717171);--line-seperator-color:#d6d6d6;--line-seperator-color-sub1:#ebebeb;--placeholder-color:#605e5c;--placeholder-color--focus:var(--neutral-foreground-rest, #1a1a1a);--input-background-color:#ffffff;--input-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--input-background-color--focus:#ffffff;--input-border:2px solid #605e5c;--input-border-top:var(--input-border, 2px solid #605e5c);--input-border-right:var(--input-border, 2px solid #605e5c);--input-border-bottom:var(--input-border, 2px solid #605e5c);--input-border-left:var(--input-border, 2px solid #605e5c);--input-border-color--hover:#323130;--input-border-color--focus:#023b8f;--list-background-color:#ffffff;--list-item-background-color--hover:var(--neutral-fill-hover, #f7f7f7);--dropdown-item-text-color:#000000;--dropdown-item-text-hover-color:#000000}.mgt-dark{--color:#ffffff;--color-sub1:#f3f2f1;--color-sub2:#c8c6c4;--color-sub3:#727170;--background-color:#000000;--background-color--hover:#323130;--background-color--active:#4f4f4f;--background-color-sub1:#161514;--background-color-sub2:#4f4f4f;--box-shadow:0 5px 14px 0 rgba(0, 0, 0, 0.8);--box-shadow-color:black;--icon-color:#717171;--icon-color-sub3:#ffffff;--icon-color--hover:#717171;--icon-color__sub3--hover:#ffffff;--tab-line-color:#3b3a39;--tab-line-color--hover:#727170;--tab-background-color--hover:#323130;--title-color-main:#ffffff;--title-color-subtitle:#f3f2f1;--title-color-sub2:#c8c6c4;--line-seperator-color:#3b3a39;--line-seperator-color-sub1:#faf9f8;--placeholder-color:#717171;--placeholder-color--focus:#f3f2f1;--input-background-color:#000000;--input-background-color--hover:#323130;--input-background-color--focus:#4f4f4f;--input-border:2px solid #8a8886;--input-border-top:var(--input-border, 2px solid #8a8886);--input-border-right:var(--input-border, 2px solid #8a8886);--input-border-bottom:var(--input-border, 2px solid #8a8886);--input-border-left:var(--input-border, 2px solid #8a8886);--input-border-color--hover:#a19f9d;--input-border-color--focus:#023b8f;--list-background-color:#161514;--list-item-background-color--hover:#323130;--dropdown-item-text-color:#ffffff;--dropdown-item-text-hover-color:#ffffff}.mgt-light{--task-border:1px solid #e1dfdd;--task-complete-border:2px dotted #e1dfdd;--task-new-add-button-disabled-background:#ebebeb;--task-icon-color:#000000}.mgt-dark{--task-border:1px solid #717171;--task-complete-border:2px dotted #717171;--task-new-add-button-disabled-background:#4f4f4f;--task-icon-color:#ffffff}:host{font-family:var(--default-font-family);display:flex;flex-direction:column;background-color:var(--background-color-sub1,#faf9f8);padding:var(--tasks-padding,12px);color:var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a))}:host input[type=date]::-webkit-calendar-picker-indicator,:host input[type=date]::-webkit-inner-spin-button{display:none;-webkit-appearance:none}:host .TaskIcon{font-family:FabricMDL2Icons;user-select:none;-moz-user-select:none;-ms-user-select:none}:host .TaskIcon.Divider{vertical-align:initial;margin:0 12px;font-size:16px}:host .Header{padding:var(--tasks-header-padding,0);margin:var(--tasks-header-margin,0 0 12px 0);padding:var(--tasks-title-padding,0);display:flex;align-items:center;justify-content:space-between}:host .Header .header__loading{max-width:90px;width:100%;height:20px;background:#f2f2f2}:host .Header select{font-family:var(--default-font-family, "Segoe UI");font-size:var(--tasks-plan-title-font-size,1.1em);padding:var(--tasks-plan-title-padding,5px);border:none;-moz-appearance:none;-webkit-appearance:none;cursor:pointer}:host .Header select::-ms-expand{display:none}:host .Header .PlanTitle{font-family:var(--default-font-family, "Segoe UI");font-size:var(--tasks-plan-title-font-size,1.1em);padding:var(--tasks-plan-title-padding,5px)}:host .Header .AddBar{display:flex}:host .Header .AddBar .AddBarItem{flex:1 1 auto}:host .Header .NewTaskDue{display:flex}:host .Header .NewTaskDue input{flex:1 1 auto;background-color:var(--background-color-sub1,#faf9f8)}:host .Header .TitleCont{flex:1 1 auto;display:flex;align-items:center;height:var(--tasks-new-button-height,34px)}:host .Header .NewTaskButton{flex:0 0 auto;display:flex;justify-content:center;align-items:center;width:var(--tasks-new-button-width,auto);height:var(--tasks-new-button-height,32px);border-radius:2px;padding:0 20px;background:var(--tasks-new-button-background,#0078d4);border:var(--tasks-new-button-border,solid 1px transparent);color:var(--tasks-new-button-color,#fff);user-select:none;-moz-user-select:none;-ms-user-select:none;cursor:pointer}:host .Header .NewTaskButton span{font-size:14px;font-weight:600;letter-spacing:.1px;line-height:14px}:host .Header .NewTaskButton .TaskIcon{margin-right:8px}:host .Header .NewTaskButton.hidden{visibility:hidden}:host .Header .NewTaskButton:hover{background:var(--tasks-new-button-hover-background,#106ebe)}:host .Header .NewTaskButton:active{background:var(--tasks-new-button-active-background,#005a9e)}:host .Task{position:relative;margin:var(--task-margin,0 0 18px 0);padding:var(--task-padding,0 0 0 0);background-color:var(--tasks-background-color,var(--background-color,#fff));border:var(--task-border,1px solid #e1dfdd);border-radius:8px}:host .Task .TaskContent{display:flex}:host .Task .TaskContent .Divider{position:absolute;height:2px;left:0;right:0;bottom:0;background-color:var(--background-color-sub1,#faf9f8)}:host .Task .TaskContent .TaskDetailsContainer{flex:1;display:grid;display:-ms-grid;grid-template-columns:auto 1fr;-ms-grid-columns:auto 1fr;grid-template-rows:auto auto auto auto;-ms-grid-rows:auto auto auto auto;justify-content:space-between;align-items:flex-start;color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:12px;font-weight:600;white-space:normal;margin-bottom:12px}:host .Task .TaskContent .TaskDetailsContainer .TaskDetail{width:100%;height:100%;margin:4px 24px 6px 0;display:flex;justify-content:flex-start;align-items:center}:host .Task .TaskContent .TaskDetailsContainer .TaskTitle{color:var(--task-title-color,var(--title-color-subtitle,var(--neutral-foreground-rest,#1a1a1a)));font-size:14px;font-weight:600;grid-row:1;-ms-grid-row:1;grid-column:1/3;-ms-grid-column:1;-ms-grid-column-span:2;margin:22px 0 4px}:host .Task .TaskContent .TaskDetailsContainer .TaskGroup{min-height:24px;grid-row:2;-ms-grid-row:2;grid-column:1;-ms-grid-column:1}:host .Task .TaskContent .TaskDetailsContainer .TaskBucket{min-height:24px;grid-row:2;-ms-grid-row:2;grid-column:2;-ms-grid-column:2}:host .Task .TaskContent .TaskDetailsContainer .TaskDue{justify-content:flex-end;align-items:flex-start;grid-row:4;-ms-grid-row:4;grid-column:1/3;-ms-grid-column:1;-ms-grid-column-span:2}:host .Task .TaskContent .TaskDetailsContainer.tablet{grid-template-columns:1fr .5fr 1fr .5fr;-ms-grid-columns:1fr .5fr 1fr .5fr;grid-template-rows:auto auto;-ms-grid-rows:auto auto}:host .Task .TaskContent .TaskDetailsContainer.tablet.NoPlan{grid-template-columns:0 1fr 1fr 1fr;-ms-grid-columns:0 1fr 1fr 1fr}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskDetail{margin:4px 24px 6px 0}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskTitle{grid-row:1;-ms-grid-row:1;grid-column:1/5;-ms-grid-column:1;-ms-grid-column-span:4}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskGroup{grid-row:2;-ms-grid-row:2;grid-column:1;-ms-grid-column:1}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskBucket{grid-row:2;-ms-grid-row:2;grid-column:2;-ms-grid-column:2}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskAssignee{grid-row:2;-ms-grid-row:2;grid-column:3;-ms-grid-column:3}:host .Task .TaskContent .TaskDetailsContainer.tablet .TaskDue{justify-content:flex-start;align-items:center;grid-row:2;-ms-grid-row:2;grid-column:4;-ms-grid-column:4}:host .Task .TaskContent .TaskDetailsContainer.desktop{grid-template-columns:2fr 1fr .5fr 1fr .5fr;-ms-grid-columns:2fr 1fr .5fr 1fr .5fr;grid-template-rows:auto;-ms-grid-rows:auto;margin:0}:host .Task .TaskContent .TaskDetailsContainer.desktop.NoPlan{grid-template-columns:2fr 0 1fr 1fr 1fr;-ms-grid-columns:2fr 0 1fr 1fr 1fr}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskDetail{margin:0 24px 0 0}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskTitle{padding:0;grid-row:1;-ms-grid-row:1;grid-column:1;-ms-grid-column:1}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskGroup{min-height:61px;grid-row:1;-ms-grid-row:1;grid-column:2;-ms-grid-column:2}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskBucket{grid-row:1;-ms-grid-row:1;grid-column:3;-ms-grid-column:3}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskAssignee{grid-row:1;-ms-grid-row:1;grid-column:4;-ms-grid-column:4}:host .Task .TaskContent .TaskDetailsContainer.desktop .TaskDue{justify-content:flex-start;align-items:center;grid-row:1;-ms-grid-row:1;grid-column:5;-ms-grid-column:5}:host .Task .TaskContent .TaskDetailsContainer svg{vertical-align:middle;margin-right:4px}:host .Task .TaskContent .TaskDetailsContainer svg path{fill:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)))}:host .Task .TaskContent .TaskDetailsContainer select,:host .Task .TaskContent .TaskDetailsContainer span{vertical-align:middle;color:var(--color-sub2,var(--neutral-foreground-hint,#717171))}:host .Task .TaskContent .TaskDetailsContainer .TaskIcon{color:#797775;margin-right:8px}:host .Task .TaskContent .TaskDetailsContainer .people{color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:16px}:host .Task .TaskContent .TaskDetailsContainer .person{display:inline-block}:host .Task .TaskContent .TaskDetailsContainer .Picker{background-color:var(--background-color-sub1,#faf9f8);-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box;width:var(--mgt-flyout-set-width,350px);color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)))}:host .Task .TaskContent .TaskDetailsContainer .Picker .people-picker{--separator-margin:0px 10px 0px 10px}:host .Task .TaskContent .TaskDetailsContainer input,:host .Task .TaskContent .TaskDetailsContainer select{color:var(--task-detail-color,var(--color-sub2,var(--neutral-foreground-hint,#717171)));font-size:.9em;background-color:var(--background-color-sub1,#faf9f8)}:host .Task .TaskCheckContainer{font-family:FabricMDL2Icons;display:inline-block;border-radius:50%;color:#fff;cursor:pointer;display:flex;align-items:var(--task-icon-alignment,flex-start);margin:21px 10px 20px 20px;user-select:none;-moz-user-select:none;-ms-user-select:none}:host .Task .TaskCheckContainer.Complete .TaskCheck{background-color:var(--task-icon-background-completed,#00ad56);border:var(--task-icon-border-completed,solid 1px #fff);color:var(--task-icon-color-completed,#fff)}:host .Task .TaskCheckContainer.Complete .TaskContent .TaskDetailsContainer .TaskTitle{text-decoration:line-through;color:var(--color-sub3,#727170)}:host .Task .TaskCheckContainer .TaskCheck{font-family:FabricMDL2Icons;font-size:12px;display:inline-block;width:18px;height:18px;border-radius:var(--task-icon-border-radius,50%);border:var(--task-icon-border,solid 1px #797775);color:var(--task-icon-color,#000);display:flex;justify-content:center;align-items:center;background-color:var(--task-icon-background,transparent);user-select:none;-moz-user-select:none;-ms-user-select:none}:host .Task .TaskCheckContainer .TaskCheck.Loading .TaskCheckContent{animation:rotateIcon 2s infinite linear}:host .Task .TaskOptions{cursor:pointer;user-select:none;-moz-user-select:none;-ms-user-select:none;margin:16px 8px 0 0}:host .Task.ReadOnly .TaskCheckContainer{cursor:default}:host .Task.Complete{background:var(--task-complete-background,var(--background-color-sub1,#faf9f8));border:var(--task-complete-border,2px dotted #e1dfdd)}:host .Task.Complete .TaskContent .TaskDetailsContainer .TaskTitle{text-decoration:line-through;color:var(--color-sub3,#727170)}:host .Task.NewTask{margin:var(--task-new-margin,var(--task-margin,0 0 24px 0));display:flex;flex-direction:row}:host .Task.NewTask .SelfAssign{display:none}:host .Task.NewTask .AssignTo{border:0;background:0 0}:host .Task.NewTask .FakeCheckBox{width:15px;height:15px;cursor:pointer;margin:0 5px 0 5px}:host .Task.NewTask .FakeCheckBox::after{font-family:FabricMDL2Icons;content:"uE739"}:host .Task.NewTask .FakeCheckBox~:checked{font-family:FabricMDL2Icons;content:"uE73A"}:host .Task.NewTask .TaskContent{flex:1 1 auto;align-content:center;vertical-align:middle;margin:0 0 0 12px}:host .Task.NewTask .TaskContent .TaskDetailsContainer{display:flex;flex-direction:column;align-items:stretch;margin:0}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle{display:flex;height:32px;padding:2px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input{flex:1;font-family:var(--default-font-family, "Segoe UI");margin:var(--task-new-input-margin,0 24px 0 16px);padding:var(--task-new-input-padding,6px);font-size:var(--task-new-input-font-size,14px);font-weight:600;border:var(--task-new-border,none);border-bottom:1px solid #e1dfdd;outline:0;border-radius:0;background-color:var(--background-color-sub1,#faf9f8)}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input:hover{border-bottom:1px solid #106ebe}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input:active{border-bottom:1px solid #005a9e}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskTitle input:focus{border-bottom:1px solid #0078d4}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails{display:flex;justify-content:stretch;align-items:center;flex-wrap:wrap;margin:14px 0 14px 4px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskGroup{margin:8px 16px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskBucket{margin:8px 16px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskDue{margin:8px 16px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .NewTaskAssignee{margin:8px 16px;min-width:80px}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails .TaskPeople label{display:flex;align-content:center;align-items:center}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select{font-family:var(--default-font-family);font-size:12px;font-weight:600;border:var(--task-new-select-border,none);border-bottom:1px solid #e1dfdd}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input:hover,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select:hover{border-bottom:1px solid #106ebe}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input:active,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select:active{border-bottom:1px solid #005a9e}:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails input:focus,:host .Task.NewTask .TaskContent .TaskDetailsContainer .TaskDetails select:focus{border-bottom:1px solid #0078d4}:host .Task.NewTask .TaskAddButtonContainer{margin-right:28px}:host .Task.NewTask .TaskAddButtonContainer .TaskAdd,:host .Task.NewTask .TaskAddButtonContainer .TaskCancel{justify-content:center;align-items:center;cursor:pointer;flex:0 0 auto;display:flex;width:var(--tasks-new-button-width,100px);height:var(--tasks-new-button-height,32px);border-radius:4px;border:var(--tasks-new-button-border,solid 1px #e5e5e5);font-family:var(--default-font-family, "Segoe UI");font-size:14px;line-height:20px}:host .Task.NewTask .TaskAddButtonContainer .TaskAdd{color:#fff;background:var(--task-new-add-button-background,#0078d4);margin:22px 0 12px auto}:host .Task.NewTask .TaskAddButtonContainer .TaskCancel{color:var(--task-new-cancel-button-color,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)))}:host .Task.NewTask .TaskAddButtonContainer.Disabled .TaskAdd{color:var(--task-new-cancel-button-color,var(--color-sub1,var(--neutral-foreground-rest,#1a1a1a)));background:var(--task-new-add-button-disabled-background,#fff);cursor:default}:host .Task.LoadingTask .TaskCheckContainer{cursor:default}:host .Task.LoadingTask .TaskDetails{display:flex}:host .Task.LoadingTask .TaskCheck{background:#f2f2f2;border-color:#f2f2f2;cursor:default}:host .Task.LoadingTask .TaskDetailIcon{width:16px;height:16px;margin:5px;background:#f2f2f2}:host .Task.LoadingTask .TaskTitle{background:#f2f2f2;max-width:400px;height:20px;margin-right:20px!important}:host .Task.LoadingTask .TaskDetail{margin-right:12px;display:flex;flex-direction:row;align-items:center}:host .Task.LoadingTask .TaskDetailName{width:81px;height:10px;background:#f2f2f2}@keyframes rotateIcon{from{transform:rotate(0)}to{transform:rotate(360deg)}}[dir=rtl] .arrow-options{--arrow-options-left:auto}[dir=rtl] .dot-options{--dot-options-translateX:translateX(60px)}[dir=rtl] .TaskDetails{margin-right:14px!important}[dir=rtl] .TaskIcon{margin-left:8px}[dir=rtl] .TaskDetail svg{margin-left:4px}@media (forced-colors:active) and (prefers-color-scheme:dark){:host svg{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}:host svg path{fill:#fff!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}@media (forced-colors:active) and (prefers-color-scheme:light){:host svg{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}:host svg path{fill:#000!important;fill-rule:nonzero!important;clip-rule:nonzero!important}}:host{border-radius:8px}:host .Task{border:none}
`
];

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-todo/strings.js
var strings16 = {
  cancelNewTaskSubtitle: "Cancel",
  newTaskPlaceholder: "Adding task...",
  addTaskButtonSubtitle: "Add",
  removeTaskSubtitle: "Delete Task"
};

// node_modules/@microsoft/mgt-components/dist/es6/components/mgt-todo/mgt-todo.js
var __decorate26 = function(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
};
var __metadata23 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MgtTodo = class MgtTodo2 extends MgtTasksBase {
  /**
   * Array of styles to apply to the element. The styles should be defined
   * using the `css` tag function.
   */
  static get styles() {
    return styles21;
  }
  get strings() {
    return strings16;
  }
  /**
   * Get the scopes required for todo
   *
   * @static
   * @return {*}  {string[]}
   * @memberof MgtTodo
   */
  static get requiredScopes() {
    return ["tasks.read", "tasks.readwrite"];
  }
  constructor() {
    super();
    this._graph = null;
    this._newTaskDueDate = null;
    this._newTaskListId = "";
    this._currentList = null;
    this._lists = [];
    this._tasks = [];
    this._loadingTasks = [];
    this._isLoadingTasks = false;
  }
  /**
   * Render the list of todo tasks
   */
  renderTasks() {
    if (this._isLoadingTasks) {
      return this.renderLoadingTask();
    }
    let tasks = this._tasks;
    if (tasks && this.taskFilter) {
      tasks = tasks.filter((task) => this.taskFilter(task));
    }
    const taskTemplates = repeat(tasks, (task) => task.id, (task) => this.renderTask(task));
    return html`
      ${taskTemplates}
    `;
  }
  /**
   * Render the details part of the new task panel
   *
   * @protected
   * @returns {TemplateResult}
   * @memberof MgtTodo
   */
  renderNewTaskDetails() {
    const lists = this._lists.filter((list) => this._currentList && list.id === this._currentList.id || !this._currentList && list.id === this._newTaskListId);
    if (lists.length > 0 && !this._newTaskListId) {
      this._newTaskListId = lists[0].id;
    }
    const taskList = this._currentList ? html`
          <span class="NewTaskGroup">
            ${this.renderBucketIcon()}
            <span>${this._currentList.displayName}</span>
          </span>
        ` : html`
          <span class="NewTaskGroup">
            ${this.renderBucketIcon()}
            <select
              .value="${this._newTaskListId}"
              @change="${(e) => {
      this._newTaskListId = e.target.value;
    }}"
            >
              ${lists.map((list) => html`
                  <option value="${list.id}">${list.displayName}</option>
                `)}
            </select>
          </span>
        `;
    const taskDue = html`
      <span class="NewTaskDue">
        ${this.renderCalendarIcon()}
        <input
          type="date"
          label="new-taskDate-input"
          aria-label="new-taskDate-input"
          role="textbox"
          .value="${this.dateToInputValue(this._newTaskDueDate)}"
          @change="${(e) => {
      const value = e.target.value;
      if (value) {
        this._newTaskDueDate = /* @__PURE__ */ new Date(value + "T17:00");
      } else {
        this._newTaskDueDate = null;
      }
    }}"
        />
      </span>
    `;
    return html`
      ${taskList} ${taskDue}
    `;
  }
  /**
   * Render the header part of the component.
   *
   * @protected
   * @returns
   * @memberof MgtTodo
   */
  renderHeaderContent() {
    if (this.isLoadingState) {
      return html`
        <div class="header__loading"></div>
      `;
    }
    const lists = this._lists || [];
    const currentList = this._currentList;
    const targetId = this.targetId;
    let listSelect;
    if (targetId && lists.length) {
      const list = lists.find((l) => l.id === targetId);
      if (list) {
        listSelect = html`
          <span class="PlanTitle">
            ${list.displayName}
          </span>
        `;
      }
    } else if (currentList) {
      const listOptions = {};
      for (const l of lists) {
        listOptions[l.displayName] = () => this.loadTaskList(l);
      }
      listSelect = mgtHtml`
        <mgt-arrow-options .value="${currentList.displayName}" .options="${listOptions}"></mgt-arrow-options>
      `;
    }
    return html`
      <span class="TitleCont">
        ${listSelect}
      </span>
    `;
  }
  /**
   * Render a task in the list.
   *
   * @protected
   * @param {TodoTask} task
   * @returns
   * @memberof MgtTodo
   */
  renderTask(task) {
    const context = { task, list: this._currentList };
    if (this.hasTemplate("task")) {
      return this.renderTemplate("task", context, task.id);
    }
    const isCompleted = TaskStatus[task.status] === TaskStatus.completed;
    const isLoading = this._loadingTasks.includes(task.id);
    const taskCheckClasses = {
      Complete: !isLoading && isCompleted,
      Loading: isLoading,
      TaskCheck: true,
      TaskIcon: true
    };
    const taskCheckContent = isLoading ? html`
          
        ` : isCompleted ? html`
          
        ` : null;
    let taskDetailsTemplate = null;
    if (this.hasTemplate("task-details")) {
      taskDetailsTemplate = this.renderTemplate("task-details", context, `task-details-${task.id}`);
    } else {
      const taskDueTemplate = task.dueDateTime ? html`
            <div class="TaskDetail TaskDue">
              <span>Due ${getShortDateString(new Date(task.dueDateTime.dateTime))}</span>
            </div>
          ` : null;
      taskDetailsTemplate = html`
        <div class="TaskTitle">
          ${task.title}
        </div>
        <div class="TaskDetail TaskBucket">
          ${this.renderBucketIcon()}
          <span>${this._currentList.displayName}</span>
        </div>
        ${taskDueTemplate}
      `;
    }
    const taskOptionsTemplate = !this.readOnly && !this.hideOptions ? mgtHtml`
            <div class="TaskOptions">
              <mgt-dot-options
                .options="${{
      [this.strings.removeTaskSubtitle]: (e) => this.removeTask(e, task.id)
    }}"
              ></mgt-dot-options>
            </div>
          ` : null;
    const taskClasses = classMap({
      Complete: isCompleted,
      Incomplete: !isCompleted,
      ReadOnly: this.readOnly,
      Task: true
    });
    const taskCheckContainerClasses = classMap({
      Complete: isCompleted,
      Incomplete: !isCompleted,
      TaskCheckContainer: true
    });
    return html`
      <div class=${taskClasses}>
        <div class="TaskContent" @click="${(e) => this.handleTaskClick(e, task)}}">
          <span class=${taskCheckContainerClasses} @click="${(e) => this.handleTaskCheckClick(e, task)}">
            <span class=${classMap(taskCheckClasses)}>
              <span class="TaskCheckContent">${taskCheckContent}</span>
            </span>
          </span>
          <div class="TaskDetailsContainer ${this.mediaQuery}">
            ${taskDetailsTemplate}
          </div>
          ${taskOptionsTemplate}
          <div class="Divider"></div>
        </div>
      </div>
    `;
  }
  /**
   * loads tasks from dataSource
   *
   * @returns
   * @memberof MgtTasks
   */
  loadState() {
    return __awaiter29(this, void 0, void 0, function* () {
      const provider = Providers.globalProvider;
      if (!provider || provider.state !== ProviderState.SignedIn) {
        return;
      }
      if (!this._graph) {
        const graph = provider.graph.forComponent(this);
        this._graph = graph;
      }
      let lists = this._lists;
      if (!lists || !lists.length) {
        if (this.targetId) {
          const targetList = yield getTodoTaskList(this._graph, this.targetId);
          lists = targetList ? [targetList] : [];
        } else {
          lists = yield getTodoTaskLists(this._graph);
        }
        this._tasks = [];
        this._currentList = null;
        this._lists = lists;
      }
      let currentList = this._currentList;
      if (!currentList && lists && lists.length) {
        if (this.initialId) {
          currentList = lists.find((l) => l.id === this.initialId);
        }
        if (!currentList) {
          currentList = lists[0];
        }
        this._tasks = [];
        this._currentList = currentList;
      }
      if (currentList) {
        yield this.loadTaskList(currentList);
      }
    });
  }
  /**
   * Send a request the Graph to create a new todo task item
   *
   * @protected
   * @returns {Promise<any>}
   * @memberof MgtTodo
   */
  createNewTask() {
    return __awaiter29(this, void 0, void 0, function* () {
      const listId = this._currentList.id;
      const taskData = {
        title: this.newTaskName
      };
      if (this._newTaskDueDate) {
        taskData["dueDateTime"] = {
          dateTime: this._newTaskDueDate.toLocaleDateString(),
          timeZone: "UTC"
        };
      }
      const task = yield createTodoTask(this._graph, listId, taskData);
      this._tasks.unshift(task);
    });
  }
  /**
   * Clear out the new task metadata input fields
   *
   * @protected
   * @memberof MgtTodo
   */
  clearNewTaskData() {
    super.clearNewTaskData();
    this._newTaskDueDate = null;
    this._newTaskListId = null;
  }
  /**
   * Clear the state of the component
   *
   * @protected
   * @memberof MgtTodo
   */
  clearState() {
    super.clearState();
    this._currentList = null;
    this._lists = [];
    this._tasks = [];
    this._loadingTasks = [];
    this._isLoadingTasks = false;
  }
  loadTaskList(list) {
    return __awaiter29(this, void 0, void 0, function* () {
      this._isLoadingTasks = true;
      this._currentList = list;
      this.requestUpdate();
      this._tasks = yield getTodoTasks(this._graph, list.id);
      this._isLoadingTasks = false;
      this.requestUpdate();
    });
  }
  updateTaskStatus(task, taskStatus) {
    return __awaiter29(this, void 0, void 0, function* () {
      this._loadingTasks = [...this._loadingTasks, task.id];
      this.requestUpdate();
      task.status = taskStatus;
      const listId = this._currentList.id;
      task = yield updateTodoTask(this._graph, listId, task.id, task);
      const taskIndex = this._tasks.findIndex((t) => t.id === task.id);
      this._tasks[taskIndex] = task;
      this._loadingTasks = this._loadingTasks.filter((id) => id !== task.id);
      this.requestUpdate();
    });
  }
  // tslint:disable-next-line: completed-docs
  removeTask(e, taskId) {
    return __awaiter29(this, void 0, void 0, function* () {
      this._tasks = this._tasks.filter((t) => t.id !== taskId);
      this.requestUpdate();
      const listId = this._currentList.id;
      yield deleteTodoTask(this._graph, listId, taskId);
      this._tasks = this._tasks.filter((t) => t.id !== taskId);
    });
  }
  handleTaskCheckClick(e, task) {
    if (!this.readOnly) {
      if (TaskStatus[task.status] === TaskStatus.completed) {
        this.updateTaskStatus(task, TaskStatus.notStarted);
      } else {
        this.updateTaskStatus(task, TaskStatus.completed);
      }
      e.stopPropagation();
      e.preventDefault();
    }
  }
};
MgtTodo = __decorate26([
  customElement("todo"),
  __metadata23("design:paramtypes", [])
], MgtTodo);

// node_modules/@microsoft/mgt-components/dist/es6/components/components.js
var import_mgt_theme_toggle = __toESM(require_mgt_theme_toggle());
__reExport(components_exports, __toESM(require_mgt_theme_toggle()));

// node_modules/@microsoft/mgt-components/dist/es6/index.js
__reExport(es6_exports, components_exports);

// node_modules/@microsoft/mgt-react/dist/es6/index.js
__reExport(es6_exports2, es6_exports);
init_es6();
export {
  Agenda,
  BatchResponse,
  BetaGraph,
  CacheService,
  CacheStore,
  ComponentMediaQuery,
  EventDispatcher,
  File,
  FileList,
  Get,
  Graph,
  GraphPageIterator,
  GroupType,
  IProvider,
  LocalizationHelper,
  Login,
  LoginType,
  MICROSOFT_GRAPH_DEFAULT_ENDPOINT,
  MICROSOFT_GRAPH_ENDPOINTS,
  Mgt,
  MgtAgenda,
  MgtBaseComponent,
  MgtBaseProvider,
  MgtContact,
  MgtFile,
  MgtFileList,
  MgtGet,
  MgtLogin,
  MgtMessages,
  MgtOrganization,
  MgtPeople,
  MgtPeoplePicker,
  MgtPerson,
  MgtPersonCard,
  MgtPicker,
  MgtProfile,
  MgtTasks,
  MgtTeamsChannelPicker,
  MgtTemplatedComponent,
  MgtTodo,
  MockProvider,
  PACKAGE_VERSION,
  People,
  PeoplePicker,
  Person,
  PersonCard,
  PersonCardInteraction,
  PersonType,
  PersonViewType,
  Picker,
  ProviderState,
  Providers,
  ProvidersChangedState,
  ResponseType2 as ResponseType,
  SimpleProvider,
  Tasks,
  TasksSource,
  TeamsChannelPicker,
  TeamsHelper,
  TemplateHelper,
  ThemeToggle,
  Todo,
  UserType,
  ViewType,
  arraysAreEqual,
  avatarType,
  chainMiddleware,
  createFromProvider,
  customElement,
  customElementHelper,
  equals,
  mgtHtml,
  prepScopes,
  validateBaseURL,
  wrapMgt
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

lit-html/development/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/repeat.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@microsoft_mgt-react.js.map
