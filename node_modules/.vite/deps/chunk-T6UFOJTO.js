import {
  AbortError,
  RestError,
  bearerTokenAuthenticationPolicy,
  createClientLogger,
  createDefaultHttpClient,
  createPipelineFromOptions,
  createPipelineRequest,
  delay,
  init_esm_browser,
  init_src,
  init_src2,
  init_src3,
  init_src4,
  isTokenCredential,
  v4_default
} from "./chunk-C3C35S6U.js";
import {
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __rest,
  init_tslib_es6
} from "./chunk-JZQ4H723.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/browser/index.js
var init_browser = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/browser/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.4.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a2;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== void 0 ? _a2 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: All API registration versions must match");
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a2, _b;
  var globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_browser();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger4 = getGlobal("diag");
  if (!logger4) {
    return;
  }
  args.unshift(namespace);
  return logger4[funcName].apply(logger4, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger4) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger4 = logger4 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger4[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger4);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger4 = getGlobal("diag");
            if (!logger4)
              return;
            return logger4[funcName].apply(logger4, __spreadArray2([], __read2(args), false));
          };
        }
        var self2 = this;
        var setLogger = function(logger4, optionsOrLogLevel) {
          var _a2, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger4 === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger4);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a2) {
          var _b = __read3(_a2, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a2;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return))
              _a2.call(keys_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
var diag;
var init_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.set(key, value);
          return context3;
        };
        self2.deleteValue = function(key) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.delete(key);
          return context3;
        };
      }
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context3, fn, thisArg) {
        var _a2;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a2 = this._getContextManager()).with.apply(_a2, __spreadArray4([context3, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context3, target) {
        return this._getContextManager().bind(context3, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context3) {
  return context3.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context3, span) {
  return context3.setValue(SPAN_KEY, span);
}
function deleteSpan(context3) {
  return context3.deleteValue(SPAN_KEY);
}
function setSpanContext(context3, spanContext) {
  return setSpan(context3, new NonRecordingSpan(spanContext));
}
function getSpanContext(context3) {
  var _a2;
  return (_a2 = getSpan(context3)) === null || _a2 === void 0 ? void 0 : _a2.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context3) {
        if (context3 === void 0) {
          context3 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context3 && getSpanContext(context3);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context3) {
        return this._getTracer().startSpan(name, options, context3);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a2;
        return (_a2 = this.getDelegateTracer(name, version, options)) !== null && _a2 !== void 0 ? _a2 : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a2;
        return (_a2 = this._delegate) !== null && _a2 !== void 0 ? _a2 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a2;
        return (_a2 = this._delegate) === null || _a2 === void 0 ? void 0 : _a2.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind3) {
      SpanKind3[SpanKind3["INTERNAL"] = 0] = "INTERNAL";
      SpanKind3[SpanKind3["SERVER"] = 1] = "SERVER";
      SpanKind3[SpanKind3["CLIENT"] = 2] = "CLIENT";
      SpanKind3[SpanKind3["PRODUCER"] = 3] = "PRODUCER";
      SpanKind3[SpanKind3["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode3) {
      SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
      SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
      SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
var init_utils2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_tracestate_impl();
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {
        return context3;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context3) {
  return context3.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context3, baggage) {
  return context3.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context3) {
  return context3.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context3, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context3, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context3, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context3, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/interfaces.js
function setSpan2(context3, span) {
  return trace.setSpan(context3, span);
}
function isSpanContextValid2(context3) {
  return trace.isSpanContextValid(context3);
}
function getTracer(name, version) {
  return trace.getTracer(name || "azure/core-tracing", version);
}
var SpanKind2, context2, SpanStatusCode2;
var init_interfaces = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/interfaces.js"() {
    init_esm();
    (function(SpanKind3) {
      SpanKind3[SpanKind3["INTERNAL"] = 0] = "INTERNAL";
      SpanKind3[SpanKind3["SERVER"] = 1] = "SERVER";
      SpanKind3[SpanKind3["CLIENT"] = 2] = "CLIENT";
      SpanKind3[SpanKind3["PRODUCER"] = 3] = "PRODUCER";
      SpanKind3[SpanKind3["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind2 || (SpanKind2 = {}));
    context2 = context;
    (function(SpanStatusCode3) {
      SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
      SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
      SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode2 || (SpanStatusCode2 = {}));
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/createSpan.js
function isTracingDisabled() {
  var _a2;
  if (typeof process === "undefined") {
    return false;
  }
  const azureTracingDisabledValue = (_a2 = process.env.AZURE_TRACING_DISABLED) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
  if (azureTracingDisabledValue === "false" || azureTracingDisabledValue === "0") {
    return false;
  }
  return Boolean(azureTracingDisabledValue);
}
function createSpanFunction(args) {
  return function(operationName, operationOptions) {
    const tracer = getTracer();
    const tracingOptions = (operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) || {};
    const spanOptions = Object.assign({ kind: SpanKind2.INTERNAL }, tracingOptions.spanOptions);
    const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;
    let span;
    if (isTracingDisabled()) {
      span = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
    } else {
      span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);
    }
    if (args.namespace) {
      span.setAttribute("az.namespace", args.namespace);
    }
    let newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording() && args.namespace) {
      newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": args.namespace }) });
    }
    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions, tracingContext: setSpan2(tracingOptions.tracingContext || context2.active(), span) });
    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
      span,
      updatedOptions: newOperationOptions
    };
  };
}
var init_createSpan = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/createSpan.js"() {
    init_interfaces();
    init_esm();
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/utils/traceParentHeader.js
function getTraceParentHeader(spanContext) {
  const missingFields = [];
  if (!spanContext.traceId) {
    missingFields.push("traceId");
  }
  if (!spanContext.spanId) {
    missingFields.push("spanId");
  }
  if (missingFields.length) {
    return;
  }
  const flags = spanContext.traceFlags || 0;
  const hexFlags = flags.toString(16);
  const traceFlags = hexFlags.length === 1 ? `0${hexFlags}` : hexFlags;
  return `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;
}
var VERSION2;
var init_traceParentHeader = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/utils/traceParentHeader.js"() {
    VERSION2 = "00";
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/index.js
var init_src5 = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/index.js"() {
    init_createSpan();
    init_interfaces();
    init_traceParentHeader();
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@azure/core-http/dist-esm/src/httpHeaders.js
function getHeaderKey(headerName) {
  return headerName.toLowerCase();
}
function isHttpHeadersLike(object) {
  if (object && typeof object === "object") {
    const castObject = object;
    if (typeof castObject.rawHeaders === "function" && typeof castObject.clone === "function" && typeof castObject.get === "function" && typeof castObject.set === "function" && typeof castObject.contains === "function" && typeof castObject.remove === "function" && typeof castObject.headersArray === "function" && typeof castObject.headerValues === "function" && typeof castObject.headerNames === "function" && typeof castObject.toJson === "function") {
      return true;
    }
  }
  return false;
}
var HttpHeaders;
var init_httpHeaders = __esm({
  "node_modules/@azure/core-http/dist-esm/src/httpHeaders.js"() {
    HttpHeaders = class {
      constructor(rawHeaders) {
        this._headersMap = {};
        if (rawHeaders) {
          for (const headerName in rawHeaders) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param headerName - The name of the header to set. This value is case-insensitive.
       * @param headerValue - The value of the header to set.
       */
      set(headerName, headerValue) {
        this._headersMap[getHeaderKey(headerName)] = {
          name: headerName,
          value: headerValue.toString()
        };
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param headerName - The name of the header.
       */
      get(headerName) {
        const header = this._headersMap[getHeaderKey(headerName)];
        return !header ? void 0 : header.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       */
      contains(headerName) {
        return !!this._headersMap[getHeaderKey(headerName)];
      }
      /**
       * Remove the header with the provided headerName. Return whether or not the header existed and
       * was removed.
       * @param headerName - The name of the header to remove.
       */
      remove(headerName) {
        const result = this.contains(headerName);
        delete this._headersMap[getHeaderKey(headerName)];
        return result;
      }
      /**
       * Get the headers that are contained this collection as an object.
       */
      rawHeaders() {
        return this.toJson({ preserveCase: true });
      }
      /**
       * Get the headers that are contained in this collection as an array.
       */
      headersArray() {
        const headers = [];
        for (const headerKey in this._headersMap) {
          headers.push(this._headersMap[headerKey]);
        }
        return headers;
      }
      /**
       * Get the header names that are contained in this collection.
       */
      headerNames() {
        const headerNames = [];
        const headers = this.headersArray();
        for (let i = 0; i < headers.length; ++i) {
          headerNames.push(headers[i].name);
        }
        return headerNames;
      }
      /**
       * Get the header values that are contained in this collection.
       */
      headerValues() {
        const headerValues = [];
        const headers = this.headersArray();
        for (let i = 0; i < headers.length; ++i) {
          headerValues.push(headers[i].value);
        }
        return headerValues;
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJson(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const headerKey in this._headersMap) {
            const header = this._headersMap[headerKey];
            result[header.name] = header.value;
          }
        } else {
          for (const headerKey in this._headersMap) {
            const header = this._headersMap[headerKey];
            result[getHeaderKey(header.name)] = header.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJson({ preserveCase: true }));
      }
      /**
       * Create a deep clone/copy of this HttpHeaders collection.
       */
      clone() {
        const resultPreservingCasing = {};
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          resultPreservingCasing[header.name] = header.value;
        }
        return new HttpHeaders(resultPreservingCasing);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/base64.browser.js
function encodeString(value) {
  return btoa(value);
}
function encodeByteArray2(value) {
  let str = "";
  for (let i = 0; i < value.length; i++) {
    str += String.fromCharCode(value[i]);
  }
  return btoa(str);
}
function decodeString2(value) {
  const byteString = atob(value);
  const arr = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    arr[i] = byteString.charCodeAt(i);
  }
  return arr;
}
var init_base64_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/base64.browser.js"() {
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/constants.js
var Constants;
var init_constants = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/constants.js"() {
    Constants = {
      /**
       * The core-http version
       */
      coreHttpVersion: "2.3.1",
      /**
       * Specifies HTTP.
       */
      HTTP: "http:",
      /**
       * Specifies HTTPS.
       */
      HTTPS: "https:",
      /**
       * Specifies HTTP Proxy.
       */
      HTTP_PROXY: "HTTP_PROXY",
      /**
       * Specifies HTTPS Proxy.
       */
      HTTPS_PROXY: "HTTPS_PROXY",
      /**
       * Specifies NO Proxy.
       */
      NO_PROXY: "NO_PROXY",
      /**
       * Specifies ALL Proxy.
       */
      ALL_PROXY: "ALL_PROXY",
      HttpConstants: {
        /**
         * Http Verbs
         */
        HttpVerbs: {
          PUT: "PUT",
          GET: "GET",
          DELETE: "DELETE",
          POST: "POST",
          MERGE: "MERGE",
          HEAD: "HEAD",
          PATCH: "PATCH"
        },
        StatusCodes: {
          TooManyRequests: 429,
          ServiceUnavailable: 503
        }
      },
      /**
       * Defines constants for use with HTTP headers.
       */
      HeaderConstants: {
        /**
         * The Authorization header.
         */
        AUTHORIZATION: "authorization",
        AUTHORIZATION_SCHEME: "Bearer",
        /**
         * The Retry-After response-header field can be used with a 503 (Service
         * Unavailable) or 349 (Too Many Requests) responses to indicate how long
         * the service is expected to be unavailable to the requesting client.
         */
        RETRY_AFTER: "Retry-After",
        /**
         * The UserAgent header.
         */
        USER_AGENT: "User-Agent"
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/serializer.common.js
var XML_ATTRKEY2, XML_CHARKEY2;
var init_serializer_common = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/serializer.common.js"() {
    XML_ATTRKEY2 = "$";
    XML_CHARKEY2 = "_";
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/utils.js
function encodeUri(uri) {
  return encodeURIComponent(uri).replace(/!/g, "%21").replace(/"/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
}
function stripResponse(response) {
  const strippedResponse = {};
  strippedResponse.body = response.bodyAsText;
  strippedResponse.headers = response.headers;
  strippedResponse.status = response.status;
  return strippedResponse;
}
function stripRequest(request) {
  const strippedRequest = request.clone();
  if (strippedRequest.headers) {
    strippedRequest.headers.remove("authorization");
  }
  return strippedRequest;
}
function isValidUuid2(uuid) {
  return validUuidRegex2.test(uuid);
}
function generateUuid2() {
  return v4_default();
}
function executePromisesSequentially(promiseFactories, kickstart) {
  let result = Promise.resolve(kickstart);
  promiseFactories.forEach((promiseFactory) => {
    result = result.then(promiseFactory);
  });
  return result;
}
function promiseToCallback(promise) {
  if (typeof promise.then !== "function") {
    throw new Error("The provided input is not a Promise.");
  }
  return (cb) => {
    promise.then((data) => {
      return cb(void 0, data);
    }).catch((err) => {
      cb(err);
    });
  };
}
function promiseToServiceCallback(promise) {
  if (typeof promise.then !== "function") {
    throw new Error("The provided input is not a Promise.");
  }
  return (cb) => {
    promise.then((data) => {
      return process.nextTick(cb, void 0, data.parsedBody, data.request, data);
    }).catch((err) => {
      process.nextTick(cb, err);
    });
  };
}
function prepareXMLRootList2(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY2] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
function applyMixins(targetCtorParam, sourceCtors) {
  const castTargetCtorParam = targetCtorParam;
  sourceCtors.forEach((sourceCtor) => {
    Object.getOwnPropertyNames(sourceCtor.prototype).forEach((name) => {
      castTargetCtorParam.prototype[name] = sourceCtor.prototype[name];
    });
  });
}
function isDuration2(value) {
  return validateISODuration2.test(value);
}
function replaceAll2(value, searchValue, replaceValue) {
  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}
function isPrimitiveType(value) {
  return typeof value !== "object" && typeof value !== "function" || value === null;
}
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
var validUuidRegex2, isNode2, validateISODuration2;
var init_utils3 = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/utils.js"() {
    init_constants();
    init_serializer_common();
    init_esm_browser();
    validUuidRegex2 = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
    isNode2 = typeof process !== "undefined" && !!process.version && !!process.versions && !!process.versions.node;
    validateISODuration2 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  }
});

// node_modules/@azure/core-http/dist-esm/src/serializer.js
function trimEnd2(str, ch) {
  let len = str.length;
  while (len - 1 >= 0 && str[len - 1] === ch) {
    --len;
  }
  return str.substr(0, len);
}
function bufferToBase64Url2(buffer) {
  if (!buffer) {
    return void 0;
  }
  if (!(buffer instanceof Uint8Array)) {
    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
  }
  const str = encodeByteArray2(buffer);
  return trimEnd2(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray2(str) {
  if (!str) {
    return void 0;
  }
  if (str && typeof str.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  }
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  return decodeString2(str);
}
function splitSerializeName2(prop) {
  const classes = [];
  let partialclass = "";
  if (prop) {
    const subwords = prop.split(".");
    for (const item of subwords) {
      if (item.charAt(item.length - 1) === "\\") {
        partialclass += item.substr(0, item.length - 1) + ".";
      } else {
        partialclass += item;
        classes.push(partialclass);
        partialclass = "";
      }
    }
  }
  return classes;
}
function dateToUnixTime2(d) {
  if (!d) {
    return void 0;
  }
  if (typeof d.valueOf() === "string") {
    d = new Date(d);
  }
  return Math.floor(d.getTime() / 1e3);
}
function unixTimeToDate2(n) {
  if (!n) {
    return void 0;
  }
  return new Date(n * 1e3);
}
function serializeBasicTypes2(typeName, objectName, value) {
  if (value !== null && value !== void 0) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error(`${objectName} with value ${value} must be of type number.`);
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error(`${objectName} with value "${value}" must be of type string.`);
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && isValidUuid2(value))) {
        throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error(`${objectName} with value ${value} must be of type boolean.`);
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      const objectType = typeof value;
      if (objectType !== "string" && objectType !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) {
        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`);
      }
    }
  }
  return value;
}
function serializeEnumType2(objectName, allowedValues, value) {
  if (!allowedValues) {
    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
  }
  const isPresent = allowedValues.some((item) => {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }
    return item === value;
  });
  if (!isPresent) {
    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
  }
  return value;
}
function serializeByteArrayType2(objectName, value) {
  let returnValue = "";
  if (value != void 0) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    returnValue = encodeByteArray2(value);
  }
  return returnValue;
}
function serializeBase64UrlType2(objectName, value) {
  let returnValue = "";
  if (value != void 0) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    returnValue = bufferToBase64Url2(value) || "";
  }
  return returnValue;
}
function serializeDateTypes2(typeName, value, objectName) {
  if (value != void 0) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
      }
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
      }
      value = dateToUnixTime2(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!isDuration2(value)) {
        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
      }
    }
  }
  return value;
}
function serializeSequenceType2(serializer3, mapper, object, objectName, isXml, options) {
  if (!Array.isArray(object)) {
    throw new Error(`${objectName} must be of type Array.`);
  }
  const elementType = mapper.type.element;
  if (!elementType || typeof elementType !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  const tempArray = [];
  for (let i = 0; i < object.length; i++) {
    const serializedValue = serializer3.serialize(elementType, object[i], objectName, options);
    if (isXml && elementType.xmlNamespace) {
      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
      if (elementType.type.name === "Composite") {
        tempArray[i] = Object.assign({}, serializedValue);
        tempArray[i][XML_ATTRKEY2] = { [xmlnsKey]: elementType.xmlNamespace };
      } else {
        tempArray[i] = {};
        tempArray[i][options.xmlCharKey] = serializedValue;
        tempArray[i][XML_ATTRKEY2] = { [xmlnsKey]: elementType.xmlNamespace };
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }
  return tempArray;
}
function serializeDictionaryType2(serializer3, mapper, object, objectName, isXml, options) {
  if (typeof object !== "object") {
    throw new Error(`${objectName} must be of type object.`);
  }
  const valueType = mapper.type.value;
  if (!valueType || typeof valueType !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  const tempDictionary = {};
  for (const key of Object.keys(object)) {
    const serializedValue = serializer3.serialize(valueType, object[key], objectName, options);
    tempDictionary[key] = getXmlObjectValue2(valueType, serializedValue, isXml, options);
  }
  if (isXml && mapper.xmlNamespace) {
    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
    const result = tempDictionary;
    result[XML_ATTRKEY2] = { [xmlnsKey]: mapper.xmlNamespace };
    return result;
  }
  return tempDictionary;
}
function resolveAdditionalProperties2(serializer3, mapper, objectName) {
  const additionalProperties = mapper.type.additionalProperties;
  if (!additionalProperties && mapper.type.className) {
    const modelMapper = resolveReferencedMapper2(serializer3, mapper, objectName);
    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
  }
  return additionalProperties;
}
function resolveReferencedMapper2(serializer3, mapper, objectName) {
  const className = mapper.type.className;
  if (!className) {
    throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
  }
  return serializer3.modelMappers[className];
}
function resolveModelProperties2(serializer3, mapper, objectName) {
  let modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    const modelMapper = resolveReferencedMapper2(serializer3, mapper, objectName);
    if (!modelMapper) {
      throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
    }
    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
    if (!modelProps) {
      throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
    }
  }
  return modelProps;
}
function serializeCompositeType2(serializer3, mapper, object, objectName, isXml, options) {
  if (getPolymorphicDiscriminatorRecursively2(serializer3, mapper)) {
    mapper = getPolymorphicMapper2(serializer3, mapper, object, "clientName");
  }
  if (object != void 0) {
    const payload = {};
    const modelProps = resolveModelProperties2(serializer3, mapper, objectName);
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      if (propertyMapper.readOnly) {
        continue;
      }
      let propName;
      let parentObject = payload;
      if (serializer3.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        const paths = splitSerializeName2(propertyMapper.serializedName);
        propName = paths.pop();
        for (const pathName of paths) {
          const childObject = parentObject[pathName];
          if (childObject == void 0 && (object[key] != void 0 || propertyMapper.defaultValue !== void 0)) {
            parentObject[pathName] = {};
          }
          parentObject = parentObject[pathName];
        }
      }
      if (parentObject != void 0) {
        if (isXml && mapper.xmlNamespace) {
          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
          parentObject[XML_ATTRKEY2] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY2]), { [xmlnsKey]: mapper.xmlNamespace });
        }
        const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
        let toSerialize = object[key];
        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively2(serializer3, mapper);
        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == void 0) {
          toSerialize = mapper.serializedName;
        }
        const serializedValue = serializer3.serialize(propertyMapper, toSerialize, propertyObjectName, options);
        if (serializedValue !== void 0 && propName != void 0) {
          const value = getXmlObjectValue2(propertyMapper, serializedValue, isXml, options);
          if (isXml && propertyMapper.xmlIsAttribute) {
            parentObject[XML_ATTRKEY2] = parentObject[XML_ATTRKEY2] || {};
            parentObject[XML_ATTRKEY2][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = { [propertyMapper.xmlElementName]: value };
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }
    const additionalPropertiesMapper = resolveAdditionalProperties2(serializer3, mapper, objectName);
    if (additionalPropertiesMapper) {
      const propNames = Object.keys(modelProps);
      for (const clientPropName in object) {
        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
        if (isAdditionalProperty) {
          payload[clientPropName] = serializer3.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
        }
      }
    }
    return payload;
  }
  return object;
}
function getXmlObjectValue2(propertyMapper, serializedValue, isXml, options) {
  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }
  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[XML_ATTRKEY2]) {
      return serializedValue;
    } else {
      const result2 = Object.assign({}, serializedValue);
      result2[XML_ATTRKEY2] = xmlNamespace;
      return result2;
    }
  }
  const result = {};
  result[options.xmlCharKey] = serializedValue;
  result[XML_ATTRKEY2] = xmlNamespace;
  return result;
}
function isSpecialXmlProperty2(propertyName, options) {
  return [XML_ATTRKEY2, options.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType2(serializer3, mapper, responseBody, objectName, options) {
  var _a2, _b;
  const xmlCharKey = (_a2 = options.xmlCharKey) !== null && _a2 !== void 0 ? _a2 : XML_CHARKEY2;
  if (getPolymorphicDiscriminatorRecursively2(serializer3, mapper)) {
    mapper = getPolymorphicMapper2(serializer3, mapper, responseBody, "serializedName");
  }
  const modelProps = resolveModelProperties2(serializer3, mapper, objectName);
  let instance = {};
  const handledPropertyNames = [];
  for (const key of Object.keys(modelProps)) {
    const propertyMapper = modelProps[key];
    const paths = splitSerializeName2(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    const { serializedName, xmlName, xmlElementName } = propertyMapper;
    let propertyObjectName = objectName;
    if (serializedName !== "" && serializedName !== void 0) {
      propertyObjectName = objectName + "." + serializedName;
    }
    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
    if (headerCollectionPrefix) {
      const dictionary = {};
      for (const headerKey of Object.keys(responseBody)) {
        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer3.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
        }
        handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer3.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY2]) {
        instance[key] = serializer3.deserialize(propertyMapper, responseBody[XML_ATTRKEY2][xmlName], propertyObjectName, options);
      } else if (propertyMapper.xmlIsMsText) {
        if (responseBody[xmlCharKey] !== void 0) {
          instance[key] = responseBody[xmlCharKey];
        } else if (typeof responseBody === "string") {
          instance[key] = responseBody;
        }
      } else {
        const propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          const wrapped = responseBody[xmlName];
          const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];
          instance[key] = serializer3.deserialize(propertyMapper, elementList, propertyObjectName, options);
        } else {
          const property = responseBody[propertyName];
          instance[key] = serializer3.deserialize(propertyMapper, property, propertyObjectName, options);
        }
      }
    } else {
      let propertyInstance;
      let res = responseBody;
      for (const item of paths) {
        if (!res)
          break;
        res = res[item];
      }
      propertyInstance = res;
      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == void 0) {
        propertyInstance = mapper.serializedName;
      }
      let serializedValue;
      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        const arrayInstance = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        for (const [k, v] of Object.entries(instance)) {
          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
            arrayInstance[k] = v;
          }
        }
        instance = arrayInstance;
      } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
        serializedValue = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        instance[key] = serializedValue;
      }
    }
  }
  const additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    const isAdditionalProperty = (responsePropName) => {
      for (const clientPropName in modelProps) {
        const paths = splitSerializeName2(modelProps[clientPropName].serializedName);
        if (paths[0] === responsePropName) {
          return false;
        }
      }
      return true;
    };
    for (const responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer3.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
      }
    }
  } else if (responseBody) {
    for (const key of Object.keys(responseBody)) {
      if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty2(key, options)) {
        instance[key] = responseBody[key];
      }
    }
  }
  return instance;
}
function deserializeDictionaryType2(serializer3, mapper, responseBody, objectName, options) {
  const value = mapper.type.value;
  if (!value || typeof value !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    const tempDictionary = {};
    for (const key of Object.keys(responseBody)) {
      tempDictionary[key] = serializer3.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}
function deserializeSequenceType2(serializer3, mapper, responseBody, objectName, options) {
  const element = mapper.type.element;
  if (!element || typeof element !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      responseBody = [responseBody];
    }
    const tempArray = [];
    for (let i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer3.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
    }
    return tempArray;
  }
  return responseBody;
}
function getPolymorphicMapper2(serializer3, mapper, object, polymorphicPropertyName) {
  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively2(serializer3, mapper);
  if (polymorphicDiscriminator) {
    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName != void 0) {
      const discriminatorValue = object[discriminatorName];
      if (discriminatorValue != void 0) {
        const typeName = mapper.type.uberParent || mapper.type.className;
        const indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + "." + discriminatorValue;
        const polymorphicMapper = serializer3.modelMappers.discriminators[indexDiscriminator];
        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }
  return mapper;
}
function getPolymorphicDiscriminatorRecursively2(serializer3, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely2(serializer3, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely2(serializer3, mapper.type.className);
}
function getPolymorphicDiscriminatorSafely2(serializer3, typeName) {
  return typeName && serializer3.modelMappers[typeName] && serializer3.modelMappers[typeName].type.polymorphicDiscriminator;
}
function serializeObject(toSerialize) {
  const castToSerialize = toSerialize;
  if (toSerialize == void 0)
    return void 0;
  if (toSerialize instanceof Uint8Array) {
    toSerialize = encodeByteArray2(toSerialize);
    return toSerialize;
  } else if (toSerialize instanceof Date) {
    return toSerialize.toISOString();
  } else if (Array.isArray(toSerialize)) {
    const array = [];
    for (let i = 0; i < toSerialize.length; i++) {
      array.push(serializeObject(toSerialize[i]));
    }
    return array;
  } else if (typeof toSerialize === "object") {
    const dictionary = {};
    for (const property in toSerialize) {
      dictionary[property] = serializeObject(castToSerialize[property]);
    }
    return dictionary;
  }
  return toSerialize;
}
function strEnum(o) {
  const result = {};
  for (const key of o) {
    result[key] = key;
  }
  return result;
}
var Serializer, MapperType;
var init_serializer = __esm({
  "node_modules/@azure/core-http/dist-esm/src/serializer.js"() {
    init_base64_browser();
    init_utils3();
    init_serializer_common();
    Serializer = class {
      constructor(modelMappers = {}, isXML) {
        this.modelMappers = modelMappers;
        this.isXML = isXML;
      }
      /**
       * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.
       * @param mapper - The definition of data models.
       * @param value - The value.
       * @param objectName - Name of the object. Used in the error messages.
       * @deprecated Removing the constraints validation on client side.
       */
      validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue) => {
          throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value != void 0) {
          const valueAsNumber = value;
          const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
          if (ExclusiveMaximum != void 0 && valueAsNumber >= ExclusiveMaximum) {
            failValidation("ExclusiveMaximum", ExclusiveMaximum);
          }
          if (ExclusiveMinimum != void 0 && valueAsNumber <= ExclusiveMinimum) {
            failValidation("ExclusiveMinimum", ExclusiveMinimum);
          }
          if (InclusiveMaximum != void 0 && valueAsNumber > InclusiveMaximum) {
            failValidation("InclusiveMaximum", InclusiveMaximum);
          }
          if (InclusiveMinimum != void 0 && valueAsNumber < InclusiveMinimum) {
            failValidation("InclusiveMinimum", InclusiveMinimum);
          }
          const valueAsArray = value;
          if (MaxItems != void 0 && valueAsArray.length > MaxItems) {
            failValidation("MaxItems", MaxItems);
          }
          if (MaxLength != void 0 && valueAsArray.length > MaxLength) {
            failValidation("MaxLength", MaxLength);
          }
          if (MinItems != void 0 && valueAsArray.length < MinItems) {
            failValidation("MinItems", MinItems);
          }
          if (MinLength != void 0 && valueAsArray.length < MinLength) {
            failValidation("MinLength", MinLength);
          }
          if (MultipleOf != void 0 && valueAsNumber % MultipleOf !== 0) {
            failValidation("MultipleOf", MultipleOf);
          }
          if (Pattern) {
            const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
            if (typeof value !== "string" || value.match(pattern) === null) {
              failValidation("Pattern", Pattern);
            }
          }
          if (UniqueItems && valueAsArray.some((item, i, ar) => ar.indexOf(item) !== i)) {
            failValidation("UniqueItems", UniqueItems);
          }
        }
      }
      /**
       * Serialize the given object based on its metadata defined in the mapper.
       *
       * @param mapper - The mapper which defines the metadata of the serializable object.
       * @param object - A valid Javascript object to be serialized.
       * @param objectName - Name of the serialized object.
       * @param options - additional options to deserialization.
       * @returns A valid serialized Javascript object.
       */
      serialize(mapper, object, objectName, options = {}) {
        var _a2, _b, _c;
        const updatedOptions = {
          rootName: (_a2 = options.rootName) !== null && _a2 !== void 0 ? _a2 : "",
          includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
          xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY2
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Sequence$/i) !== null) {
          payload = [];
        }
        if (mapper.isConstant) {
          object = mapper.defaultValue;
        }
        const { required, nullable } = mapper;
        if (required && nullable && object === void 0) {
          throw new Error(`${objectName} cannot be undefined.`);
        }
        if (required && !nullable && object == void 0) {
          throw new Error(`${objectName} cannot be null or undefined.`);
        }
        if (!required && nullable === false && object === null) {
          throw new Error(`${objectName} cannot be null.`);
        }
        if (object == void 0) {
          payload = object;
        } else {
          if (mapperType.match(/^any$/i) !== null) {
            payload = object;
          } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
            payload = serializeBasicTypes2(mapperType, objectName, object);
          } else if (mapperType.match(/^Enum$/i) !== null) {
            const enumMapper = mapper;
            payload = serializeEnumType2(objectName, enumMapper.type.allowedValues, object);
          } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
            payload = serializeDateTypes2(mapperType, object, objectName);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = serializeByteArrayType2(objectName, object);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = serializeBase64UrlType2(objectName, object);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = serializeSequenceType2(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = serializeDictionaryType2(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Composite$/i) !== null) {
            payload = serializeCompositeType2(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          }
        }
        return payload;
      }
      /**
       * Deserialize the given object based on its metadata defined in the mapper.
       *
       * @param mapper - The mapper which defines the metadata of the serializable object.
       * @param responseBody - A valid Javascript entity to be deserialized.
       * @param objectName - Name of the deserialized object.
       * @param options - Controls behavior of XML parser and builder.
       * @returns A valid deserialized Javascript object.
       */
      deserialize(mapper, responseBody, objectName, options = {}) {
        var _a2, _b, _c;
        const updatedOptions = {
          rootName: (_a2 = options.rootName) !== null && _a2 !== void 0 ? _a2 : "",
          includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
          xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY2
        };
        if (responseBody == void 0) {
          if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
            responseBody = [];
          }
          if (mapper.defaultValue !== void 0) {
            responseBody = mapper.defaultValue;
          }
          return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Composite$/i) !== null) {
          payload = deserializeCompositeType2(this, mapper, responseBody, objectName, updatedOptions);
        } else {
          if (this.isXML) {
            const xmlCharKey = updatedOptions.xmlCharKey;
            const castResponseBody = responseBody;
            if (castResponseBody[XML_ATTRKEY2] != void 0 && castResponseBody[xmlCharKey] != void 0) {
              responseBody = castResponseBody[xmlCharKey];
            }
          }
          if (mapperType.match(/^Number$/i) !== null) {
            payload = parseFloat(responseBody);
            if (isNaN(payload)) {
              payload = responseBody;
            }
          } else if (mapperType.match(/^Boolean$/i) !== null) {
            if (responseBody === "true") {
              payload = true;
            } else if (responseBody === "false") {
              payload = false;
            } else {
              payload = responseBody;
            }
          } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
            payload = responseBody;
          } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
            payload = new Date(responseBody);
          } else if (mapperType.match(/^UnixTime$/i) !== null) {
            payload = unixTimeToDate2(responseBody);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = decodeString2(responseBody);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = base64UrlToByteArray2(responseBody);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = deserializeSequenceType2(this, mapper, responseBody, objectName, updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = deserializeDictionaryType2(this, mapper, responseBody, objectName, updatedOptions);
          }
        }
        if (mapper.isConstant) {
          payload = mapper.defaultValue;
        }
        return payload;
      }
    };
    MapperType = strEnum([
      "Base64Url",
      "Boolean",
      "ByteArray",
      "Composite",
      "Date",
      "DateTime",
      "DateTimeRfc1123",
      "Dictionary",
      "Enum",
      "Number",
      "Object",
      "Sequence",
      "String",
      "Stream",
      "TimeSpan",
      "UnixTime"
    ]);
  }
});

// node_modules/@azure/core-http/dist-esm/src/webResource.js
function isWebResourceLike(object) {
  if (object && typeof object === "object") {
    const castObject = object;
    if (typeof castObject.url === "string" && typeof castObject.method === "string" && typeof castObject.headers === "object" && isHttpHeadersLike(castObject.headers) && typeof castObject.validateRequestProperties === "function" && typeof castObject.prepare === "function" && typeof castObject.clone === "function") {
      return true;
    }
  }
  return false;
}
var WebResource;
var init_webResource = __esm({
  "node_modules/@azure/core-http/dist-esm/src/webResource.js"() {
    init_httpHeaders();
    init_serializer();
    init_utils3();
    WebResource = class {
      constructor(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse, streamResponseStatusCodes) {
        this.streamResponseBody = streamResponseBody;
        this.streamResponseStatusCodes = streamResponseStatusCodes;
        this.url = url || "";
        this.method = method || "GET";
        this.headers = isHttpHeadersLike(headers) ? headers : new HttpHeaders(headers);
        this.body = body;
        this.query = query;
        this.formData = void 0;
        this.withCredentials = withCredentials || false;
        this.abortSignal = abortSignal;
        this.timeout = timeout || 0;
        this.onUploadProgress = onUploadProgress;
        this.onDownloadProgress = onDownloadProgress;
        this.proxySettings = proxySettings;
        this.keepAlive = keepAlive;
        this.decompressResponse = decompressResponse;
        this.requestId = this.headers.get("x-ms-client-request-id") || generateUuid2();
      }
      /**
       * Validates that the required properties such as method, url, headers["Content-Type"],
       * headers["accept-language"] are defined. It will throw an error if one of the above
       * mentioned properties are not defined.
       */
      validateRequestProperties() {
        if (!this.method) {
          throw new Error("WebResource.method is required.");
        }
        if (!this.url) {
          throw new Error("WebResource.url is required.");
        }
      }
      /**
       * Prepares the request.
       * @param options - Options to provide for preparing the request.
       * @returns Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
       */
      prepare(options) {
        if (!options) {
          throw new Error("options object is required");
        }
        if (options.method === void 0 || options.method === null || typeof options.method.valueOf() !== "string") {
          throw new Error("options.method must be a string.");
        }
        if (options.url && options.pathTemplate) {
          throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
        }
        if ((options.pathTemplate === void 0 || options.pathTemplate === null || typeof options.pathTemplate.valueOf() !== "string") && (options.url === void 0 || options.url === null || typeof options.url.valueOf() !== "string")) {
          throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
        }
        if (options.url) {
          if (typeof options.url !== "string") {
            throw new Error('options.url must be of type "string".');
          }
          this.url = options.url;
        }
        if (options.method) {
          const validMethods = ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "POST", "PATCH", "TRACE"];
          if (validMethods.indexOf(options.method.toUpperCase()) === -1) {
            throw new Error('The provided method "' + options.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
          }
        }
        this.method = options.method.toUpperCase();
        if (options.pathTemplate) {
          const { pathTemplate, pathParameters } = options;
          if (typeof pathTemplate !== "string") {
            throw new Error('options.pathTemplate must be of type "string".');
          }
          if (!options.baseUrl) {
            options.baseUrl = "https://management.azure.com";
          }
          const baseUrl = options.baseUrl;
          let url = baseUrl + (baseUrl.endsWith("/") ? "" : "/") + (pathTemplate.startsWith("/") ? pathTemplate.slice(1) : pathTemplate);
          const segments = url.match(/({[\w-]*\s*[\w-]*})/gi);
          if (segments && segments.length) {
            if (!pathParameters) {
              throw new Error(`pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`);
            }
            segments.forEach(function(item) {
              const pathParamName = item.slice(1, -1);
              const pathParam = pathParameters[pathParamName];
              if (pathParam === null || pathParam === void 0 || !(typeof pathParam === "string" || typeof pathParam === "object")) {
                const stringifiedPathParameters = JSON.stringify(pathParameters, void 0, 2);
                throw new Error(`pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName} however, it is not present in parameters: ${stringifiedPathParameters}.The value of the path parameter can either be a "string" of the form { ${pathParamName}: "some sample value" } or it can be an "object" of the form { "${pathParamName}": { value: "some sample value", skipUrlEncoding: true } }.`);
              }
              if (typeof pathParam.valueOf() === "string") {
                url = url.replace(item, encodeURIComponent(pathParam));
              }
              if (typeof pathParam.valueOf() === "object") {
                if (!pathParam.value) {
                  throw new Error(`options.pathParameters[${pathParamName}] is of type "object" but it does not contain a "value" property.`);
                }
                if (pathParam.skipUrlEncoding) {
                  url = url.replace(item, pathParam.value);
                } else {
                  url = url.replace(item, encodeURIComponent(pathParam.value));
                }
              }
            });
          }
          this.url = url;
        }
        if (options.queryParameters) {
          const queryParameters = options.queryParameters;
          if (typeof queryParameters !== "object") {
            throw new Error(`options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.`);
          }
          if (this.url && this.url.indexOf("?") === -1) {
            this.url += "?";
          }
          const queryParams = [];
          this.query = {};
          for (const queryParamName in queryParameters) {
            const queryParam = queryParameters[queryParamName];
            if (queryParam) {
              if (typeof queryParam === "string") {
                queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
                this.query[queryParamName] = encodeURIComponent(queryParam);
              } else if (typeof queryParam === "object") {
                if (!queryParam.value) {
                  throw new Error(`options.queryParameters[${queryParamName}] is of type "object" but it does not contain a "value" property.`);
                }
                if (queryParam.skipUrlEncoding) {
                  queryParams.push(queryParamName + "=" + queryParam.value);
                  this.query[queryParamName] = queryParam.value;
                } else {
                  queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
                  this.query[queryParamName] = encodeURIComponent(queryParam.value);
                }
              }
            }
          }
          this.url += queryParams.join("&");
        }
        if (options.headers) {
          const headers = options.headers;
          for (const headerName of Object.keys(options.headers)) {
            this.headers.set(headerName, headers[headerName]);
          }
        }
        if (!this.headers.get("accept-language")) {
          this.headers.set("accept-language", "en-US");
        }
        if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) {
          this.headers.set("x-ms-client-request-id", this.requestId);
        }
        if (!this.headers.get("Content-Type")) {
          this.headers.set("Content-Type", "application/json; charset=utf-8");
        }
        this.body = options.body;
        if (options.body !== void 0 && options.body !== null) {
          if (options.bodyIsStream) {
            if (!this.headers.get("Transfer-Encoding")) {
              this.headers.set("Transfer-Encoding", "chunked");
            }
            if (this.headers.get("Content-Type") !== "application/octet-stream") {
              this.headers.set("Content-Type", "application/octet-stream");
            }
          } else {
            if (options.serializationMapper) {
              this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
            }
            if (!options.disableJsonStringifyOnBody) {
              this.body = JSON.stringify(options.body);
            }
          }
        }
        if (options.spanOptions) {
          this.spanOptions = options.spanOptions;
        }
        if (options.tracingContext) {
          this.tracingContext = options.tracingContext;
        }
        this.abortSignal = options.abortSignal;
        this.onDownloadProgress = options.onDownloadProgress;
        this.onUploadProgress = options.onUploadProgress;
        return this;
      }
      /**
       * Clone this WebResource HTTP request object.
       * @returns The clone of this WebResource HTTP request object.
       */
      clone() {
        const result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);
        if (this.formData) {
          result.formData = this.formData;
        }
        if (this.operationSpec) {
          result.operationSpec = this.operationSpec;
        }
        if (this.shouldDeserialize) {
          result.shouldDeserialize = this.shouldDeserialize;
        }
        if (this.operationResponseGetter) {
          result.operationResponseGetter = this.operationResponseGetter;
        }
        return result;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/url.js
function isAlphaNumericCharacter(character) {
  const characterCode = character.charCodeAt(0);
  return 48 <= characterCode && characterCode <= 57 || 65 <= characterCode && characterCode <= 90 || 97 <= characterCode && characterCode <= 122;
}
function readRemaining(tokenizer) {
  let result = "";
  if (tokenizer._currentIndex < tokenizer._textLength) {
    result = tokenizer._text.substring(tokenizer._currentIndex);
    tokenizer._currentIndex = tokenizer._textLength;
  }
  return result;
}
function hasCurrentCharacter(tokenizer) {
  return tokenizer._currentIndex < tokenizer._textLength;
}
function getCurrentCharacter(tokenizer) {
  return tokenizer._text[tokenizer._currentIndex];
}
function nextCharacter(tokenizer, step) {
  if (hasCurrentCharacter(tokenizer)) {
    if (!step) {
      step = 1;
    }
    tokenizer._currentIndex += step;
  }
}
function peekCharacters(tokenizer, charactersToPeek) {
  let endIndex = tokenizer._currentIndex + charactersToPeek;
  if (tokenizer._textLength < endIndex) {
    endIndex = tokenizer._textLength;
  }
  return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
}
function readWhile(tokenizer, condition) {
  let result = "";
  while (hasCurrentCharacter(tokenizer)) {
    const currentCharacter = getCurrentCharacter(tokenizer);
    if (!condition(currentCharacter)) {
      break;
    } else {
      result += currentCharacter;
      nextCharacter(tokenizer);
    }
  }
  return result;
}
function readWhileLetterOrDigit(tokenizer) {
  return readWhile(tokenizer, (character) => isAlphaNumericCharacter(character));
}
function readUntilCharacter(tokenizer, ...terminatingCharacters) {
  return readWhile(tokenizer, (character) => terminatingCharacters.indexOf(character) === -1);
}
function nextScheme(tokenizer) {
  const scheme = readWhileLetterOrDigit(tokenizer);
  tokenizer._currentToken = URLToken.scheme(scheme);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else {
    tokenizer._currentState = "HOST";
  }
}
function nextSchemeOrHost(tokenizer) {
  const schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentToken = URLToken.host(schemeOrHost);
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === ":") {
    if (peekCharacters(tokenizer, 3) === "://") {
      tokenizer._currentToken = URLToken.scheme(schemeOrHost);
      tokenizer._currentState = "HOST";
    } else {
      tokenizer._currentToken = URLToken.host(schemeOrHost);
      tokenizer._currentState = "PORT";
    }
  } else {
    tokenizer._currentToken = URLToken.host(schemeOrHost);
    if (getCurrentCharacter(tokenizer) === "/") {
      tokenizer._currentState = "PATH";
    } else {
      tokenizer._currentState = "QUERY";
    }
  }
}
function nextHost(tokenizer) {
  if (peekCharacters(tokenizer, 3) === "://") {
    nextCharacter(tokenizer, 3);
  }
  const host = readUntilCharacter(tokenizer, ":", "/", "?");
  tokenizer._currentToken = URLToken.host(host);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === ":") {
    tokenizer._currentState = "PORT";
  } else if (getCurrentCharacter(tokenizer) === "/") {
    tokenizer._currentState = "PATH";
  } else {
    tokenizer._currentState = "QUERY";
  }
}
function nextPort(tokenizer) {
  if (getCurrentCharacter(tokenizer) === ":") {
    nextCharacter(tokenizer);
  }
  const port = readUntilCharacter(tokenizer, "/", "?");
  tokenizer._currentToken = URLToken.port(port);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === "/") {
    tokenizer._currentState = "PATH";
  } else {
    tokenizer._currentState = "QUERY";
  }
}
function nextPath(tokenizer) {
  const path = readUntilCharacter(tokenizer, "?");
  tokenizer._currentToken = URLToken.path(path);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else {
    tokenizer._currentState = "QUERY";
  }
}
function nextQuery(tokenizer) {
  if (getCurrentCharacter(tokenizer) === "?") {
    nextCharacter(tokenizer);
  }
  const query = readRemaining(tokenizer);
  tokenizer._currentToken = URLToken.query(query);
  tokenizer._currentState = "DONE";
}
var URLQuery, URLBuilder, URLToken, URLTokenizer;
var init_url = __esm({
  "node_modules/@azure/core-http/dist-esm/src/url.js"() {
    init_utils3();
    URLQuery = class {
      constructor() {
        this._rawQuery = {};
      }
      /**
       * Get whether or not there any query parameters in this URLQuery.
       */
      any() {
        return Object.keys(this._rawQuery).length > 0;
      }
      /**
       * Get the keys of the query string.
       */
      keys() {
        return Object.keys(this._rawQuery);
      }
      /**
       * Set a query parameter with the provided name and value. If the parameterValue is undefined or
       * empty, then this will attempt to remove an existing query parameter with the provided
       * parameterName.
       */
      set(parameterName, parameterValue) {
        const caseParameterValue = parameterValue;
        if (parameterName) {
          if (caseParameterValue !== void 0 && caseParameterValue !== null) {
            const newValue = Array.isArray(caseParameterValue) ? caseParameterValue : caseParameterValue.toString();
            this._rawQuery[parameterName] = newValue;
          } else {
            delete this._rawQuery[parameterName];
          }
        }
      }
      /**
       * Get the value of the query parameter with the provided name. If no parameter exists with the
       * provided parameter name, then undefined will be returned.
       */
      get(parameterName) {
        return parameterName ? this._rawQuery[parameterName] : void 0;
      }
      /**
       * Get the string representation of this query. The return value will not start with a "?".
       */
      toString() {
        let result = "";
        for (const parameterName in this._rawQuery) {
          if (result) {
            result += "&";
          }
          const parameterValue = this._rawQuery[parameterName];
          if (Array.isArray(parameterValue)) {
            const parameterStrings = [];
            for (const parameterValueElement of parameterValue) {
              parameterStrings.push(`${parameterName}=${parameterValueElement}`);
            }
            result += parameterStrings.join("&");
          } else {
            result += `${parameterName}=${parameterValue}`;
          }
        }
        return result;
      }
      /**
       * Parse a URLQuery from the provided text.
       */
      static parse(text) {
        const result = new URLQuery();
        if (text) {
          if (text.startsWith("?")) {
            text = text.substring(1);
          }
          let currentState = "ParameterName";
          let parameterName = "";
          let parameterValue = "";
          for (let i = 0; i < text.length; ++i) {
            const currentCharacter = text[i];
            switch (currentState) {
              case "ParameterName":
                switch (currentCharacter) {
                  case "=":
                    currentState = "ParameterValue";
                    break;
                  case "&":
                    parameterName = "";
                    parameterValue = "";
                    break;
                  default:
                    parameterName += currentCharacter;
                    break;
                }
                break;
              case "ParameterValue":
                switch (currentCharacter) {
                  case "&":
                    result.set(parameterName, parameterValue);
                    parameterName = "";
                    parameterValue = "";
                    currentState = "ParameterName";
                    break;
                  default:
                    parameterValue += currentCharacter;
                    break;
                }
                break;
              default:
                throw new Error("Unrecognized URLQuery parse state: " + currentState);
            }
          }
          if (currentState === "ParameterValue") {
            result.set(parameterName, parameterValue);
          }
        }
        return result;
      }
    };
    URLBuilder = class {
      /**
       * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL
       * (such as a host, port, path, or query), those parts will be added to this URL as well.
       */
      setScheme(scheme) {
        if (!scheme) {
          this._scheme = void 0;
        } else {
          this.set(scheme, "SCHEME");
        }
      }
      /**
       * Get the scheme that has been set in this URL.
       */
      getScheme() {
        return this._scheme;
      }
      /**
       * Set the host for this URL. If the provided host contains other parts of a URL (such as a
       * port, path, or query), those parts will be added to this URL as well.
       */
      setHost(host) {
        if (!host) {
          this._host = void 0;
        } else {
          this.set(host, "SCHEME_OR_HOST");
        }
      }
      /**
       * Get the host that has been set in this URL.
       */
      getHost() {
        return this._host;
      }
      /**
       * Set the port for this URL. If the provided port contains other parts of a URL (such as a
       * path or query), those parts will be added to this URL as well.
       */
      setPort(port) {
        if (port === void 0 || port === null || port === "") {
          this._port = void 0;
        } else {
          this.set(port.toString(), "PORT");
        }
      }
      /**
       * Get the port that has been set in this URL.
       */
      getPort() {
        return this._port;
      }
      /**
       * Set the path for this URL. If the provided path contains a query, then it will be added to
       * this URL as well.
       */
      setPath(path) {
        if (!path) {
          this._path = void 0;
        } else {
          const schemeIndex = path.indexOf("://");
          if (schemeIndex !== -1) {
            const schemeStart = path.lastIndexOf("/", schemeIndex);
            this.set(schemeStart === -1 ? path : path.substr(schemeStart + 1), "SCHEME");
          } else {
            this.set(path, "PATH");
          }
        }
      }
      /**
       * Append the provided path to this URL's existing path. If the provided path contains a query,
       * then it will be added to this URL as well.
       */
      appendPath(path) {
        if (path) {
          let currentPath = this.getPath();
          if (currentPath) {
            if (!currentPath.endsWith("/")) {
              currentPath += "/";
            }
            if (path.startsWith("/")) {
              path = path.substring(1);
            }
            path = currentPath + path;
          }
          this.set(path, "PATH");
        }
      }
      /**
       * Get the path that has been set in this URL.
       */
      getPath() {
        return this._path;
      }
      /**
       * Set the query in this URL.
       */
      setQuery(query) {
        if (!query) {
          this._query = void 0;
        } else {
          this._query = URLQuery.parse(query);
        }
      }
      /**
       * Set a query parameter with the provided name and value in this URL's query. If the provided
       * query parameter value is undefined or empty, then the query parameter will be removed if it
       * existed.
       */
      setQueryParameter(queryParameterName, queryParameterValue) {
        if (queryParameterName) {
          if (!this._query) {
            this._query = new URLQuery();
          }
          this._query.set(queryParameterName, queryParameterValue);
        }
      }
      /**
       * Get the value of the query parameter with the provided query parameter name. If no query
       * parameter exists with the provided name, then undefined will be returned.
       */
      getQueryParameterValue(queryParameterName) {
        return this._query ? this._query.get(queryParameterName) : void 0;
      }
      /**
       * Get the query in this URL.
       */
      getQuery() {
        return this._query ? this._query.toString() : void 0;
      }
      /**
       * Set the parts of this URL by parsing the provided text using the provided startState.
       */
      set(text, startState) {
        const tokenizer = new URLTokenizer(text, startState);
        while (tokenizer.next()) {
          const token = tokenizer.current();
          let tokenPath;
          if (token) {
            switch (token.type) {
              case "SCHEME":
                this._scheme = token.text || void 0;
                break;
              case "HOST":
                this._host = token.text || void 0;
                break;
              case "PORT":
                this._port = token.text || void 0;
                break;
              case "PATH":
                tokenPath = token.text || void 0;
                if (!this._path || this._path === "/" || tokenPath !== "/") {
                  this._path = tokenPath;
                }
                break;
              case "QUERY":
                this._query = URLQuery.parse(token.text);
                break;
              default:
                throw new Error(`Unrecognized URLTokenType: ${token.type}`);
            }
          }
        }
      }
      /**
       * Serializes the URL as a string.
       * @returns the URL as a string.
       */
      toString() {
        let result = "";
        if (this._scheme) {
          result += `${this._scheme}://`;
        }
        if (this._host) {
          result += this._host;
        }
        if (this._port) {
          result += `:${this._port}`;
        }
        if (this._path) {
          if (!this._path.startsWith("/")) {
            result += "/";
          }
          result += this._path;
        }
        if (this._query && this._query.any()) {
          result += `?${this._query.toString()}`;
        }
        return result;
      }
      /**
       * If the provided searchValue is found in this URLBuilder, then replace it with the provided
       * replaceValue.
       */
      replaceAll(searchValue, replaceValue) {
        if (searchValue) {
          this.setScheme(replaceAll2(this.getScheme(), searchValue, replaceValue));
          this.setHost(replaceAll2(this.getHost(), searchValue, replaceValue));
          this.setPort(replaceAll2(this.getPort(), searchValue, replaceValue));
          this.setPath(replaceAll2(this.getPath(), searchValue, replaceValue));
          this.setQuery(replaceAll2(this.getQuery(), searchValue, replaceValue));
        }
      }
      /**
       * Parses a given string URL into a new {@link URLBuilder}.
       */
      static parse(text) {
        const result = new URLBuilder();
        result.set(text, "SCHEME_OR_HOST");
        return result;
      }
    };
    URLToken = class {
      constructor(text, type) {
        this.text = text;
        this.type = type;
      }
      static scheme(text) {
        return new URLToken(text, "SCHEME");
      }
      static host(text) {
        return new URLToken(text, "HOST");
      }
      static port(text) {
        return new URLToken(text, "PORT");
      }
      static path(text) {
        return new URLToken(text, "PATH");
      }
      static query(text) {
        return new URLToken(text, "QUERY");
      }
    };
    URLTokenizer = class {
      constructor(_text, state) {
        this._text = _text;
        this._textLength = _text ? _text.length : 0;
        this._currentState = state !== void 0 && state !== null ? state : "SCHEME_OR_HOST";
        this._currentIndex = 0;
      }
      /**
       * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer
       * hasn't started or has finished tokenizing.
       */
      current() {
        return this._currentToken;
      }
      /**
       * Advance to the next URLToken and return whether or not a URLToken was found.
       */
      next() {
        if (!hasCurrentCharacter(this)) {
          this._currentToken = void 0;
        } else {
          switch (this._currentState) {
            case "SCHEME":
              nextScheme(this);
              break;
            case "SCHEME_OR_HOST":
              nextSchemeOrHost(this);
              break;
            case "HOST":
              nextHost(this);
              break;
            case "PORT":
              nextPort(this);
              break;
            case "PATH":
              nextPath(this);
              break;
            case "QUERY":
              nextQuery(this);
              break;
            default:
              throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`);
          }
        }
        return !!this._currentToken;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/sanitizer.js
var RedactedString, defaultAllowedHeaderNames, defaultAllowedQueryParameters, Sanitizer;
var init_sanitizer = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/sanitizer.js"() {
    init_url();
    init_utils3();
    RedactedString = "REDACTED";
    defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    defaultAllowedQueryParameters = ["api-version"];
    Sanitizer = class {
      constructor({ allowedHeaderNames = [], allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = Array.isArray(allowedHeaderNames) ? defaultAllowedHeaderNames.concat(allowedHeaderNames) : defaultAllowedHeaderNames;
        allowedQueryParameters = Array.isArray(allowedQueryParameters) ? defaultAllowedQueryParameters.concat(allowedQueryParameters) : defaultAllowedQueryParameters;
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "_headersMap") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || isObject(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeHeaders(value) {
        return this.sanitizeObject(value, this.allowedHeaderNames, (v, k) => v[k].value);
      }
      sanitizeQuery(value) {
        return this.sanitizeObject(value, this.allowedQueryParameters, (v, k) => v[k]);
      }
      sanitizeObject(value, allowedKeys, accessor) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (allowedKeys.has(k.toLowerCase())) {
            sanitized[k] = accessor(value, k);
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
          return value;
        }
        const urlBuilder = URLBuilder.parse(value);
        const queryString = urlBuilder.getQuery();
        if (!queryString) {
          return value;
        }
        const query = URLQuery.parse(queryString);
        for (const k of query.keys()) {
          if (!this.allowedQueryParameters.has(k.toLowerCase())) {
            query.set(k, RedactedString);
          }
        }
        urlBuilder.setQuery(query.toString());
        return urlBuilder.toString();
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/inspect.browser.js
var custom;
var init_inspect_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/inspect.browser.js"() {
    custom = {};
  }
});

// node_modules/@azure/core-http/dist-esm/src/restError.js
var errorSanitizer, RestError2;
var init_restError = __esm({
  "node_modules/@azure/core-http/dist-esm/src/restError.js"() {
    init_sanitizer();
    init_inspect_browser();
    errorSanitizer = new Sanitizer();
    RestError2 = class extends Error {
      constructor(message, code, statusCode, request, response) {
        super(message);
        this.name = "RestError";
        this.code = code;
        this.statusCode = statusCode;
        this.request = request;
        this.response = response;
        Object.setPrototypeOf(this, RestError2.prototype);
      }
      /**
       * Logging method for util.inspect in Node
       */
      [custom]() {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
      }
    };
    RestError2.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError2.PARSE_ERROR = "PARSE_ERROR";
  }
});

// node_modules/@azure/core-http/dist-esm/src/xhrHttpClient.js
function handleBlobResponse(xhr, request, res, rej) {
  xhr.addEventListener("readystatechange", () => {
    var _a2;
    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
      if (request.streamResponseBody || ((_a2 = request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(xhr.status))) {
        const blobBody = new Promise((resolve, reject) => {
          xhr.addEventListener("load", () => {
            resolve(xhr.response);
          });
          rejectOnTerminalEvent(request, xhr, reject);
        });
        res({
          request,
          status: xhr.status,
          headers: parseHeaders(xhr),
          blobBody
        });
      } else {
        xhr.addEventListener("load", () => {
          if (xhr.response) {
            const reader = new FileReader();
            reader.onload = function(e) {
              var _a3;
              const text = (_a3 = e.target) === null || _a3 === void 0 ? void 0 : _a3.result;
              res({
                request,
                status: xhr.status,
                headers: parseHeaders(xhr),
                bodyAsText: text
              });
            };
            reader.onerror = function(_e) {
              rej(reader.error);
            };
            reader.readAsText(xhr.response, "UTF-8");
          } else {
            res({
              request,
              status: xhr.status,
              headers: parseHeaders(xhr)
            });
          }
        });
      }
    }
  });
}
function addProgressListener(xhr, listener) {
  if (listener) {
    xhr.addEventListener("progress", (rawEvent) => listener({
      loadedBytes: rawEvent.loaded
    }));
  }
}
function parseHeaders(xhr) {
  const responseHeaders = new HttpHeaders();
  const headerLines = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);
  for (const line of headerLines) {
    const index = line.indexOf(":");
    const headerName = line.slice(0, index);
    const headerValue = line.slice(index + 2);
    responseHeaders.set(headerName, headerValue);
  }
  return responseHeaders;
}
function rejectOnTerminalEvent(request, xhr, reject) {
  xhr.addEventListener("error", () => reject(new RestError2(`Failed to send request to ${request.url}`, RestError2.REQUEST_SEND_ERROR, void 0, request)));
  const abortError = new AbortError("The operation was aborted.");
  xhr.addEventListener("abort", () => reject(abortError));
  xhr.addEventListener("timeout", () => reject(abortError));
}
var XhrHttpClient;
var init_xhrHttpClient = __esm({
  "node_modules/@azure/core-http/dist-esm/src/xhrHttpClient.js"() {
    init_httpHeaders();
    init_src2();
    init_restError();
    XhrHttpClient = class {
      sendRequest(request) {
        var _a2;
        const xhr = new XMLHttpRequest();
        if (request.proxySettings) {
          throw new Error("HTTP proxy is not supported in browser environment");
        }
        const abortSignal = request.abortSignal;
        if (abortSignal) {
          if (abortSignal.aborted) {
            return Promise.reject(new AbortError("The operation was aborted."));
          }
          const listener = () => {
            xhr.abort();
          };
          abortSignal.addEventListener("abort", listener);
          xhr.addEventListener("readystatechange", () => {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              abortSignal.removeEventListener("abort", listener);
            }
          });
        }
        addProgressListener(xhr.upload, request.onUploadProgress);
        addProgressListener(xhr, request.onDownloadProgress);
        if (request.formData) {
          const formData = request.formData;
          const requestForm = new FormData();
          const appendFormValue = (key, value) => {
            if (value && Object.prototype.hasOwnProperty.call(value, "value") && Object.prototype.hasOwnProperty.call(value, "options")) {
              requestForm.append(key, value.value, value.options);
            } else {
              requestForm.append(key, value);
            }
          };
          for (const formKey of Object.keys(formData)) {
            const formValue = formData[formKey];
            if (Array.isArray(formValue)) {
              for (let j = 0; j < formValue.length; j++) {
                appendFormValue(formKey, formValue[j]);
              }
            } else {
              appendFormValue(formKey, formValue);
            }
          }
          request.body = requestForm;
          request.formData = void 0;
          const contentType2 = request.headers.get("Content-Type");
          if (contentType2 && contentType2.indexOf("multipart/form-data") !== -1) {
            request.headers.remove("Content-Type");
          }
        }
        xhr.open(request.method, request.url);
        xhr.timeout = request.timeout;
        xhr.withCredentials = request.withCredentials;
        for (const header of request.headers.headersArray()) {
          xhr.setRequestHeader(header.name, header.value);
        }
        xhr.responseType = ((_a2 = request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.size) || request.streamResponseBody ? "blob" : "text";
        xhr.send(request.body === void 0 ? null : request.body);
        if (xhr.responseType === "blob") {
          return new Promise((resolve, reject) => {
            handleBlobResponse(xhr, request, resolve, reject);
            rejectOnTerminalEvent(request, xhr, reject);
          });
        } else {
          return new Promise(function(resolve, reject) {
            xhr.addEventListener("load", () => resolve({
              request,
              status: xhr.status,
              headers: parseHeaders(xhr),
              bodyAsText: xhr.responseText
            }));
            rejectOnTerminalEvent(request, xhr, reject);
          });
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/defaultHttpClient.browser.js
var init_defaultHttpClient_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/defaultHttpClient.browser.js"() {
    init_xhrHttpClient();
  }
});

// node_modules/@azure/core-http/dist-esm/src/httpPipelineLogLevel.js
var HttpPipelineLogLevel;
var init_httpPipelineLogLevel = __esm({
  "node_modules/@azure/core-http/dist-esm/src/httpPipelineLogLevel.js"() {
    (function(HttpPipelineLogLevel2) {
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
    })(HttpPipelineLogLevel || (HttpPipelineLogLevel = {}));
  }
});

// node_modules/@azure/core-http/dist-esm/src/operationOptions.js
function operationOptionsToRequestOptionsBase(opts) {
  const { requestOptions, tracingOptions } = opts, additionalOptions = __rest(opts, ["requestOptions", "tracingOptions"]);
  let result = additionalOptions;
  if (requestOptions) {
    result = Object.assign(Object.assign({}, result), requestOptions);
  }
  if (tracingOptions) {
    result.tracingContext = tracingOptions.tracingContext;
    result.spanOptions = tracingOptions === null || tracingOptions === void 0 ? void 0 : tracingOptions.spanOptions;
  }
  return result;
}
var init_operationOptions = __esm({
  "node_modules/@azure/core-http/dist-esm/src/operationOptions.js"() {
    init_tslib_es6();
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/requestPolicy.js
var BaseRequestPolicy, RequestPolicyOptions;
var init_requestPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/requestPolicy.js"() {
    init_httpPipelineLogLevel();
    BaseRequestPolicy = class {
      /**
       * The main method to implement that manipulates a request/response.
       */
      constructor(_nextPolicy, _options) {
        this._nextPolicy = _nextPolicy;
        this._options = _options;
      }
      /**
       * Get whether or not a log with the provided log level should be logged.
       * @param logLevel - The log level of the log that will be logged.
       * @returns Whether or not a log with the provided log level should be logged.
       */
      shouldLog(logLevel) {
        return this._options.shouldLog(logLevel);
      }
      /**
       * Attempt to log the provided message to the provided logger. If no logger was provided or if
       * the log level does not meat the logger's threshold, then nothing will be logged.
       * @param logLevel - The log level of this log.
       * @param message - The message of this log.
       */
      log(logLevel, message) {
        this._options.log(logLevel, message);
      }
    };
    RequestPolicyOptions = class {
      constructor(_logger) {
        this._logger = _logger;
      }
      /**
       * Get whether or not a log with the provided log level should be logged.
       * @param logLevel - The log level of the log that will be logged.
       * @returns Whether or not a log with the provided log level should be logged.
       */
      shouldLog(logLevel) {
        return !!this._logger && logLevel !== HttpPipelineLogLevel.OFF && logLevel <= this._logger.minimumLogLevel;
      }
      /**
       * Attempt to log the provided message to the provided logger. If no logger was provided or if
       * the log level does not meet the logger's threshold, then nothing will be logged.
       * @param logLevel - The log level of this log.
       * @param message - The message of this log.
       */
      log(logLevel, message) {
        if (this._logger && this.shouldLog(logLevel)) {
          this._logger.log(logLevel, message);
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/xml.browser.js
function getDoc() {
  if (!cachedDoc) {
    cachedDoc = document.implementation.createDocument(null, null, null);
  }
  return cachedDoc;
}
function getParser() {
  if (!cachedParser) {
    cachedParser = new DOMParser();
  }
  return cachedParser;
}
function getSerializer() {
  if (!cachedSerializer) {
    cachedSerializer = new XMLSerializer();
  }
  return cachedSerializer;
}
function parseXML(str, opts = {}) {
  var _a2, _b, _c, _d;
  try {
    const updatedOptions = {
      rootName: (_a2 = opts.rootName) !== null && _a2 !== void 0 ? _a2 : "",
      includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
      xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY2
    };
    const dom = getParser().parseFromString((_d = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _d !== void 0 ? _d : str, "application/xml");
    throwIfError(dom);
    let obj;
    if (updatedOptions.includeRoot) {
      obj = domToObject(dom, updatedOptions);
    } else {
      obj = domToObject(dom.childNodes[0], updatedOptions);
    }
    return Promise.resolve(obj);
  } catch (err) {
    return Promise.reject(err);
  }
}
function getErrorNamespace() {
  var _a2, _b;
  if (errorNS === void 0) {
    try {
      const invalidXML = (_a2 = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML("INVALID")) !== null && _a2 !== void 0 ? _a2 : "INVALID";
      errorNS = (_b = getParser().parseFromString(invalidXML, "text/xml").getElementsByTagName("parsererror")[0].namespaceURI) !== null && _b !== void 0 ? _b : "";
    } catch (ignored) {
      errorNS = "";
    }
  }
  return errorNS;
}
function throwIfError(dom) {
  const parserErrors = dom.getElementsByTagName("parsererror");
  if (parserErrors.length > 0 && getErrorNamespace()) {
    for (let i = 0; i < parserErrors.length; i++) {
      if (parserErrors[i].namespaceURI === errorNS) {
        throw new Error(parserErrors[i].innerHTML);
      }
    }
  }
}
function isElement(node) {
  return !!node.attributes;
}
function asElementWithAttributes(node) {
  return isElement(node) && node.hasAttributes() ? node : void 0;
}
function domToObject(node, options) {
  let result = {};
  const childNodeCount = node.childNodes.length;
  const firstChildNode = node.childNodes[0];
  const onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || void 0;
  const elementWithAttributes = asElementWithAttributes(node);
  if (elementWithAttributes) {
    result[XML_ATTRKEY2] = {};
    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {
      const attr = elementWithAttributes.attributes[i];
      result[XML_ATTRKEY2][attr.nodeName] = attr.nodeValue;
    }
    if (onlyChildTextValue) {
      result[options.xmlCharKey] = onlyChildTextValue;
    }
  } else if (childNodeCount === 0) {
    result = "";
  } else if (onlyChildTextValue) {
    result = onlyChildTextValue;
  }
  if (!onlyChildTextValue) {
    for (let i = 0; i < childNodeCount; i++) {
      const child = node.childNodes[i];
      if (child.nodeType !== Node.TEXT_NODE) {
        const childObject = domToObject(child, options);
        if (!result[child.nodeName]) {
          result[child.nodeName] = childObject;
        } else if (Array.isArray(result[child.nodeName])) {
          result[child.nodeName].push(childObject);
        } else {
          result[child.nodeName] = [result[child.nodeName], childObject];
        }
      }
    }
  }
  return result;
}
function stringifyXML(content, opts = {}) {
  var _a2, _b, _c;
  const updatedOptions = {
    rootName: (_a2 = opts.rootName) !== null && _a2 !== void 0 ? _a2 : "root",
    includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
    xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY2
  };
  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + getSerializer().serializeToString(dom);
}
function buildAttributes(attrs) {
  const result = [];
  for (const key of Object.keys(attrs)) {
    const attr = getDoc().createAttribute(key);
    attr.value = attrs[key].toString();
    result.push(attr);
  }
  return result;
}
function buildNode(obj, elementName, options) {
  if (obj === void 0 || obj === null || typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
    const elem = getDoc().createElement(elementName);
    elem.textContent = obj === void 0 || obj === null ? "" : obj.toString();
    return [elem];
  } else if (Array.isArray(obj)) {
    const result = [];
    for (const arrayElem of obj) {
      for (const child of buildNode(arrayElem, elementName, options)) {
        result.push(child);
      }
    }
    return result;
  } else if (typeof obj === "object") {
    const elem = getDoc().createElement(elementName);
    for (const key of Object.keys(obj)) {
      if (key === XML_ATTRKEY2) {
        for (const attr of buildAttributes(obj[key])) {
          elem.attributes.setNamedItem(attr);
        }
      } else if (key === options.xmlCharKey) {
        elem.textContent = obj[key].toString();
      } else {
        for (const child of buildNode(obj[key], key, options)) {
          elem.appendChild(child);
        }
      }
    }
    return [elem];
  } else {
    throw new Error(`Illegal value passed to buildObject: ${obj}`);
  }
}
var cachedDoc, cachedParser, cachedSerializer, ttPolicy, errorNS;
var init_xml_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/xml.browser.js"() {
    init_serializer_common();
    if (!self.document || !self.DOMParser || !self.Node || !self.XMLSerializer) {
      throw new Error(`This library depends on the following DOM objects: ["document", "DOMParser", "Node", "XMLSerializer"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `);
    }
    if (typeof self.trustedTypes !== "undefined") {
      ttPolicy = self.trustedTypes.createPolicy("@azure/core-http#xml.browser", {
        createHTML: (s) => s
      });
    }
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/deserializationPolicy.js
function deserializationPolicy2(deserializationContentTypes, parsingOptions) {
  return {
    create: (nextPolicy, options) => {
      return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);
    }
  };
}
function getOperationResponse(parsedResponse) {
  let result;
  const request = parsedResponse.request;
  const operationSpec = request.operationSpec;
  if (operationSpec) {
    const operationResponseGetter = request.operationResponseGetter;
    if (!operationResponseGetter) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse2(parsedResponse) {
  const shouldDeserialize = parsedResponse.request.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
function deserializeResponseBody2(jsonContentTypes, xmlContentTypes, response, options = {}) {
  var _a2, _b, _c;
  const updatedOptions = {
    rootName: (_a2 = options.rootName) !== null && _a2 !== void 0 ? _a2 : "",
    includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
    xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY2
  };
  return parse2(jsonContentTypes, xmlContentTypes, response, updatedOptions).then((parsedResponse) => {
    if (!shouldDeserializeResponse2(parsedResponse)) {
      return parsedResponse;
    }
    const operationSpec = parsedResponse.request.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
      return parsedResponse;
    }
    const responseSpec = getOperationResponse(parsedResponse);
    const { error, shouldReturnResponse } = handleErrorResponse2(parsedResponse, operationSpec, responseSpec);
    if (error) {
      throw error;
    } else if (shouldReturnResponse) {
      return parsedResponse;
    }
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        let valueToDeserialize = parsedResponse.parsedBody;
        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        }
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (innerError) {
          const restError = new RestError2(`Error ${innerError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
          throw restError;
        }
      } else if (operationSpec.httpMethod === "HEAD") {
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      }
      if (responseSpec.headersMapper) {
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJson(), "operationRes.parsedHeaders", options);
      }
    }
    return parsedResponse;
  });
}
function isOperationSpecEmpty2(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse2(parsedResponse, operationSpec, responseSpec) {
  var _a2;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty2(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const streaming = ((_a2 = parsedResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(parsedResponse.status)) || parsedResponse.request.streamResponseBody;
  const initialErrorMessage = streaming ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError2(initialErrorMessage, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let parsedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence) {
          valueToDeserialize = typeof parsedBody === "object" ? parsedBody[defaultBodyMapper.xmlElementName] : [];
        }
        parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
      }
      const internalError = parsedBody.error || parsedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = parsedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJson(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
function parse2(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
  var _a2;
  const errorHandler = (err) => {
    const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
    const errCode = err.code || RestError2.PARSE_ERROR;
    const e = new RestError2(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
    return Promise.reject(e);
  };
  const streaming = ((_a2 = operationResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(operationResponse.status)) || operationResponse.request.streamResponseBody;
  if (!streaming && operationResponse.bodyAsText) {
    const text = operationResponse.bodyAsText;
    const contentType2 = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType2 ? [] : contentType2.split(";").map((component) => component.toLowerCase());
    if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
      return new Promise((resolve) => {
        operationResponse.parsedBody = JSON.parse(text);
        resolve(operationResponse);
      }).catch(errorHandler);
    } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
      return parseXML(text, opts).then((body) => {
        operationResponse.parsedBody = body;
        return operationResponse;
      }).catch(errorHandler);
    }
  }
  return Promise.resolve(operationResponse);
}
var defaultJsonContentTypes2, defaultXmlContentTypes2, DefaultDeserializationOptions, DeserializationPolicy;
var init_deserializationPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/deserializationPolicy.js"() {
    init_requestPolicy();
    init_serializer_common();
    init_serializer();
    init_restError();
    init_xml_browser();
    defaultJsonContentTypes2 = ["application/json", "text/json"];
    defaultXmlContentTypes2 = ["application/xml", "application/atom+xml"];
    DefaultDeserializationOptions = {
      expectedContentTypes: {
        json: defaultJsonContentTypes2,
        xml: defaultXmlContentTypes2
      }
    };
    DeserializationPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions = {}) {
        var _a2;
        super(nextPolicy, requestPolicyOptions);
        this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes2;
        this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes2;
        this.xmlCharKey = (_a2 = parsingOptions.xmlCharKey) !== null && _a2 !== void 0 ? _a2 : XML_CHARKEY2;
      }
      async sendRequest(request) {
        return this._nextPolicy.sendRequest(request).then((response) => deserializeResponseBody2(this.jsonContentTypes, this.xmlContentTypes, response, {
          xmlCharKey: this.xmlCharKey
        }));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/keepAlivePolicy.js
function keepAlivePolicy(keepAliveOptions) {
  return {
    create: (nextPolicy, options) => {
      return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);
    }
  };
}
var DefaultKeepAliveOptions, KeepAlivePolicy;
var init_keepAlivePolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/keepAlivePolicy.js"() {
    init_requestPolicy();
    DefaultKeepAliveOptions = {
      enable: true
    };
    KeepAlivePolicy = class extends BaseRequestPolicy {
      /**
       * Creates an instance of KeepAlivePolicy.
       *
       * @param nextPolicy -
       * @param options -
       * @param keepAliveOptions -
       */
      constructor(nextPolicy, options, keepAliveOptions) {
        super(nextPolicy, options);
        this.keepAliveOptions = keepAliveOptions;
      }
      /**
       * Sends out request.
       *
       * @param request -
       * @returns
       */
      async sendRequest(request) {
        request.keepAlive = this.keepAliveOptions.enable;
        return this._nextPolicy.sendRequest(request);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/redirectPolicy.js
function redirectPolicy(maximumRetries = 20) {
  return {
    create: (nextPolicy, options) => {
      return new RedirectPolicy(nextPolicy, options, maximumRetries);
    }
  };
}
function handleRedirect(policy, response, currentRetries) {
  const { request, status } = response;
  const locationHeader = response.headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && (!policy.maxRetries || currentRetries < policy.maxRetries)) {
    const builder = URLBuilder.parse(request.url);
    builder.setPath(locationHeader);
    request.url = builder.toString();
    if (status === 303) {
      request.method = "GET";
      delete request.body;
    }
    return policy._nextPolicy.sendRequest(request).then((res) => handleRedirect(policy, res, currentRetries + 1));
  }
  return Promise.resolve(response);
}
var allowedRedirect, DefaultRedirectOptions, RedirectPolicy;
var init_redirectPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/redirectPolicy.js"() {
    init_requestPolicy();
    init_url();
    allowedRedirect = ["GET", "HEAD"];
    DefaultRedirectOptions = {
      handleRedirects: true,
      maxRetries: 20
    };
    RedirectPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, maxRetries = 20) {
        super(nextPolicy, options);
        this.maxRetries = maxRetries;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request).then((response) => handleRedirect(this, response, 0));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/exponentialBackoffStrategy.js
function isNumber(n) {
  return typeof n === "number";
}
function shouldRetry(retryLimit, predicate, retryData, response, error) {
  if (!predicate(response, error)) {
    return false;
  }
  return retryData.retryCount < retryLimit;
}
function updateRetryData(retryOptions, retryData = { retryCount: 0, retryInterval: 0 }, err) {
  if (err) {
    if (retryData.error) {
      err.innerError = retryData.error;
    }
    retryData.error = err;
  }
  retryData.retryCount++;
  let incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;
  const boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));
  incrementDelta *= boundedRandDelta;
  retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);
  return retryData;
}
var DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
var init_exponentialBackoffStrategy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/exponentialBackoffStrategy.js"() {
    DEFAULT_CLIENT_RETRY_COUNT = 3;
    DEFAULT_CLIENT_RETRY_INTERVAL = 1e3 * 30;
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 90;
    DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1e3 * 3;
  }
});

// node_modules/@azure/core-http/dist-esm/src/log.js
var logger3;
var init_log = __esm({
  "node_modules/@azure/core-http/dist-esm/src/log.js"() {
    init_src();
    logger3 = createClientLogger("core-http");
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/exponentialRetryPolicy.js
function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
  return {
    create: (nextPolicy, options) => {
      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);
    }
  };
}
async function retry(policy, request, response, retryData, requestError) {
  function shouldPolicyRetry(responseParam) {
    const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;
    if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {
      return false;
    }
    if (statusCode === void 0 || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {
      return false;
    }
    return true;
  }
  retryData = updateRetryData({
    retryInterval: policy.retryInterval,
    minRetryInterval: 0,
    maxRetryInterval: policy.maxRetryInterval
  }, retryData, requestError);
  const isAborted = request.abortSignal && request.abortSignal.aborted;
  if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {
    logger3.info(`Retrying request in ${retryData.retryInterval}`);
    try {
      await delay(retryData.retryInterval);
      const res = await policy._nextPolicy.sendRequest(request.clone());
      return retry(policy, request, res, retryData);
    } catch (err) {
      return retry(policy, request, response, retryData, err);
    }
  } else if (isAborted || requestError || !response) {
    const err = retryData.error || new RestError2("Failed to send the request.", RestError2.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
    throw err;
  } else {
    return response;
  }
}
var RetryMode, DefaultRetryOptions, ExponentialRetryPolicy;
var init_exponentialRetryPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/exponentialRetryPolicy.js"() {
    init_requestPolicy();
    init_exponentialBackoffStrategy();
    init_constants();
    init_restError();
    init_src3();
    init_log();
    (function(RetryMode2) {
      RetryMode2[RetryMode2["Exponential"] = 0] = "Exponential";
    })(RetryMode || (RetryMode = {}));
    DefaultRetryOptions = {
      maxRetries: DEFAULT_CLIENT_RETRY_COUNT,
      retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,
      maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL
    };
    ExponentialRetryPolicy = class extends BaseRequestPolicy {
      /**
       * @param nextPolicy - The next RequestPolicy in the pipeline chain.
       * @param options - The options for this RequestPolicy.
       * @param retryCount - The client retry count.
       * @param retryInterval - The client retry interval, in milliseconds.
       * @param minRetryInterval - The minimum retry interval, in milliseconds.
       * @param maxRetryInterval - The maximum retry interval, in milliseconds.
       */
      constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {
        super(nextPolicy, options);
        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
        this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request.clone()).then((response) => retry(this, request, response)).catch((error) => retry(this, request, error.response, void 0, error));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/logPolicy.js
function logPolicy(loggingOptions = {}) {
  return {
    create: (nextPolicy, options) => {
      return new LogPolicy(nextPolicy, options, loggingOptions);
    }
  };
}
var LogPolicy;
var init_logPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/logPolicy.js"() {
    init_requestPolicy();
    init_sanitizer();
    init_log();
    LogPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, { logger: logger4 = logger3.info, allowedHeaderNames = [], allowedQueryParameters = [] } = {}) {
        super(nextPolicy, options);
        this.logger = logger4;
        this.sanitizer = new Sanitizer({ allowedHeaderNames, allowedQueryParameters });
      }
      /**
       * Header names whose values will be logged when logging is enabled. Defaults to
       * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
       * specified in this field will be added to that list.  Any other values will
       * be written to logs as "REDACTED".
       * @deprecated Pass these into the constructor instead.
       */
      get allowedHeaderNames() {
        return this.sanitizer.allowedHeaderNames;
      }
      /**
       * Header names whose values will be logged when logging is enabled. Defaults to
       * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
       * specified in this field will be added to that list.  Any other values will
       * be written to logs as "REDACTED".
       * @deprecated Pass these into the constructor instead.
       */
      set allowedHeaderNames(allowedHeaderNames) {
        this.sanitizer.allowedHeaderNames = allowedHeaderNames;
      }
      /**
       * Query string names whose values will be logged when logging is enabled. By default no
       * query string values are logged.
       * @deprecated Pass these into the constructor instead.
       */
      get allowedQueryParameters() {
        return this.sanitizer.allowedQueryParameters;
      }
      /**
       * Query string names whose values will be logged when logging is enabled. By default no
       * query string values are logged.
       * @deprecated Pass these into the constructor instead.
       */
      set allowedQueryParameters(allowedQueryParameters) {
        this.sanitizer.allowedQueryParameters = allowedQueryParameters;
      }
      sendRequest(request) {
        if (!this.logger.enabled)
          return this._nextPolicy.sendRequest(request);
        this.logRequest(request);
        return this._nextPolicy.sendRequest(request).then((response) => this.logResponse(response));
      }
      logRequest(request) {
        this.logger(`Request: ${this.sanitizer.sanitize(request)}`);
      }
      logResponse(response) {
        this.logger(`Response status code: ${response.status}`);
        this.logger(`Headers: ${this.sanitizer.sanitize(response.headers)}`);
        return response;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/operationParameter.js
function getPathStringFromParameter2(parameter) {
  return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
}
function getPathStringFromParameterPath(parameterPath, mapper) {
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
var init_operationParameter = __esm({
  "node_modules/@azure/core-http/dist-esm/src/operationParameter.js"() {
  }
});

// node_modules/@azure/core-http/dist-esm/src/operationSpec.js
function getStreamResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperType.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
var init_operationSpec = __esm({
  "node_modules/@azure/core-http/dist-esm/src/operationSpec.js"() {
    init_serializer();
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/msRestUserAgentPolicy.browser.js
function getDefaultUserAgentKey() {
  return "x-ms-useragent";
}
function getPlatformSpecificData() {
  const navigator2 = self.navigator;
  const osInfo = {
    key: "OS",
    value: (navigator2.oscpu || navigator2.platform).replace(" ", "")
  };
  return [osInfo];
}
var init_msRestUserAgentPolicy_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/msRestUserAgentPolicy.browser.js"() {
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/userAgentPolicy.js
function getRuntimeInfo() {
  const msRestRuntime = {
    key: "core-http",
    value: Constants.coreHttpVersion
  };
  return [msRestRuntime];
}
function getUserAgentString(telemetryInfo, keySeparator = " ", valueSeparator = "/") {
  return telemetryInfo.map((info) => {
    const value = info.value ? `${valueSeparator}${info.value}` : "";
    return `${info.key}${value}`;
  }).join(keySeparator);
}
function getDefaultUserAgentValue() {
  const runtimeInfo = getRuntimeInfo();
  const platformSpecificData = getPlatformSpecificData();
  const userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
  return userAgent;
}
function userAgentPolicy(userAgentData) {
  const key = !userAgentData || userAgentData.key === void 0 || userAgentData.key === null ? getDefaultUserAgentKey() : userAgentData.key;
  const value = !userAgentData || userAgentData.value === void 0 || userAgentData.value === null ? getDefaultUserAgentValue() : userAgentData.value;
  return {
    create: (nextPolicy, options) => {
      return new UserAgentPolicy(nextPolicy, options, key, value);
    }
  };
}
var getDefaultUserAgentHeaderName, UserAgentPolicy;
var init_userAgentPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/userAgentPolicy.js"() {
    init_requestPolicy();
    init_msRestUserAgentPolicy_browser();
    init_constants();
    init_httpHeaders();
    getDefaultUserAgentHeaderName = getDefaultUserAgentKey;
    UserAgentPolicy = class extends BaseRequestPolicy {
      constructor(_nextPolicy, _options, headerKey, headerValue) {
        super(_nextPolicy, _options);
        this._nextPolicy = _nextPolicy;
        this._options = _options;
        this.headerKey = headerKey;
        this.headerValue = headerValue;
      }
      sendRequest(request) {
        this.addUserAgentHeader(request);
        return this._nextPolicy.sendRequest(request);
      }
      /**
       * Adds the user agent header to the outgoing request.
       */
      addUserAgentHeader(request) {
        if (!request.headers) {
          request.headers = new HttpHeaders();
        }
        if (!request.headers.get(this.headerKey) && this.headerValue) {
          request.headers.set(this.headerKey, this.headerValue);
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/queryCollectionFormat.js
var QueryCollectionFormat;
var init_queryCollectionFormat = __esm({
  "node_modules/@azure/core-http/dist-esm/src/queryCollectionFormat.js"() {
    (function(QueryCollectionFormat2) {
      QueryCollectionFormat2["Csv"] = ",";
      QueryCollectionFormat2["Ssv"] = " ";
      QueryCollectionFormat2["Tsv"] = "	";
      QueryCollectionFormat2["Pipes"] = "|";
      QueryCollectionFormat2["Multi"] = "Multi";
    })(QueryCollectionFormat || (QueryCollectionFormat = {}));
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js
async function beginRefresh(getAccessToken, retryIntervalInMs, timeoutInMs) {
  async function tryGetAccessToken() {
    if (Date.now() < timeoutInMs) {
      try {
        return await getAccessToken();
      } catch (_a2) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, scopes, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a2;
      return !cycler.isRefreshing && ((_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(getTokenOptions) {
    var _a2;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (tokenOptions) => {
    if (cycler.mustRefresh)
      return refresh(tokenOptions);
    if (cycler.shouldRefresh) {
      refresh(tokenOptions);
    }
    return token;
  };
}
function bearerTokenAuthenticationPolicy2(credential, scopes) {
  const getToken = createTokenCycler(
    credential,
    scopes
    /* , options */
  );
  class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
    async sendRequest(webResource) {
      if (!webResource.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      const { token } = await getToken({
        abortSignal: webResource.abortSignal,
        tracingOptions: {
          tracingContext: webResource.tracingContext
        }
      });
      webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);
      return this._nextPolicy.sendRequest(webResource);
    }
  }
  return {
    create: (nextPolicy, options) => {
      return new BearerTokenAuthenticationPolicy(nextPolicy, options);
    }
  };
}
var DEFAULT_CYCLER_OPTIONS;
var init_bearerTokenAuthenticationPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js"() {
    init_requestPolicy();
    init_constants();
    init_src3();
    DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      retryIntervalInMs: 3e3,
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/disableResponseDecompressionPolicy.browser.js
function disableResponseDecompressionPolicy() {
  return {
    create: (_nextPolicy, _options) => {
      throw DisbleResponseDecompressionNotSupportedInBrowser;
    }
  };
}
var DisbleResponseDecompressionNotSupportedInBrowser;
var init_disableResponseDecompressionPolicy_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/disableResponseDecompressionPolicy.browser.js"() {
    init_requestPolicy();
    DisbleResponseDecompressionNotSupportedInBrowser = new Error("DisableResponseDecompressionPolicy is not supported in browser environment");
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/generateClientRequestIdPolicy.js
function generateClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    create: (nextPolicy, options) => {
      return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
    }
  };
}
var GenerateClientRequestIdPolicy;
var init_generateClientRequestIdPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/generateClientRequestIdPolicy.js"() {
    init_requestPolicy();
    GenerateClientRequestIdPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, _requestIdHeaderName) {
        super(nextPolicy, options);
        this._requestIdHeaderName = _requestIdHeaderName;
      }
      sendRequest(request) {
        if (!request.headers.contains(this._requestIdHeaderName)) {
          request.headers.set(this._requestIdHeaderName, request.requestId);
        }
        return this._nextPolicy.sendRequest(request);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/httpClientCache.js
function getCachedDefaultHttpClient2() {
  if (!cachedHttpClient2) {
    cachedHttpClient2 = new XhrHttpClient();
  }
  return cachedHttpClient2;
}
var cachedHttpClient2;
var init_httpClientCache = __esm({
  "node_modules/@azure/core-http/dist-esm/src/httpClientCache.js"() {
    init_defaultHttpClient_browser();
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/ndJsonPolicy.js
function ndJsonPolicy() {
  return {
    create: (nextPolicy, options) => {
      return new NdJsonPolicy(nextPolicy, options);
    }
  };
}
var NdJsonPolicy;
var init_ndJsonPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/ndJsonPolicy.js"() {
    init_requestPolicy();
    NdJsonPolicy = class extends BaseRequestPolicy {
      /**
       * Creates an instance of KeepAlivePolicy.
       */
      constructor(nextPolicy, options) {
        super(nextPolicy, options);
      }
      /**
       * Sends a request.
       */
      async sendRequest(request) {
        if (typeof request.body === "string" && request.body.startsWith("[")) {
          const body = JSON.parse(request.body);
          if (Array.isArray(body)) {
            request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
          }
        }
        return this._nextPolicy.sendRequest(request);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/proxyPolicy.browser.js
function getDefaultProxySettings(_proxyUrl) {
  return void 0;
}
function proxyPolicy(_proxySettings) {
  return {
    create: (_nextPolicy, _options) => {
      throw proxyNotSupportedInBrowser;
    }
  };
}
var proxyNotSupportedInBrowser;
var init_proxyPolicy_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/proxyPolicy.browser.js"() {
    init_requestPolicy();
    proxyNotSupportedInBrowser = new Error("ProxyPolicy is not supported in browser environment");
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/rpRegistrationPolicy.js
function rpRegistrationPolicy(retryTimeout = 30) {
  return {
    create: (nextPolicy, options) => {
      return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
    }
  };
}
function registerIfNeeded(policy, request, response) {
  if (response.status === 409) {
    const rpName = checkRPNotRegisteredError(response.bodyAsText);
    if (rpName) {
      const urlPrefix = extractSubscriptionUrl(request.url);
      return registerRP(policy, urlPrefix, rpName, request).catch(() => false).then((registrationStatus) => {
        if (registrationStatus) {
          request.headers.set("x-ms-client-request-id", generateUuid2());
          return policy._nextPolicy.sendRequest(request.clone());
        }
        return response;
      });
    }
  }
  return Promise.resolve(response);
}
function getRequestEssentials(originalRequest, reuseUrlToo = false) {
  const reqOptions = originalRequest.clone();
  if (reuseUrlToo) {
    reqOptions.url = originalRequest.url;
  }
  reqOptions.headers.set("x-ms-client-request-id", generateUuid2());
  reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
  return reqOptions;
}
function checkRPNotRegisteredError(body) {
  let result, responseBody;
  if (body) {
    try {
      responseBody = JSON.parse(body);
    } catch (err) {
    }
    if (responseBody && responseBody.error && responseBody.error.message && responseBody.error.code && responseBody.error.code === "MissingSubscriptionRegistration") {
      const matchRes = responseBody.error.message.match(/.*'(.*)'/i);
      if (matchRes) {
        result = matchRes.pop();
      }
    }
  }
  return result;
}
function extractSubscriptionUrl(url) {
  let result;
  const matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
  if (matchRes && matchRes[0]) {
    result = matchRes[0];
  } else {
    throw new Error(`Unable to extract subscriptionId from the given url - ${url}.`);
  }
  return result;
}
async function registerRP(policy, urlPrefix, provider, originalRequest) {
  const postUrl = `${urlPrefix}providers/${provider}/register?api-version=2016-02-01`;
  const getUrl = `${urlPrefix}providers/${provider}?api-version=2016-02-01`;
  const reqOptions = getRequestEssentials(originalRequest);
  reqOptions.method = "POST";
  reqOptions.url = postUrl;
  const response = await policy._nextPolicy.sendRequest(reqOptions);
  if (response.status !== 200) {
    throw new Error(`Autoregistration of ${provider} failed. Please try registering manually.`);
  }
  return getRegistrationStatus(policy, getUrl, originalRequest);
}
async function getRegistrationStatus(policy, url, originalRequest) {
  const reqOptions = getRequestEssentials(originalRequest);
  reqOptions.url = url;
  reqOptions.method = "GET";
  const res = await policy._nextPolicy.sendRequest(reqOptions);
  const obj = res.parsedBody;
  if (res.parsedBody && obj.registrationState && obj.registrationState === "Registered") {
    return true;
  } else {
    await delay(policy._retryTimeout * 1e3);
    return getRegistrationStatus(policy, url, originalRequest);
  }
}
var RPRegistrationPolicy;
var init_rpRegistrationPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/rpRegistrationPolicy.js"() {
    init_utils3();
    init_requestPolicy();
    init_src3();
    RPRegistrationPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, _retryTimeout = 30) {
        super(nextPolicy, options);
        this._retryTimeout = _retryTimeout;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request.clone()).then((response) => registerIfNeeded(this, request, response));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/signingPolicy.js
function signingPolicy(authenticationProvider) {
  return {
    create: (nextPolicy, options) => {
      return new SigningPolicy(nextPolicy, options, authenticationProvider);
    }
  };
}
var SigningPolicy;
var init_signingPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/signingPolicy.js"() {
    init_requestPolicy();
    SigningPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, authenticationProvider) {
        super(nextPolicy, options);
        this.authenticationProvider = authenticationProvider;
      }
      signRequest(request) {
        return this.authenticationProvider.signRequest(request);
      }
      sendRequest(request) {
        return this.signRequest(request).then((nextRequest) => this._nextPolicy.sendRequest(nextRequest));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/systemErrorRetryPolicy.js
function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
  return {
    create: (nextPolicy, options) => {
      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
    }
  };
}
async function retry2(policy, request, operationResponse, err, retryData) {
  retryData = updateRetryData(policy, retryData, err);
  function shouldPolicyRetry(_response, error) {
    if (error && error.code && (error.code === "ETIMEDOUT" || error.code === "ESOCKETTIMEDOUT" || error.code === "ECONNREFUSED" || error.code === "ECONNRESET" || error.code === "ENOENT")) {
      return true;
    }
    return false;
  }
  if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {
    try {
      await delay(retryData.retryInterval);
      return policy._nextPolicy.sendRequest(request.clone());
    } catch (nestedErr) {
      return retry2(policy, request, operationResponse, nestedErr, retryData);
    }
  } else {
    if (err) {
      return Promise.reject(retryData.error);
    }
    return operationResponse;
  }
}
var SystemErrorRetryPolicy;
var init_systemErrorRetryPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/systemErrorRetryPolicy.js"() {
    init_requestPolicy();
    init_exponentialBackoffStrategy();
    init_src3();
    SystemErrorRetryPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        super(nextPolicy, options);
        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
        this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
        this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request.clone()).catch((error) => retry2(this, request, error.response, error));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/throttlingRetryStrategy.js
var DEFAULT_CLIENT_MAX_RETRY_COUNT;
var init_throttlingRetryStrategy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/throttlingRetryStrategy.js"() {
    DEFAULT_CLIENT_MAX_RETRY_COUNT = 3;
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/throttlingRetryPolicy.js
function throttlingRetryPolicy() {
  return {
    create: (nextPolicy, options) => {
      return new ThrottlingRetryPolicy(nextPolicy, options);
    }
  };
}
var StatusCodes, StandardAbortMessage, ThrottlingRetryPolicy;
var init_throttlingRetryPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/throttlingRetryPolicy.js"() {
    init_requestPolicy();
    init_src2();
    init_constants();
    init_throttlingRetryStrategy();
    init_src3();
    StatusCodes = Constants.HttpConstants.StatusCodes;
    StandardAbortMessage = "The operation was aborted.";
    ThrottlingRetryPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, _handleResponse) {
        super(nextPolicy, options);
        this.numberOfRetries = 0;
        this._handleResponse = _handleResponse || this._defaultResponseHandler;
      }
      async sendRequest(httpRequest) {
        const response = await this._nextPolicy.sendRequest(httpRequest.clone());
        if (response.status !== StatusCodes.TooManyRequests && response.status !== StatusCodes.ServiceUnavailable) {
          return response;
        } else {
          return this._handleResponse(httpRequest, response);
        }
      }
      async _defaultResponseHandler(httpRequest, httpResponse) {
        var _a2;
        const retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);
        if (retryAfterHeader) {
          const delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);
          if (delayInMs) {
            this.numberOfRetries += 1;
            await delay(delayInMs, {
              abortSignal: httpRequest.abortSignal,
              abortErrorMsg: StandardAbortMessage
            });
            if ((_a2 = httpRequest.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
              throw new AbortError(StandardAbortMessage);
            }
            if (this.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {
              return this.sendRequest(httpRequest);
            } else {
              return this._nextPolicy.sendRequest(httpRequest);
            }
          }
        }
        return httpResponse;
      }
      static parseRetryAfterHeader(headerValue) {
        const retryAfterInSeconds = Number(headerValue);
        if (Number.isNaN(retryAfterInSeconds)) {
          return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
        } else {
          return retryAfterInSeconds * 1e3;
        }
      }
      static parseDateRetryAfterHeader(headerValue) {
        try {
          const now = Date.now();
          const date = Date.parse(headerValue);
          const diff = date - now;
          return Number.isNaN(diff) ? void 0 : diff;
        } catch (error) {
          return void 0;
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/tracingPolicy.js
function tracingPolicy(tracingOptions = {}) {
  return {
    create(nextPolicy, options) {
      return new TracingPolicy(nextPolicy, options, tracingOptions);
    }
  };
}
var createSpan2, TracingPolicy;
var init_tracingPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/tracingPolicy.js"() {
    init_requestPolicy();
    init_src5();
    init_log();
    createSpan2 = createSpanFunction({
      packagePrefix: "",
      namespace: ""
    });
    TracingPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, tracingOptions) {
        super(nextPolicy, options);
        this.userAgent = tracingOptions.userAgent;
      }
      async sendRequest(request) {
        if (!request.tracingContext) {
          return this._nextPolicy.sendRequest(request);
        }
        const span = this.tryCreateSpan(request);
        if (!span) {
          return this._nextPolicy.sendRequest(request);
        }
        try {
          const response = await this._nextPolicy.sendRequest(request);
          this.tryProcessResponse(span, response);
          return response;
        } catch (err) {
          this.tryProcessError(span, err);
          throw err;
        }
      }
      tryCreateSpan(request) {
        var _a2;
        try {
          const { span } = createSpan2(`HTTP ${request.method}`, {
            tracingOptions: {
              spanOptions: Object.assign(Object.assign({}, request.spanOptions), { kind: SpanKind2.CLIENT }),
              tracingContext: request.tracingContext
            }
          });
          if (!span.isRecording()) {
            span.end();
            return void 0;
          }
          const namespaceFromContext = (_a2 = request.tracingContext) === null || _a2 === void 0 ? void 0 : _a2.getValue(Symbol.for("az.namespace"));
          if (typeof namespaceFromContext === "string") {
            span.setAttribute("az.namespace", namespaceFromContext);
          }
          span.setAttributes({
            "http.method": request.method,
            "http.url": request.url,
            requestId: request.requestId
          });
          if (this.userAgent) {
            span.setAttribute("http.user_agent", this.userAgent);
          }
          const spanContext = span.spanContext();
          const traceParentHeader = getTraceParentHeader(spanContext);
          if (traceParentHeader && isSpanContextValid2(spanContext)) {
            request.headers.set("traceparent", traceParentHeader);
            const traceState = spanContext.traceState && spanContext.traceState.serialize();
            if (traceState) {
              request.headers.set("tracestate", traceState);
            }
          }
          return span;
        } catch (error) {
          logger3.warning(`Skipping creating a tracing span due to an error: ${error.message}`);
          return void 0;
        }
      }
      tryProcessError(span, err) {
        try {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: err.message
          });
          if (err.statusCode) {
            span.setAttribute("http.status_code", err.statusCode);
          }
          span.end();
        } catch (error) {
          logger3.warning(`Skipping tracing span processing due to an error: ${error.message}`);
        }
      }
      tryProcessResponse(span, response) {
        try {
          span.setAttribute("http.status_code", response.status);
          const serviceRequestId = response.headers.get("x-ms-request-id");
          if (serviceRequestId) {
            span.setAttribute("serviceRequestId", serviceRequestId);
          }
          span.setStatus({
            code: SpanStatusCode2.OK
          });
          span.end();
        } catch (error) {
          logger3.warning(`Skipping tracing span processing due to an error: ${error.message}`);
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/serviceClient.js
function serializeRequestBody2(serviceClient, httpRequest, operationArguments, operationSpec) {
  var _a2, _b, _c, _d, _e, _f;
  const serializerOptions = (_b = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions) !== null && _b !== void 0 ? _b : {};
  const updatedOptions = {
    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : "",
    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,
    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY2
  };
  const xmlCharKey = serializerOptions.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    httpRequest.body = getOperationArgumentValueFromParameter2(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (httpRequest.body !== void 0 && httpRequest.body !== null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter2(operationSpec.requestBody);
        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperType.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace2(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);
          if (typeName === MapperType.Sequence) {
            httpRequest.body = stringifyXML(prepareXMLRootList2(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          } else if (!isStream) {
            httpRequest.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          httpRequest.body = JSON.stringify(httpRequest.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    httpRequest.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter2(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter2(formDataParameter);
        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter2(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace2(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY2] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function getValueOrFunctionResult(value, defaultValueCreator) {
  let result;
  if (typeof value === "string") {
    result = value;
  } else {
    result = defaultValueCreator();
    if (typeof value === "function") {
      result = value(result);
    }
  }
  return result;
}
function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
  const factories = [];
  if (options.generateClientRequestIdHeader) {
    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));
  }
  if (authPolicyFactory) {
    factories.push(authPolicyFactory);
  }
  const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);
  const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);
  if (userAgentHeaderName && userAgentHeaderValue) {
    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));
  }
  factories.push(redirectPolicy());
  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));
  if (!options.noRetryPolicy) {
    factories.push(exponentialRetryPolicy());
    factories.push(systemErrorRetryPolicy());
    factories.push(throttlingRetryPolicy());
  }
  factories.push(deserializationPolicy2(options.deserializationContentTypes));
  if (isNode2) {
    factories.push(proxyPolicy(options.proxySettings));
  }
  factories.push(logPolicy({ logger: logger3.info }));
  return factories;
}
function createPipelineFromOptions2(pipelineOptions, authPolicyFactory) {
  const requestPolicyFactories = [];
  if (pipelineOptions.sendStreamingJson) {
    requestPolicyFactories.push(ndJsonPolicy());
  }
  let userAgentValue = void 0;
  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {
    const userAgentInfo = [];
    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);
    const defaultUserAgentInfo = getDefaultUserAgentValue();
    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
      userAgentInfo.push(defaultUserAgentInfo);
    }
    userAgentValue = userAgentInfo.join(" ");
  }
  const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);
  const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);
  const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);
  if (isNode2) {
    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));
  }
  const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);
  const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);
  requestPolicyFactories.push(tracingPolicy({ userAgent: userAgentValue }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({ value: userAgentValue }), generateClientRequestIdPolicy(), deserializationPolicy2(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));
  if (redirectOptions.handleRedirects) {
    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));
  }
  if (authPolicyFactory) {
    requestPolicyFactories.push(authPolicyFactory);
  }
  requestPolicyFactories.push(logPolicy(loggingOptions));
  if (isNode2 && pipelineOptions.decompressResponse === false) {
    requestPolicyFactories.push(disableResponseDecompressionPolicy());
  }
  return {
    httpClient: pipelineOptions.httpClient,
    requestPolicyFactories
  };
}
function getOperationArgumentValueFromParameter2(serviceClient, operationArguments, parameter, serializer3) {
  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer3);
}
function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer3) {
  var _a2;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  const serializerOptions = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions;
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath2(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound) {
          propertySearchResult = getPropertyFromParameterPath2(serviceClient, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
      const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);
      serializer3.serialize(parameterMapper, value, parameterPathString, serializerOptions);
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer3);
      const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);
      serializer3.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);
      if (propertyValue !== void 0 && propertyValue !== null) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath2(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent !== void 0 && parent !== null && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
function flattenResponse2(_response, responseSpec) {
  const parsedHeaders = _response.parsedHeaders;
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const addOperationResponse = (obj) => {
    return Object.defineProperty(obj, "_response", {
      value: _response
    });
  };
  if (bodyMapper) {
    const typeName = bodyMapper.type.name;
    if (typeName === "Stream") {
      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { blobBody: _response.blobBody, readableStreamBody: _response.readableStreamBody }));
    }
    const modelProperties = typeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (typeName === "Sequence" || isPageableResponse) {
      const arrayResponse = [..._response.parsedBody || []];
      for (const key of Object.keys(modelProperties)) {
        if (modelProperties[key].serializedName) {
          arrayResponse[key] = _response.parsedBody[key];
        }
      }
      if (parsedHeaders) {
        for (const key of Object.keys(parsedHeaders)) {
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      addOperationResponse(arrayResponse);
      return arrayResponse;
    }
    if (typeName === "Composite" || typeName === "Dictionary") {
      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
    }
  }
  if (bodyMapper || _response.request.method === "HEAD" || isPrimitiveType(_response.parsedBody)) {
    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { body: _response.parsedBody }));
  }
  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
}
function getCredentialScopes2(options, baseUri) {
  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {
    const scopes = options.credentialScopes;
    return Array.isArray(scopes) ? scopes.map((scope) => new URL(scope).toString()) : new URL(scopes).toString();
  }
  if (baseUri) {
    return `${baseUri}/.default`;
  }
  return void 0;
}
var ServiceClient2;
var init_serviceClient = __esm({
  "node_modules/@azure/core-http/dist-esm/src/serviceClient.js"() {
    init_utils3();
    init_serializer();
    init_deserializationPolicy();
    init_keepAlivePolicy();
    init_redirectPolicy();
    init_exponentialRetryPolicy();
    init_logPolicy();
    init_operationParameter();
    init_operationSpec();
    init_webResource();
    init_requestPolicy();
    init_serializer_common();
    init_utils3();
    init_src4();
    init_userAgentPolicy();
    init_queryCollectionFormat();
    init_url();
    init_bearerTokenAuthenticationPolicy();
    init_disableResponseDecompressionPolicy_browser();
    init_generateClientRequestIdPolicy();
    init_httpClientCache();
    init_log();
    init_ndJsonPolicy();
    init_proxyPolicy_browser();
    init_rpRegistrationPolicy();
    init_signingPolicy();
    init_xml_browser();
    init_systemErrorRetryPolicy();
    init_throttlingRetryPolicy();
    init_tracingPolicy();
    ServiceClient2 = class {
      /**
       * The ServiceClient constructor
       * @param credentials - The credentials used for authentication with the service.
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(credentials, options) {
        if (!options) {
          options = {};
        }
        this._withCredentials = options.withCredentials || false;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient2();
        this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);
        let requestPolicyFactories;
        if (Array.isArray(options.requestPolicyFactories)) {
          logger3.info("ServiceClient: using custom request policies");
          requestPolicyFactories = options.requestPolicyFactories;
        } else {
          let authPolicyFactory = void 0;
          if (isTokenCredential(credentials)) {
            logger3.info("ServiceClient: creating bearer token authentication policy from provided credentials");
            const wrappedPolicyFactory = () => {
              let bearerTokenPolicyFactory = void 0;
              const serviceClient = this;
              const serviceClientOptions = options;
              return {
                create(nextPolicy, createOptions) {
                  const credentialScopes = getCredentialScopes2(serviceClientOptions, serviceClient.baseUri);
                  if (!credentialScopes) {
                    throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);
                  }
                  if (bearerTokenPolicyFactory === void 0 || bearerTokenPolicyFactory === null) {
                    bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy2(credentials, credentialScopes);
                  }
                  return bearerTokenPolicyFactory.create(nextPolicy, createOptions);
                }
              };
            };
            authPolicyFactory = wrappedPolicyFactory();
          } else if (credentials && typeof credentials.signRequest === "function") {
            logger3.info("ServiceClient: creating signing policy from provided credentials");
            authPolicyFactory = signingPolicy(credentials);
          } else if (credentials !== void 0 && credentials !== null) {
            throw new Error("The credentials argument must implement the TokenCredential interface");
          }
          logger3.info("ServiceClient: using default request policies");
          requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);
          if (options.requestPolicyFactories) {
            const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
            if (newRequestPolicyFactories) {
              requestPolicyFactories = newRequestPolicyFactories;
            }
          }
        }
        this._requestPolicyFactories = requestPolicyFactories;
      }
      /**
       * Send the provided httpRequest.
       */
      sendRequest(options) {
        if (options === null || options === void 0 || typeof options !== "object") {
          throw new Error("options cannot be null or undefined and it must be of type object.");
        }
        let httpRequest;
        try {
          if (isWebResourceLike(options)) {
            options.validateRequestProperties();
            httpRequest = options;
          } else {
            httpRequest = new WebResource();
            httpRequest = httpRequest.prepare(options);
          }
        } catch (error) {
          return Promise.reject(error);
        }
        let httpPipeline = this._httpClient;
        if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {
          for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {
            httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
          }
        }
        return httpPipeline.sendRequest(httpRequest);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       * @param callback - The callback to call when the response is received.
       */
      async sendOperationRequest(operationArguments, operationSpec, callback) {
        var _a2;
        if (typeof operationArguments.options === "function") {
          callback = operationArguments.options;
          operationArguments.options = void 0;
        }
        const serializerOptions = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions;
        const httpRequest = new WebResource();
        let result;
        try {
          const baseUri = operationSpec.baseUrl || this.baseUri;
          if (!baseUri) {
            throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
          }
          httpRequest.method = operationSpec.httpMethod;
          httpRequest.operationSpec = operationSpec;
          const requestUrl = URLBuilder.parse(baseUri);
          if (operationSpec.path) {
            requestUrl.appendPath(operationSpec.path);
          }
          if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {
            for (const urlParameter of operationSpec.urlParameters) {
              let urlParameterValue = getOperationArgumentValueFromParameter2(this, operationArguments, urlParameter, operationSpec.serializer);
              urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter2(urlParameter), serializerOptions);
              if (!urlParameter.skipEncoding) {
                urlParameterValue = encodeURIComponent(urlParameterValue);
              }
              requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter2(urlParameter)}}`, urlParameterValue);
            }
          }
          if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {
            for (const queryParameter of operationSpec.queryParameters) {
              let queryParameterValue = getOperationArgumentValueFromParameter2(this, operationArguments, queryParameter, operationSpec.serializer);
              if (queryParameterValue !== void 0 && queryParameterValue !== null) {
                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter2(queryParameter), serializerOptions);
                if (queryParameter.collectionFormat !== void 0 && queryParameter.collectionFormat !== null) {
                  if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {
                    if (queryParameterValue.length === 0) {
                      continue;
                    } else {
                      for (const index in queryParameterValue) {
                        const item = queryParameterValue[index];
                        queryParameterValue[index] = item === void 0 || item === null ? "" : item.toString();
                      }
                    }
                  } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {
                    queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                  }
                }
                if (!queryParameter.skipEncoding) {
                  if (Array.isArray(queryParameterValue)) {
                    for (const index in queryParameterValue) {
                      if (queryParameterValue[index] !== void 0 && queryParameterValue[index] !== null) {
                        queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);
                      }
                    }
                  } else {
                    queryParameterValue = encodeURIComponent(queryParameterValue);
                  }
                }
                if (queryParameter.collectionFormat !== void 0 && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {
                  queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                }
                requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter2(queryParameter), queryParameterValue);
              }
            }
          }
          httpRequest.url = requestUrl.toString();
          const contentType2 = operationSpec.contentType || this.requestContentType;
          if (contentType2 && operationSpec.requestBody) {
            httpRequest.headers.set("Content-Type", contentType2);
          }
          if (operationSpec.headerParameters) {
            for (const headerParameter of operationSpec.headerParameters) {
              let headerValue = getOperationArgumentValueFromParameter2(this, operationArguments, headerParameter, operationSpec.serializer);
              if (headerValue !== void 0 && headerValue !== null) {
                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter2(headerParameter), serializerOptions);
                const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
                if (headerCollectionPrefix) {
                  for (const key of Object.keys(headerValue)) {
                    httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                  }
                } else {
                  httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter2(headerParameter), headerValue);
                }
              }
            }
          }
          const options = operationArguments.options;
          if (options) {
            if (options.customHeaders) {
              for (const customHeaderName in options.customHeaders) {
                httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
              }
            }
            if (options.abortSignal) {
              httpRequest.abortSignal = options.abortSignal;
            }
            if (options.timeout) {
              httpRequest.timeout = options.timeout;
            }
            if (options.onUploadProgress) {
              httpRequest.onUploadProgress = options.onUploadProgress;
            }
            if (options.onDownloadProgress) {
              httpRequest.onDownloadProgress = options.onDownloadProgress;
            }
            if (options.spanOptions) {
              httpRequest.spanOptions = options.spanOptions;
            }
            if (options.tracingContext) {
              httpRequest.tracingContext = options.tracingContext;
            }
            if (options.shouldDeserialize !== void 0 && options.shouldDeserialize !== null) {
              httpRequest.shouldDeserialize = options.shouldDeserialize;
            }
          }
          httpRequest.withCredentials = this._withCredentials;
          serializeRequestBody2(this, httpRequest, operationArguments, operationSpec);
          if (httpRequest.streamResponseStatusCodes === void 0) {
            httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);
          }
          let rawResponse;
          let sendRequestError;
          try {
            rawResponse = await this.sendRequest(httpRequest);
          } catch (error) {
            sendRequestError = error;
          }
          if (sendRequestError) {
            if (sendRequestError.response) {
              sendRequestError.details = flattenResponse2(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses["default"]);
            }
            result = Promise.reject(sendRequestError);
          } else {
            result = Promise.resolve(flattenResponse2(rawResponse, operationSpec.responses[rawResponse.status]));
          }
        } catch (error) {
          result = Promise.reject(error);
        }
        const cb = callback;
        if (cb) {
          result.then((res) => cb(null, res._response.parsedBody, res._response.request, res._response)).catch((err) => cb(err));
        }
        return result;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/createSpanLegacy.js
function createSpanFunction2(args) {
  return createSpanFunction(args);
}
var init_createSpanLegacy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/createSpanLegacy.js"() {
    init_src5();
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenCache.js
var TokenRefreshBufferMs, ExpiringAccessTokenCache;
var init_accessTokenCache = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenCache.js"() {
    TokenRefreshBufferMs = 2 * 60 * 1e3;
    ExpiringAccessTokenCache = class {
      /**
       * Constructs an instance of {@link ExpiringAccessTokenCache} with
       * an optional expiration buffer time.
       */
      constructor(tokenRefreshBufferMs = TokenRefreshBufferMs) {
        this.cachedToken = void 0;
        this.tokenRefreshBufferMs = tokenRefreshBufferMs;
      }
      /**
       * Saves an access token into the internal in-memory cache.
       * @param accessToken - Access token or undefined to clear the cache.
       */
      setCachedToken(accessToken) {
        this.cachedToken = accessToken;
      }
      /**
       * Returns the cached access token, or `undefined` if one is not cached or the cached one is expiring soon.
       */
      getCachedToken() {
        if (this.cachedToken && Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) {
          this.cachedToken = void 0;
        }
        return this.cachedToken;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenRefresher.js
var AccessTokenRefresher;
var init_accessTokenRefresher = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenRefresher.js"() {
    AccessTokenRefresher = class {
      constructor(credential, scopes, requiredMillisecondsBeforeNewRefresh = 3e4) {
        this.credential = credential;
        this.scopes = scopes;
        this.requiredMillisecondsBeforeNewRefresh = requiredMillisecondsBeforeNewRefresh;
        this.lastCalled = 0;
      }
      /**
       * Returns true if the required milliseconds(defaulted to 30000) have been passed signifying
       * that we are ready for a new refresh.
       */
      isReady() {
        return !this.lastCalled || Date.now() - this.lastCalled > this.requiredMillisecondsBeforeNewRefresh;
      }
      /**
       * Stores the time in which it is called,
       * then requests a new token,
       * then sets this.promise to undefined,
       * then returns the token.
       */
      async getToken(options) {
        this.lastCalled = Date.now();
        const token = await this.credential.getToken(this.scopes, options);
        this.promise = void 0;
        return token || void 0;
      }
      /**
       * Requests a new token if we're not currently waiting for a new token.
       * Returns null if the required time between each call hasn't been reached.
       */
      refresh(options) {
        if (!this.promise) {
          this.promise = this.getToken(options);
        }
        return this.promise;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/basicAuthenticationCredentials.js
var HeaderConstants, DEFAULT_AUTHORIZATION_SCHEME, BasicAuthenticationCredentials;
var init_basicAuthenticationCredentials = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/basicAuthenticationCredentials.js"() {
    init_base64_browser();
    init_constants();
    init_httpHeaders();
    HeaderConstants = Constants.HeaderConstants;
    DEFAULT_AUTHORIZATION_SCHEME = "Basic";
    BasicAuthenticationCredentials = class {
      /**
       * Creates a new BasicAuthenticationCredentials object.
       *
       * @param userName - User name.
       * @param password - Password.
       * @param authorizationScheme - The authorization scheme.
       */
      constructor(userName, password, authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME) {
        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
        if (userName === null || userName === void 0 || typeof userName.valueOf() !== "string") {
          throw new Error("userName cannot be null or undefined and must be of type string.");
        }
        if (password === null || password === void 0 || typeof password.valueOf() !== "string") {
          throw new Error("password cannot be null or undefined and must be of type string.");
        }
        this.userName = userName;
        this.password = password;
        this.authorizationScheme = authorizationScheme;
      }
      /**
       * Signs a request with the Authentication header.
       *
       * @param webResource - The WebResourceLike to be signed.
       * @returns The signed request object.
       */
      signRequest(webResource) {
        const credentials = `${this.userName}:${this.password}`;
        const encodedCredentials = `${this.authorizationScheme} ${encodeString(credentials)}`;
        if (!webResource.headers)
          webResource.headers = new HttpHeaders();
        webResource.headers.set(HeaderConstants.AUTHORIZATION, encodedCredentials);
        return Promise.resolve(webResource);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/apiKeyCredentials.js
var ApiKeyCredentials;
var init_apiKeyCredentials = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/apiKeyCredentials.js"() {
    init_httpHeaders();
    ApiKeyCredentials = class {
      /**
       * @param options - Specifies the options to be provided for auth. Either header or query needs to be provided.
       */
      constructor(options) {
        if (!options || options && !options.inHeader && !options.inQuery) {
          throw new Error(`options cannot be null or undefined. Either "inHeader" or "inQuery" property of the options object needs to be provided.`);
        }
        this.inHeader = options.inHeader;
        this.inQuery = options.inQuery;
      }
      /**
       * Signs a request with the values provided in the inHeader and inQuery parameter.
       *
       * @param webResource - The WebResourceLike to be signed.
       * @returns The signed request object.
       */
      signRequest(webResource) {
        if (!webResource) {
          return Promise.reject(new Error(`webResource cannot be null or undefined and must be of type "object".`));
        }
        if (this.inHeader) {
          if (!webResource.headers) {
            webResource.headers = new HttpHeaders();
          }
          for (const headerName in this.inHeader) {
            webResource.headers.set(headerName, this.inHeader[headerName]);
          }
        }
        if (this.inQuery) {
          if (!webResource.url) {
            return Promise.reject(new Error(`url cannot be null in the request object.`));
          }
          if (webResource.url.indexOf("?") < 0) {
            webResource.url += "?";
          }
          for (const key in this.inQuery) {
            if (!webResource.url.endsWith("?")) {
              webResource.url += "&";
            }
            webResource.url += `${key}=${this.inQuery[key]}`;
          }
        }
        return Promise.resolve(webResource);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/topicCredentials.js
var TopicCredentials;
var init_topicCredentials = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/topicCredentials.js"() {
    init_apiKeyCredentials();
    TopicCredentials = class extends ApiKeyCredentials {
      /**
       * Creates a new EventGrid TopicCredentials object.
       *
       * @param topicKey - The EventGrid topic key
       */
      constructor(topicKey) {
        if (!topicKey || topicKey && typeof topicKey !== "string") {
          throw new Error("topicKey cannot be null or undefined and must be of type string.");
        }
        const options = {
          inHeader: {
            "aeg-sas-key": topicKey
          }
        };
        super(options);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  AccessTokenRefresher: () => AccessTokenRefresher,
  ApiKeyCredentials: () => ApiKeyCredentials,
  BaseRequestPolicy: () => BaseRequestPolicy,
  BasicAuthenticationCredentials: () => BasicAuthenticationCredentials,
  Constants: () => Constants,
  DefaultHttpClient: () => XhrHttpClient,
  ExpiringAccessTokenCache: () => ExpiringAccessTokenCache,
  HttpHeaders: () => HttpHeaders,
  HttpPipelineLogLevel: () => HttpPipelineLogLevel,
  MapperType: () => MapperType,
  QueryCollectionFormat: () => QueryCollectionFormat,
  RequestPolicyOptions: () => RequestPolicyOptions,
  RestError: () => RestError2,
  RetryMode: () => RetryMode,
  Serializer: () => Serializer,
  ServiceClient: () => ServiceClient2,
  TopicCredentials: () => TopicCredentials,
  URLBuilder: () => URLBuilder,
  URLQuery: () => URLQuery,
  WebResource: () => WebResource,
  XML_ATTRKEY: () => XML_ATTRKEY2,
  XML_CHARKEY: () => XML_CHARKEY2,
  applyMixins: () => applyMixins,
  bearerTokenAuthenticationPolicy: () => bearerTokenAuthenticationPolicy2,
  createPipelineFromOptions: () => createPipelineFromOptions2,
  createSpanFunction: () => createSpanFunction2,
  delay: () => delay,
  deserializationPolicy: () => deserializationPolicy2,
  deserializeResponseBody: () => deserializeResponseBody2,
  disableResponseDecompressionPolicy: () => disableResponseDecompressionPolicy,
  encodeUri: () => encodeUri,
  executePromisesSequentially: () => executePromisesSequentially,
  exponentialRetryPolicy: () => exponentialRetryPolicy,
  flattenResponse: () => flattenResponse2,
  generateClientRequestIdPolicy: () => generateClientRequestIdPolicy,
  generateUuid: () => generateUuid2,
  getDefaultProxySettings: () => getDefaultProxySettings,
  getDefaultUserAgentValue: () => getDefaultUserAgentValue,
  isDuration: () => isDuration2,
  isNode: () => isNode2,
  isTokenCredential: () => isTokenCredential,
  isValidUuid: () => isValidUuid2,
  keepAlivePolicy: () => keepAlivePolicy,
  logPolicy: () => logPolicy,
  operationOptionsToRequestOptionsBase: () => operationOptionsToRequestOptionsBase,
  parseXML: () => parseXML,
  promiseToCallback: () => promiseToCallback,
  promiseToServiceCallback: () => promiseToServiceCallback,
  proxyPolicy: () => proxyPolicy,
  redirectPolicy: () => redirectPolicy,
  serializeObject: () => serializeObject,
  signingPolicy: () => signingPolicy,
  stringifyXML: () => stringifyXML,
  stripRequest: () => stripRequest,
  stripResponse: () => stripResponse,
  systemErrorRetryPolicy: () => systemErrorRetryPolicy,
  throttlingRetryPolicy: () => throttlingRetryPolicy,
  tracingPolicy: () => tracingPolicy,
  userAgentPolicy: () => userAgentPolicy
});
var init_src6 = __esm({
  "node_modules/@azure/core-http/dist-esm/src/index.js"() {
    init_webResource();
    init_defaultHttpClient_browser();
    init_httpHeaders();
    init_httpPipelineLogLevel();
    init_restError();
    init_operationOptions();
    init_serviceClient();
    init_queryCollectionFormat();
    init_constants();
    init_bearerTokenAuthenticationPolicy();
    init_logPolicy();
    init_requestPolicy();
    init_generateClientRequestIdPolicy();
    init_exponentialRetryPolicy();
    init_systemErrorRetryPolicy();
    init_throttlingRetryPolicy();
    init_proxyPolicy_browser();
    init_redirectPolicy();
    init_keepAlivePolicy();
    init_disableResponseDecompressionPolicy_browser();
    init_signingPolicy();
    init_userAgentPolicy();
    init_deserializationPolicy();
    init_tracingPolicy();
    init_serializer();
    init_utils3();
    init_url();
    init_src3();
    init_createSpanLegacy();
    init_src4();
    init_accessTokenCache();
    init_accessTokenRefresher();
    init_basicAuthenticationCredentials();
    init_apiKeyCredentials();
    init_topicCredentials();
    init_xml_browser();
    init_serializer_common();
  }
});

// node_modules/@azure/communication-signaling/dist/index.js
var require_dist = __commonJS({
  "node_modules/@azure/communication-signaling/dist/index.js"(exports, module) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var coreHttp = _interopDefault((init_src6(), __toCommonJS(src_exports2)));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function unwrapExports(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function createCommonjsModule(fn, module2) {
      return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
    }
    var tsregistrar = createCommonjsModule(function(module2, exports2) {
      !function(t, e) {
        module2.exports = e();
      }(commonjsGlobal, function() {
        return function(t) {
          function e(n) {
            if (r[n])
              return r[n].exports;
            var i = r[n] = { i: n, l: false, exports: {} };
            return t[n].call(i.exports, i, i.exports, e), i.l = true, i.exports;
          }
          var r = {};
          return e.m = t, e.c = r, e.i = function(t2) {
            return t2;
          }, e.d = function(t2, r2, n) {
            e.o(t2, r2) || Object.defineProperty(t2, r2, { configurable: false, enumerable: true, get: n });
          }, e.n = function(t2) {
            var r2 = t2 && t2.__esModule ? function() {
              return t2.default;
            } : function() {
              return t2;
            };
            return e.d(r2, "a", r2), r2;
          }, e.o = function(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          }, e.p = "", e(e.s = 1);
        }([function(t, e, r) {
          function n(t2, e2) {
            var r2, n2 = new Promise(function(e3, n3) {
              fetch(t2).then(function(t3) {
                clearTimeout(r2), e3(t3);
              }).catch(function(t3) {
                clearTimeout(r2), n3(t3);
              });
            });
            if (0 !== e2) {
              var i2 = new Promise(function(n3, i3) {
                r2 = setTimeout(i3, e2, new Error("Fetch for '" + t2.url + "' timed out"));
              });
              return Promise.race([n2, i2]);
            }
            return n2;
          }
          function i(t2) {
            try {
              return JSON.stringify(t2);
            } catch (e2) {
              return "Unable to serialize object of type " + typeof t2;
            }
          }
          Object.defineProperty(e, "__esModule", { value: true }), e.fetchWithTimeout = n, e.toJson = i;
          var o = function() {
            function t2() {
              this.start = Date.now();
            }
            return Object.defineProperty(t2.prototype, "duration", { get: function() {
              return Date.now() - this.start;
            }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "startTime", { get: function() {
              return this.start;
            }, enumerable: true, configurable: true }), t2.prototype.reset = function() {
              this.start = Date.now();
            }, t2;
          }();
          e.Timespan = o;
        }, function(t, e, r) {
          function n(t2, e2, r2) {
            return new f(t2, e2, r2);
          }
          var i = this && this.__extends || function() {
            var t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e2) {
              t3.__proto__ = e2;
            } || function(t3, e2) {
              for (var r2 in e2)
                e2.hasOwnProperty(r2) && (t3[r2] = e2[r2]);
            };
            return function(e2, r2) {
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__awaiter || function(t2, e2, r2, n2) {
            return new (r2 || (r2 = Promise))(function(i2, o2) {
              function s2(t3) {
                try {
                  c2(n2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                try {
                  c2(n2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                t3.done ? i2(t3.value) : new r2(function(e3) {
                  e3(t3.value);
                }).then(s2, a2);
              }
              c2((n2 = n2.apply(t2, e2 || [])).next());
            });
          }, s = this && this.__generator || function(t2, e2) {
            function r2(t3) {
              return function(e3) {
                return n2([t3, e3]);
              };
            }
            function n2(r3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; c2; )
                try {
                  if (i2 = 1, o2 && (s2 = 2 & r3[0] ? o2.return : r3[0] ? o2.throw || ((s2 = o2.return) && s2.call(o2), 0) : o2.next) && !(s2 = s2.call(o2, r3[1])).done)
                    return s2;
                  switch (o2 = 0, s2 && (r3 = [2 & r3[0], s2.value]), r3[0]) {
                    case 0:
                    case 1:
                      s2 = r3;
                      break;
                    case 4:
                      return c2.label++, { value: r3[1], done: false };
                    case 5:
                      c2.label++, o2 = r3[1], r3 = [0];
                      continue;
                    case 7:
                      r3 = c2.ops.pop(), c2.trys.pop();
                      continue;
                    default:
                      if (s2 = c2.trys, !(s2 = s2.length > 0 && s2[s2.length - 1]) && (6 === r3[0] || 2 === r3[0])) {
                        c2 = 0;
                        continue;
                      }
                      if (3 === r3[0] && (!s2 || r3[1] > s2[0] && r3[1] < s2[3])) {
                        c2.label = r3[1];
                        break;
                      }
                      if (6 === r3[0] && c2.label < s2[1]) {
                        c2.label = s2[1], s2 = r3;
                        break;
                      }
                      if (s2 && c2.label < s2[2]) {
                        c2.label = s2[2], c2.ops.push(r3);
                        break;
                      }
                      s2[2] && c2.ops.pop(), c2.trys.pop();
                      continue;
                  }
                  r3 = e2.call(t2, c2);
                } catch (t3) {
                  r3 = [6, t3], o2 = 0;
                } finally {
                  i2 = s2 = 0;
                }
              if (5 & r3[0])
                throw r3[1];
              return { value: r3[0] ? r3[1] : void 0, done: true };
            }
            var i2, o2, s2, a2, c2 = { label: 0, sent: function() {
              if (1 & s2[0])
                throw s2[1];
              return s2[1];
            }, trys: [], ops: [] };
            return a2 = { next: r2(0), throw: r2(1), return: r2(2) }, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
              return this;
            }), a2;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var a = r(0), c = function(t2) {
            function e2(e3) {
              var r2 = t2.call(this, e3) || this;
              return r2.name = "CancelationError", r2;
            }
            return i(e2, t2), e2;
          }(Error), u = function() {
            function t2(e2, r2, n2) {
              this.logger = e2, this.maxBackoffInMs = r2, this.initialDelay = n2, this.backoffCount = 0, this.id = ++t2.idCounter;
            }
            return t2.prototype.delay = function(t3) {
              var e2 = this;
              if (void 0 !== this.timerHandle)
                throw new Error("Retry sequence logical failure");
              if (-1 === this.backoffCount)
                return new Promise(function(t4, e3) {
                  e3(new c("Cancelled"));
                });
              var r2 = this.calculateNextBackoffMs();
              return this.backoffCount++, this.logger.info("[RegistrarClient] Backing off " + t3 + " for " + r2 + " milliseconds with ID " + this.id), new Promise(function(n2, i2) {
                e2.cancelFunc = i2, e2.timerHandle = setTimeout(function() {
                  e2.logger.info("[RegistrarClient] Back off for " + t3 + " with ID " + e2.id + " complete"), e2.timerHandle = void 0, n2();
                }, r2);
              });
            }, t2.prototype.cancel = function() {
              void 0 !== this.timerHandle && (this.logger.debug("Resetting back off"), clearTimeout(this.timerHandle), void 0 !== this.cancelFunc && this.cancelFunc(new c("Cancelled"))), this.backoffCount = -1;
            }, t2.prototype.calculateNextBackoffMs = function() {
              var t3 = 1 + 0.4 * (Math.random() - 0.5), e2 = this.initialDelay * Math.pow(2, this.backoffCount) * t3;
              return e2 = Math.round(e2), Math.min(this.maxBackoffInMs, e2);
            }, t2.idCounter = 0, t2;
          }(), f = function() {
            function t2(t3, e2, r2) {
              this.logger = t3, this.skypeTokenProvider = e2, this.options = r2, this.backoffs = {};
            }
            return t2.prototype.setTelemetryLogger = function(t3) {
              this.eventLogger = t3;
            }, t2.prototype.register = function(t3, e2) {
              return o(this, void 0, void 0, function() {
                return s(this, function(r2) {
                  switch (r2.label) {
                    case 0:
                      return [4, this.performRegistration(t3, e2, "pr_set_registration")];
                    case 1:
                      return r2.sent(), this.cachedRegistrationParams = [t3, e2], [2];
                  }
                });
              });
            }, t2.prototype.unregister = function() {
              return o(this, void 0, void 0, function() {
                var t3;
                return s(this, function(e2) {
                  switch (e2.label) {
                    case 0:
                      return this.logger.info("[RegistrarClient] sending unregister request"), t3 = new Request(this.options.registrarUrl + "/" + this.options.registrationId, { method: "DELETE", mode: "cors", headers: new Headers({ accept: "application/json, text/javascript" }) }), [4, this.callRegistrar(t3, "pr_delete_registration")];
                    case 1:
                      return e2.sent(), [2];
                  }
                });
              });
            }, t2.prototype.cancelPendingRequests = function() {
              var t3 = this;
              Object.keys(this.backoffs).forEach(function(e2) {
                t3.backoffs[e2].cancel();
              }), this.backoffs = {};
            }, t2.prototype.resendRegistration = function() {
              return o(this, void 0, void 0, function() {
                return s(this, function(t3) {
                  switch (t3.label) {
                    case 0:
                      if (!this.cachedRegistrationParams)
                        throw new Error("Re-registration failed because there is no registration parameters cached");
                      return [4, this.performRegistration(this.cachedRegistrationParams[0], this.cachedRegistrationParams[1], "pr_resend_registration")];
                    case 1:
                      return t3.sent(), [2];
                  }
                });
              });
            }, t2.prototype.performRegistration = function(t3, e2, r2) {
              return o(this, void 0, void 0, function() {
                var n2, i2;
                return s(this, function(o2) {
                  switch (o2.label) {
                    case 0:
                      return this.logger.info("[RegistrarClient] Sending register request"), n2 = { clientDescription: t3, registrationId: this.options.registrationId, nodeId: "", transports: e2 }, i2 = new Request(this.options.registrarUrl, { method: "POST", mode: "cors", headers: new Headers({ "content-type": "application/json", accept: "application/json, text/javascript" }), body: a.toJson(n2) }), [4, this.callRegistrar(i2, r2)];
                    case 1:
                      return o2.sent(), [2];
                  }
                });
              });
            }, t2.prototype.startBackoff = function() {
              var t3 = new u(this.logger, this.options.maxRetryDelayMs, this.options.initialRetryDelayMs);
              return this.backoffs[t3.id] = t3, t3;
            }, t2.prototype.stopBackoff = function(t3) {
              t3.cancel(), delete this.backoffs[t3.id];
            }, t2.prototype.getSkypeToken = function() {
              return o(this, void 0, void 0, function() {
                var t3, e2, r2, n2;
                return s(this, function(i2) {
                  switch (i2.label) {
                    case 0:
                      t3 = this.startBackoff(), i2.label = 1;
                    case 1:
                      return i2.trys.push([1, 3, , 8]), this.logger.info("[RegistrarClient] Asking for a new skypetoken"), [4, this.skypeTokenProvider(true)];
                    case 2:
                      return e2 = i2.sent(), this.stopBackoff(t3), [2, e2];
                    case 3:
                      r2 = i2.sent(), i2.label = 4;
                    case 4:
                      return i2.trys.push([4, 6, , 7]), [4, t3.delay("Fetching a new skypetoken")];
                    case 5:
                      return i2.sent(), [3, 8];
                    case 6:
                      throw n2 = i2.sent(), this.stopBackoff(t3), n2;
                    case 7:
                      return [3, 8];
                    case 8:
                      return [3, 1];
                    case 9:
                      return [2];
                  }
                });
              });
            }, t2.prototype.callRegistrar = function(t3, e2) {
              return o(this, void 0, void 0, function() {
                var r2, n2, i2, o2, c2, u2, f2, l, h, p, d, g, y, v;
                return s(this, function(s2) {
                  switch (s2.label) {
                    case 0:
                      return r2 = this.startBackoff(), [4, this.skypeTokenProvider(false)];
                    case 1:
                      n2 = s2.sent(), this.setSkypeTokenHeader(t3, n2), i2 = new a.Timespan(), s2.label = 2;
                    case 2:
                      o2 = void 0, s2.label = 3;
                    case 3:
                      return s2.trys.push([3, 8, 13, 14]), c2 = t3.clone(), [4, a.fetchWithTimeout(c2, this.options.requestTimeoutMs)];
                    case 4:
                      return o2 = s2.sent(), 401 !== o2.status ? [3, 6] : (u2 = this.setSkypeTokenHeader, f2 = [t3], [4, this.getSkypeToken()]);
                    case 5:
                      return u2.apply(this, f2.concat([s2.sent()])), [3, 20];
                    case 6:
                      if (o2.status >= 500 && o2.status < 600)
                        throw new Error("Fetch for '" + t3.url + "' failed with " + o2.status + " " + o2.statusText);
                      s2.label = 7;
                    case 7:
                      return [3, 14];
                    case 8:
                      l = s2.sent(), this.logger.error("[RegistrarClient] Request failed with " + l), s2.label = 9;
                    case 9:
                      return s2.trys.push([9, 11, , 12]), [4, r2.delay("Registrar call retry")];
                    case 10:
                      return s2.sent(), [3, 20];
                    case 11:
                      throw h = s2.sent(), this.logger.error("[RegistrarClient] Request cancelled"), this.stopBackoff(r2), h;
                    case 12:
                      return [3, 14];
                    case 13:
                      return this.sendTelemetryEvent(e2, t3, o2, i2), [7];
                    case 14:
                      return this.stopBackoff(r2), o2.ok ? [2, o2] : [3, 15];
                    case 15:
                      p = void 0, s2.label = 16;
                    case 16:
                      return s2.trys.push([16, 18, , 19]), g = (d = JSON).stringify, [4, o2.json()];
                    case 17:
                      return p = g.apply(d, [s2.sent()]), [3, 19];
                    case 18:
                      return y = s2.sent(), p = "no details", [3, 19];
                    case 19:
                      throw v = "Fetch for '" + t3.url + "' failed with " + o2.status + " " + o2.statusText + " (" + p + ", MS-CV: " + o2.headers.get("MS-CV") + ")", this.logger.error("[RegistrarClient] " + v), new Error(v);
                    case 20:
                      return [3, 2];
                    case 21:
                      return [2];
                  }
                });
              });
            }, t2.prototype.setSkypeTokenHeader = function(t3, e2) {
              t3.headers.set("X-Skypetoken", e2);
            }, t2.prototype.sendTelemetryEvent = function(t3, e2, r2, n2) {
              if (void 0 !== this.eventLogger) {
                var i2 = { name: t3, properties: { url: { value: e2.url }, result_code: { value: void 0 !== r2 ? r2.status : 0 }, begin_timestamp: { value: n2.startTime }, elapsed: { value: n2.duration } } };
                this.eventLogger.logEvent(i2);
              }
            }, t2;
          }();
          e.RegistrarClient = f, e.createRegistrarClient = n;
        }]);
      });
    });
    unwrapExports(tsregistrar);
    var tstrouter = createCommonjsModule(function(module2, exports2) {
      !function(t, e) {
        module2.exports = e(tsregistrar);
      }(commonjsGlobal, function(t) {
        return function(t2) {
          function e(o) {
            if (n[o])
              return n[o].exports;
            var i = n[o] = { i: o, l: false, exports: {} };
            return t2[o].call(i.exports, i, i.exports, e), i.l = true, i.exports;
          }
          var n = {};
          return e.m = t2, e.c = n, e.i = function(t3) {
            return t3;
          }, e.d = function(t3, n2, o) {
            e.o(t3, n2) || Object.defineProperty(t3, n2, { configurable: false, enumerable: true, get: o });
          }, e.n = function(t3) {
            var n2 = t3 && t3.__esModule ? function() {
              return t3.default;
            } : function() {
              return t3;
            };
            return e.d(n2, "a", n2), n2;
          }, e.o = function(t3, e2) {
            return Object.prototype.hasOwnProperty.call(t3, e2);
          }, e.p = "", e(e.s = 17);
        }([function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function() {
            function t3(t4, e2) {
              this.name = t4, this.logger = e2;
            }
            return t3.prototype.debug = function(t4) {
              this.logger.debug("[" + this.name + "] " + t4);
            }, t3.prototype.info = function(t4) {
              this.logger.info("[" + this.name + "] " + t4);
            }, t3.prototype.warn = function(t4) {
              this.logger.warn("[" + this.name + "] " + t4);
            }, t3.prototype.error = function(t4) {
              this.logger.error("[" + this.name + "] " + t4);
            }, t3;
          }();
          e.Logger = o;
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true }), e.constants = { TROUTER_INIT: "trouterinit", TROUTER_READY_EVENT: "trouterReadyEvent", TROUTER_READY_TIMEOUT: "trouterReadyTimeout", TROUTER_TOKEN_REQUEST: "trouterTokenRequest", TROUTER_TOKEN_GET_SUCCEEDED: "trouterTokenGetSucceeded", TROUTER_TOKEN_GET_FAILED: "trouterTokenGetFailed", TROUTER_RECONNECTING: "trouterReconnecting", RENEWAL: "renewal", NEW_CONNECTION: "newConnection", ENDPOINT_REGISTRATION_FAILED: "endpointRegistrationFailed" }, e.CLIENT_VERSION = "2021.48.01.1", e.HANDLED_MESSAGE_ACK = 200, e.UNHANDLED_MESSAGE_ACK = 404, e.FAILED_MESSAGE_ACK = 500;
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          !function(t3) {
            t3[t3.Unknown = 0] = "Unknown", t3[t3.Active = 1] = "Active", t3[t3.Inactive = 2] = "Inactive";
          }(e.UserActivityState || (e.UserActivityState = {}));
          var o = function() {
            function t3() {
            }
            return t3;
          }();
          e.HttpHeaders = o;
          !function(t3) {
            t3[t3.Unknown = 0] = "Unknown", t3[t3.Connected = 2] = "Connected", t3[t3.Disconnected = 3] = "Disconnected", t3[t3.Switching = 9] = "Switching";
          }(e.TrouterState || (e.TrouterState = {}));
        }, function(t2, e, n) {
          function o(t3) {
            try {
              return JSON.stringify(t3);
            } catch (e2) {
              return "Unable to serialize object of type " + typeof t3;
            }
          }
          function i(t3) {
            var e2 = Math.round(new Date().getTime() / 1e3);
            return void 0 !== t3 && t3 > e2 ? t3 - e2 : 0;
          }
          function r(t3) {
            return Math.round(new Date().getTime() / 1e3) + t3;
          }
          function s(t3, e2) {
            return c(this, void 0, void 0, function() {
              var n2, o2, i2;
              return a(this, function(r2) {
                return o2 = new Promise(function(e3, o3) {
                  fetch(t3).then(function(t4) {
                    clearTimeout(n2), e3(t4);
                  }).catch(function(t4) {
                    clearTimeout(n2), o3(t4);
                  });
                }), 0 !== e2 ? (i2 = new Promise(function(o3, i3) {
                  n2 = setTimeout(i3, e2, new Error("Fetch for '" + t3.url + "' timed out"));
                }), [2, Promise.race([o2, i2])]) : [2, o2];
              });
            });
          }
          var c = this && this.__awaiter || function(t3, e2, n2, o2) {
            return new (n2 || (n2 = Promise))(function(i2, r2) {
              function s2(t4) {
                try {
                  a2(o2.next(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function c2(t4) {
                try {
                  a2(o2.throw(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function a2(t4) {
                t4.done ? i2(t4.value) : new n2(function(e3) {
                  e3(t4.value);
                }).then(s2, c2);
              }
              a2((o2 = o2.apply(t3, e2 || [])).next());
            });
          }, a = this && this.__generator || function(t3, e2) {
            function n2(t4) {
              return function(e3) {
                return o2([t4, e3]);
              };
            }
            function o2(n3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; a2; )
                try {
                  if (i2 = 1, r2 && (s2 = 2 & n3[0] ? r2.return : n3[0] ? r2.throw || ((s2 = r2.return) && s2.call(r2), 0) : r2.next) && !(s2 = s2.call(r2, n3[1])).done)
                    return s2;
                  switch (r2 = 0, s2 && (n3 = [2 & n3[0], s2.value]), n3[0]) {
                    case 0:
                    case 1:
                      s2 = n3;
                      break;
                    case 4:
                      return a2.label++, { value: n3[1], done: false };
                    case 5:
                      a2.label++, r2 = n3[1], n3 = [0];
                      continue;
                    case 7:
                      n3 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (s2 = a2.trys, !(s2 = s2.length > 0 && s2[s2.length - 1]) && (6 === n3[0] || 2 === n3[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === n3[0] && (!s2 || n3[1] > s2[0] && n3[1] < s2[3])) {
                        a2.label = n3[1];
                        break;
                      }
                      if (6 === n3[0] && a2.label < s2[1]) {
                        a2.label = s2[1], s2 = n3;
                        break;
                      }
                      if (s2 && a2.label < s2[2]) {
                        a2.label = s2[2], a2.ops.push(n3);
                        break;
                      }
                      s2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  n3 = e2.call(t3, a2);
                } catch (t4) {
                  n3 = [6, t4], r2 = 0;
                } finally {
                  i2 = s2 = 0;
                }
              if (5 & n3[0])
                throw n3[1];
              return { value: n3[0] ? n3[1] : void 0, done: true };
            }
            var i2, r2, s2, c2, a2 = { label: 0, sent: function() {
              if (1 & s2[0])
                throw s2[1];
              return s2[1];
            }, trys: [], ops: [] };
            return c2 = { next: n2(0), throw: n2(1), return: n2(2) }, "function" == typeof Symbol && (c2[Symbol.iterator] = function() {
              return this;
            }), c2;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.toJson = o, e.calculateTtlInSec = i, e.calculateExpireTsInSec = r, e.fetchWithTimeout = s;
          var h = function() {
            function t3(t4) {
              this.base = void 0 !== t4 ? t4 : this.createCorrelationVectorBase(), this.extension = 0;
            }
            return t3.extend = function(e2) {
              return new t3(e2);
            }, t3.prototype.increase = function() {
              this.extension++;
            }, t3.prototype.value = function() {
              return this.base + "." + this.extension;
            }, t3.prototype.createCorrelationVectorBase = function() {
              for (var t4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0987654321/+", e2 = "AQgw", n2 = "", o2 = 0; o2 < 21; o2++)
                n2 += t4.charAt(Math.floor(Math.random() * t4.length));
              return n2 += e2.charAt(Math.floor(Math.random() * e2.length));
            }, t3;
          }();
          e.CorrelationVector = h;
          var u = function() {
            function t3() {
              this.start = Date.now();
            }
            return Object.defineProperty(t3.prototype, "duration", { get: function() {
              return Date.now() - this.start;
            }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "startTime", { get: function() {
              return this.start;
            }, enumerable: true, configurable: true }), t3.prototype.reset = function() {
              this.start = Date.now();
            }, t3;
          }();
          e.Timespan = u;
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(3), i = function() {
            function t3(t4, e2, n2, o2, i2, r, s) {
              this.connectionId = t4, this.connectedClientId = e2, this.domId = n2, this.unsecureUrl = o2, this.url = i2, this.c2cUrlBase = r, this.expirationTsSec = s;
            }
            return t3.prototype.getRemainingTtlInSec = function() {
              return o.calculateTtlInSec(this.expirationTsSec);
            }, t3;
          }();
          e.ServerState = i;
          !function(t3) {
            t3[t3.Unknown = 0] = "Unknown", t3[t3.Modified = 1] = "Modified", t3[t3.Snapshot = 2] = "Snapshot", t3[t3.Connected = 3] = "Connected";
          }(e.UserActivityEventReason || (e.UserActivityEventReason = {}));
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(1), i = function() {
            function t3(t4) {
              this.logger = t4, this.messageHandlers = [];
            }
            return t3.prototype.register = function(t4) {
              if (this.messageHandlers.some(function(e2) {
                return e2 === t4;
              }))
                throw new Error("Registering the same handler twice is not allowed");
              this.messageHandlers.push(t4);
            }, t3.prototype.clear = function() {
              this.logger.debug("Clearing message handlers"), this.messageHandlers = [];
            }, t3.prototype.active = function() {
              return this.messageHandlers.length > 0;
            }, t3.prototype.handleMessage = function(t4) {
              for (var e2 = { resultCode: o.UNHANDLED_MESSAGE_ACK, isHandled: false }, n2 = 0, i2 = this.messageHandlers; n2 < i2.length; n2++) {
                var r = i2[n2], s = this.safeExecuteHandle(r, t4);
                if (void 0 !== s && (void 0 === s.isHandled || s.isHandled))
                  return void 0 === s.resultCode && (s.resultCode = o.HANDLED_MESSAGE_ACK), s;
              }
              return e2;
            }, t3.prototype.safeExecuteHandle = function(t4, e2) {
              try {
                return t4.handleMessage(e2);
              } catch (t5) {
                return void this.logger.warn("A trouter message handler is throwing exceptions. exception: " + t5);
              }
            }, t3;
          }();
          e.MessageHandlerRegistry = i;
        }, function(t2, e, n) {
          function o(t3) {
            var e2, n2 = this;
            return function(o2) {
              return i(n2, void 0, void 0, function() {
                return r(this, function(n3) {
                  return o2 && (e2 = void 0), [2, new Promise(function(n4, i2) {
                    t3(o2).then(function(t4) {
                      e2 = t4, n4(t4);
                    }).catch(function(t4) {
                      void 0 !== e2 && e2.length > 0 && n4(e2), i2(t4);
                    });
                  })];
                });
              });
            };
          }
          var i = this && this.__awaiter || function(t3, e2, n2, o2) {
            return new (n2 || (n2 = Promise))(function(i2, r2) {
              function s(t4) {
                try {
                  a(o2.next(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function c(t4) {
                try {
                  a(o2.throw(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function a(t4) {
                t4.done ? i2(t4.value) : new n2(function(e3) {
                  e3(t4.value);
                }).then(s, c);
              }
              a((o2 = o2.apply(t3, e2 || [])).next());
            });
          }, r = this && this.__generator || function(t3, e2) {
            function n2(t4) {
              return function(e3) {
                return o2([t4, e3]);
              };
            }
            function o2(n3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (i2 = 1, r2 && (s = 2 & n3[0] ? r2.return : n3[0] ? r2.throw || ((s = r2.return) && s.call(r2), 0) : r2.next) && !(s = s.call(r2, n3[1])).done)
                    return s;
                  switch (r2 = 0, s && (n3 = [2 & n3[0], s.value]), n3[0]) {
                    case 0:
                    case 1:
                      s = n3;
                      break;
                    case 4:
                      return a.label++, { value: n3[1], done: false };
                    case 5:
                      a.label++, r2 = n3[1], n3 = [0];
                      continue;
                    case 7:
                      n3 = a.ops.pop(), a.trys.pop();
                      continue;
                    default:
                      if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n3[0] || 2 === n3[0])) {
                        a = 0;
                        continue;
                      }
                      if (3 === n3[0] && (!s || n3[1] > s[0] && n3[1] < s[3])) {
                        a.label = n3[1];
                        break;
                      }
                      if (6 === n3[0] && a.label < s[1]) {
                        a.label = s[1], s = n3;
                        break;
                      }
                      if (s && a.label < s[2]) {
                        a.label = s[2], a.ops.push(n3);
                        break;
                      }
                      s[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  n3 = e2.call(t3, a);
                } catch (t4) {
                  n3 = [6, t4], r2 = 0;
                } finally {
                  i2 = s = 0;
                }
              if (5 & n3[0])
                throw n3[1];
              return { value: n3[0] ? n3[1] : void 0, done: true };
            }
            var i2, r2, s, c, a = { label: 0, sent: function() {
              if (1 & s[0])
                throw s[1];
              return s[1];
            }, trys: [], ops: [] };
            return c = { next: n2(0), throw: n2(1), return: n2(2) }, "function" == typeof Symbol && (c[Symbol.iterator] = function() {
              return this;
            }), c;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.addCacheAsBackupTo = o;
        }, function(t2, e, n) {
          var o = this && this.__awaiter || function(t3, e2, n2, o2) {
            return new (n2 || (n2 = Promise))(function(i2, r2) {
              function s2(t4) {
                try {
                  a2(o2.next(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function c2(t4) {
                try {
                  a2(o2.throw(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function a2(t4) {
                t4.done ? i2(t4.value) : new n2(function(e3) {
                  e3(t4.value);
                }).then(s2, c2);
              }
              a2((o2 = o2.apply(t3, e2 || [])).next());
            });
          }, i = this && this.__generator || function(t3, e2) {
            function n2(t4) {
              return function(e3) {
                return o2([t4, e3]);
              };
            }
            function o2(n3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; a2; )
                try {
                  if (i2 = 1, r2 && (s2 = 2 & n3[0] ? r2.return : n3[0] ? r2.throw || ((s2 = r2.return) && s2.call(r2), 0) : r2.next) && !(s2 = s2.call(r2, n3[1])).done)
                    return s2;
                  switch (r2 = 0, s2 && (n3 = [2 & n3[0], s2.value]), n3[0]) {
                    case 0:
                    case 1:
                      s2 = n3;
                      break;
                    case 4:
                      return a2.label++, { value: n3[1], done: false };
                    case 5:
                      a2.label++, r2 = n3[1], n3 = [0];
                      continue;
                    case 7:
                      n3 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (s2 = a2.trys, !(s2 = s2.length > 0 && s2[s2.length - 1]) && (6 === n3[0] || 2 === n3[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === n3[0] && (!s2 || n3[1] > s2[0] && n3[1] < s2[3])) {
                        a2.label = n3[1];
                        break;
                      }
                      if (6 === n3[0] && a2.label < s2[1]) {
                        a2.label = s2[1], s2 = n3;
                        break;
                      }
                      if (s2 && a2.label < s2[2]) {
                        a2.label = s2[2], a2.ops.push(n3);
                        break;
                      }
                      s2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  n3 = e2.call(t3, a2);
                } catch (t4) {
                  n3 = [6, t4], r2 = 0;
                } finally {
                  i2 = s2 = 0;
                }
              if (5 & n3[0])
                throw n3[1];
              return { value: n3[0] ? n3[1] : void 0, done: true };
            }
            var i2, r2, s2, c2, a2 = { label: 0, sent: function() {
              if (1 & s2[0])
                throw s2[1];
              return s2[1];
            }, trys: [], ops: [] };
            return c2 = { next: n2(0), throw: n2(1), return: n2(2) }, "function" == typeof Symbol && (c2[Symbol.iterator] = function() {
              return this;
            }), c2;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var r = n(3), s = n(2), c = n(0), a = n(14), h = n(16), u = function() {
            function t3(t4, e2) {
              this.state = t4, this.correlationVector = void 0 !== e2 ? e2 : r.CorrelationVector.extend();
            }
            return t3.prototype.getStateString = function() {
              switch (this.state) {
                case s.UserActivityState.Active:
                  return "active";
                case s.UserActivityState.Inactive:
                  return "inactive";
                case s.UserActivityState.Unknown:
                  return "unknown";
                default:
                  return "undefined";
              }
            }, t3.prototype.toEventObject = function() {
              return { state: this.getStateString(), cv: this.correlationVector.value() };
            }, t3.prototype.toEventJSON = function() {
              return r.toJson(this.toEventObject());
            }, t3;
          }();
          e.UserActivityObject = u;
          var p = function() {
            function t3(t4, e2, n2, o2) {
              this.logFunc = t4, this.options = e2, this.tokenProvider = n2, this.listener = o2, this.logger = new c.Logger("Manager", t4), this.logger.info("Created TrouterManager with options " + r.toJson(this.options)), this.fsm = new h.TrouterManagerFsm(t4, this), this.baseEndpointUrl = "", this.processedMessageLoss = {}, this.userActivityObject = new u(s.UserActivityState.Unknown);
            }
            return t3.prototype.start = function() {
              this.fsm.start();
            }, t3.prototype.stop = function(t4) {
              this.fsm.stop(t4);
            }, t3.prototype.configure = function(t4) {
              this.options = t4, void 0 !== this.firstConnection && this.firstConnection.configure(t4), void 0 !== this.secondConnection && this.secondConnection.configure(t4), this.logger.info("Reconfigured TrouterManager with options " + r.toJson(this.options));
            }, t3.prototype.checkConnection = function(t4) {
              void 0 !== this.firstConnection && this.firstConnection.checkConnection(t4), void 0 !== this.secondConnection && this.secondConnection.checkConnection(t4);
            }, t3.prototype.resendRegistration = function() {
              return o(this, void 0, void 0, function() {
                return i(this, function(t4) {
                  return void 0 !== this.secondConnection ? (this.logger.info("Resending registration on the second/new connection"), [2, this.secondConnection.resendRegistration()]) : void 0 !== this.firstConnection ? (this.logger.info("Resending registration on the first/current connection"), [2, this.firstConnection.resendRegistration()]) : (this.logger.info("No connection to resend registration on, will be done upon (re)connect"), [2]);
                });
              });
            }, t3.prototype.getServerState = function() {
              if (void 0 !== this.firstConnection)
                return this.firstConnection.getServerState();
            }, t3.prototype.getState = function() {
              return this.fsm.getState();
            }, t3.prototype.startFirstConnection = function() {
              var t4 = new a.TrouterConnection(this.logFunc, this.options, this, this.tokenProvider, this.userActivityObject);
              this.firstConnection = t4, this.getConnectionCache().then(function(e2) {
                t4.start(e2);
              }).catch();
            }, t3.prototype.startSecondConnection = function(t4) {
              var e2 = new a.TrouterConnection(this.logFunc, this.options, this, this.tokenProvider, this.userActivityObject);
              this.secondConnection = e2, void 0 !== this.firstConnection && this.firstConnection.disableRegistrationsAndAutoReconnect(), t4 ? this.getConnectionCache().then(function(t5) {
                e2.start(t5);
              }).catch() : e2.start();
            }, t3.prototype.stopFirstConnection = function(t4) {
              void 0 !== this.firstConnection && (this.storedFirstConnection = this.firstConnection, this.firstConnection.stop(t4), this.firstConnection = void 0);
            }, t3.prototype.stopSecondConnection = function(t4) {
              void 0 !== this.secondConnection && (this.secondConnection.stop(t4), this.secondConnection = void 0);
            }, t3.prototype.stopSecondConnectionDelayed = function() {
              if (void 0 !== this.secondConnection) {
                var t4 = this.secondConnection;
                this.secondConnection = void 0, this.logger.info("Closing an inactive connection in " + Math.round(this.options.lingeringConnectionDelayMs / 1e3) + "s"), setTimeout(function() {
                  t4.stop(true);
                }, this.options.lingeringConnectionDelayMs);
              }
            }, t3.prototype.forceStopLingeringConnection = function() {
              this.storedFirstConnection && (this.storedFirstConnection.stop(false), this.storedFirstConnection = void 0);
            }, t3.prototype.switchConnections = function() {
              var t4 = this.firstConnection;
              this.firstConnection = this.secondConnection, this.secondConnection = t4;
            }, t3.prototype.doesSecondConnectionExist = function() {
              return void 0 !== this.secondConnection;
            }, t3.prototype.dispatchConnected = function() {
              if (void 0 !== this.firstConnection) {
                var t4 = this.firstConnection.getServerState(), e2 = "/" === t4.url.slice(-1) ? t4.url.slice(0, -1) : t4.url, n2 = { baseEndpointUrl: e2, newEndpointUrl: e2 !== this.baseEndpointUrl, c2cUrlBase: t4.c2cUrlBase, clientId: t4.connectedClientId, connectionId: t4.connectionId, connectionTtlSec: t4.getRemainingTtlInSec() };
                this.baseEndpointUrl = e2, this.listener.onTrouterConnected(t4.url, n2);
              }
            }, t3.prototype.dispatchReconnecting = function() {
              this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();
            }, t3.prototype.dispatchStopped = function() {
              this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();
            }, t3.prototype.dispatchRegistrationState = function(t4) {
              this.options.registrationStateCallback && this.options.registrationStateCallback(t4);
            }, t3.prototype.onDownstreamRequest = function(t4, e2, n2) {
              var o2 = { id: e2.id, method: e2.method, path: "/" + e2.shortUrl, body: e2.body, headers: e2.headers }, i2 = { id: e2.id, status: 0, headers: {}, body: "", send: function() {
                return i2.status <= 100 || i2.status >= 999 ? 3 : (n2.writeHead(i2.status, i2.headers), n2.end(i2.body));
              } };
              this.listener.onTrouterRequest(o2, i2);
            }, t3.prototype.onConnected = function(t4) {
              this.fsm.onConnected(t4 === this.firstConnection);
            }, t3.prototype.onRegistered = function(t4) {
              this.fsm.onRegistered(t4 === this.firstConnection);
            }, t3.prototype.onUnregistered = function(t4) {
              this.fsm.onUnregistered(t4 === this.firstConnection || t4 === this.storedFirstConnection);
            }, t3.prototype.onReconnecting = function(t4) {
              this.fsm.onReconnecting(t4 === this.firstConnection);
            }, t3.prototype.onReconnectIsRequired = function(t4, e2) {
              this.fsm.onReconnectionRequired(t4 === this.firstConnection, e2);
            }, t3.prototype.onDisconnected = function(t4) {
              this.fsm.onDisconnected(t4 === this.storedFirstConnection), this.storedFirstConnection = void 0;
            }, t3.prototype.onUserActivityStateAccepted = function(t4) {
              this.listener.onTrouterUserActivityStateAccepted && this.listener.onTrouterUserActivityStateAccepted(t4);
            }, t3.prototype.onConnectionParametersUpdated = function(t4) {
              this.setConnectionCache(t4);
            }, t3.prototype.setUserActivityState = function(t4, e2) {
              return this.userActivityObject = new u(t4, r.CorrelationVector.extend(e2)), void 0 !== this.secondConnection ? (this.logger.info("Setting user activity " + this.userActivityObject.toEventJSON() + " on the second/new connection"), void this.secondConnection.setUserActivityState(this.userActivityObject)) : void 0 !== this.firstConnection ? (this.logger.info("Setting user activity " + this.userActivityObject.toEventJSON() + " on the first/current connection"), void this.firstConnection.setUserActivityState(this.userActivityObject)) : void 0;
            }, t3.prototype.onTrouterMessageLost = function(t4) {
              var e2 = this;
              if (this.listener.onTrouterMessageLoss)
                if (t4 && t4.length) {
                  var n2 = t4.filter(function(t5) {
                    return void 0 !== e2.processedMessageLoss[t5.tag + "-" + t5.etag];
                  });
                  if (n2.length && (this.logger.warn("onTrouterMessageLoss - removing duplicates and sending event to server"), this.sendProcessedDroppedIndicators(n2), t4 = t4.filter(function(t5) {
                    return void 0 === e2.processedMessageLoss[t5.tag + "-" + t5.etag];
                  }), !t4.length))
                    return void this.logger.warn("onTrouterMessageLoss - All the data are duplicated");
                  var o2 = this.listener.onTrouterMessageLoss(t4.map(function(t5) {
                    return t5.tag;
                  }));
                  if (!o2)
                    return void this.logger.warn("onTrouterMessageLoss - flow tags have not been processed by listeners");
                  t4.forEach(function(t5) {
                    e2.processedMessageLoss[t5.tag + "-" + t5.etag] = "";
                  }), this.sendProcessedDroppedIndicators(t4);
                } else
                  this.logger.warn("onTrouterMessageLoss - no flow tags have been provided");
            }, t3.prototype.getConnectionCache = function() {
              var t4 = this;
              return this.options.connectionCache ? (this.logger.debug("Querying host's connection cache"), this.options.connectionCache.onGetTrouterConnectionCache().then(function(t5) {
                return t5 ? JSON.parse(t5) : void 0;
              }).catch(function(e2) {
                return t4.logger.warn("Invalid connection cache content provided: " + e2), t4.connectionCache;
              })) : Promise.resolve(this.connectionCache);
            }, t3.prototype.setConnectionCache = function(t4) {
              if (this.connectionCache = t4, this.options.connectionCache)
                try {
                  this.options.connectionCache.onSetTrouterConnectionCache(JSON.stringify(t4));
                } catch (t5) {
                  this.logger.warn("Error setting external connection cache: " + t5);
                }
            }, t3.prototype.sendProcessedDroppedIndicators = function(t4) {
              return void 0 !== this.firstConnection ? void this.firstConnection.sendProcessedDroppedIndicators(t4) : void 0 !== this.secondConnection ? void this.secondConnection.sendProcessedDroppedIndicators(t4) : void 0;
            }, t3;
          }();
          e.TrouterManager = p;
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function() {
            function t3(t4) {
              this.logger = t4;
            }
            return t3.prototype.getPromise = function() {
              var t4 = this;
              return void 0 !== this.url ? (this.logger.debug("[TrouterUrlPromise] returning previously resolved url: " + this.url), Promise.resolve(this.url)) : (void 0 === this.pendingPromise ? (this.logger.debug("[TrouterUrlPromise] creating and returning promise"), this.pendingPromise = new Promise(function(e2, n2) {
                t4.pendingPromiseResolveRef = e2, t4.pendingPromiseRejectRef = n2;
              })) : this.logger.debug("[TrouterUrlPromise] returning existing promise"), this.pendingPromise);
            }, t3.prototype.resolveUrl = function(t4) {
              this.url = t4, this.logger.debug("[TrouterUrlPromise] got url: " + this.url);
              var e2 = this.pendingPromiseResolveRef;
              this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e2 && (this.logger.debug("[TrouterUrlPromise] resolving promise"), e2(t4));
            }, t3.prototype.rejectUrl = function(t4) {
              this.logger.debug("[TrouterUrlPromise] aborting");
              var e2 = this.pendingPromiseRejectRef;
              this.url = void 0, this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e2 && (this.logger.debug("[TrouterUrlPromise] rejecting promise"), e2(t4));
            }, t3.prototype.resetUrl = function() {
              this.logger.debug("[TrouterUrlPromise] resetting url"), this.url = void 0;
            }, t3;
          }();
          e.TrouterUrlPromise = o;
        }, function(t2, e, n) {
          (function(t3, n2) {
            !function(t4, e2) {
              var n3 = t4;
              n3.version = "0.9.6", n3.protocol = 1, n3.transports = [], n3.j = [], n3.sockets = {}, n3.connect = function(t5, o2) {
                var i, r, s = n3.util.parseUri(t5);
                e2 && e2.location && (s.protocol = s.protocol || e2.location.protocol.slice(0, -1), s.host = s.host || (e2.document ? e2.document.domain : e2.location.hostname), s.port = s.port || e2.location.port), i = n3.util.uniqueUri(s);
                var c = { host: s.host, secure: "https" == s.protocol, port: s.port || ("https" == s.protocol ? 443 : 80), query: s.query || "" };
                return n3.util.merge(c, o2), !c["force new connection"] && n3.sockets[i] || (r = new n3.Socket(c)), !c["force new connection"] && r && (n3.sockets[i] = r), r = r || n3.sockets[i], r.of(s.path.length > 1 ? s.path : "");
              };
            }(n2.exports, void 0 === t3 ? window : t3);
            var o = n2.exports;
            !function(t4, e2) {
              var n3 = t4.util = {}, o2 = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, i = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
              n3.parseUri = function(t5) {
                for (var e3 = o2.exec(t5 || ""), n4 = {}, r2 = 14; r2--; )
                  n4[i[r2]] = e3[r2] || "";
                return n4;
              }, n3.uniqueUri = function(t5) {
                var n4 = t5.protocol, o3 = t5.host, i2 = t5.port;
                return "document" in e2 ? (o3 = o3 || document.domain, i2 = i2 || ("https" == n4 && "https:" !== document.location.protocol ? 443 : document.location.port)) : (o3 = o3 || "localhost", i2 || "https" != n4 || (i2 = 443)), (n4 || "http") + "://" + o3 + ":" + (i2 || 80);
              }, n3.query = function(t5, e3) {
                var o3 = n3.chunkQuery(t5 || ""), i2 = [];
                n3.merge(o3, n3.chunkQuery(e3 || ""));
                for (var r2 in o3)
                  o3.hasOwnProperty(r2) && i2.push(r2 + "=" + o3[r2]);
                return i2.length ? "?" + i2.join("&") : "";
              }, n3.chunkQuery = function(t5) {
                for (var e3, n4 = {}, o3 = t5.split("&"), i2 = 0, r2 = o3.length; i2 < r2; ++i2)
                  e3 = o3[i2].split("="), e3[0] && (n4[e3[0]] = e3[1]);
                return n4;
              };
              var r = false;
              n3.load = function(t5) {
                if ("document" in e2 && "complete" === document.readyState || r)
                  return t5();
                n3.on(e2, "load", t5, false);
              }, n3.on = function(t5, e3, n4, o3) {
                t5.attachEvent ? t5.attachEvent("on" + e3, n4) : t5.addEventListener && t5.addEventListener(e3, n4, o3);
              }, n3.request = function(t5) {
                if (t5 && "undefined" != typeof XDomainRequest)
                  return new XDomainRequest();
                if ("undefined" != typeof XMLHttpRequest && (!t5 || n3.ua.hasCORS))
                  return new XMLHttpRequest();
                if (!t5)
                  try {
                    return new window[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
                  } catch (t6) {
                  }
                return null;
              }, "undefined" != typeof window && n3.load(function() {
                r = true;
              }), n3.defer = function(t5) {
                if (!n3.ua.webkit || "undefined" != typeof importScripts)
                  return t5();
                n3.load(function() {
                  setTimeout(t5, 100);
                });
              }, n3.merge = function(t5, e3, o3, i2) {
                var r2, s = i2 || [], c = void 0 === o3 ? 2 : o3;
                for (r2 in e3)
                  e3.hasOwnProperty(r2) && n3.indexOf(s, r2) < 0 && ("object" == typeof t5[r2] && c ? n3.merge(t5[r2], e3[r2], c - 1, s) : (t5[r2] = e3[r2], s.push(e3[r2])));
                return t5;
              }, n3.mixin = function(t5, e3) {
                n3.merge(t5.prototype, e3.prototype);
              }, n3.inherit = function(t5, e3) {
                function n4() {
                }
                n4.prototype = e3.prototype, t5.prototype = new n4();
              }, n3.isArray = Array.isArray || function(t5) {
                return "[object Array]" === Object.prototype.toString.call(t5);
              }, n3.intersect = function(t5, e3) {
                for (var o3 = [], i2 = t5.length > e3.length ? t5 : e3, r2 = t5.length > e3.length ? e3 : t5, s = 0, c = r2.length; s < c; s++)
                  ~n3.indexOf(i2, r2[s]) && o3.push(r2[s]);
                return o3;
              }, n3.indexOf = function(t5, e3, n4) {
                for (var o3 = t5.length, n4 = n4 < 0 ? n4 + o3 < 0 ? 0 : n4 + o3 : n4 || 0; n4 < o3 && t5[n4] !== e3; n4++)
                  ;
                return o3 <= n4 ? -1 : n4;
              }, n3.toArray = function(t5) {
                for (var e3 = [], n4 = 0, o3 = t5.length; n4 < o3; n4++)
                  e3.push(t5[n4]);
                return e3;
              }, n3.ua = {}, n3.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function() {
                try {
                  var t5 = new XMLHttpRequest();
                } catch (t6) {
                  return false;
                }
                return void 0 != t5.withCredentials;
              }(), n3.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent);
            }(void 0 !== o ? o : n2.exports, void 0 === t3 ? window : t3), function(t4, e2) {
              function n3() {
              }
              t4.EventEmitter = n3, n3.prototype.on = function(t5, n4) {
                return this.$events || (this.$events = {}), this.$events[t5] ? e2.util.isArray(this.$events[t5]) ? this.$events[t5].push(n4) : this.$events[t5] = [this.$events[t5], n4] : this.$events[t5] = n4, this;
              }, n3.prototype.addListener = n3.prototype.on, n3.prototype.once = function(t5, e3) {
                function n4() {
                  o2.removeListener(t5, n4), e3.apply(this, arguments);
                }
                var o2 = this;
                return n4.listener = e3, this.on(t5, n4), this;
              }, n3.prototype.removeListener = function(t5, n4) {
                if (this.$events && this.$events[t5]) {
                  var o2 = this.$events[t5];
                  if (e2.util.isArray(o2)) {
                    for (var i = -1, r = 0, s = o2.length; r < s; r++)
                      if (o2[r] === n4 || o2[r].listener && o2[r].listener === n4) {
                        i = r;
                        break;
                      }
                    if (i < 0)
                      return this;
                    o2.splice(i, 1), o2.length || delete this.$events[t5];
                  } else
                    (o2 === n4 || o2.listener && o2.listener === n4) && delete this.$events[t5];
                }
                return this;
              }, n3.prototype.removeAllListeners = function(t5) {
                return this.$events && this.$events[t5] && (this.$events[t5] = null), this;
              }, n3.prototype.listeners = function(t5) {
                return this.$events || (this.$events = {}), this.$events[t5] || (this.$events[t5] = []), e2.util.isArray(this.$events[t5]) || (this.$events[t5] = [this.$events[t5]]), this.$events[t5];
              }, n3.prototype.emit = function(t5) {
                if (!this.$events)
                  return false;
                var n4 = this.$events[t5];
                if (!n4)
                  return false;
                var o2 = Array.prototype.slice.call(arguments, 1);
                if ("function" == typeof n4)
                  n4.apply(this, o2);
                else {
                  if (!e2.util.isArray(n4))
                    return false;
                  for (var i = n4.slice(), r = 0, s = i.length; r < s; r++)
                    i[r].apply(this, o2);
                }
                return true;
              };
            }(void 0 !== o ? o : n2.exports, void 0 !== o ? o : n2.parent.exports), function(t4, e2) {
              if (e2 && e2.parse)
                return t4.JSON = { parse: e2.parse, stringify: e2.stringify };
              throw new Error("JSON not available");
            }(void 0 !== o ? o : n2.exports, "undefined" != typeof JSON ? JSON : void 0), function(t4, e2) {
              var n3 = t4.parser = {}, o2 = n3.packets = ["disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop"], i = n3.reasons = ["transport not supported", "client not handshaken", "unauthorized"], r = n3.advice = ["reconnect"], s = e2.JSON, c = e2.util.indexOf;
              n3.encodePacket = function(t5) {
                var e3 = c(o2, t5.type), n4 = t5.id || "", a2 = t5.endpoint || "", h = t5.ack, u = null;
                switch (t5.type) {
                  case "error":
                    var p = t5.reason ? c(i, t5.reason) : "", l = t5.advice ? c(r, t5.advice) : "";
                    "" === p && "" === l || (u = p + ("" !== l ? "+" + l : ""));
                    break;
                  case "message":
                    "" !== t5.data && (u = t5.data);
                    break;
                  case "event":
                    var d = { name: t5.name };
                    t5.args && t5.args.length && (d.args = t5.args), u = s.stringify(d);
                    break;
                  case "json":
                    u = s.stringify(t5.data);
                    break;
                  case "connect":
                    t5.qs && (u = t5.qs);
                    break;
                  case "ack":
                    u = t5.ackId + (t5.args && t5.args.length ? "+" + s.stringify(t5.args) : "");
                }
                var g = [e3, n4 + ("data" == h ? "+" : ""), a2];
                return null !== u && void 0 !== u && g.push(u), g.join(":");
              }, n3.encodePayload = function(t5) {
                var e3 = "";
                if (1 == t5.length)
                  return t5[0];
                for (var n4 = 0, o3 = t5.length; n4 < o3; n4++) {
                  e3 += "�" + t5[n4].length + "�" + t5[n4];
                }
                return e3;
              };
              var a = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
              n3.decodePacket = function(t5) {
                var e3 = t5.match(a);
                if (!e3)
                  return {};
                var n4 = e3[2] || "", t5 = e3[5] || "", c2 = { type: o2[e3[1]], endpoint: e3[4] || "" };
                switch (n4 && (c2.id = n4, e3[3] ? c2.ack = "data" : c2.ack = true), c2.type) {
                  case "error":
                    var e3 = t5.split("+");
                    c2.reason = i[e3[0]] || "", c2.advice = r[e3[1]] || "";
                    break;
                  case "message":
                    c2.data = t5 || "";
                    break;
                  case "event":
                    try {
                      var h = s.parse(t5);
                      c2.name = h.name, c2.args = h.args;
                    } catch (t6) {
                    }
                    c2.args = c2.args || [];
                    break;
                  case "json":
                    try {
                      c2.data = s.parse(t5);
                    } catch (t6) {
                    }
                    break;
                  case "connect":
                    c2.qs = t5 || "";
                    break;
                  case "ack":
                    var e3 = t5.match(/^([0-9]+)(\+)?(.*)/);
                    if (e3 && (c2.ackId = e3[1], c2.args = [], e3[3]))
                      try {
                        c2.args = e3[3] ? s.parse(e3[3]) : [];
                      } catch (t6) {
                      }
                    break;
                  case "disconnect":
                    c2.reason = t5;
                }
                return c2;
              }, n3.decodePayload = function(t5) {
                if ("�" == t5.charAt(0)) {
                  for (var e3 = [], o3 = 1, i2 = ""; o3 < t5.length; o3++)
                    "�" == t5.charAt(o3) ? (e3.push(n3.decodePacket(t5.substr(o3 + 1).substr(0, i2))), o3 += Number(i2) + 1, i2 = "") : i2 += t5.charAt(o3);
                  return e3;
                }
                return [n3.decodePacket(t5)];
              };
            }(void 0 !== o ? o : n2.exports, void 0 !== o ? o : n2.parent.exports), function(t4, e2) {
              function n3(t5, e3) {
                this.socket = t5, this.sessid = e3, this.connectErrorCallback = void 0, this.isOpened = false;
              }
              t4.Transport = n3, e2.util.mixin(n3, e2.EventEmitter), n3.prototype.onData = function(t5) {
                if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), "" !== t5) {
                  var n4 = e2.parser.decodePayload(t5);
                  if (n4 && n4.length)
                    for (var o2 = 0, i = n4.length; o2 < i; o2++)
                      this.onPacket(n4[o2]);
                }
                return this;
              }, n3.prototype.onPacket = function(t5) {
                return this.socket.setHeartbeatTimeout(), "heartbeat" == t5.type ? this.onHeartbeat() : ("connect" == t5.type && "" == t5.endpoint && this.onConnect(), "error" == t5.type && "reconnect" == t5.advice && (this.isOpened = false), this.socket.onPacket(t5), this);
              }, n3.prototype.setCloseTimeout = function() {
                if (!this.closeTimeout) {
                  var t5 = this;
                  this.closeTimeout = setTimeout(function() {
                    t5.onDisconnect();
                  }, this.socket.closeTimeout);
                }
              }, n3.prototype.onDisconnect = function() {
                return this.close && this.isOpened && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this;
              }, n3.prototype.onConnect = function() {
                return this.socket.onConnect(), this.connectErrorCallback = void 0, this;
              }, n3.prototype.clearCloseTimeout = function() {
                this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null);
              }, n3.prototype.clearTimeouts = function() {
                this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout);
              }, n3.prototype.packet = function(t5) {
                this.send(e2.parser.encodePacket(t5));
              }, n3.prototype.onHeartbeat = function(t5) {
                this.packet({ type: "heartbeat" });
              }, n3.prototype.onOpen = function() {
                this.isOpened = true, this.clearCloseTimeout(), this.socket.onOpen();
              }, n3.prototype.onClose = function() {
                this.isOpened = false, this.socket.onClose(), this.onDisconnect();
              }, n3.prototype.prepareUrl = function() {
                var t5 = this.socket.options;
                return this.scheme() + "://" + t5.host + ":" + t5.port + "/" + t5.resource + "/" + e2.protocol + "/" + this.name + "/" + this.sessid;
              }, n3.prototype.ready = function(t5, e3) {
                e3.call(this);
              }, n3.prototype.clearEventHandlers = function() {
                return this;
              };
            }(void 0 !== o ? o : n2.exports, void 0 !== o ? o : n2.parent.exports), function(t4, e2, n3) {
              function o2(t5) {
                if (this.options = { port: 80, secure: false, document: "document" in n3 && document, resource: "socket.io", transports: e2.transports.slice(), "connect timeout": 1e4, "try multiple transports": true, reconnect: true, "reconnection delay": 500, "reconnection limit": 1 / 0, "reopen delay": 3e3, "max reconnection attempts": 10, "sync disconnect on unload": true, "auto connect": true, "flash policy port": 10843 }, e2.util.merge(this.options, t5), this.connected = false, this.open = false, this.connecting = false, this.reconnecting = false, this.namespaces = {}, this.buffer = [], this.doBuffer = false, this.disconnected = false, this.options["sync disconnect on unload"] && (!this.isXDomain() || e2.util.ua.hasCORS)) {
                  var o3 = this;
                  e2.util.on(n3, "unload", function() {
                    o3.disconnectSync();
                  }, false);
                }
                this.options["auto connect"] && this.connect();
              }
              function i() {
              }
              t4.Socket = o2, e2.util.mixin(o2, e2.EventEmitter), o2.prototype.of = function(t5) {
                return this.namespaces[t5] || (this.namespaces[t5] = new e2.SocketNamespace(this, t5), "" !== t5 && this.namespaces[t5].packet({ type: "connect" })), this.namespaces[t5];
              }, o2.prototype.publish = function() {
                this.emit.apply(this, arguments);
                var t5;
                for (var e3 in this.namespaces)
                  this.namespaces.hasOwnProperty(e3) && (t5 = this.of(e3), t5.$emit.apply(t5, arguments));
              }, o2.prototype.handshake = function(t5) {
                function n4(e3) {
                  e3 instanceof Error ? o3.onError(e3.message) : t5.apply(null, e3.split(":"));
                }
                var o3 = this, r = this.options;
                if (!o3.disconnected) {
                  var s = ["http" + (r.secure ? "s" : "") + ":/", r.host + ":" + r.port, r.resource, e2.protocol, e2.util.query(this.options.query, "t=" + +new Date())].join("/");
                  if (this.isXDomain() && !e2.util.ua.hasCORS) {
                    var c = document.getElementsByTagName("script")[0], a = document.createElement("script");
                    a.src = s + "&jsonp=" + e2.j.length, c.parentNode.insertBefore(a, c), e2.j.push(function(t6) {
                      n4(t6), a.parentNode.removeChild(a);
                    });
                  } else {
                    var h = e2.util.request();
                    h.open("GET", s, true), h.withCredentials = true, h.onreadystatechange = function() {
                      4 == h.readyState && (h.onreadystatechange = i, 200 == h.status ? n4(h.responseText) : !o3.reconnecting && o3.onError(h.responseText));
                    }, h.send(null);
                  }
                }
              }, o2.prototype.getTransport = function(t5) {
                for (var n4, o3 = t5 || this.transports, i2 = 0; n4 = o3[i2]; i2++)
                  if (e2.Transport[n4] && e2.Transport[n4].check(this) && (!this.isXDomain() || e2.Transport[n4].xdomainCheck()))
                    return new e2.Transport[n4](this, this.sessionid);
                return null;
              }, o2.prototype.connect = function(t5) {
                if (this.connecting || this.disconnected)
                  return this;
                var n4 = this;
                return this.handshake(function(o3, i2, r, s) {
                  function c() {
                    if (!n4.connected && !n4.disconnected)
                      if (n4.connecting = false, clearTimeout(n4.connectTimeoutTimer), n4.options["try multiple transports"]) {
                        for (; n4.remainingTransports.length > 0 && n4.remainingTransports.splice(0, 1)[0] != n4.transport.name; )
                          ;
                        n4.remainingTransports.length ? a(n4.remainingTransports) : n4.publish("connect_failed");
                      } else
                        n4.publish("connect_failed");
                  }
                  function a(t6) {
                    if (n4.transport && (n4.transport.clearTimeouts(), n4.transport.clearEventHandlers()), n4.transport = n4.getTransport(t6), !n4.transport || n4.disconnected)
                      return n4.publish("connect_failed");
                    n4.transport.ready(n4, function() {
                      n4.connecting = true, n4.publish("connecting", n4.transport.name), n4.transport.open(c), n4.options["connect timeout"] && (n4.connectTimeoutTimer = setTimeout(function() {
                        c();
                      }, n4.options["connect timeout"]));
                    });
                  }
                  n4.sessionid = o3, n4.closeTimeout = 1e3 * r + 2e3, n4.heartbeatTimeout = 1e3 * i2 + 2e3, n4.transports = s ? e2.util.intersect(s.split(","), n4.options.transports) : n4.options.transports, n4.setHeartbeatTimeout(), n4.remainingTransports = n4.transports.slice(0), a(n4.transports), n4.once("connect", function() {
                    clearTimeout(n4.connectTimeoutTimer), t5 && "function" == typeof t5 && t5();
                  });
                }), this;
              }, o2.prototype.setHeartbeatTimeout = function() {
                clearTimeout(this.heartbeatTimeoutTimer);
                var t5 = this;
                this.heartbeatTimeoutTimer = setTimeout(function() {
                  t5.transport.onClose();
                }, this.heartbeatTimeout);
              }, o2.prototype.packet = function(t5) {
                return this.connected && !this.doBuffer ? this.transport.packet(t5) : this.buffer.push(t5), this;
              }, o2.prototype.setBuffer = function(t5) {
                this.doBuffer = t5, !t5 && this.connected && this.buffer.length && (this.transport.payload(this.buffer), this.buffer = []);
              }, o2.prototype.disconnect = function() {
                return (this.connected || this.connecting) && (this.open && this.of("").packet({ type: "disconnect" }), this.onDisconnect("booted")), this.disconnected = true, this;
              }, o2.prototype.disconnectSync = function() {
                var t5 = e2.util.request(), n4 = this.resource + "/" + e2.protocol + "/" + this.sessionid;
                t5.open("GET", n4, true), this.onDisconnect("booted");
              }, o2.prototype.isXDomain = function() {
                var t5 = n3.location.port || ("https:" == n3.location.protocol ? 443 : 80);
                return this.options.host !== n3.location.hostname || this.options.port != t5;
              }, o2.prototype.onConnect = function() {
                this.connected || (this.connected = true, this.connecting = false, this.doBuffer || this.setBuffer(false), this.emit("connect"));
              }, o2.prototype.onOpen = function() {
                this.open = true;
              }, o2.prototype.onClose = function() {
                this.open = false, clearTimeout(this.heartbeatTimeoutTimer);
              }, o2.prototype.onPacket = function(t5) {
                this.of(t5.endpoint).onPacket(t5);
              }, o2.prototype.onError = function(t5) {
                t5 && t5.advice && "reconnect" === t5.advice && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish("error", t5 && t5.reason ? t5.reason : t5);
              }, o2.prototype.onDisconnect = function(t5) {
                var e3 = this.connected, n4 = this.connecting;
                this.connected = false, this.connecting = false, this.open = false, (e3 || n4) && (this.transport.close(), this.transport.clearTimeouts(), e3 && (this.publish("disconnect", t5), "booted" != t5 && this.options.reconnect && !this.reconnecting && this.reconnect()));
              }, o2.prototype.reconnect = function() {
                function t5() {
                  if (n4.connected) {
                    for (var t6 in n4.namespaces)
                      n4.namespaces.hasOwnProperty(t6) && "" !== t6 && n4.namespaces[t6].packet({ type: "connect" });
                    n4.publish("reconnect", n4.transport.name, n4.reconnectionAttempts);
                  }
                  clearTimeout(n4.reconnectionTimer), n4.removeListener("connect_failed", e3), n4.removeListener("connect", e3), n4.reconnecting = false, delete n4.reconnectionAttempts, delete n4.reconnectionDelay, delete n4.reconnectionTimer, delete n4.redoTransports, n4.options["try multiple transports"] = i2;
                }
                function e3() {
                  if (n4.reconnecting)
                    return n4.connected ? t5() : n4.connecting && n4.reconnecting ? n4.reconnectionTimer = setTimeout(e3, 1e3) : void (n4.reconnectionAttempts++ >= o3 ? n4.redoTransports ? (n4.publish("reconnect_failed"), t5()) : (n4.on("connect_failed", e3), n4.options["try multiple transports"] = true, n4.transport = n4.getTransport(), n4.redoTransports = true, n4.connect()) : (n4.reconnectionDelay < r && (n4.reconnectionDelay *= 2), n4.connect(), n4.publish("reconnecting", n4.reconnectionDelay, n4.reconnectionAttempts), n4.reconnectionTimer = setTimeout(e3, n4.reconnectionDelay)));
                }
                this.reconnecting = true, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"];
                var n4 = this, o3 = this.options["max reconnection attempts"], i2 = this.options["try multiple transports"], r = this.options["reconnection limit"];
                this.options["try multiple transports"] = false, this.reconnectionTimer = setTimeout(e3, this.reconnectionDelay), this.on("connect", e3);
              };
            }(void 0 !== o ? o : n2.exports, void 0 !== o ? o : n2.parent.exports, void 0 === t3 ? window : t3), function(t4, e2) {
              function n3(t5, e3) {
                this.socket = t5, this.name = e3 || "", this.flags = {}, this.json = new o2(this, "json"), this.ackPackets = 0, this.acks = {};
              }
              function o2(t5, e3) {
                this.namespace = t5, this.name = e3;
              }
              t4.SocketNamespace = n3, e2.util.mixin(n3, e2.EventEmitter), n3.prototype.$emit = e2.EventEmitter.prototype.emit, n3.prototype.of = function() {
                return this.socket.of.apply(this.socket, arguments);
              }, n3.prototype.packet = function(t5) {
                return t5.endpoint = this.name, this.socket.packet(t5), this.flags = {}, this;
              }, n3.prototype.send = function(t5, e3) {
                var n4 = { type: this.flags.json ? "json" : "message", data: t5 };
                return "function" == typeof e3 && (n4.id = ++this.ackPackets, n4.ack = true, this.acks[n4.id] = e3), this.packet(n4);
              }, n3.prototype.emit = function(t5) {
                var e3 = Array.prototype.slice.call(arguments, 1), n4 = e3[e3.length - 1], o3 = { type: "event", name: t5 };
                return "function" == typeof n4 && (o3.id = ++this.ackPackets, o3.ack = "data", this.acks[o3.id] = n4, e3 = e3.slice(0, e3.length - 1)), o3.args = e3, this.packet(o3);
              }, n3.prototype.disconnect = function() {
                return "" === this.name ? this.socket.disconnect() : (this.packet({ type: "disconnect" }), this.$emit("disconnect")), this;
              }, n3.prototype.onPacket = function(t5) {
                function n4() {
                  o3.packet({ type: "ack", args: e2.util.toArray(arguments), ackId: t5.id });
                }
                var o3 = this;
                switch (t5.type) {
                  case "connect":
                    this.$emit("connect");
                    break;
                  case "disconnect":
                    "" === this.name ? this.socket.onDisconnect(t5.reason || "booted") : this.$emit("disconnect", t5.reason || "");
                    break;
                  case "message":
                  case "json":
                    var i = ["message", t5.data];
                    "data" == t5.ack ? i.push(n4) : t5.ack && this.packet({ type: "ack", ackId: t5.id }), this.$emit.apply(this, i);
                    break;
                  case "event":
                    var i = [t5.name].concat(t5.args);
                    "data" == t5.ack && i.push(n4), this.$emit.apply(this, i);
                    break;
                  case "ack":
                    this.acks[t5.ackId] && (this.acks[t5.ackId].apply(this, t5.args), delete this.acks[t5.ackId]);
                    break;
                  case "error":
                    t5.advice ? this.socket.onError(t5) : "unauthorized" == t5.reason ? this.$emit("connect_failed", t5.reason) : this.$emit("error", t5.reason);
                }
              }, o2.prototype.send = function() {
                this.namespace.flags[this.name] = true, this.namespace.send.apply(this.namespace, arguments);
              }, o2.prototype.emit = function() {
                this.namespace.flags[this.name] = true, this.namespace.emit.apply(this.namespace, arguments);
              };
            }(void 0 !== o ? o : n2.exports, void 0 !== o ? o : n2.parent.exports), function(t4, e2, n3) {
              function o2(t5) {
                e2.Transport.apply(this, arguments);
              }
              function i() {
              }
              t4.websocket = o2, e2.util.inherit(o2, e2.Transport), o2.prototype.name = "websocket", o2.prototype.open = function(t5) {
                var o3, i2 = e2.util.query(this.socket.options.query), r = this;
                return this.connectErrorCallback = t5, o3 || (o3 = n3.MozWebSocket || n3.WebSocket), this.websocket = new o3(this.prepareUrl() + i2), this.websocket.onopen = function() {
                  r.onOpen(), r.socket.setBuffer(false);
                }, this.websocket.onmessage = function(t6) {
                  r.onData(t6.data);
                }, this.websocket.onclose = function() {
                  r.onClose(), r.socket.setBuffer(true);
                }, this.websocket.onerror = function(t6) {
                  r.onError(t6);
                }, this;
              }, o2.prototype.send = function(t5) {
                return this.websocket.send(t5), this;
              }, o2.prototype.payload = function(t5) {
                for (var e3 = 0, n4 = t5.length; e3 < n4; e3++)
                  this.packet(t5[e3]);
                return this;
              }, o2.prototype.close = function() {
                return this.websocket.close(), this;
              }, o2.prototype.onError = function(t5) {
                void 0 !== this.connectErrorCallback && (this.connectErrorCallback(), this.connectErrorCallback = void 0), this.socket.onError(t5);
              }, o2.prototype.scheme = function() {
                return this.socket.options.secure ? "wss" : "ws";
              }, o2.check = function() {
                return "WebSocket" in n3 && !("__addTask" in WebSocket) || "MozWebSocket" in n3;
              }, o2.xdomainCheck = function() {
                return true;
              }, o2.prototype.clearEventHandlers = function() {
                return this.websocket && (this.websocket.onopen = this.websocket.onmessage = this.websocket.onclose = this.websocket.onerror = i), this;
              }, e2.transports.push("websocket");
            }(void 0 !== o ? o.Transport : n2.exports, void 0 !== o ? o : n2.parent.exports, void 0 === t3 ? window : t3), function(t4, e2, n3) {
              function o2(t5) {
                t5 && (e2.Transport.apply(this, arguments), this.sendBuffer = []);
              }
              function i() {
              }
              t4.XHR = o2, e2.util.inherit(o2, e2.Transport), o2.prototype.open = function() {
                return this.socket.setBuffer(false), this.onOpen(), this.get(), this.setCloseTimeout(), this;
              }, o2.prototype.payload = function(t5) {
                for (var n4 = [], o3 = 0, i2 = t5.length; o3 < i2; o3++)
                  n4.push(e2.parser.encodePacket(t5[o3]));
                this.send(e2.parser.encodePayload(n4));
              }, o2.prototype.send = function(t5) {
                return this.post(t5), this;
              }, o2.prototype.post = function(t5) {
                function e3() {
                  4 == this.readyState && (this.onreadystatechange = i, r.posting = false, 200 == this.status ? (r.socket.setBuffer(false), clearTimeout(r.sendXHR.ackTimeoutTimer)) : r.onClose());
                }
                function o3() {
                  this.onload = i, r.socket.setBuffer(false);
                }
                var r = this;
                this.socket.setBuffer(true), this.sendXHR = this.request("POST"), n3.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = o3 : this.sendXHR.onreadystatechange = e3, this.sendXHR.send(t5), r.sendXHR.ackTimeoutTimer = setTimeout(function() {
                  r.onClose();
                }, r.socket.options.ackTimeoutMs);
              }, o2.prototype.close = function() {
                return this.onClose(), this;
              }, o2.prototype.request = function(t5) {
                var n4 = e2.util.request(this.socket.isXDomain()), o3 = e2.util.query(this.socket.options.query, "t=" + +new Date());
                if (n4.open(t5 || "GET", this.prepareUrl() + o3, true), "POST" == t5)
                  try {
                    n4.setRequestHeader ? n4.setRequestHeader("Content-type", "text/plain;charset=UTF-8") : n4.contentType = "text/plain";
                  } catch (t6) {
                  }
                return n4;
              }, o2.prototype.scheme = function() {
                return this.socket.options.secure ? "https" : "http";
              }, o2.check = function(t5, o3) {
                try {
                  var i2 = e2.util.request(o3), r = n3.XDomainRequest && i2 instanceof XDomainRequest, s = t5 && t5.options && t5.options.secure ? "https:" : "http:", c = s != n3.location.protocol;
                  if (i2 && (!r || !c))
                    return true;
                } catch (t6) {
                }
                return false;
              }, o2.xdomainCheck = function() {
                return o2.check(null, true);
              }, o2.prototype.clearEventHandlers = function() {
                return this.sendXHR && (this.sendXHR.onreadystatechange = this.sendXHR.onload = i), this;
              };
            }(void 0 !== o ? o.Transport : n2.exports, void 0 !== o ? o : n2.parent.exports, void 0 === t3 ? window : t3), function(t4, e2, n3) {
              function o2() {
                e2.Transport.XHR.apply(this, arguments);
              }
              function i() {
              }
              t4["xhr-polling"] = o2, e2.util.inherit(o2, e2.Transport.XHR), e2.util.merge(o2, e2.Transport.XHR), o2.prototype.name = "xhr-polling", o2.prototype.open = function(t5) {
                var n4 = this;
                return n4.connectErrorCallback = t5, e2.Transport.XHR.prototype.open.call(n4), false;
              }, o2.prototype.get = function() {
                function t5() {
                  4 == this.readyState && (this.onreadystatechange = i, 200 == this.status ? (r.connectErrorCallback = void 0, r.onData(this.responseText), r.get()) : (r.onClose(), void 0 !== r.connectErrorCallback && (r.connectErrorCallback(), r.connectErrorCallback = void 0)));
                }
                function e3() {
                  r.connectErrorCallback = void 0, this.onload = i, this.onerror = i, r.onData(this.responseText), r.get();
                }
                function o3() {
                  r.onClose(), void 0 !== r.connectErrorCallback && (r.connectErrorCallback(), r.connectErrorCallback = void 0);
                }
                if (this.isOpened) {
                  var r = this;
                  this.xhr = this.request(), n3.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = e3, this.xhr.onerror = o3) : this.xhr.onreadystatechange = t5, this.xhr.send(null);
                }
              }, o2.prototype.onClose = function() {
                if (e2.Transport.XHR.prototype.onClose.call(this), this.xhr) {
                  this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = i;
                  try {
                    this.xhr.abort();
                  } catch (t5) {
                  }
                  this.xhr = null;
                }
              }, o2.prototype.ready = function(t5, n4) {
                var o3 = this;
                e2.util.defer(function() {
                  n4.call(o3);
                });
              }, o2.prototype.clearEventHandlers = function() {
                return e2.Transport.XHR.prototype.clearEventHandlers.call(this), this.xhr && (this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = i), this;
              }, e2.transports.push("xhr-polling");
            }(void 0 !== o ? o.Transport : n2.exports, void 0 !== o ? o : n2.parent.exports, void 0 === t3 ? window : t3), e.io = o;
          }).call(e, n(10), n(11)(t2));
        }, function(t2, e) {
          var n;
          n = function() {
            return this;
          }();
          try {
            n = n || Function("return this")() || (0, eval)("this");
          } catch (t3) {
            "object" == typeof window && (n = window);
          }
          t2.exports = n;
        }, function(t2, e) {
          t2.exports = function(t3) {
            return t3.webpackPolyfill || (t3.deprecate = function() {
            }, t3.paths = [], t3.children || (t3.children = []), Object.defineProperty(t3, "loaded", { enumerable: true, get: function() {
              return t3.l;
            } }), Object.defineProperty(t3, "id", { enumerable: true, get: function() {
              return t3.i;
            } }), t3.webpackPolyfill = 1), t3;
          };
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(3), i = n(1), r = n(0), s = function() {
            function t3(t4) {
              this.id = t4, this.status = 200, this.headers = {}, this.body = "";
            }
            return t3;
          }();
          e.ResponseData = s;
          var c;
          !function(t3) {
            t3.Connected = "trouter_js_client_connected", t3.Disconnected = "trouter_js_client_disconnected", t3.Error = "trouter_js_client_error", t3.Progress = "trouter_js_client_progress", t3.Response = "trouter_js_client_response", t3.Request = "trouter_js_client_request", t3.CheckConnection = "trouter_js_client_check_connection", t3.Registration = "trouter_js_client_registration", t3.Unregistration = "trouter_js_client_unregistration";
          }(c = e.ClientEventName || (e.ClientEventName = {}));
          var a = function() {
            function t3(t4, e2, n2, o2, i2) {
              this.stepName = t4, this.operation = e2, this.delta = n2, this.ts = o2, this.error = i2;
            }
            return t3;
          }();
          e.TrackerStep = a;
          var h = function() {
            function t3() {
            }
            return t3;
          }();
          e.Properties = h;
          var u = function() {
            function t3() {
              this.numberOfPingReplies = 0, this.connectedTimestamp = 0, this.isNewUrl = false, this.transportType = "", this.connectionNumber = 0;
            }
            return t3;
          }(), p = function() {
            function t3() {
              this.enabled = false, this.numberOfStepsToMaintain = 40, this.logHealthCheckError = false, this.sendProgressTimeoutSecs = 55, this.logSendPingError = false, this.maxBackoffInMs = 12e4, this.trouter_js_client_connected = false, this.trouter_js_client_disconnected = false, this.trouter_js_client_error = false, this.trouter_js_client_progress = false, this.trouter_js_client_response = false, this.trouter_js_client_request = false, this.trouter_js_client_registration = false, this.trouter_js_client_unregistration = false, this.trouter_js_client_check_connection = true;
            }
            return t3;
          }(), l = function() {
            function t3(t4, e2, n2, i2, s2, c2, a2) {
              this.clientId = e2, this.clientInfo = n2, this.getServerState = i2, this.endpointId = s2, this.clientCorrelationID = c2, this.environment = a2, this.logger = new r.Logger("ConnectionTracker", t4), this.clientCorrelationID = void 0 !== c2 ? c2 : "", this.steps = [], this.connectionAttempt = 0, this.totalStepCount = 0, this.beginTimestamp = new o.Timespan(), this.eventLogSettings = new p(), this.connectedInfo = new u();
            }
            return t3.prototype.enable = function(t4) {
              this.eventLogSettings.enabled = true, this.eventLogger = t4;
            }, t3.prototype.disable = function() {
              this.eventLogSettings.enabled = false;
            }, t3.prototype.sendProgress = function(t4) {
              this.steps.length > 0 && this.sendTelemetry(c.Progress, t4, this.steps);
            }, t3.prototype.cancelProgressTimer = function() {
              void 0 !== this.progressTimeout && (clearTimeout(this.progressTimeout), this.progressTimeout = void 0);
            }, t3.prototype.resetProgressSendTimer = function() {
              var t4 = this;
              this.cancelProgressTimer(), void 0 !== this.eventLogSettings.sendProgressTimeoutSecs && this.eventLogSettings.sendProgressTimeoutSecs > 0 && (this.progressTimeout = setTimeout(function() {
                t4.sendProgress({ reason: "timeout", timeoutSecs: t4.eventLogSettings.sendProgressTimeoutSecs });
              }, 1e3 * this.eventLogSettings.sendProgressTimeoutSecs));
            }, t3.prototype.setConnectedInfo = function(t4, e2) {
              this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = Date.now(), this.connectedInfo.isNewUrl = t4, this.connectedInfo.transportType = e2, ++this.connectedInfo.connectionNumber;
            }, t3.prototype.clearConnectedInfo = function() {
              this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = 0, this.connectedInfo.isNewUrl = true, this.connectedInfo.transportType = "";
            }, t3.prototype.copyProperties = function(t4, e2) {
              for (var n2 = 0, o2 = Object.keys(e2); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                e2.hasOwnProperty(i2) && void 0 !== e2[i2] && (t4[i2.replace(/-/g, "_")] = { value: e2[i2] });
              }
            }, t3.prototype.increasePingResponseCount = function() {
              ++this.connectedInfo.numberOfPingReplies;
            }, t3.prototype.sendTelemetry = function(t4, e2, n2) {
              try {
                if (true === this.eventLogSettings.enabled && true === this.eventLogSettings[t4] && void 0 !== this.eventLogger) {
                  var r2 = this.getServerState(), s2 = { name: t4, properties: { connectionAttempt: { value: this.connectionAttempt }, epid: { value: this.endpointId }, clientCorrelationID: { value: this.clientCorrelationID }, steps: { value: o.toJson(n2) }, clientID: { value: this.clientId }, eventVersion: { value: 3 }, environment: { value: this.environment }, cv: { value: i.CLIENT_VERSION }, ua: { value: this.clientInfo.ua }, connectionId: { value: r2.connectionId }, connectedClientId: { value: r2.connectedClientId }, domId: { value: r2.domId }, url: { value: r2.unsecureUrl }, surl: { value: r2.url }, ttlInSecs: { value: r2.getRemainingTtlInSec() }, numberOfPingReplies: { value: this.connectedInfo.numberOfPingReplies }, connectedTimestamp: { value: this.connectedInfo.connectedTimestamp }, isNewUrl: { value: this.connectedInfo.isNewUrl }, transportType: { value: this.connectedInfo.transportType }, connectionNumber: { value: this.connectedInfo.connectionNumber } } };
                  this.copyProperties(s2.properties, e2), this.eventLogger.logEvent(s2);
                }
              } catch (e3) {
                this.logger.warn("error in sending event " + t4 + ": " + o.toJson(e3));
              }
            }, t3.prototype.createStep = function(t4, e2, n2) {
              return new a(t4, e2, this.beginTimestamp.duration, Date.now(), n2);
            }, t3.prototype.addStep = function(t4, e2, n2) {
              if (false !== this.eventLogSettings.enabled && (0 === this.steps.length && this.beginTimestamp.reset(), this.steps.push(this.createStep(t4, e2, n2)), ++this.totalStepCount, void 0 !== this.eventLogSettings.numberOfStepsToMaintain && this.steps.length > this.eventLogSettings.numberOfStepsToMaintain)) {
                var o2 = this.steps.slice(0);
                this.steps.length = 0, this.sendTelemetry(c.Progress, { reason: "flush" }, o2);
              }
            }, t3.prototype.trackStart = function(t4) {
              this.addStep(t4, "start");
            }, t3.prototype.trackEnd = function(t4) {
              this.addStep(t4, "end");
            }, t3.prototype.trackError = function(t4, e2, n2, o2) {
              void 0 === n2 && (n2 = true), "health" === t4 && true !== this.eventLogSettings.logHealthCheckError || "ping" === t4 && false === this.eventLogSettings.logSendPingError || (void 0 === o2 && (o2 = "error"), true === n2 && this.addStep(t4, o2, e2), this.sendTelemetry(c.Error, {}, [this.createStep(t4, o2, e2)]));
            }, t3.prototype.trackProgress = function(t4, e2) {
              this.addStep(t4, e2);
            }, t3.prototype.trackConnected = function(t4, e2) {
              this.setConnectedInfo(t4, e2);
              var n2 = this.steps.slice(0), o2 = this.totalStepCount, i2 = this.beginTimestamp.duration;
              this.steps.length = 0, this.totalStepCount = 0, this.sendTelemetry(c.Connected, { stepCount: n2.length, totalStepCount: o2, connectionEstablishmentMs_Total: i2 }, n2), this.cancelProgressTimer();
            }, t3.prototype.trackDisconnected = function(t4) {
              t4.sessionLengthMS = Date.now() - this.connectedInfo.connectedTimestamp, this.sendTelemetry(c.Disconnected, t4, []), this.resetProgressSendTimer();
            }, t3.prototype.trackNewConnection = function() {
              ++this.connectionAttempt;
            }, t3.prototype.trackRequest = function(t4, e2) {
              var n2 = {};
              void 0 !== e2 && (n2.hasError = true, n2.error = e2);
              try {
                if (t4) {
                  n2.requestID = t4.id, n2.httpMethod = t4.method, n2.url = t4.url, n2.bodyLength = t4.body.length, n2.shortUrl = t4.shortUrl, n2.requestTimeStamp = t4.startTS, n2.correlationVector = t4.correlationVector;
                  for (var i2 = t4.headers, r2 = 0, s2 = Object.keys(i2); r2 < s2.length; r2++) {
                    var a2 = s2[r2];
                    i2.hasOwnProperty(a2) && (n2[a2] = i2[a2]);
                  }
                }
              } catch (t5) {
                n2.hasError = true, n2.error = n2.error + " error creating request context " + o.toJson(t5);
              }
              this.sendTelemetry(c.Request, n2, []);
            }, t3.prototype.trackResponse = function(t4, e2, n2, i2) {
              var r2 = {};
              void 0 !== i2 && (r2.hasError = true, r2.error = i2);
              try {
                if (r2.responseTimestamp = void 0 !== n2 ? n2.sentTS : Date.now(), t4) {
                  r2.requestID = t4.id, r2.httpMethod = t4.method, r2.shortUrl = t4.shortUrl, r2.correlationVector = t4.correlationVector;
                  for (var s2 = t4.headers, a2 = 0, h2 = Object.keys(s2); a2 < h2.length; a2++) {
                    var u2 = h2[a2];
                    s2.hasOwnProperty(u2) && (r2[u2] = s2[u2]);
                  }
                }
                n2 && (r2.latencyMS = e2, r2.responseCode = n2.status, r2.responseLength = n2.body.length);
              } catch (t5) {
                r2.hasError = true, r2.error = r2.error + " error creating response context " + o.toJson(t5);
              }
              this.sendTelemetry(c.Response, r2, []);
            }, t3.prototype.sendResponseError = function(t4, e2, n2) {
              this.trackResponse(e2, void 0, n2, t4);
            }, t3.prototype.close = function() {
              this.sendProgress({ reason: "closed" }), this.steps.length = 0, this.cancelProgressTimer();
            }, t3.prototype.mergeSettings = function(t4) {
              if (t4) {
                this.eventLogSettings.numberOfStepsToMaintain = Math.min(40, Math.max(10, void 0 !== t4.numberOfStepsToMaintain ? t4.numberOfStepsToMaintain : 0));
                var e2 = Math.min(3600, Math.max(55, void 0 !== t4.sendProgressTimeoutSecs ? t4.sendProgressTimeoutSecs : 0));
                this.eventLogSettings.logHealthCheckError = t4.logHealthCheckError, this.eventLogSettings.logSendPingError = t4.logSendPingError;
                for (var n2 = 0, o2 = Object.keys(c).map(function(t5) {
                  return c[t5];
                }); n2 < o2.length; n2++) {
                  var i2 = o2[n2];
                  t4.hasOwnProperty(i2) && void 0 !== t4[i2] && (this.eventLogSettings[i2] = t4[i2]);
                }
                this.eventLogSettings.sendProgressTimeoutSecs !== e2 && (this.eventLogSettings.sendProgressTimeoutSecs = e2, this.resetProgressSendTimer());
              }
            }, t3;
          }();
          e.ConnectionTracker = l;
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function() {
            function t3(t4, e2) {
              this.logger = t4, this.maxBackoffInMs = e2, this.backoffId = 0, this.backoffCount = 0;
            }
            return t3.calculateNextBackoffMs = function(t4, e2) {
              var n2 = 1 + 0.4 * (Math.random() - 0.5), o2 = 1e3 * Math.pow(2, t4) * n2;
              return o2 = Math.round(o2), Math.min(e2, o2);
            }, t3.prototype.setMaxBackoffMs = function(t4) {
              this.maxBackoffInMs = t4;
            }, t3.prototype.backoff = function(e2, n2) {
              var o2 = this;
              void 0 !== this.timerHandle && (this.logger.debug("Clearing current back off"), clearTimeout(this.timerHandle), this.timerHandle = void 0);
              var i = t3.calculateNextBackoffMs(this.backoffCount, this.maxBackoffInMs);
              this.backoffId++, this.backoffCount++, this.logger.info("Backing off " + e2 + " for " + i + " milliseconds with ID " + this.backoffId), this.timerHandle = setTimeout(function() {
                o2.logger.info("Back off for " + e2 + " with ID " + o2.backoffId + " complete, invoking handler"), o2.timerHandle = void 0, n2();
              }, i);
            }, t3.prototype.reset = function() {
              void 0 !== this.timerHandle && (this.logger.debug("Resetting back off"), clearTimeout(this.timerHandle), this.timerHandle = void 0), this.backoffCount = 0;
            }, t3;
          }();
          e.ExponentialBackoff = o;
        }, function(t2, e, n) {
          var o = this && this.__assign || Object.assign || function(t3) {
            for (var e2, n2 = 1, o2 = arguments.length; n2 < o2; n2++) {
              e2 = arguments[n2];
              for (var i2 in e2)
                Object.prototype.hasOwnProperty.call(e2, i2) && (t3[i2] = e2[i2]);
            }
            return t3;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = n(18), r = n(3), s = n(12), c = n(1), a = n(13), h = n(2), u = n(4), p = n(0), l = n(15), d = n(9), g = function() {
            function t3() {
              this.cv = c.CLIENT_VERSION, this.ua = "", this.hr = "", this.v = "";
            }
            return t3;
          }(), f = function() {
            function t3() {
              this["force new connection"] = true, this.reconnect = false, this.query = "", this.ackTimeoutMs = 5e3;
            }
            return t3;
          }(), m = "MS-CV", v = function() {
            function t3(t4) {
              this.cvCounter = 0;
              var e2 = JSON.parse(t4);
              this.startTS = e2.hasOwnProperty("startTS") ? e2.startTS : 0, this.url = e2.hasOwnProperty("url") ? e2.url : "", this.shortUrl = e2.hasOwnProperty("shortUrl") ? e2.shortUrl : "", this.body = e2.hasOwnProperty("body") ? e2.body : "", this.headers = e2.hasOwnProperty("headers") ? e2.headers : {}, this.id = e2.hasOwnProperty("id") && "number" == typeof e2.id ? e2.id : -1, this.method = e2.hasOwnProperty("method") ? e2.method : "", this.replied = false, this.timedout = false, this.timeoutTimerId = 0, this.receivedCv = this.headers[m], this.updateCvHeader();
            }
            return Object.defineProperty(t3.prototype, "correlationVector", { get: function() {
              return this.receivedCv ? this.receivedCv + "." + this.cvCounter : "";
            }, enumerable: true, configurable: true }), t3.prototype.on = function(t4, e2) {
              "data" === t4 ? this.dataCallback = e2 : "end" === t4 && ("function" == typeof this.dataCallback && this.dataCallback(this.body), e2());
            }, t3.prototype.incrementCorrelationVector = function() {
              ++this.cvCounter, this.updateCvHeader();
            }, t3.prototype.updateCvHeader = function() {
              var t4 = this.correlationVector;
              t4 && (this.headers[m] = t4);
            }, t3;
          }(), y = function() {
            function t3(t4, e2, n2) {
              this.request = t4, this.responseData = e2, this.sendResponse = n2;
            }
            return t3.prototype.writeHead = function(t4, e2) {
              this.responseData.status = t4, this.responseData.headers = e2;
            }, t3.prototype.write = function(t4) {
              this.responseData.body += t4;
            }, t3.prototype.end = function(t4) {
              return t4 && (this.responseData.body += t4), this.sendResponse(this.request, this.responseData);
            }, t3;
          }(), k = function() {
            function t3(t4) {
              this.name = t4, this.args = {}, this.timeoutTimerId = 0;
            }
            return t3;
          }(), T = function() {
            function t3(t4, e2, n2, o2, r2) {
              var h2 = this;
              this.options = e2, this.manager = n2, this.tokenProvider = o2, this.connectionId = "", this.inIncallMode = false, this.connectionAttempt = 0, this.connectedClientId = "", this.c2cUrlBase = "", this.allocationErrorsInRow = 0, this.pendingTimers = {}, this.lastDisconnectReason = "", this.UNKNOWN_TRANSPORT = "unknown_transport", this.logger = new p.Logger("Connection", t4), this.timeoutOptions = this.options.timeoutOptions, this.healthBackoff = new a.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs), this.tokenBackoff = new a.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs), this.clientID = Date.now(), "undefined" != typeof window && window.location && (this.domId = window.location.hostname), this.clientInfo = new g(), this.clientInfo.cv = c.CLIENT_VERSION, this.clientInfo.ua = "", this.options && this.options.clientInfo && (this.clientInfo.ua = this.safeString(this.options.clientInfo.ua), this.clientInfo.v = this.safeString(this.options.clientInfo.v)), this.connectionTracker = new s.ConnectionTracker(t4, this.clientID, this.clientInfo, function() {
                return h2.getServerState();
              }, this.options.endpointId, this.options.clientCorrelationID, this.options.environment), this.applyConnectionTrackerOptions(e2);
              var u2 = this.options.incallModeTimeoutMs > 0;
              if (this.fsm = new l.TrouterFsm(t4, this, u2), e2.registration) {
                var d2 = { registrarUrl: e2.registration.registrarUrl, registrationId: e2.registration.registrationId, requestTimeoutMs: e2.timeoutOptions.fetchTimeoutMs, initialRetryDelayMs: 1e3, maxRetryDelayMs: e2.timeoutOptions.maxBackoffMs };
                this.registrarClient = i.createRegistrarClient(t4, this.tokenProvider, d2);
              }
              this.userActivityState = r2;
            }
            return t3.prototype.start = function(t4) {
              this.logger.info("Starting"), this.externalConnectParams = t4, this.fsm.start();
            }, t3.prototype.stop = function(t4) {
              this.logger.info("Stopping"), this.connectionTracker.close(), this.fsm.stop(t4);
            }, t3.prototype.configure = function(t4) {
              var e2 = this.options.trouterUrl !== t4.trouterUrl;
              this.options = t4, this.applyConnectionTrackerOptions(t4), e2 && (this.logger.info("Configuration changed. Reconnection required."), this.fsm.onReconnectRequired(false));
            }, t3.prototype.checkConnection = function(t4) {
              this.logger.info("checkConnection called with " + t4), this.fsm.checkConnection(t4), t4 && this.connectionTracker.sendTelemetry(s.ClientEventName.CheckConnection, { disconnectDetected: t4 }, []);
            }, t3.prototype.disableRegistrationsAndAutoReconnect = function() {
              this.stopRegisterTimer(), this.resetRegisterBackoff(), this.fsm.disableAutoReconnect();
            }, t3.prototype.getServerState = function() {
              return new u.ServerState(this.connectionId, this.connectedClientId, this.domId ? this.domId : "", this.allocateResult ? this.allocateResult.url : "", this.allocateResult ? this.allocateResult.surl : "", this.c2cUrlBase, this.connectionExpireTimestampInSecs);
            }, t3.prototype.getToken = function(t4, e2) {
              var n2 = this;
              this.logger.info("Getting token " + (e2 ? "with backoff" : "without backoff"));
              var o2 = function() {
                n2.connectionTracker.trackStart("token"), n2.tokenProvider(!t4).then(function(t5) {
                  n2.logger.debug("token is received"), n2.connectionTracker.trackEnd("token"), n2.fsm.onTokenReceived(t5);
                }).catch(function(e3) {
                  var o3 = r.toJson(e3.stack);
                  n2.logger.error("Getting token failed, will retry after timeout. Error: " + o3), n2.connectionTracker.trackError("token", o3), n2.getToken(t4, true);
                });
              };
              e2 ? this.tokenBackoff.backoff("getting token", o2) : (this.tokenBackoff.reset(), o2());
            }, t3.prototype.startConnectionTimer = function() {
              var t4 = this;
              this.stopConnectionTimer(), this.logger.debug("Starting connection timeout for " + this.timeoutOptions.connectionTimeoutMs + " ms"), this.connectionTimeoutId = setTimeout(function() {
                t4.logger.info("Connection timeout is fired"), t4.fsm.onConnectingTimeout();
              }, this.timeoutOptions.connectionTimeoutMs);
            }, t3.prototype.stopConnectionTimer = function() {
              this.connectionTimeoutId && (this.logger.debug("Stopping connection timeout"), clearTimeout(this.connectionTimeoutId), this.connectionTimeoutId = void 0);
            }, t3.prototype.startPingTimer = function() {
              var t4 = this;
              "websocket" === this.transportTypeName ? (this.logger.debug("Starting ping timeout for " + this.timeoutOptions.pingTimeoutMs + " ms"), this.pingTimerId = setInterval(function() {
                t4.logger.info("Ping interval fired"), t4.fsm.onPingInterval();
              }, this.timeoutOptions.pingTimeoutMs)) : this.logger.debug("Not starting ping for transport " + this.transportTypeName);
            }, t3.prototype.stopPingTimer = function() {
              this.pingTimerId && (this.logger.debug("Stopping ping timeout"), this.clearPingResponseTimer(), clearInterval(this.pingTimerId), this.pingTimerId = void 0);
            }, t3.prototype.shouldSkipRegistration = function() {
              return void 0 === this.options.registration;
            }, t3.prototype.hasCustomRegisterTtl = function() {
              return this.options.registration && this.options.registration.registrarTtlSec;
            }, t3.prototype.startRegisterTimer = function() {
              var t4 = this;
              void 0 !== this.registrationTimerId && this.stopRegisterTimer();
              var e2 = this.getRegistrationTtl() - 30;
              this.logger.debug("Starting registration timeout for " + e2 + " sec"), this.registrationTimerId = setTimeout(function() {
                t4.logger.info("Registration timeout is fired"), t4.registrationTimerId = setTimeout(function() {
                  t4.registrationTimerId = void 0, t4.logger.debug("Re-registration did not happen in time"), t4.dispatchUnregistered();
                }, 3e4), t4.fsm.onRegistrationTimeout();
              }, 1e3 * e2);
            }, t3.prototype.stopRegisterTimer = function() {
              this.registrationTimerId && (this.logger.debug("Stopping registration timeout"), clearTimeout(this.registrationTimerId), this.registrationTimerId = void 0);
            }, t3.prototype.resendRegistration = function() {
              if (!this.registrarClient)
                throw new Error("Trouter Client not configured to handle registrations");
              return this.registrarClient.resendRegistration();
            }, t3.prototype.buildSocketIoUrlParams = function() {
              if (!this.allocateResult)
                throw new Error("Allocate result is undefined in buildSocketIoUrlParams()");
              for (var t4 = {}, e2 = this.allocateResult.connectparams, n2 = 0, o2 = Object.keys(e2); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                e2.hasOwnProperty(i2) && void 0 !== e2[i2] && (t4[i2] = e2[i2]);
              }
              return t4.v = "v4", t4.tc = encodeURI(r.toJson(this.clientInfo)), t4.timeout = this.timeoutOptions.pingTimeoutMs / 1e3, t4.auth = "true", this.options.endpointId && (t4.epid = this.options.endpointId), this.userActivityState.state !== h.UserActivityState.Unknown && (t4.userActivity = encodeURI(r.toJson(this.userActivityState.toEventObject()))), this.appendConnectedClientIds(this.buildQuery(t4), true);
            }, t3.prototype.startSocketIo = function() {
              var t4 = this;
              if (this.logger.info("Starting socket io"), this.connectionTracker.trackStart("connectSocket"), !this.allocateResult)
                throw new Error("Allocate result is undefined in startSocketIo()");
              var e2 = this.options.ioOptions || new f();
              if (e2["force new connection"] = true, e2.reconnect = false, e2.query = this.buildSocketIoUrlParams(), this.logger.info("connecting to " + this.allocateResult.socketio + "?" + e2.query), this.stopSocketIo(), this.socket = (this.options.io || d).connect(this.allocateResult.socketio, e2), void 0 === this.socket)
                throw new Error("Can't create Socket.io object");
              this.socket.on("connecting", function(e3) {
                t4.onSocketConnecting(e3);
              }), this.socket.on("connect", function() {
                t4.onSocketConnect();
              }), this.socket.on("connect_failed", function(e3) {
                t4.onSocketConnectFailed(e3);
              }), this.socket.on("disconnect", function(e3) {
                t4.onSocketDisconnect(e3);
              }), this.socket.on("reconnect", function() {
                t4.onSocketReconnect();
              }), this.socket.on("reconnect_failed", function(e3) {
                t4.onSocketReconnectFailed(e3);
              }), this.socket.on("reconnecting", function() {
                t4.onSocketReconnecting();
              }), this.socket.on("error", function(e3) {
                t4.onSocketError(e3);
              }), this.socket.on("message", function(e3) {
                t4.onSocketMessage(e3);
              }), this.socket.on("trouter.connected", function(e3) {
                t4.onTrouterConnected(e3);
              }), this.socket.on("trouter.reconnect", function(e3) {
                t4.onTrouterReconnect(e3);
              }), this.socket.on("trouter.message_loss", function(e3) {
                t4.onTrouterMessageLoss(e3);
              });
            }, t3.prototype.stopSocketIo = function() {
              if (this.socket) {
                this.logger.info("clearing socket.io");
                try {
                  for (var t4 = 0, e2 = ["connecting", "connect", "connect_failed", "disconnect", "reconnect", "reconnect_failed", "reconnecting", "error", "message", "trouter.connected", "trouter.reconnect", "trouter.message_loss"]; t4 < e2.length; t4++) {
                    var n2 = e2[t4];
                    this.socket.removeAllListeners(n2);
                  }
                  this.socket.disconnect(), this.logger.debug("cleared socket"), this.socket = void 0;
                } catch (t5) {
                  this.logger.error("exception in disconnecting previous socket. Error: " + r.toJson(t5.stack));
                }
              }
            }, t3.prototype.dispatchConnected = function() {
              this.logger.info("dispatching connected"), this.manager.onConnected(this);
            }, t3.prototype.dispatchRegistered = function() {
              this.logger.info("dispatching registered"), this.manager.onRegistered(this);
            }, t3.prototype.dispatchUnregistered = function() {
              this.logger.info("dispatching unregistered"), this.manager.onUnregistered(this);
            }, t3.prototype.dispatchDownstreamRequest = function(t4) {
              var e2 = this;
              this.logger.info("dispatching downstream request");
              try {
                var n2 = new y(t4, new s.ResponseData(t4.id), function(t5, n3) {
                  return e2.logger.info("sending response to downstream"), e2.sendResponse(t5, n3);
                });
                this.manager.onDownstreamRequest(this, t4, n2);
              } catch (t5) {
                this.logger.error("exception in socket.on message. Error : " + r.toJson(t5.stack));
              }
            }, t3.prototype.dispatchReconnecting = function() {
              this.logger.info("dispatching reconnecting"), this.manager.onReconnecting(this);
            }, t3.prototype.dispatchReconnectIsRequired = function(t4) {
              this.logger.info("dispatching reconnect is required by server"), this.manager.onReconnectIsRequired(this, t4);
            }, t3.prototype.dispatchDisconnected = function() {
              this.logger.info("dispatching disconnected"), this.manager.onDisconnected(this);
            }, t3.prototype.dispatchTrouterMessageLost = function(t4) {
              this.logger.info("dispatching trouter lost message"), this.manager.onTrouterMessageLost(t4);
            }, t3.prototype.sendProcessedDroppedIndicators = function(t4) {
              var e2 = this;
              try {
                this.logger.info("emitting processed flow tags to the server");
                var n2 = new k("trouter.processed_message_loss");
                n2.args = { droppedIndicators: t4 }, this.sendDownstreamEvent(n2, function() {
                  e2.logger.info("emitted processed flow tags to the server");
                });
              } catch (t5) {
                var o2 = r.toJson(t5.stack);
                this.logger.error("unable to send processed message loss event. Error: " + o2), this.connectionTracker.trackError("trouter.processed_message_loss", o2, false);
              }
            }, t3.prototype.resetAllocationConnectionParams = function() {
              this.allocateResult && (this.logger.info("Resetting allocation connection parameters"), this.allocateResult = void 0);
            }, t3.prototype.sendAllocateRequest = function(t4) {
              var e2 = this;
              this.connectionAttempt++, this.connectionTracker.trackNewConnection();
              var n2, i2 = this.options.trouterUrl, s2 = i2;
              if (this.allocateResult)
                s2 = this.getReconnectUrlFromAllocateResult(this.allocateResult), n2 = this.allocateResult.connectparams;
              else {
                var c2 = this.externalConnectParams;
                c2 && c2.se && parseInt(c2.se, 10) <= Date.now() + 36e5 && (this.logger.warn("Dropping expired cached connection parameters: " + new Date(parseInt(c2.se, 10))), this.externalConnectParams = c2 = void 0), c2 && c2.serviceUrl !== s2 && (this.logger.warn("Dropping cached connection parameters for a different environment (" + c2.serviceUrl + ", now " + s2 + ")"), this.externalConnectParams = c2 = void 0), c2 && c2.reconnectUrl ? (s2 = c2.reconnectUrl, n2 = o({}, c2, { reconnectUrl: void 0 })) : n2 = c2;
              }
              s2 = this.appendCorrelationIds(s2, false), s2 = this.appendEndpointId(s2, false), n2 && (s2 += "&" + this.buildQuery(n2), n2.v || (s2 += "&v=v4"));
              var a2 = new Request(s2, { method: "POST", mode: "cors", headers: new Headers({ "X-Skypetoken": t4, "Content-Type": "text/plain" }) });
              this.logger.info("sendAllocateRequest: POST " + s2), this.connectionTracker.trackStart("allocation");
              var h2 = -1;
              r.fetchWithTimeout(a2, this.timeoutOptions.fetchTimeoutMs).then(function(t5) {
                if (h2 = t5.status, !t5.ok)
                  throw new Error(t5.statusText);
                var n3 = t5.headers.get("content-type");
                if (!n3 || "application/json" !== n3 && "application/json;" !== n3.substring(0, 17))
                  throw new Error("Content-type '" + n3 + "' is unexpected");
                return e2.connectionTracker.trackEnd("allocation"), t5.json();
              }).then(function(t5) {
                e2.allocationErrorsInRow = 0, e2.onAllocationResponse(t5, i2);
              }).catch(function(t5) {
                e2.allocationErrorsInRow++;
                var n3 = t5 + ", status code " + h2;
                e2.logger.error(e2.allocationErrorsInRow + " failed allocation attempts in a row. Error: " + n3), e2.connectionTracker.trackError("allocation", n3), e2.allocationErrorsInRow >= 2 && e2.resetAllocationConnectionParams(), e2.externalConnectParams && e2.connectionAttempt > 2 && (h2 >= 400 && h2 <= 599 ? (e2.logger.warn(e2.connectionAttempt + " connection attempts, server-side failure: erasing external connection parameters"), e2.externalConnectParams = void 0) : e2.externalConnectParams.reconnectUrl && (e2.logger.warn(e2.connectionAttempt + " connection attempts, erasing reconnect URL"), delete e2.externalConnectParams.reconnectUrl)), e2.fsm.onAllocationFailed(401 === h2);
              });
            }, t3.prototype.sendPingRequest = function() {
              var t4 = this;
              if (this.socket && void 0 === this.pingResponseTimerId)
                try {
                  this.logger.info("emitting ping event"), this.socket.emit("ping", function() {
                    t4.onPingResponse();
                  }), this.pingResponseTimerId = setTimeout(function() {
                    t4.logger.error("Ping response timeout is fired"), t4.clearPingResponseTimer(), t4.fsm.onPingResponseTimeout();
                  }, this.timeoutOptions.pongTimeoutMs);
                } catch (t5) {
                  var e2 = r.toJson(t5.stack);
                  this.logger.error("unable to send ping. Error: " + e2), this.connectionTracker.trackError("ping", e2, false);
                }
            }, t3.prototype.setUserActivityState = function(t4) {
              var e2 = t4.state !== this.userActivityState.state;
              this.userActivityState = t4, this.fsm.onSetUserActivityState(t4, e2);
            }, t3.prototype.sendUserActivityState = function(t4, e2) {
              this.userActivityState.state !== h.UserActivityState.Unknown && ("websocket" === this.transportTypeName && e2 ? t4 === u.UserActivityEventReason.Connected ? this.sendUserActivityStateMultiple(2) : this.sendUserActivityStateMultiple(1) : "xhr-polling" === this.transportTypeName && t4 === u.UserActivityEventReason.Modified && this.fsm.forceReconnect());
            }, t3.prototype.sendRegisterRequest = function() {
              var t4 = this;
              if (!this.options.registration || !this.registrarClient)
                throw new Error("Internal error - options.registration is undefined");
              if (!this.allocateResult)
                throw new Error("Allocate result is undefined in sendRegisterRequest()");
              this.logger.info("sending register request");
              var e2 = new r.Timespan();
              this.connectionTracker.trackStart("registration"), this.registrarClient.register({ appId: this.options.registration.pnhAppId, aesKey: "", languageId: "en-US", platform: this.options.registration.platform, templateKey: this.options.registration.pnhTemplateKey, platformUIVersion: this.options.registration.platformUIVersion, productContext: this.options.registration.productContext }, { TROUTER: [{ context: this.options.registration.context, path: this.allocateResult.surl, ttl: this.getRegistrationTtl() }] }).then(function() {
                t4.logger.info("Register request successful"), t4.connectionTracker.trackEnd("registration"), t4.fsm.onRegistrationSucceed(), t4.connectionTracker.sendTelemetry(s.ClientEventName.Registration, { duration: e2.duration }, []);
              }).catch(function(n2) {
                t4.logger.error("Register request failed. Error: " + n2), t4.connectionTracker.trackError("registration", n2.message), t4.fsm.onRegistrationFailed(false), t4.connectionTracker.sendTelemetry(s.ClientEventName.Registration, { duration: e2.duration }, []);
              });
            }, t3.prototype.sendUnregisterRequest = function() {
              var t4 = this;
              this.logger.info("sending unregister request");
              var e2 = new r.Timespan();
              if (!this.options.registration || !this.registrarClient)
                throw new Error("Internal error - options.registration is undefined");
              this.connectionTracker.trackStart("unregistration"), this.registrarClient.unregister().then(function() {
                t4.logger.info("Unregister request successful"), t4.connectionTracker.trackEnd("unregistration"), t4.fsm.onUnregistrationSucceed(), t4.connectionTracker.sendTelemetry(s.ClientEventName.Unregistration, { duration: e2.duration }, []);
              }).catch(function(n2) {
                t4.logger.error("Unregister request failed. Error: " + n2), t4.connectionTracker.trackError("unregistration", n2.message), t4.fsm.onUnregistrationFailed(false), t4.connectionTracker.sendTelemetry(s.ClientEventName.Unregistration, { duration: e2.duration }, []);
              });
            }, t3.prototype.resetTokenBackoff = function() {
              this.tokenBackoff.reset();
            }, t3.prototype.resetRegisterBackoff = function() {
              this.registrarClient && this.registrarClient.cancelPendingRequests();
            }, t3.prototype.clearTimers = function() {
              this.logger.debug("Clearing all pending downstream events related timers");
              for (var t4 = 0, e2 = Object.keys(this.pendingTimers); t4 < e2.length; t4++) {
                var n2 = e2[t4];
                this.clearTimer(Number(n2));
              }
            }, t3.prototype.restartIncallModeTimer = function() {
              var t4 = this;
              this.clearIncallModeTimerId(), this.logger.debug("Restarting incall mode timer"), this.incallModeTimerId = setTimeout(function() {
                t4.logger.info("Call mode timer fired"), t4.fsm.onIncallModeTimer();
              }, this.options.incallModeTimeoutMs);
            }, t3.prototype.enterIncallMode = function() {
              this.logger.info("Entering incall mode"), this.timeoutOptions = this.options.incallTimeoutOptions, this.healthBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = true;
            }, t3.prototype.exitIncallMode = function() {
              this.logger.info("Exiting incall mode"), this.clearIncallModeTimerId(), this.timeoutOptions = this.options.timeoutOptions, this.healthBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = false;
            }, t3.prototype.isIncallMode = function() {
              return this.inIncallMode;
            }, t3.prototype.onSocketConnecting = function(t4) {
              this.logger.info("onSocketConnecting(" + t4 + ")"), this.transportTypeName = t4, this.connectionTracker.trackProgress("connecting", this.transportTypeName), this.fsm.onConnecting();
            }, t3.prototype.onSocketConnect = function() {
              this.logger.info("onSocketConnect");
            }, t3.prototype.onSocketConnectFailed = function(t4) {
              this.logger.error("onSocketConnectFailed"), this.connectionTracker.trackError("connect_failed", t4, true, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), this.fsm.onConnectingFailed();
            }, t3.prototype.onSocketDisconnect = function(t4) {
              this.logger.error("onSocketDisconnect, reason: " + t4);
              var e2 = { reason: t4, serverClosed: !this.fsm.isActive() };
              this.connectionTracker.trackDisconnected(e2), this.connectionTracker.clearConnectedInfo();
              var n2 = e2.sessionLengthMS || 0;
              "dup" === t4 && "dup" === this.lastDisconnectReason && n2 < this.options.duplicateDisconnectThresholdMs && (this.logger.warn("Socket was closed by server as Duplicate for the second time in a row after " + n2 + " ms which is below the threshold of " + this.options.duplicateDisconnectThresholdMs + " ms. Resetting cached connection parameters and making a new allocation."), this.resetAllocationConnectionParams()), this.lastDisconnectReason = t4, this.fsm.onSocketError(void 0), this.connectionExpireTimestampInSecs = void 0;
            }, t3.prototype.onSocketReconnect = function() {
              this.logger.error("onSocketReconnect"), this.fsm.onTrouterConnected();
            }, t3.prototype.onSocketReconnectFailed = function(t4) {
              this.logger.error("onSocketReconnectFailed with '" + t4 + "'"), this.fsm.onSocketError("string" == typeof t4 ? t4 : void 0);
            }, t3.prototype.onSocketReconnecting = function() {
              this.logger.error("onSocketReconnecting");
            }, t3.prototype.onSocketError = function(t4) {
              this.logger.error("onSocketError with '" + r.toJson(t4) + "'"), this.connectionTracker.trackError("connectSocket", t4), this.fsm.onSocketError("string" == typeof t4 ? t4 : void 0);
            }, t3.prototype.onSocketMessage = function(t4) {
              var e2 = this;
              this.logger.info("onSocketMessage");
              var n2;
              try {
                n2 = new v(t4);
                var o2 = n2.headers && n2.headers["X-Microsoft-Skype-Chain-ID"], i2 = o2 ? " Chain-Id " + o2 : "";
                this.logger.info("Received request N " + n2.id + i2 + " CV " + n2.correlationVector + " to '" + n2.url + "'"), n2.startTS = Date.now(), n2.url && this.urlPath && 0 === n2.url.indexOf(this.urlPath) && (n2.shortUrl = n2.url.substring(this.urlPath.length));
              } catch (t5) {
                var c2 = r.toJson(t5.stack);
                return this.logger.error("unable to parse request. Error: " + c2), this.connectionTracker.trackRequest(void 0, c2), void this.connectionTracker.sendResponseError("unable to parse request, error: " + t5);
              }
              n2.timeoutTimerId = setTimeout(function() {
                if (!n2.replied) {
                  e2.logger.error("Request " + n2.id + " timed out");
                  var t5 = new s.ResponseData(n2.id);
                  t5.status = 504, t5.headers = { "Trouter-Responder": "ClientLib" }, e2.sendResponse(n2, t5), n2.timedout = true;
                }
              }, this.timeoutOptions.requestTimeoutMs);
              try {
                this.connectionTracker.trackRequest(n2), this.fsm.onDownstreamRequest(n2);
              } catch (t5) {
                this.logger.error("exception in socket.on message. Error: " + r.toJson(t5.stack)), this.connectionTracker.sendResponseError(t5.message, n2, void 0);
              }
            }, t3.prototype.onTrouterConnected = function(t4) {
              if (!this.allocateResult)
                return void this.logger.error("Invalid internal state - received onTrouterConnected while allocateResult is not set");
              this.logger.info("onTrouterConnected: " + this.allocateResult.url), this.socket && this.socket.socket && this.socket.socket.options && this.socket.socket.options.query && (this.socket.socket.options.query += "&connected=true"), this.urlPath = this.allocateResult.url.replace(/https?:\/\/([A-z0-9\:\$\-\_\.\+\!\*\"\(\)\,]*)\//, "/");
              var e2 = this.connectedUrl !== this.allocateResult.url;
              this.connectedUrl = this.allocateResult.url, this.connectionExpireTimestampInSecs = r.calculateExpireTsInSec(t4.ttl), this.connectionTracker.trackEnd("connectSocket"), this.connectionTracker.trackConnected(e2, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), this.fsm.onTrouterConnected();
            }, t3.prototype.onTrouterReconnect = function(t4) {
              var e2 = t4.target;
              this.logger.info("onTrouterReconnect target: " + e2), "self" === e2 ? this.fsm.onReconnectRequired(true) : this.fsm.onReconnectRequired(false);
            }, t3.prototype.onTrouterMessageLoss = function(t4) {
              this.logger.info("onTrouterMessageLoss"), this.fsm.onTrouterMessageLost(t4.droppedIndicators);
            }, t3.prototype.getReconnectUrlFromAllocateResult = function(t4) {
              return t4.socketio + "v4/a";
            }, t3.prototype.onAllocationResponse = function(t4, e2) {
              this.logger.info("Received allocation response " + JSON.stringify(t4)), this.allocateResult = t4, this.externalConnectParams = void 0;
              var n2 = +t4.ttl;
              if (this.connectionExpireTimestampInSecs = r.calculateExpireTsInSec(n2), this.connectionId = this.allocateResult.id || "", this.connectedClientId = this.allocateResult.ccid, this.logger.info("connected client id set {connectedClientId:" + this.connectedClientId + "}"), this.c2cUrlBase = t4.curlb || "", "" === this.c2cUrlBase) {
                var i2 = t4.surl.indexOf("://");
                i2 >= 0 && (i2 = t4.surl.indexOf("/", i2 + 3)) >= 5 && ":3443" === t4.surl.substr(i2 - 5, 5) && (this.c2cUrlBase = t4.surl.substr(0, i2 - 5));
              }
              var s2 = o({ serviceUrl: e2, reconnectUrl: this.getReconnectUrlFromAllocateResult(this.allocateResult) }, t4.connectparams);
              this.manager.onConnectionParametersUpdated(s2), this.fsm.onAllocationSucceed();
            }, t3.prototype.onPingResponse = function() {
              this.logger.info("onPingResponse"), this.connectionTracker.increasePingResponseCount(), this.clearPingResponseTimer(), this.fsm.onPingResponse();
            }, t3.prototype.clearPingResponseTimer = function() {
              void 0 !== this.pingResponseTimerId && (clearTimeout(this.pingResponseTimerId), this.pingResponseTimerId = void 0);
            }, t3.prototype.buildQuery = function(t4) {
              for (var e2 = [], n2 = 0, o2 = Object.keys(t4); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                t4.hasOwnProperty(i2) && void 0 !== t4[i2] && e2.push(i2 + "=" + t4[i2]);
              }
              return e2.join("&");
            }, t3.prototype.appendConnectedClientIds = function(t4, e2) {
              var n2 = "";
              t4.indexOf("ccid=") < 0 && (n2 = "ccid=" + this.connectedClientId + "&"), this.domId && (n2 += "dom=" + this.domId + "&"), n2.length > 0 && (n2 = n2.slice(0, -1));
              var o2 = e2 || -1 !== t4.indexOf("?") ? "&" : "?";
              return this.appendCorrelationIds(t4 + o2 + n2, e2);
            }, t3.prototype.appendEndpointId = function(t4, e2) {
              var n2 = e2 || -1 !== t4.indexOf("?") ? "&" : "?";
              return t4.indexOf("epid") < 0 && this.options.endpointId ? "" + t4 + n2 + "epid=" + this.options.endpointId : t4;
            }, t3.prototype.appendCorrelationIds = function(t4, e2) {
              var n2 = e2 || -1 !== t4.indexOf("?") ? "&" : "?";
              return t4.indexOf("cor_id") < 0 ? "" + t4 + n2 + "cor_id=" + this.options.clientCorrelationID + "&con_num=" + this.clientID + "_" + this.connectionAttempt : t4;
            }, t3.prototype.getHealthUrl = function(t4) {
              return t4.substring(0, t4.lastIndexOf("/a")) + "/h";
            }, t3.prototype.safeString = function(t4) {
              return "string" == typeof t4 ? t4 : "";
            }, t3.prototype.sendResponse = function(t4, e2) {
              if (t4.timedout)
                return this.logger.error("Request " + t4.id + " already timed out"), 1;
              if (t4.replied)
                return this.logger.error("Response for request " + t4.id + " already sent"), 2;
              clearTimeout(t4.timeoutTimerId), t4.timeoutTimerId = 0, t4.replied = true, e2.headers = e2.headers || {};
              var n2 = t4.correlationVector;
              this.logger.info("Sending response for request N " + t4.id + " CV " + n2 + " with status " + e2.status), n2 && (e2.headers[m] = n2), t4.headers && t4.headers["trouter-request"] && !e2.headers["trouter-request"] && (e2.headers["trouter-request"] = t4.headers["trouter-request"]);
              var o2 = Date.now() - t4.startTS;
              if (e2.headers["trouter-client"] = r.toJson({ cd: o2 }), this.logger.debug("response: " + r.toJson(e2)), !this.socket)
                return this.connectionTracker.sendResponseError("no socket", t4, e2), 4;
              try {
                return this.socket.send(r.toJson(e2)), e2.sentTS = Date.now(), t4.incrementCorrelationVector(), this.connectionTracker.trackResponse(t4, o2, e2), "websocket" === this.transportTypeName && this.sendPingRequest(), 0;
              } catch (n3) {
                var i2 = "unable to send data on response.end. Error: " + r.toJson(n3.stack);
                return this.logger.error(i2), this.connectionTracker.sendResponseError(i2, t4, e2), 4;
              }
            }, t3.prototype.sendUserActivityStateMultiple = function(t4) {
              var e2 = this, n2 = new k("user.activity"), o2 = this.userActivityState.toEventObject();
              n2.args = o2, this.userActivityState.correlationVector.increase(), this.logger.debug("Sending user activity '" + this.userActivityState.toEventJSON() + "', remaining " + (t4 - 1)), this.sendDownstreamEvent(n2, function() {
                if (e2.logger.info("User activity state: " + o2.state + ", cv: " + o2.cv + " accepted"), e2.manager.onUserActivityStateAccepted && e2.manager.onUserActivityStateAccepted(o2.cv), e2.clearTimer(n2.timeoutTimerId), t4 > 1) {
                  var i2 = setTimeout(function() {
                    e2.clearTimer(i2), e2.sendUserActivityStateMultiple(t4 - 1);
                  }, e2.options.userActivitySecondResendDelayMs);
                  e2.registerTimer(i2, "user.activity/resend");
                }
              }), n2.timeoutTimerId = setTimeout(function() {
                e2.logger.error("Activity state response timeout is fired"), e2.fsm.onActivityStateResponseTimeout(), e2.clearTimer(n2.timeoutTimerId);
              }, this.timeoutOptions.userActivityResponseTimeoutMs), this.registerTimer(n2.timeoutTimerId, "user.activity/response");
            }, t3.prototype.sendDownstreamEvent = function(t4, e2) {
              this.logger.info("Sending downstream event " + t4.name), this.socket && this.socket.emit(t4.name, t4.args, e2);
            }, t3.prototype.registerTimer = function(t4, e2) {
              this.logger.debug("registering timer " + t4 + " -> " + e2), this.pendingTimers[t4] = e2;
            }, t3.prototype.clearTimer = function(t4) {
              var e2 = this.pendingTimers[t4];
              this.logger.debug("clearing timer " + t4 + " -> " + e2), delete this.pendingTimers[t4], clearTimeout(t4);
            }, t3.prototype.getRegistrationTtl = function() {
              var t4 = r.calculateTtlInSec(this.connectionExpireTimestampInSecs);
              return this.logger.debug("Current connectionID will expire in " + t4 + " seconds"), this.options.registration && this.options.registration.registrarTtlSec && t4 > 0 ? Math.min(this.options.registration.registrarTtlSec, t4) : this.options.registration && this.options.registration.registrarTtlSec ? this.options.registration.registrarTtlSec : t4 > 0 ? t4 : 3600;
            }, t3.prototype.clearIncallModeTimerId = function() {
              void 0 !== this.incallModeTimerId && (this.logger.debug("Clearing in-call mode timer"), clearTimeout(this.incallModeTimerId), this.incallModeTimerId = void 0);
            }, t3.prototype.applyConnectionTrackerOptions = function(t4) {
              try {
                t4.eventLogger && "function" == typeof t4.eventLogger.logEvent ? (this.connectionTracker.mergeSettings(t4.telemetrySettings), this.connectionTracker.enable(t4.eventLogger)) : this.logger.warn("Trouter client event logging disabled due to invalid configuration.");
              } catch (t5) {
                this.logger.warn("Trouter client event logging disabled. Error: " + r.toJson(t5.stack)), this.connectionTracker.disable();
              }
            }, t3;
          }();
          e.TrouterConnection = T;
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o, i = n(4), r = n(0);
          !function(t3) {
            t3[t3.Initial = 0] = "Initial", t3[t3.RetrievingToken = 1] = "RetrievingToken", t3[t3.Allocating = 2] = "Allocating", t3[t3.Handshaking = 3] = "Handshaking", t3[t3.Connecting = 4] = "Connecting", t3[t3.Connected = 5] = "Connected", t3[t3.UnregisteringRetrievingToken = 6] = "UnregisteringRetrievingToken", t3[t3.Unregistering = 7] = "Unregistering";
          }(o = e.State || (e.State = {}));
          var s;
          !function(t3) {
            t3[t3.Initial = 0] = "Initial", t3[t3.RetrievingToken = 1] = "RetrievingToken", t3[t3.Registering = 2] = "Registering", t3[t3.Registered = 3] = "Registered", t3[t3.NotRegistered = 4] = "NotRegistered";
          }(s || (s = {}));
          var c = function() {
            function t3(t4, e2, n2) {
              this.worker = e2, this.incallModeEnabled = n2, this.state = o.Initial, this.connectionErrors = 0, this.autoReconnect = true, this.logger = new r.Logger("ConnectionFsm", t4), this.connectedSubstate = s.Initial;
            }
            return t3.prototype.getState = function() {
              return this.state;
            }, t3.prototype.isActive = function() {
              return this.state === o.Allocating || this.state === o.Connected || this.state === o.Handshaking || this.state === o.Connecting || this.state === o.RetrievingToken;
            }, t3.prototype.start = function() {
              return this.state === o.Initial ? (this.setState(o.RetrievingToken), this.worker.getToken(true, false), true) : (this.showIgnored("start"), false);
            }, t3.prototype.stop = function(t4) {
              t4 && (this.connectedSubstate = s.Initial), this.worker.isIncallMode() && this.worker.exitIncallMode(), this.worker.resetTokenBackoff(), this.worker.resetRegisterBackoff(), this.worker.stopConnectionTimer(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopRegisterTimer(), this.state !== o.Connecting && this.state !== o.Handshaking && this.state !== o.Connected || this.worker.stopSocketIo(), this.isRegistered() && this.state !== o.UnregisteringRetrievingToken && this.state !== o.Unregistering ? (this.setState(o.UnregisteringRetrievingToken), this.worker.getToken(true, false)) : (this.setState(o.Initial), this.worker.dispatchDisconnected());
            }, t3.prototype.onTokenReceived = function(t4) {
              this.state === o.RetrievingToken ? (this.setState(o.Allocating), this.worker.startConnectionTimer(), this.worker.sendAllocateRequest(t4)) : this.state === o.Connected && this.connectedSubstate === s.RetrievingToken ? (this.connectedSubstate = s.Registering, this.worker.sendRegisterRequest()) : this.state === o.UnregisteringRetrievingToken ? (this.setState(o.Unregistering), this.worker.sendUnregisterRequest()) : this.showIgnored("onTokenReceived");
            }, t3.prototype.checkConnection = function(t4) {
              t4 && this.onPingInterval();
            }, t3.prototype.onAllocationSucceed = function() {
              return this.state === o.Allocating ? (this.setState(o.Handshaking), this.connectedSubstate === s.Registered && this.worker.dispatchUnregistered(), this.connectedSubstate = s.Initial, this.worker.startSocketIo(), true) : (this.showIgnored("onAllocationSucceed"), false);
            }, t3.prototype.onAllocationFailed = function(t4) {
              this.state === o.Allocating ? (this.setState(o.RetrievingToken), this.worker.stopConnectionTimer(), this.worker.getToken(!t4, true)) : this.showIgnored("onAllocationFailed");
            }, t3.prototype.onConnectingTimeout = function() {
              this.state === o.Allocating || this.state === o.Connecting || this.state === o.Handshaking ? (this.setState(o.RetrievingToken), this.resetAllocationIfNecessary(void 0), this.worker.stopSocketIo(), this.worker.getToken(true, false)) : this.showIgnored("onConnectingTimeout");
            }, t3.prototype.onConnecting = function() {
              this.state === o.Handshaking ? this.setState(o.Connecting) : this.showIgnored("onConnecting");
            }, t3.prototype.onConnectingFailed = function() {
              this.state === o.Connecting ? this.onConnectingTimeout() : this.state === o.Handshaking ? (this.logger.error("Unexpected error in Socket.io - no valid transports"), this.onConnectingTimeout()) : this.showIgnored("onConnectingFailed");
            }, t3.prototype.onSocketError = function(t4) {
              this.state === o.Handshaking || this.state === o.Connected ? (this.worker.stopSocketIo(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopConnectionTimer(), this.state !== o.Connected && this.worker.resetAllocationConnectionParams(), this.autoReconnect ? (this.setState(o.RetrievingToken), this.worker.resetRegisterBackoff(), this.worker.dispatchReconnecting(), this.worker.getToken(true, false)) : (this.logger.debug("Socket error/disconnect occurred and automatic reconnect is disabled. Connection will stop."), this.stop(true))) : this.showIgnored("onSocketError");
            }, t3.prototype.onTrouterConnected = function() {
              this.state === o.Connecting ? (this.setState(o.Connected), this.worker.resetTokenBackoff(), this.worker.stopConnectionTimer(), this.worker.sendUserActivityState(i.UserActivityEventReason.Connected, true), this.worker.startPingTimer(), this.worker.dispatchConnected(), this.connectionErrors = 0, this.worker.shouldSkipRegistration() ? (this.connectedSubstate = s.NotRegistered, this.worker.dispatchRegistered()) : (this.connectedSubstate = s.RetrievingToken, this.worker.getToken(true, false))) : this.showIgnored("onTrouterConnected");
            }, t3.prototype.onReconnectRequired = function(t4) {
              this.worker.dispatchReconnectIsRequired(t4);
            }, t3.prototype.disableAutoReconnect = function() {
              this.autoReconnect = false;
            }, t3.prototype.onDownstreamRequest = function(t4) {
              this.state === o.Connected ? (this.switchToIncallModeIfEnabled(), this.worker.dispatchDownstreamRequest(t4)) : this.showIgnored("onDownstreamRequest");
            }, t3.prototype.onTrouterMessageLost = function(t4) {
              this.state === o.Connected ? this.worker.dispatchTrouterMessageLost(t4) : this.showIgnored("onTrouterMessageLost");
            }, t3.prototype.onPingInterval = function() {
              this.state === o.Connected ? this.worker.sendPingRequest() : this.showIgnored("onPingInterval");
            }, t3.prototype.onPingResponseTimeout = function() {
              this.onMissedResponse("onPingResponseTimeout");
            }, t3.prototype.onPingResponse = function() {
              this.state === o.Connected || this.showIgnored("onPingResponse");
            }, t3.prototype.onRegistrationFailed = function(t4) {
              this.state === o.Connected && this.connectedSubstate === s.Registering ? (this.connectedSubstate = s.RetrievingToken, this.worker.getToken(!t4, true)) : this.showIgnored("onRegistrationFailed");
            }, t3.prototype.onRegistrationSucceed = function() {
              this.state === o.Connected ? (this.connectedSubstate === s.Registering && (this.connectedSubstate = s.Registered, this.worker.dispatchRegistered()), this.worker.hasCustomRegisterTtl() && this.worker.startRegisterTimer()) : this.showIgnored("onRegistrationSucceed");
            }, t3.prototype.onRegistrationTimeout = function() {
              this.state === o.Connected && this.connectedSubstate !== s.NotRegistered ? (this.connectedSubstate = s.RetrievingToken, this.worker.getToken(true, false)) : this.showIgnored("onRegistrationTimeout");
            }, t3.prototype.onUnregistrationFailed = function(t4) {
              this.state === o.Unregistering ? (this.setState(o.UnregisteringRetrievingToken), this.worker.getToken(!t4, !t4)) : this.showIgnored("onUnregistrationFailed");
            }, t3.prototype.onUnregistrationSucceed = function() {
              this.state === o.Unregistering ? (this.setState(o.Initial), this.worker.dispatchUnregistered(), this.worker.dispatchDisconnected()) : this.showIgnored("onUnregistrationSucceed");
            }, t3.prototype.onIncallModeTimer = function() {
              this.worker.exitIncallMode(), this.state === o.Connected ? (this.worker.stopPingTimer(), this.worker.startPingTimer()) : this.showIgnored("onIncallModeTimer");
            }, t3.prototype.onSetUserActivityState = function(t4, e2) {
              e2 ? (this.logger.info("Changing user activity state to '" + t4.toEventJSON() + "'"), this.worker.sendUserActivityState(i.UserActivityEventReason.Modified, this.state === o.Connected)) : this.logger.debug("Not changing the same user activity state '" + t4.toEventJSON() + "'");
            }, t3.prototype.onActivityStateResponseTimeout = function() {
              this.onMissedResponse("onActivityStateResponseTimeout");
            }, t3.prototype.forceReconnect = function() {
              this.setState(o.RetrievingToken), this.worker.resetTokenBackoff(), this.worker.stopConnectionTimer(), this.worker.resetRegisterBackoff(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopSocketIo(), this.worker.dispatchReconnecting(), this.worker.getToken(true, false);
            }, t3.prototype.onMissedResponse = function(t4) {
              this.state === o.Connected ? (this.setState(o.RetrievingToken), this.worker.resetRegisterBackoff(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopSocketIo(), this.worker.dispatchReconnecting(), this.worker.getToken(true, false)) : this.showIgnored(t4);
            }, t3.prototype.showIgnored = function(t4) {
              this.logger.debug("Ignoring event '" + t4 + "' in state '" + o[this.state] + "'");
            }, t3.prototype.setState = function(t4) {
              if (this.logger.info("Switching from state '" + o[this.state] + "' to state '" + o[t4] + "'"), this.state === t4)
                return void this.logger.error("Attempt to switching into the current state '" + o[t4] + "'");
              this.state = t4;
            }, t3.prototype.resetAllocationIfNecessary = function(t4) {
              this.connectionErrors++, this.connectionErrors >= 2 || void 0 !== t4 && /^4\d\d /.test(t4) ? (this.logger.error("Connection error count is " + this.connectionErrors + " - will reset allocation"), this.connectionErrors = 0) : this.logger.info("Connection error count is " + this.connectionErrors + " - will NOT reset allocation");
            }, t3.prototype.isRegistered = function() {
              return this.connectedSubstate === s.Registered || this.connectedSubstate === s.Registering;
            }, t3.prototype.switchToIncallModeIfEnabled = function() {
              this.incallModeEnabled && (this.worker.isIncallMode() || (this.worker.enterIncallMode(), this.worker.stopPingTimer(), this.worker.startPingTimer()), this.worker.restartIncallModeTimer());
            }, t3;
          }();
          e.TrouterFsm = c;
        }, function(t2, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(2), i = n(0), r = function() {
            function t3(t4, e2) {
              this.worker = e2, this.state = o.TrouterState.Unknown, this.logger = new i.Logger("ManagerFsm", t4);
            }
            return t3.prototype.start = function() {
              this.state === o.TrouterState.Unknown ? (this.setState(o.TrouterState.Disconnected), this.worker.forceStopLingeringConnection(), this.worker.startFirstConnection()) : this.showIgnored("start");
            }, t3.prototype.stop = function(t4) {
              this.state !== o.TrouterState.Unknown ? (this.setState(o.TrouterState.Unknown), this.worker.stopFirstConnection(true === t4), this.worker.stopSecondConnection(true === t4)) : this.showIgnored("stop");
            }, t3.prototype.getState = function() {
              return this.state;
            }, t3.prototype.onConnected = function(t4) {
              this.state === o.TrouterState.Disconnected && t4 ? this.worker.doesSecondConnectionExist() ? this.setState(o.TrouterState.Switching) : (this.setState(o.TrouterState.Connected), this.worker.dispatchConnected()) : this.showIgnored("onConnected(" + t4 + ")");
            }, t3.prototype.onRegistered = function(t4) {
              this.state !== o.TrouterState.Disconnected || t4 ? this.state !== o.TrouterState.Switching || t4 || (this.setState(o.TrouterState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnectionDelayed(), this.worker.dispatchConnected()) : (this.setState(o.TrouterState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnection(true), this.worker.dispatchConnected()), this.worker.dispatchRegistrationState(true);
            }, t3.prototype.onUnregistered = function(t4) {
              t4 && this.worker.dispatchRegistrationState(false);
            }, t3.prototype.onReconnecting = function(t4) {
              this.state === o.TrouterState.Connected && t4 ? (this.setState(o.TrouterState.Disconnected), this.worker.dispatchReconnecting()) : this.state === o.TrouterState.Switching && t4 ? (this.setState(o.TrouterState.Disconnected), this.worker.dispatchReconnecting()) : this.showIgnored("onReconnecting(" + t4 + ")");
            }, t3.prototype.onReconnectionRequired = function(t4, e2) {
              this.state === o.TrouterState.Connected && t4 ? (this.setState(o.TrouterState.Switching), this.worker.startSecondConnection(e2)) : this.state === o.TrouterState.Disconnected && t4 ? this.worker.startSecondConnection(e2) : this.showIgnored("onReconnectionRequired(" + t4 + ")");
            }, t3.prototype.onDisconnected = function(t4) {
              this.state === o.TrouterState.Unknown && t4 ? this.worker.dispatchStopped() : this.showIgnored("onDisconnected(" + t4 + ")");
            }, t3.prototype.showIgnored = function(t4) {
              this.logger.info("Ignoring event '" + t4 + "' in state '" + o.TrouterState[this.state] + "'");
            }, t3.prototype.setState = function(t4) {
              if (this.logger.info("Switching from state '" + o.TrouterState[this.state] + "' to state '" + o.TrouterState[t4] + "'"), this.state === t4)
                return void this.logger.error("Attempt to switching into the current state '" + o.TrouterState[t4] + "'");
              this.state = t4;
            }, t3;
          }();
          e.TrouterManagerFsm = r;
        }, function(t2, e, n) {
          function o(t3, e2) {
            if (!e2)
              return t3;
            var n2 = a({}, t3, { enabled: e2.TelemetryEnabled });
            return void 0 !== e2.ClientTelemetryEventEnabled && (n2 = a({}, n2, e2.ClientTelemetryEventEnabled)), n2;
          }
          function i(t3, e2) {
            return { clientInfo: { ua: t3.trouterSettings.productName, v: t3.trouterSettings.version }, ioOptions: { ackTimeoutMs: 5e3 }, clientCorrelationID: t3.trouterSettings.sessionId, environment: t3.trouterSettings.environment, telemetrySettings: o(t3.telemetryConfig.settings, e2), eventLogger: t3.telemetryConfig.eventLogger, endpointId: t3.trouterSettings.registrationId, trouterUrl: e2 && e2.TrouterConnectionUrl || t3.trouterSettings.trouterServiceUrl, registration: t3.trouterSettings.registrarServiceUrl ? { registrarUrl: t3.trouterSettings.registrarServiceUrl, registrationId: t3.trouterSettings.registrationId || "", pnhAppId: t3.trouterSettings.pnhAppId || "", platform: t3.trouterSettings.platform || "", pnhTemplateKey: t3.trouterSettings.pnhTemplate || "", platformUIVersion: t3.trouterSettings.platformUIVersion || "", productContext: t3.trouterSettings.pnhProductContext || void 0, context: t3.trouterSettings.pnhContext || "", registrarTtlSec: (t3.trouterSettings.maxRegistrationTimeInMs || 0) / 1e3 } : void 0, timeoutOptions: a({ connectionTimeoutMs: t3.trouterSettings.trouterConnectTimeoutInMs || 3e4, fetchTimeoutMs: 1e4, pingTimeoutMs: 4e4, pongTimeoutMs: 5e3, maxBackoffMs: 3e4, requestTimeoutMs: 5e3, userActivityResponseTimeoutMs: 1e4 }, t3.trouterSettings.timeoutOptions), incallTimeoutOptions: a({ connectionTimeoutMs: 1e4, fetchTimeoutMs: 5e3, pingTimeoutMs: 5e3, pongTimeoutMs: 2e3, maxBackoffMs: 1e4, requestTimeoutMs: 5e3, userActivityResponseTimeoutMs: 1e4 }, t3.trouterSettings.incallTimeoutOptions), incallModeTimeoutMs: t3.trouterSettings.incallModeTimeoutMs || 0, lingeringConnectionDelayMs: 6e4, userActivitySecondResendDelayMs: t3.trouterSettings.userActivitySecondResendDelayMs || 1e4, duplicateDisconnectThresholdMs: 1e4, connectionCache: t3.connectionCache, registrationStateCallback: t3.registrationStateCallbackForAcsDoNotUse };
          }
          function r(t3) {
            return new y(t3);
          }
          function s() {
            return p.CLIENT_VERSION;
          }
          function c(t3, e2) {
            var n2 = t3.indexOf("://");
            if (n2 >= 0) {
              var o2 = t3.indexOf("/", n2 + 3);
              if (o2 >= 0)
                return e2 + t3.substr(o2);
            }
            return "";
          }
          var a = this && this.__assign || Object.assign || function(t3) {
            for (var e2, n2 = 1, o2 = arguments.length; n2 < o2; n2++) {
              e2 = arguments[n2];
              for (var i2 in e2)
                Object.prototype.hasOwnProperty.call(e2, i2) && (t3[i2] = e2[i2]);
            }
            return t3;
          }, h = this && this.__awaiter || function(t3, e2, n2, o2) {
            return new (n2 || (n2 = Promise))(function(i2, r2) {
              function s2(t4) {
                try {
                  a2(o2.next(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function c2(t4) {
                try {
                  a2(o2.throw(t4));
                } catch (t5) {
                  r2(t5);
                }
              }
              function a2(t4) {
                t4.done ? i2(t4.value) : new n2(function(e3) {
                  e3(t4.value);
                }).then(s2, c2);
              }
              a2((o2 = o2.apply(t3, e2 || [])).next());
            });
          }, u = this && this.__generator || function(t3, e2) {
            function n2(t4) {
              return function(e3) {
                return o2([t4, e3]);
              };
            }
            function o2(n3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; a2; )
                try {
                  if (i2 = 1, r2 && (s2 = 2 & n3[0] ? r2.return : n3[0] ? r2.throw || ((s2 = r2.return) && s2.call(r2), 0) : r2.next) && !(s2 = s2.call(r2, n3[1])).done)
                    return s2;
                  switch (r2 = 0, s2 && (n3 = [2 & n3[0], s2.value]), n3[0]) {
                    case 0:
                    case 1:
                      s2 = n3;
                      break;
                    case 4:
                      return a2.label++, { value: n3[1], done: false };
                    case 5:
                      a2.label++, r2 = n3[1], n3 = [0];
                      continue;
                    case 7:
                      n3 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (s2 = a2.trys, !(s2 = s2.length > 0 && s2[s2.length - 1]) && (6 === n3[0] || 2 === n3[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === n3[0] && (!s2 || n3[1] > s2[0] && n3[1] < s2[3])) {
                        a2.label = n3[1];
                        break;
                      }
                      if (6 === n3[0] && a2.label < s2[1]) {
                        a2.label = s2[1], s2 = n3;
                        break;
                      }
                      if (s2 && a2.label < s2[2]) {
                        a2.label = s2[2], a2.ops.push(n3);
                        break;
                      }
                      s2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  n3 = e2.call(t3, a2);
                } catch (t4) {
                  n3 = [6, t4], r2 = 0;
                } finally {
                  i2 = s2 = 0;
                }
              if (5 & n3[0])
                throw n3[1];
              return { value: n3[0] ? n3[1] : void 0, done: true };
            }
            var i2, r2, s2, c2, a2 = { label: 0, sent: function() {
              if (1 & s2[0])
                throw s2[1];
              return s2[1];
            }, trys: [], ops: [] };
            return c2 = { next: n2(0), throw: n2(1), return: n2(2) }, "function" == typeof Symbol && (c2[Symbol.iterator] = function() {
              return this;
            }), c2;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var p = n(1), l = n(2);
          e.TrouterState = l.TrouterState, e.UserActivityState = l.UserActivityState;
          var d = n(0), g = n(5), f = n(6), m = n(7), v = n(8), y = function() {
            function t3(t4) {
              this.logProvider = t4, this.stateChangedListeners = [], this.logger = new d.Logger("Trouter", t4), this.trouterUrlPromise = new v.TrouterUrlPromise(t4), this.messageHandlers = new g.MessageHandlerRegistry(t4), this.listeners = {}, this.connectionInfo = null, this.logger.info("Created TrouterService version " + p.CLIENT_VERSION);
            }
            return t3.prototype.start = function(t4) {
              if (this.logger.info("Start"), !t4.trouterSettings.disableInternalSkypeTokenCache) {
                var e2 = t4.skypeTokenProvider;
                t4.skypeTokenProvider = f.addCacheAsBackupTo(e2);
              }
              this.trouterCfg = t4;
              var n2 = i(t4, this.ecsCfg);
              void 0 === this.trouterServer && (this.trouterServer = new m.TrouterManager(this.logProvider, n2, t4.skypeTokenProvider, this)), this.trouterServer.start();
            }, t3.prototype.stop = function(t4) {
              this.logger.info("close connection"), this.trouterUrlPromise.rejectUrl(new Error("TrouterService is stopped")), void 0 !== this.trouterServer && this.trouterServer.stop(t4);
            }, t3.prototype.setEcsConfig = function(t4) {
              return h(this, void 0, void 0, function() {
                var e2 = this;
                return u(this, function(n2) {
                  return [2, new Promise(function(n3, o2) {
                    if (e2.ecsCfg = t4.TrouterJScriptClient, e2.logger.info("Setting ECS configuration to " + JSON.stringify(e2.ecsCfg)), void 0 !== e2.trouterServer && void 0 !== e2.trouterCfg) {
                      var r2 = i(e2.trouterCfg, e2.ecsCfg);
                      e2.trouterServer.configure(r2);
                    }
                    n3();
                  })];
                });
              });
            }, t3.prototype.checkConnection = function(t4) {
              void 0 !== this.trouterServer && this.trouterServer.checkConnection(t4 || false);
            }, t3.prototype.resendRegistration = function() {
              return h(this, void 0, void 0, function() {
                return u(this, function(t4) {
                  if (!this.trouterServer)
                    throw new Error("resendRegistration called too early");
                  return [2, this.trouterServer.resendRegistration()];
                });
              });
            }, t3.prototype.registerListener = function(t4, e2) {
              return "" === e2 || "/" !== e2[0] || e2.indexOf("?") >= 0 || e2.indexOf("#") >= 0 ? (this.logger.error("Listener path '" + e2 + "' is not valid"), false) : this.listeners[e2] ? (this.logger.error("Another listener is already registered for path '" + e2 + "'"), false) : (this.listeners[e2] = t4, this.logger.debug("Listener for path '" + e2 + "' registered"), this.connectionInfo && t4.onTrouterConnected(this.connectionInfo.baseEndpointUrl + e2, this.connectionInfo), true);
            }, t3.prototype.unregisterListener = function(t4) {
              for (var e2 = [], n2 = 0, o2 = Object.keys(this.listeners); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                this.listeners[i2] === t4 && e2.push(i2);
              }
              if (0 === e2.length)
                return false;
              for (var r2 = 0, s2 = e2; r2 < s2.length; r2++) {
                var i2 = s2[r2];
                delete this.listeners[i2];
              }
              return this.logger.debug("Listener for path(s) '" + e2.join("', '") + "' unregistered"), true;
            }, t3.prototype.onTrouterConnected = function(t4, e2) {
              this.logger.debug("Trouter is now connected");
              for (var n2 = 0, o2 = Object.keys(this.listeners); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                try {
                  this.listeners[i2].onTrouterConnected(e2.baseEndpointUrl + i2, e2);
                } catch (t5) {
                  this.logger.error("Listener '" + i2 + "' threw an exception from onTrouterConnected(): " + t5);
                }
              }
              this.connectionInfo = e2, this.trouterUrlPromise.resolveUrl(t4), this.notifyStateChanged(l.TrouterState.Connected, { url: t4, getRemainingTtlInSec: function() {
                return e2.connectionTtlSec;
              } });
            }, t3.prototype.onTrouterDisconnected = function() {
              this.logger.debug("Trouter is now disconnected"), this.connectionInfo = null;
              for (var t4 = 0, e2 = Object.keys(this.listeners); t4 < e2.length; t4++) {
                var n2 = e2[t4], o2 = this.listeners[n2];
                if (o2.onTrouterDisconnected)
                  try {
                    o2.onTrouterDisconnected();
                  } catch (t5) {
                    this.logger.error("Listener '" + n2 + "' threw an exception from onTrouterDisconnected(): " + t5);
                  }
              }
              this.notifyStateChanged(l.TrouterState.Disconnected);
            }, t3.prototype.onTrouterRequest = function(t4, e2) {
              for (var n2 = "", o2 = 0, i2 = Object.keys(this.listeners); o2 < i2.length; o2++) {
                var r2 = i2[o2];
                t4.path.substring(0, r2.length) === r2 && r2.length > n2.length && (n2 = r2);
              }
              if ("" === n2)
                this.tryMessageHandlers(t4, e2) || (e2.status = 404, e2.headers = { "Trouter-Responder": "ClientLib" }, e2.send());
              else
                try {
                  this.listeners[n2].onTrouterRequest(t4, e2);
                } catch (t5) {
                  this.logger.error("Listener '" + n2 + "' threw an exception from onTrouterRequest(): " + t5), e2.status = 500, e2.headers = { "Trouter-Responder": "ClientLib" }, e2.send();
                }
            }, t3.prototype.onTrouterMessageLoss = function(t4) {
              this.logger.info("onTrouterMessageLoss called with value " + t4);
              for (var e2 = true, n2 = 0, o2 = Object.keys(this.listeners); n2 < o2.length; n2++) {
                var i2 = o2[n2], r2 = this.listeners[i2];
                if (r2.onTrouterMessageLoss)
                  try {
                    e2 = r2.onTrouterMessageLoss(t4) && e2, void 0 === e2 && (this.logger.error("Listener '" + i2 + "' did not response with boolean value onTrouterMessageLoss()"), e2 = false);
                  } catch (t5) {
                    this.logger.error("Listener '" + i2 + "' threw an exception from onTrouterMessageLoss(): " + t5), e2 = false;
                  }
              }
              return e2;
            }, t3.prototype.onTrouterUserActivityStateAccepted = function(t4) {
              this.logger.debug("onTrouterUserActivityStateAccepted cv: " + t4);
              for (var e2 = 0, n2 = Object.keys(this.listeners); e2 < n2.length; e2++) {
                var o2 = n2[e2], i2 = this.listeners[o2];
                if (i2.onTrouterUserActivityStateAccepted)
                  try {
                    i2.onTrouterUserActivityStateAccepted(t4);
                  } catch (t5) {
                    this.logger.error("Listener '" + o2 + "' threw an exception from onTrouterUserActivityStateAccepted(): " + t5);
                  }
              }
            }, t3.prototype.setUserActivityState = function(t4, e2) {
              if (t4 !== l.UserActivityState.Active && t4 !== l.UserActivityState.Inactive)
                throw new Error("setUserActivityState called with unsupported value " + t4);
              if (this.logger.info("setUserActivityState called with value " + l.UserActivityState[t4]), !this.trouterServer || this.state() === l.TrouterState.Unknown)
                throw new Error("setUserActivityState called too early");
              this.trouterServer.setUserActivityState(t4, e2);
            }, t3.prototype.state = function() {
              return void 0 !== this.trouterServer ? this.trouterServer.getState() : l.TrouterState.Unknown;
            }, t3.prototype.getServerState = function() {
              if (void 0 !== this.trouterServer)
                return this.trouterServer.getServerState();
            }, t3.prototype.getTrouterUrlAsync = function() {
              return void 0 !== this.trouterServer ? this.trouterUrlPromise.getPromise() : Promise.reject(new Error("TrouterService has not been started"));
            }, t3.prototype.onStateChanged = function(t4) {
              if (this.logger.info("onStateChanged called"), void 0 === t4)
                this.stateChangedListeners = this.stateChangedListeners.filter(function(t5) {
                  return void 0 === t5.wrappedCallback;
                });
              else {
                this.offStateChanged(t4);
                var e2 = function(e3, n2) {
                  t4(e3, n2 ? n2.url : "");
                };
                e2.wrappedCallback = t4, this.stateChangedListeners.push(e2);
              }
            }, t3.prototype.offStateChanged = function(t4) {
              this.logger.info("offStateChanged called");
              var e2 = this.stateChangedListeners.length;
              return this.stateChangedListeners = this.stateChangedListeners.filter(function(e3) {
                return e3.wrappedCallback !== t4;
              }), e2 > this.stateChangedListeners.length;
            }, t3.prototype.addCallback = function(t4) {
              this.logger.info("addListener called"), -1 === this.stateChangedListeners.indexOf(t4, 0) && void 0 !== t4 && this.stateChangedListeners.push(t4);
            }, t3.prototype.removeCallback = function(t4) {
              this.logger.info("removeListener called");
              var e2 = this.stateChangedListeners.indexOf(t4, 0);
              return e2 > -1 && (this.stateChangedListeners.splice(e2, 1), true);
            }, t3.prototype.registerMessageHandler = function(t4) {
              this.logger.info("registerMessageHandler is called"), this.messageHandlers.register(t4);
            }, t3.prototype.clearMessageHandlers = function() {
              this.logger.info("clearMessageHandlers is called"), this.messageHandlers.clear();
            }, t3.prototype.notifyStateChanged = function(t4, e2) {
              var n2 = this;
              this.logger.info("notifyStateChanged called, will forward to " + this.stateChangedListeners.length + " listeners"), this.stateChangedListeners.forEach(function(o2) {
                try {
                  o2(t4, e2);
                } catch (t5) {
                  n2.logger.error("Error in callback " + t5);
                }
              });
            }, t3.prototype.tryMessageHandlers = function(t4, e2) {
              if (!this.messageHandlers.active())
                return false;
              var n2, o2 = null;
              try {
                n2 = JSON.parse(t4.body), o2 = n2 && (n2.evt || n2.eventId) || null;
              } catch (t5) {
              }
              var i2 = { eventId: o2, url: (this.connectionInfo ? this.connectionInfo.baseEndpointUrl : "") + t4.path, body: n2, rawBody: t4.body, headers: t4.headers }, r2 = this.messageHandlers.handleMessage(i2);
              return !!r2.isHandled && (e2.status = r2.resultCode, r2.responseHeaders && (e2.headers = r2.responseHeaders), r2.responseBody && (e2.body = r2.responseBody), e2.send(), true);
            }, t3;
          }();
          e.TrouterService = y, e.createTrouterService = r, e.getTrouterServiceVersion = s, e.replaceTrouterUrlBase = c;
        }, function(e, n) {
          e.exports = t;
        }]);
      });
    });
    unwrapExports(tstrouter);
    var constants = createCommonjsModule(function(module2, exports2) {
      exports2.__esModule = true;
      exports2.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES = 3;
      exports2.GCCHIGH_TROUTER_SERVICE_URL = "https://go.trouter.gov.teams.microsoft.us/v4/a";
      exports2.GCCHIGH_REGISTRAR_SERVICE_URL = "https://registrar.gov.teams.microsoft.us/V3/registrations";
      exports2.DOD_TROUTER_SERVICE_URL = "https://go.trouter.dod.teams.microsoft.us/v4/a";
      exports2.DOD_REGISTRAR_SERVICE_URL = "https://registrar.dod.teams.microsoft.us/V3/registrations";
      exports2.INT_TROUTER_SERVICE_URL = "https://go.trouter-int.skype.net/v4/a";
      exports2.INT_REGISTRAR_SERVICE_URL = "https://edge.skype.net/registrar/testenv/v3/registrations";
      exports2.PUBLIC_TROUTER_SERVICE_URL = "https://go.trouter.skype.com/v4/a";
      exports2.PUBLIC_REGISTRAR_SERVICE_URL = "https://edge.skype.com/registrar/prod/v3/registrations";
      var CloudType;
      (function(CloudType2) {
        CloudType2["Public"] = "Public";
        CloudType2["GccHigh"] = "GCC High";
        CloudType2["Dod"] = "DoD";
      })(CloudType = exports2.CloudType || (exports2.CloudType = {}));
      var CloudPrefix;
      (function(CloudPrefix2) {
        CloudPrefix2["OrgId"] = "orgid";
        CloudPrefix2["Acs"] = "acs";
        CloudPrefix2["Spool"] = "spool";
        CloudPrefix2["GccHigh"] = "gcch";
        CloudPrefix2["GccHighAcs"] = "gcch-acs";
        CloudPrefix2["Dod"] = "dod";
        CloudPrefix2["DodAcs"] = "dod-acs";
      })(CloudPrefix = exports2.CloudPrefix || (exports2.CloudPrefix = {}));
    });
    unwrapExports(constants);
    var constants_1 = constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES;
    var constants_2 = constants.GCCHIGH_TROUTER_SERVICE_URL;
    var constants_3 = constants.GCCHIGH_REGISTRAR_SERVICE_URL;
    var constants_4 = constants.DOD_TROUTER_SERVICE_URL;
    var constants_5 = constants.DOD_REGISTRAR_SERVICE_URL;
    var constants_6 = constants.INT_TROUTER_SERVICE_URL;
    var constants_7 = constants.INT_REGISTRAR_SERVICE_URL;
    var constants_8 = constants.PUBLIC_TROUTER_SERVICE_URL;
    var constants_9 = constants.PUBLIC_REGISTRAR_SERVICE_URL;
    var constants_10 = constants.CloudType;
    var constants_11 = constants.CloudPrefix;
    var TrouterUtils = createCommonjsModule(function(module2, exports2) {
      var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      exports2.__esModule = true;
      var eventIds = /* @__PURE__ */ new Map([
        ["chatMessageReceived", 200],
        ["typingIndicatorReceived", 245],
        ["readReceiptReceived", 246],
        ["chatMessageEdited", 247],
        ["chatMessageDeleted", 248],
        ["chatThreadCreated", 257],
        ["chatThreadPropertiesUpdated", 258],
        ["chatThreadDeleted", 259],
        ["participantsAdded", 260],
        ["participantsRemoved", 261]
      ]);
      var publicTeamsUserPrefix = "8:orgid:";
      var dodTeamsUserPrefix = "8:dod:";
      var gcchTeamsUserPrefix = "8:gcch:";
      var teamsVisitorUserPrefix = "8:teamsvisitor:";
      var phoneNumberPrefix = "4:";
      var acsUserPrefix = "8:acs:";
      var acsGcchUserPrefix = "8:gcch-acs:";
      var acsDodUserPrefix = "8:dod-acs:";
      var spoolUserPrefix = "8:spool:";
      exports2.toMessageHandler = function(event, listener) {
        var eventId = eventIds.get(event);
        return {
          handleMessage: function(message) {
            var genericPayload = null;
            if (message === null || message === void 0 ? void 0 : message.rawBody) {
              genericPayload = JSON.parse(message.rawBody);
            }
            if (genericPayload === null || genericPayload.eventId !== eventId) {
              return void 0;
            }
            var eventPayload = toEventPayload(event, genericPayload);
            if (eventPayload === null) {
              return void 0;
            }
            listener(eventPayload);
            return { isHandled: true, resultCode: 200 };
          }
        };
      };
      var toEventPayload = function(event, genericPayload) {
        if (event === "chatMessageReceived") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            id: payload.messageId,
            createdOn: new Date(payload.originalArrivalTime),
            version: payload.version,
            type: payload.messageType,
            message: payload.messageBody,
            metadata: parseMetadata(payload.acsChatMessageMetadata)
          };
          return eventPayload;
        }
        if (event === "chatMessageEdited") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            id: payload.messageId,
            createdOn: new Date(payload.originalArrivalTime),
            version: payload.version,
            message: payload.messageBody,
            editedOn: new Date(payload.edittime),
            type: payload.messageType,
            metadata: parseMetadata(payload.acsChatMessageMetadata)
          };
          return eventPayload;
        }
        if (event === "chatMessageDeleted") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            id: payload.messageId,
            createdOn: new Date(payload.originalArrivalTime),
            version: payload.version,
            deletedOn: new Date(payload.deletetime),
            type: payload.messageType
          };
          return eventPayload;
        }
        if (event === "typingIndicatorReceived") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            version: payload.version,
            receivedOn: new Date(payload.originalArrivalTime)
          };
          return eventPayload;
        }
        if (event === "readReceiptReceived") {
          var payload = genericPayload;
          var readReceiptMessageBody = JSON.parse(payload.messageBody);
          var consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(";");
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: "",
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            chatMessageId: payload.messageId,
            readOn: new Date(+consumptionHorizon[1])
          };
          return eventPayload;
        }
        if (event === "chatThreadCreated") {
          var payload = genericPayload;
          var createdByPayload = JSON.parse(unescape(payload.createdBy));
          var membersPayload = JSON.parse(unescape(payload.members));
          var propertiesPayload = JSON.parse(unescape(payload.properties));
          var createdBy = {
            id: constructIdentifierKindFromMri(createdByPayload.participantId),
            displayName: createdByPayload.displayName
          };
          var chatParticipants = membersPayload.map(function(m) {
            return {
              id: constructIdentifierKindFromMri(m.participantId),
              displayName: m.displayName
            };
          });
          var eventPayload = {
            threadId: payload.threadId,
            createdOn: new Date(payload.createTime),
            createdBy,
            version: payload.version,
            participants: chatParticipants,
            properties: propertiesPayload
          };
          return eventPayload;
        }
        if (event === "chatThreadPropertiesUpdated") {
          var payload = genericPayload;
          var updatedByPayload = JSON.parse(unescape(payload.editedBy));
          var propertiesPayload = JSON.parse(unescape(payload.properties));
          var updatedBy = {
            id: constructIdentifierKindFromMri(updatedByPayload.participantId),
            displayName: updatedByPayload.displayName
          };
          var eventPayload = {
            threadId: payload.threadId,
            updatedOn: new Date(payload.editTime),
            updatedBy,
            version: payload.version,
            properties: propertiesPayload
          };
          return eventPayload;
        }
        if (event === "chatThreadDeleted") {
          var payload = genericPayload;
          var deletedByPayload = JSON.parse(unescape(payload.deletedBy));
          var deletedBy = {
            id: constructIdentifierKindFromMri(deletedByPayload.participantId),
            displayName: deletedByPayload.displayName
          };
          var eventPayload = {
            threadId: payload.threadId,
            deletedOn: new Date(payload.deleteTime),
            deletedBy,
            version: payload.version
          };
          return eventPayload;
        }
        if (event === "participantsAdded") {
          var payload = genericPayload;
          var addedByPayload = JSON.parse(unescape(payload.addedBy));
          var participantsAddedPayload = JSON.parse(unescape(payload.participantsAdded));
          var addedBy = {
            id: constructIdentifierKindFromMri(addedByPayload.participantId),
            displayName: addedByPayload.displayName
          };
          var chatParticipants = participantsAddedPayload.map(function(m) {
            return {
              id: constructIdentifierKindFromMri(m.participantId),
              displayName: m.displayName,
              shareHistoryTime: new Date(m.shareHistoryTime)
            };
          });
          var eventPayload = {
            threadId: payload.threadId,
            addedOn: new Date(payload.time),
            addedBy,
            version: payload.version,
            participantsAdded: chatParticipants
          };
          return eventPayload;
        }
        if (event === "participantsRemoved") {
          var payload = genericPayload;
          var removedByPayload = JSON.parse(unescape(payload.removedBy));
          var participantsRemovedPayload = JSON.parse(unescape(payload.participantsRemoved));
          var removedBy = {
            id: constructIdentifierKindFromMri(removedByPayload.participantId),
            displayName: removedByPayload.displayName
          };
          var chatParticipants = participantsRemovedPayload.map(function(m) {
            return {
              id: constructIdentifierKindFromMri(m.participantId),
              displayName: m.displayName,
              shareHistoryTime: new Date(m.shareHistoryTime)
            };
          });
          var eventPayload = {
            threadId: payload.threadId,
            removedOn: new Date(payload.time),
            removedBy,
            version: payload.version,
            participantsRemoved: chatParticipants
          };
          return eventPayload;
        }
        return null;
      };
      exports2.toLogProvider = function(logger4) {
        return {
          log: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger4.info(message);
          },
          warn: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger4.warning(message);
          },
          error: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger4.error(message);
          },
          debug: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger4.verbose(message);
          },
          info: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger4.verbose(message);
          }
        };
      };
      exports2.toTelemetrySender = function(logger4) {
        return {
          logEvent: function(clientEvent) {
            return logger4.info(clientEvent);
          }
        };
      };
      var constructIdentifierKindFromMri = function(mri) {
        if (mri.startsWith(publicTeamsUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),
            isAnonymous: false,
            cloud: "public"
          };
        } else if (mri.startsWith(dodTeamsUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),
            isAnonymous: false,
            cloud: "dod"
          };
        } else if (mri.startsWith(gcchTeamsUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),
            isAnonymous: false,
            cloud: "gcch"
          };
        } else if (mri.startsWith(teamsVisitorUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),
            isAnonymous: true
          };
        } else if (mri.startsWith(phoneNumberPrefix)) {
          return {
            kind: "phoneNumber",
            rawId: mri,
            phoneNumber: mri.substring(phoneNumberPrefix.length)
          };
        } else if (mri.startsWith(acsUserPrefix) || mri.startsWith(acsGcchUserPrefix) || mri.startsWith(acsDodUserPrefix) || mri.startsWith(spoolUserPrefix)) {
          return { kind: "communicationUser", communicationUserId: mri };
        } else {
          return { kind: "unknown", id: mri };
        }
      };
      var parseMetadata = function(metadata) {
        if (metadata === void 0 || metadata === null || metadata === "" || metadata === "null") {
          return {};
        }
        return JSON.parse(metadata);
      };
      function base64decode(encodedString) {
        return !coreHttp.isNode ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
      }
      exports2.base64decode = base64decode;
      var parseJWT = function(token) {
        var _a2 = token === null || token === void 0 ? void 0 : token.split("."), payload = _a2[1];
        if (payload === void 0) {
          throw new Error("Invalid token");
        }
        payload = payload.replace(/-/g, "+").replace(/_/g, "/");
        return JSON.parse(decodeURIComponent(escape(base64decode(payload))));
      };
      exports2.getCloudTypeFromCredential = function(credential) {
        return __awaiter(void 0, void 0, void 0, function() {
          var accessToken, jwtToken, parsedJwtToken, identityMri;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, credential.getToken()];
              case 1:
                accessToken = _a2.sent();
                jwtToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.token;
                parsedJwtToken = parseJWT(jwtToken);
                identityMri = parsedJwtToken.skypeid;
                return [2, getCloudTypeFromSkypeId(identityMri)];
            }
          });
        });
      };
      function getCloudTypeFromSkypeId(skypeId) {
        var cloudPrefix = skypeId.substring(0, skypeId.indexOf(":"));
        switch (cloudPrefix) {
          case constants.CloudPrefix.OrgId:
          case constants.CloudPrefix.Acs:
          case constants.CloudPrefix.Spool: {
            return constants.CloudType.Public;
          }
          case constants.CloudPrefix.GccHigh:
          case constants.CloudPrefix.GccHighAcs: {
            return constants.CloudType.GccHigh;
          }
          case constants.CloudPrefix.Dod:
          case constants.CloudPrefix.DodAcs: {
            return constants.CloudType.Dod;
          }
          default: {
            return constants.CloudType.Public;
          }
        }
      }
    });
    unwrapExports(TrouterUtils);
    var TrouterUtils_1 = TrouterUtils.toMessageHandler;
    var TrouterUtils_2 = TrouterUtils.toLogProvider;
    var TrouterUtils_3 = TrouterUtils.toTelemetrySender;
    var TrouterUtils_4 = TrouterUtils.base64decode;
    var TrouterUtils_5 = TrouterUtils.getCloudTypeFromCredential;
    var TrouterSettings = createCommonjsModule(function(module2, exports2) {
      var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      exports2.__esModule = true;
      var defaultSettings = {
        version: "1.0.0",
        registrationId: "",
        sessionId: "",
        pnhAppId: "AcsWeb",
        pnhTemplate: "AcsWeb_Chat_1.2",
        platform: "SPOOL",
        platformUIVersion: "0.0.0",
        environment: "",
        productName: "acs-chat-web",
        trouterServiceUrl: constants.PUBLIC_TROUTER_SERVICE_URL,
        registrarServiceUrl: constants.PUBLIC_REGISTRAR_SERVICE_URL,
        registrarRefreshTimeoutInMs: 35e4,
        timeoutOptions: {
          connectionTimeoutMs: 2e4,
          fetchTimeoutMs: 1e4,
          pingTimeoutMs: 4e4,
          pongTimeoutMs: 5e3,
          maxBackoffMs: 5e4,
          requestTimeoutMs: 5e3
        },
        maxRegistrationTimeInMs: 72e5
      };
      var createDefaultSettings = function() {
        var settings = defaultSettings;
        settings.registrationId = coreHttp.generateUuid();
        settings.sessionId = coreHttp.generateUuid();
        return settings;
      };
      var createIntSettings = function() {
        var settings = createDefaultSettings();
        settings.pnhAppId = "cns-e2e-test";
        settings.pnhTemplate = "cns-e2e-test:1.2";
        settings.registrarServiceUrl = constants.INT_REGISTRAR_SERVICE_URL;
        settings.trouterServiceUrl = constants.INT_TROUTER_SERVICE_URL;
        return settings;
      };
      var createGcchSettings = function() {
        var settings = createDefaultSettings();
        settings.registrarServiceUrl = constants.GCCHIGH_REGISTRAR_SERVICE_URL;
        settings.trouterServiceUrl = constants.GCCHIGH_TROUTER_SERVICE_URL;
        return settings;
      };
      var createDodSettings = function() {
        var settings = createDefaultSettings();
        settings.registrarServiceUrl = constants.DOD_REGISTRAR_SERVICE_URL;
        settings.trouterServiceUrl = constants.DOD_TROUTER_SERVICE_URL;
        return settings;
      };
      exports2.createSettings = function(credential, options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var settings, cloud;
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!((options === null || options === void 0 ? void 0 : options.environment) === "INT"))
                  return [3, 1];
                settings = createIntSettings();
                return [3, 3];
              case 1:
                return [4, TrouterUtils.getCloudTypeFromCredential(credential)];
              case 2:
                cloud = _b.sent();
                if (cloud === constants.CloudType.GccHigh) {
                  settings = createGcchSettings();
                } else if (cloud === constants.CloudType.Dod) {
                  settings = createDodSettings();
                } else {
                  settings = createDefaultSettings();
                }
                _b.label = 3;
              case 3:
                settings.maxRegistrationTimeInMs = (_a2 = options === null || options === void 0 ? void 0 : options.registrationTimeInMs) !== null && _a2 !== void 0 ? _a2 : defaultSettings.maxRegistrationTimeInMs;
                return [2, settings];
            }
          });
        });
      };
      exports2.defaultTelemetrySettings = {
        // TBD Can we hook up OpenTelemetry?
        enabled: false
      };
    });
    unwrapExports(TrouterSettings);
    var TrouterSettings_1 = TrouterSettings.createSettings;
    var TrouterSettings_2 = TrouterSettings.defaultTelemetrySettings;
    var SignalingClient = createCommonjsModule(function(module2, exports2) {
      var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      exports2.__esModule = true;
      var CommunicationSignalingClient2 = (
        /** @class */
        function() {
          function CommunicationSignalingClient3(credential, logger4, options) {
            this.credential = credential;
            this.logger = logger4;
            this.options = options;
            this.stateChangedListener = null;
            this.tokenFetchRetries = 0;
            this.trouter = tstrouter.createTrouterService(TrouterUtils.toLogProvider(logger4));
          }
          CommunicationSignalingClient3.prototype.start = function() {
            return __awaiter(this, void 0, void 0, function() {
              var _a2, _b;
              var _this = this;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    if (!(this.config === void 0))
                      return [3, 2];
                    _a2 = this;
                    _b = {};
                    return [4, TrouterSettings.createSettings(this.credential, this.options)];
                  case 1:
                    _a2.config = (_b.trouterSettings = _c.sent(), _b.skypeTokenProvider = function(forceRefresh) {
                      return __awaiter(_this, void 0, void 0, function() {
                        var _a3, _b2;
                        return __generator(this, function(_c2) {
                          switch (_c2.label) {
                            case 0:
                              if (!forceRefresh)
                                return [3, 3];
                              this.tokenFetchRetries += 1;
                              if (!(this.tokenFetchRetries > constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES))
                                return [3, 2];
                              return [4, this.stop(true)];
                            case 1:
                              _c2.sent();
                              throw new Error("Access token is expired and failed to fetch a valid one after " + constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES + " retries");
                            case 2:
                              return [3, 4];
                            case 3:
                              this.tokenFetchRetries = 0;
                              _c2.label = 4;
                            case 4:
                              _b2 = (_a3 = Promise).resolve;
                              return [4, this.credential.getToken()];
                            case 5:
                              return [2, _b2.apply(_a3, [_c2.sent().token])];
                          }
                        });
                      });
                    }, _b.telemetryConfig = {
                      eventLogger: TrouterUtils.toTelemetrySender(this.logger),
                      settings: TrouterSettings.defaultTelemetrySettings
                    }, _b);
                    _c.label = 2;
                  case 2:
                    this.trouter.start(this.config);
                    this.trouter.setUserActivityState(tstrouter.UserActivityState.Active);
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CommunicationSignalingClient3.prototype.stop = function(isTokenExpired) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                this.trouter.offStateChanged(this.stateChangedListener);
                this.trouter.clearMessageHandlers();
                this.trouter.stop(isTokenExpired !== null && isTokenExpired !== void 0 ? isTokenExpired : this.tokenFetchRetries > constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES);
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CommunicationSignalingClient3.prototype.on = function(event, listener) {
            if (event === "connectionChanged") {
              this.trouter.offStateChanged(this.stateChangedListener);
              this.stateChangedListener = function(state, _url) {
                return listener(state);
              };
              this.trouter.onStateChanged(this.stateChangedListener);
              return;
            }
            this.trouter.registerMessageHandler(TrouterUtils.toMessageHandler(event, listener));
          };
          return CommunicationSignalingClient3;
        }()
      );
      exports2.CommunicationSignalingClient = CommunicationSignalingClient2;
    });
    unwrapExports(SignalingClient);
    var SignalingClient_1 = SignalingClient.CommunicationSignalingClient;
    var src = createCommonjsModule(function(module2, exports2) {
      function __export2(m) {
        for (var p in m)
          if (!exports2.hasOwnProperty(p))
            exports2[p] = m[p];
      }
      exports2.__esModule = true;
      __export2(SignalingClient);
    });
    var index = unwrapExports(src);
    module.exports = index;
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/chatClient.js
init_tslib_es6();

// node_modules/@azure/communication-chat/dist-esm/src/models/mappers.js
init_tslib_es6();

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/autoRefreshTokenCredential.js
var minutesToMs = (minutes) => minutes * 1e3 * 60;
var defaultExpiringSoonInterval = minutesToMs(10);

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/credential/cryptoUtils.browser.js
var _a;
var subtle = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.subtle;

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js
init_src3();

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/credential/communicationAuthPolicy.js
init_src4();

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/credential/clientArguments.js
init_src4();

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/credential/connectionString.js
init_src4();

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/identifierModels.js
var isCommunicationUserIdentifier = (identifier) => {
  return typeof identifier.communicationUserId === "string";
};
var isPhoneNumberIdentifier = (identifier) => {
  return typeof identifier.phoneNumber === "string";
};
var isMicrosoftTeamsUserIdentifier = (identifier) => {
  return typeof identifier.microsoftTeamsUserId === "string";
};
var getIdentifierKind = (identifier) => {
  if (isCommunicationUserIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), { kind: "communicationUser" });
  }
  if (isPhoneNumberIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), { kind: "phoneNumber" });
  }
  if (isMicrosoftTeamsUserIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), { kind: "microsoftTeamsUser" });
  }
  return Object.assign(Object.assign({}, identifier), { kind: "unknown" });
};
var getIdentifierRawId = (identifier) => {
  const identifierKind = getIdentifierKind(identifier);
  switch (identifierKind.kind) {
    case "communicationUser":
      return identifierKind.communicationUserId;
    case "microsoftTeamsUser": {
      const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;
      if (rawId)
        return rawId;
      if (isAnonymous)
        return `8:teamsvisitor:${microsoftTeamsUserId}`;
      switch (cloud) {
        case "dod":
          return `8:dod:${microsoftTeamsUserId}`;
        case "gcch":
          return `8:gcch:${microsoftTeamsUserId}`;
        case "public":
          return `8:orgid:${microsoftTeamsUserId}`;
      }
      return `8:orgid:${microsoftTeamsUserId}`;
    }
    case "phoneNumber": {
      const { phoneNumber, rawId } = identifierKind;
      if (rawId)
        return rawId;
      return `4:${phoneNumber}`;
    }
    case "unknown": {
      return identifierKind.id;
    }
  }
};

// node_modules/@azure/communication-chat/node_modules/@azure/communication-common/dist-esm/src/identifierModelSerializer.js
var assertNotNullOrUndefined = (obj, prop) => {
  const subObjName = Object.keys(obj)[0];
  const subObj = obj[subObjName];
  if (prop in subObj) {
    return subObj[prop];
  }
  throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);
};
var assertMaximumOneNestedModel = (identifier) => {
  const presentProperties = [];
  if (identifier.communicationUser !== void 0) {
    presentProperties.push("communicationUser");
  }
  if (identifier.microsoftTeamsUser !== void 0) {
    presentProperties.push("microsoftTeamsUser");
  }
  if (identifier.phoneNumber !== void 0) {
    presentProperties.push("phoneNumber");
  }
  if (presentProperties.length > 1) {
    throw new Error(`Only one of the properties in ${JSON.stringify(presentProperties)} should be present.`);
  }
};
var serializeCommunicationIdentifier = (identifier) => {
  var _a2, _b, _c, _d;
  const identifierKind = getIdentifierKind(identifier);
  switch (identifierKind.kind) {
    case "communicationUser":
      return {
        rawId: getIdentifierRawId(identifierKind),
        communicationUser: { id: identifierKind.communicationUserId }
      };
    case "phoneNumber":
      return {
        rawId: (_a2 = identifierKind.rawId) !== null && _a2 !== void 0 ? _a2 : getIdentifierRawId(identifierKind),
        phoneNumber: {
          value: identifierKind.phoneNumber
        }
      };
    case "microsoftTeamsUser":
      return {
        rawId: (_b = identifierKind.rawId) !== null && _b !== void 0 ? _b : getIdentifierRawId(identifierKind),
        microsoftTeamsUser: {
          userId: identifierKind.microsoftTeamsUserId,
          isAnonymous: (_c = identifierKind.isAnonymous) !== null && _c !== void 0 ? _c : false,
          cloud: (_d = identifierKind.cloud) !== null && _d !== void 0 ? _d : "public"
        }
      };
    case "unknown":
      return { rawId: identifierKind.id };
    default:
      throw new Error(`Can't serialize an identifier with kind ${identifierKind.kind}`);
  }
};
var getKind = (serializedIdentifier) => {
  if (serializedIdentifier.communicationUser) {
    return "communicationUser";
  }
  if (serializedIdentifier.phoneNumber) {
    return "phoneNumber";
  }
  if (serializedIdentifier.microsoftTeamsUser) {
    return "microsoftTeamsUser";
  }
  return "unknown";
};
var deserializeCommunicationIdentifier = (serializedIdentifier) => {
  var _a2;
  assertMaximumOneNestedModel(serializedIdentifier);
  const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;
  const kind = (_a2 = serializedIdentifier.kind) !== null && _a2 !== void 0 ? _a2 : getKind(serializedIdentifier);
  if (kind === "communicationUser" && communicationUser) {
    return {
      kind: "communicationUser",
      communicationUserId: assertNotNullOrUndefined({ communicationUser }, "id")
    };
  }
  if (kind === "phoneNumber" && phoneNumber) {
    return {
      kind: "phoneNumber",
      phoneNumber: assertNotNullOrUndefined({ phoneNumber }, "value"),
      rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, "rawId")
    };
  }
  if (kind === "microsoftTeamsUser" && microsoftTeamsUser) {
    return {
      kind: "microsoftTeamsUser",
      microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, "userId"),
      isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, "isAnonymous"),
      cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, "cloud"),
      rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, "rawId")
    };
  }
  return {
    kind: "unknown",
    id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, "rawId")
  };
};

// node_modules/@azure/communication-chat/dist-esm/src/models/mappers.js
var mapToCreateChatThreadOptionsRestModel = (options) => {
  const { participants, idempotencyToken } = options, rest = __rest(options, ["participants", "idempotencyToken"]);
  return Object.assign({ repeatabilityRequestId: idempotencyToken }, rest);
};
var mapToChatParticipantRestModel = (chatParticipant) => {
  const { id } = chatParticipant, rest = __rest(chatParticipant, ["id"]);
  return Object.assign(Object.assign({}, rest), { communicationIdentifier: serializeCommunicationIdentifier(id) });
};
var mapToAddChatParticipantsRequestRestModel = (addParticipantsRequest) => {
  var _a2;
  return {
    participants: (_a2 = addParticipantsRequest.participants) === null || _a2 === void 0 ? void 0 : _a2.map((participant) => mapToChatParticipantRestModel(participant))
  };
};
var mapToChatParticipantSdkModel = (chatParticipant) => {
  const { communicationIdentifier } = chatParticipant, rest = __rest(chatParticipant, ["communicationIdentifier"]);
  return Object.assign(Object.assign({}, rest), { id: deserializeCommunicationIdentifier(communicationIdentifier) });
};
var mapToChatContentSdkModel = (content) => {
  const { participants, initiatorCommunicationIdentifier } = content, otherChatContents = __rest(content, ["participants", "initiatorCommunicationIdentifier"]);
  let result = Object.assign({}, otherChatContents);
  if (initiatorCommunicationIdentifier) {
    const initiator = deserializeCommunicationIdentifier(initiatorCommunicationIdentifier);
    result = Object.assign(Object.assign({}, result), { initiator });
  }
  if (participants) {
    result = Object.assign(Object.assign({}, result), { participants: participants === null || participants === void 0 ? void 0 : participants.map((participant) => mapToChatParticipantSdkModel(participant)) });
  }
  return result;
};
var mapToChatMessageSdkModel = (chatMessage) => {
  const { content, senderCommunicationIdentifier } = chatMessage, otherChatMessage = __rest(chatMessage, ["content", "senderCommunicationIdentifier"]);
  let result = Object.assign({}, otherChatMessage);
  if (content) {
    result = Object.assign(Object.assign({}, result), { content: mapToChatContentSdkModel(content) });
  }
  if (senderCommunicationIdentifier) {
    const sender = deserializeCommunicationIdentifier(senderCommunicationIdentifier);
    result = Object.assign(Object.assign({}, result), { sender });
  }
  return result;
};
var mapToChatThreadPropertiesSdkModel = (chatThread) => {
  const { createdByCommunicationIdentifier } = chatThread, rest = __rest(chatThread, ["createdByCommunicationIdentifier"]);
  if (createdByCommunicationIdentifier) {
    return Object.assign(Object.assign({}, rest), { createdBy: deserializeCommunicationIdentifier(createdByCommunicationIdentifier) });
  } else {
    return Object.assign({}, rest);
  }
};
var mapToCreateChatThreadResultSdkModel = (result) => {
  const { chatThread } = result, rest = __rest(result, ["chatThread"]);
  if (chatThread) {
    return Object.assign(Object.assign({}, rest), { chatThread: mapToChatThreadPropertiesSdkModel(chatThread) });
  } else {
    return Object.assign({}, rest);
  }
};
var mapToReadReceiptSdkModel = (readReceipt) => {
  const { senderCommunicationIdentifier } = readReceipt, rest = __rest(readReceipt, ["senderCommunicationIdentifier"]);
  return Object.assign(Object.assign({}, rest), { sender: deserializeCommunicationIdentifier(senderCommunicationIdentifier) });
};

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/index.js
var KnownCommunicationCloudEnvironmentModel;
(function(KnownCommunicationCloudEnvironmentModel2) {
  KnownCommunicationCloudEnvironmentModel2["Public"] = "public";
  KnownCommunicationCloudEnvironmentModel2["Dod"] = "dod";
  KnownCommunicationCloudEnvironmentModel2["Gcch"] = "gcch";
})(KnownCommunicationCloudEnvironmentModel || (KnownCommunicationCloudEnvironmentModel = {}));

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/base64.browser.js
function encodeByteArray(value) {
  let str = "";
  for (let i = 0; i < value.length; i++) {
    str += String.fromCharCode(value[i]);
  }
  return btoa(str);
}
function decodeString(value) {
  const byteString = atob(value);
  const arr = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    arr[i] = byteString.charCodeAt(i);
  }
  return arr;
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/interfaces.js
var XML_ATTRKEY = "$";
var XML_CHARKEY = "_";

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/utils.js
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function isDuration(value) {
  return validateISODuration.test(value);
}
var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
function isValidUuid(uuid) {
  return validUuidRegex.test(uuid);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
  }
}
function flattenResponse(fullResponse, responseSpec) {
  var _a2, _b;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = (_a2 = fullResponse.parsedBody) !== null && _a2 !== void 0 ? _a2 : [];
    for (const key of Object.keys(modelProperties)) {
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
      }
    }
    if (parsedHeaders) {
      for (const key of Object.keys(parsedHeaders)) {
        arrayResponse[key] = parsedHeaders[key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/serializer.js
var SerializerImpl = class {
  constructor(modelMappers = {}, isXML = false) {
    this.modelMappers = modelMappers;
    this.isXML = isXML;
  }
  /**
   * @deprecated Removing the constraints validation on client side.
   */
  validateConstraints(mapper, value, objectName) {
    const failValidation = (constraintName, constraintValue) => {
      throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
    };
    if (mapper.constraints && value !== void 0 && value !== null) {
      const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
      if (ExclusiveMaximum !== void 0 && value >= ExclusiveMaximum) {
        failValidation("ExclusiveMaximum", ExclusiveMaximum);
      }
      if (ExclusiveMinimum !== void 0 && value <= ExclusiveMinimum) {
        failValidation("ExclusiveMinimum", ExclusiveMinimum);
      }
      if (InclusiveMaximum !== void 0 && value > InclusiveMaximum) {
        failValidation("InclusiveMaximum", InclusiveMaximum);
      }
      if (InclusiveMinimum !== void 0 && value < InclusiveMinimum) {
        failValidation("InclusiveMinimum", InclusiveMinimum);
      }
      if (MaxItems !== void 0 && value.length > MaxItems) {
        failValidation("MaxItems", MaxItems);
      }
      if (MaxLength !== void 0 && value.length > MaxLength) {
        failValidation("MaxLength", MaxLength);
      }
      if (MinItems !== void 0 && value.length < MinItems) {
        failValidation("MinItems", MinItems);
      }
      if (MinLength !== void 0 && value.length < MinLength) {
        failValidation("MinLength", MinLength);
      }
      if (MultipleOf !== void 0 && value % MultipleOf !== 0) {
        failValidation("MultipleOf", MultipleOf);
      }
      if (Pattern) {
        const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
        if (typeof value !== "string" || value.match(pattern) === null) {
          failValidation("Pattern", Pattern);
        }
      }
      if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {
        failValidation("UniqueItems", UniqueItems);
      }
    }
  }
  /**
   * Serialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param object - A valid Javascript object to be serialized
   *
   * @param objectName - Name of the serialized object
   *
   * @param options - additional options to serialization
   *
   * @returns A valid serialized Javascript object
   */
  serialize(mapper, object, objectName, options = { xml: {} }) {
    var _a2, _b, _c;
    const updatedOptions = {
      xml: {
        rootName: (_a2 = options.xml.rootName) !== null && _a2 !== void 0 ? _a2 : "",
        includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
        xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
      }
    };
    let payload = {};
    const mapperType = mapper.type.name;
    if (!objectName) {
      objectName = mapper.serializedName;
    }
    if (mapperType.match(/^Sequence$/i) !== null) {
      payload = [];
    }
    if (mapper.isConstant) {
      object = mapper.defaultValue;
    }
    const { required, nullable } = mapper;
    if (required && nullable && object === void 0) {
      throw new Error(`${objectName} cannot be undefined.`);
    }
    if (required && !nullable && (object === void 0 || object === null)) {
      throw new Error(`${objectName} cannot be null or undefined.`);
    }
    if (!required && nullable === false && object === null) {
      throw new Error(`${objectName} cannot be null.`);
    }
    if (object === void 0 || object === null) {
      payload = object;
    } else {
      if (mapperType.match(/^any$/i) !== null) {
        payload = object;
      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
        payload = serializeBasicTypes(mapperType, objectName, object);
      } else if (mapperType.match(/^Enum$/i) !== null) {
        const enumMapper = mapper;
        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
        payload = serializeDateTypes(mapperType, object, objectName);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = serializeByteArrayType(objectName, object);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = serializeBase64UrlType(objectName, object);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      } else if (mapperType.match(/^Composite$/i) !== null) {
        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      }
    }
    return payload;
  }
  /**
   * Deserialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param responseBody - A valid Javascript entity to be deserialized
   *
   * @param objectName - Name of the deserialized object
   *
   * @param options - Controls behavior of XML parser and builder.
   *
   * @returns A valid deserialized Javascript object
   */
  deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
    var _a2, _b, _c, _d;
    const updatedOptions = {
      xml: {
        rootName: (_a2 = options.xml.rootName) !== null && _a2 !== void 0 ? _a2 : "",
        includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
        xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
      },
      ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false
    };
    if (responseBody === void 0 || responseBody === null) {
      if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
        responseBody = [];
      }
      if (mapper.defaultValue !== void 0) {
        responseBody = mapper.defaultValue;
      }
      return responseBody;
    }
    let payload;
    const mapperType = mapper.type.name;
    if (!objectName) {
      objectName = mapper.serializedName;
    }
    if (mapperType.match(/^Composite$/i) !== null) {
      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
    } else {
      if (this.isXML) {
        const xmlCharKey = updatedOptions.xml.xmlCharKey;
        if (responseBody[XML_ATTRKEY] !== void 0 && responseBody[xmlCharKey] !== void 0) {
          responseBody = responseBody[xmlCharKey];
        }
      }
      if (mapperType.match(/^Number$/i) !== null) {
        payload = parseFloat(responseBody);
        if (isNaN(payload)) {
          payload = responseBody;
        }
      } else if (mapperType.match(/^Boolean$/i) !== null) {
        if (responseBody === "true") {
          payload = true;
        } else if (responseBody === "false") {
          payload = false;
        } else {
          payload = responseBody;
        }
      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
        payload = responseBody;
      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
        payload = new Date(responseBody);
      } else if (mapperType.match(/^UnixTime$/i) !== null) {
        payload = unixTimeToDate(responseBody);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = decodeString(responseBody);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = base64UrlToByteArray(responseBody);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
      }
    }
    if (mapper.isConstant) {
      payload = mapper.defaultValue;
    }
    return payload;
  }
};
function createSerializer(modelMappers = {}, isXML = false) {
  return new SerializerImpl(modelMappers, isXML);
}
function trimEnd(str, ch) {
  let len = str.length;
  while (len - 1 >= 0 && str[len - 1] === ch) {
    --len;
  }
  return str.substr(0, len);
}
function bufferToBase64Url(buffer) {
  if (!buffer) {
    return void 0;
  }
  if (!(buffer instanceof Uint8Array)) {
    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
  }
  const str = encodeByteArray(buffer);
  return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray(str) {
  if (!str) {
    return void 0;
  }
  if (str && typeof str.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  }
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  return decodeString(str);
}
function splitSerializeName(prop) {
  const classes = [];
  let partialclass = "";
  if (prop) {
    const subwords = prop.split(".");
    for (const item of subwords) {
      if (item.charAt(item.length - 1) === "\\") {
        partialclass += item.substr(0, item.length - 1) + ".";
      } else {
        partialclass += item;
        classes.push(partialclass);
        partialclass = "";
      }
    }
  }
  return classes;
}
function dateToUnixTime(d) {
  if (!d) {
    return void 0;
  }
  if (typeof d.valueOf() === "string") {
    d = new Date(d);
  }
  return Math.floor(d.getTime() / 1e3);
}
function unixTimeToDate(n) {
  if (!n) {
    return void 0;
  }
  return new Date(n * 1e3);
}
function serializeBasicTypes(typeName, objectName, value) {
  if (value !== null && value !== void 0) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error(`${objectName} with value ${value} must be of type number.`);
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error(`${objectName} with value "${value}" must be of type string.`);
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && isValidUuid(value))) {
        throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error(`${objectName} with value ${value} must be of type boolean.`);
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      const objectType = typeof value;
      if (objectType !== "string" && typeof value.pipe !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly
      !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream.`);
      }
    }
  }
  return value;
}
function serializeEnumType(objectName, allowedValues, value) {
  if (!allowedValues) {
    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
  }
  const isPresent = allowedValues.some((item) => {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }
    return item === value;
  });
  if (!isPresent) {
    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
  }
  return value;
}
function serializeByteArrayType(objectName, value) {
  if (value !== void 0 && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    value = encodeByteArray(value);
  }
  return value;
}
function serializeBase64UrlType(objectName, value) {
  if (value !== void 0 && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    value = bufferToBase64Url(value);
  }
  return value;
}
function serializeDateTypes(typeName, value, objectName) {
  if (value !== void 0 && value !== null) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
      }
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
      }
      value = dateToUnixTime(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!isDuration(value)) {
        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
      }
    }
  }
  return value;
}
function serializeSequenceType(serializer3, mapper, object, objectName, isXml, options) {
  var _a2;
  if (!Array.isArray(object)) {
    throw new Error(`${objectName} must be of type Array.`);
  }
  let elementType = mapper.type.element;
  if (!elementType || typeof elementType !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  if (elementType.type.name === "Composite" && elementType.type.className) {
    elementType = (_a2 = serializer3.modelMappers[elementType.type.className]) !== null && _a2 !== void 0 ? _a2 : elementType;
  }
  const tempArray = [];
  for (let i = 0; i < object.length; i++) {
    const serializedValue = serializer3.serialize(elementType, object[i], objectName, options);
    if (isXml && elementType.xmlNamespace) {
      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
      if (elementType.type.name === "Composite") {
        tempArray[i] = Object.assign({}, serializedValue);
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      } else {
        tempArray[i] = {};
        tempArray[i][options.xml.xmlCharKey] = serializedValue;
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }
  return tempArray;
}
function serializeDictionaryType(serializer3, mapper, object, objectName, isXml, options) {
  if (typeof object !== "object") {
    throw new Error(`${objectName} must be of type object.`);
  }
  const valueType = mapper.type.value;
  if (!valueType || typeof valueType !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  const tempDictionary = {};
  for (const key of Object.keys(object)) {
    const serializedValue = serializer3.serialize(valueType, object[key], objectName, options);
    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
  }
  if (isXml && mapper.xmlNamespace) {
    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
    const result = tempDictionary;
    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
    return result;
  }
  return tempDictionary;
}
function resolveAdditionalProperties(serializer3, mapper, objectName) {
  const additionalProperties = mapper.type.additionalProperties;
  if (!additionalProperties && mapper.type.className) {
    const modelMapper = resolveReferencedMapper(serializer3, mapper, objectName);
    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
  }
  return additionalProperties;
}
function resolveReferencedMapper(serializer3, mapper, objectName) {
  const className = mapper.type.className;
  if (!className) {
    throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
  }
  return serializer3.modelMappers[className];
}
function resolveModelProperties(serializer3, mapper, objectName) {
  let modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    const modelMapper = resolveReferencedMapper(serializer3, mapper, objectName);
    if (!modelMapper) {
      throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
    }
    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
    if (!modelProps) {
      throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
    }
  }
  return modelProps;
}
function serializeCompositeType(serializer3, mapper, object, objectName, isXml, options) {
  if (getPolymorphicDiscriminatorRecursively(serializer3, mapper)) {
    mapper = getPolymorphicMapper(serializer3, mapper, object, "clientName");
  }
  if (object !== void 0 && object !== null) {
    const payload = {};
    const modelProps = resolveModelProperties(serializer3, mapper, objectName);
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      if (propertyMapper.readOnly) {
        continue;
      }
      let propName;
      let parentObject = payload;
      if (serializer3.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        const paths = splitSerializeName(propertyMapper.serializedName);
        propName = paths.pop();
        for (const pathName of paths) {
          const childObject = parentObject[pathName];
          if ((childObject === void 0 || childObject === null) && (object[key] !== void 0 && object[key] !== null || propertyMapper.defaultValue !== void 0)) {
            parentObject[pathName] = {};
          }
          parentObject = parentObject[pathName];
        }
      }
      if (parentObject !== void 0 && parentObject !== null) {
        if (isXml && mapper.xmlNamespace) {
          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
          parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
        }
        const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
        let toSerialize = object[key];
        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer3, mapper);
        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null)) {
          toSerialize = mapper.serializedName;
        }
        const serializedValue = serializer3.serialize(propertyMapper, toSerialize, propertyObjectName, options);
        if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
          if (isXml && propertyMapper.xmlIsAttribute) {
            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};
            parentObject[XML_ATTRKEY][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = { [propertyMapper.xmlElementName]: value };
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }
    const additionalPropertiesMapper = resolveAdditionalProperties(serializer3, mapper, objectName);
    if (additionalPropertiesMapper) {
      const propNames = Object.keys(modelProps);
      for (const clientPropName in object) {
        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
        if (isAdditionalProperty) {
          payload[clientPropName] = serializer3.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
        }
      }
    }
    return payload;
  }
  return object;
}
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }
  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[XML_ATTRKEY]) {
      return serializedValue;
    } else {
      const result2 = Object.assign({}, serializedValue);
      result2[XML_ATTRKEY] = xmlNamespace;
      return result2;
    }
  }
  const result = {};
  result[options.xml.xmlCharKey] = serializedValue;
  result[XML_ATTRKEY] = xmlNamespace;
  return result;
}
function isSpecialXmlProperty(propertyName, options) {
  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType(serializer3, mapper, responseBody, objectName, options) {
  var _a2, _b;
  const xmlCharKey = (_a2 = options.xml.xmlCharKey) !== null && _a2 !== void 0 ? _a2 : XML_CHARKEY;
  if (getPolymorphicDiscriminatorRecursively(serializer3, mapper)) {
    mapper = getPolymorphicMapper(serializer3, mapper, responseBody, "serializedName");
  }
  const modelProps = resolveModelProperties(serializer3, mapper, objectName);
  let instance = {};
  const handledPropertyNames = [];
  for (const key of Object.keys(modelProps)) {
    const propertyMapper = modelProps[key];
    const paths = splitSerializeName(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    const { serializedName, xmlName, xmlElementName } = propertyMapper;
    let propertyObjectName = objectName;
    if (serializedName !== "" && serializedName !== void 0) {
      propertyObjectName = objectName + "." + serializedName;
    }
    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
    if (headerCollectionPrefix) {
      const dictionary = {};
      for (const headerKey of Object.keys(responseBody)) {
        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer3.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
        }
        handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer3.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {
        instance[key] = serializer3.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);
      } else if (propertyMapper.xmlIsMsText) {
        if (responseBody[xmlCharKey] !== void 0) {
          instance[key] = responseBody[xmlCharKey];
        } else if (typeof responseBody === "string") {
          instance[key] = responseBody;
        }
      } else {
        const propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          const wrapped = responseBody[xmlName];
          const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];
          instance[key] = serializer3.deserialize(propertyMapper, elementList, propertyObjectName, options);
          handledPropertyNames.push(xmlName);
        } else {
          const property = responseBody[propertyName];
          instance[key] = serializer3.deserialize(propertyMapper, property, propertyObjectName, options);
          handledPropertyNames.push(propertyName);
        }
      }
    } else {
      let propertyInstance;
      let res = responseBody;
      let steps = 0;
      for (const item of paths) {
        if (!res)
          break;
        steps++;
        res = res[item];
      }
      if (res === null && steps < paths.length) {
        res = void 0;
      }
      propertyInstance = res;
      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null)) {
        propertyInstance = mapper.serializedName;
      }
      let serializedValue;
      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        const arrayInstance = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        for (const [k, v] of Object.entries(instance)) {
          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
            arrayInstance[k] = v;
          }
        }
        instance = arrayInstance;
      } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
        serializedValue = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        instance[key] = serializedValue;
      }
    }
  }
  const additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    const isAdditionalProperty = (responsePropName) => {
      for (const clientPropName in modelProps) {
        const paths = splitSerializeName(modelProps[clientPropName].serializedName);
        if (paths[0] === responsePropName) {
          return false;
        }
      }
      return true;
    };
    for (const responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer3.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
      }
    }
  } else if (responseBody && !options.ignoreUnknownProperties) {
    for (const key of Object.keys(responseBody)) {
      if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
        instance[key] = responseBody[key];
      }
    }
  }
  return instance;
}
function deserializeDictionaryType(serializer3, mapper, responseBody, objectName, options) {
  const value = mapper.type.value;
  if (!value || typeof value !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    const tempDictionary = {};
    for (const key of Object.keys(responseBody)) {
      tempDictionary[key] = serializer3.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}
function deserializeSequenceType(serializer3, mapper, responseBody, objectName, options) {
  var _a2;
  let element = mapper.type.element;
  if (!element || typeof element !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      responseBody = [responseBody];
    }
    if (element.type.name === "Composite" && element.type.className) {
      element = (_a2 = serializer3.modelMappers[element.type.className]) !== null && _a2 !== void 0 ? _a2 : element;
    }
    const tempArray = [];
    for (let i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer3.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
    }
    return tempArray;
  }
  return responseBody;
}
function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
  const typeNamesToCheck = [typeName];
  while (typeNamesToCheck.length) {
    const currentName = typeNamesToCheck.shift();
    const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
      return discriminators[indexDiscriminator];
    } else {
      for (const [name, mapper] of Object.entries(discriminators)) {
        if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
          typeNamesToCheck.push(mapper.type.className);
        }
      }
    }
  }
  return void 0;
}
function getPolymorphicMapper(serializer3, mapper, object, polymorphicPropertyName) {
  var _a2;
  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer3, mapper);
  if (polymorphicDiscriminator) {
    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName) {
      if (polymorphicPropertyName === "serializedName") {
        discriminatorName = discriminatorName.replace(/\\/gi, "");
      }
      const discriminatorValue = object[discriminatorName];
      const typeName = (_a2 = mapper.type.uberParent) !== null && _a2 !== void 0 ? _a2 : mapper.type.className;
      if (typeof discriminatorValue === "string" && typeName) {
        const polymorphicMapper = getIndexDiscriminator(serializer3.modelMappers.discriminators, discriminatorValue, typeName);
        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }
  return mapper;
}
function getPolymorphicDiscriminatorRecursively(serializer3, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer3, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer3, mapper.type.className);
}
function getPolymorphicDiscriminatorSafely(serializer3, typeName) {
  return typeName && serializer3.modelMappers[typeName] && serializer3.modelMappers[typeName].type.polymorphicDiscriminator;
}
var MapperTypeNames = {
  Base64Url: "Base64Url",
  Boolean: "Boolean",
  ByteArray: "ByteArray",
  Composite: "Composite",
  Date: "Date",
  DateTime: "DateTime",
  DateTimeRfc1123: "DateTimeRfc1123",
  Dictionary: "Dictionary",
  Enum: "Enum",
  Number: "Number",
  Object: "Object",
  Sequence: "Sequence",
  String: "String",
  Stream: "Stream",
  TimeSpan: "TimeSpan",
  UnixTime: "UnixTime"
};

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/operationHelpers.js
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
var operationRequestMap = /* @__PURE__ */ new WeakMap();
var originalRequestSymbol = Symbol.for("@azure/core-client original request");
function hasOriginalRequest(request) {
  return originalRequestSymbol in request;
}
function getOperationRequestInfo(request) {
  if (hasOriginalRequest(request)) {
    return getOperationRequestInfo(request[originalRequestSymbol]);
  }
  let info = operationRequestMap.get(request);
  if (!info) {
    info = {};
    operationRequestMap.set(request, info);
  }
  return info;
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js
var defaultJsonContentTypes = ["application/json", "text/json"];
var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
var deserializationPolicyName = "deserializationPolicy";
function deserializationPolicy(options = {}) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const jsonContentTypes = (_b = (_a2 = options.expectedContentTypes) === null || _a2 === void 0 ? void 0 : _a2.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;
  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;
  const parseXML2 = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML2);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML2) {
  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML2);
  if (!shouldDeserializeResponse(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
  if (error) {
    throw error;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
      } catch (deserializeError) {
        const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
  var _a2;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const initialErrorMessage = ((_a2 = parsedResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML2) {
  var _a2;
  if (!((_a2 = operationResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text = operationResponse.bodyAsText;
    const contentType2 = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType2 ? [] : contentType2.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML2) {
          throw new Error("Parsing XML not supported.");
        }
        const body = await parseXML2(text, opts.xml);
        operationResponse.parsedBody = body;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError.PARSE_ERROR;
      const e = new RestError(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js
var serializationPolicyName = "serializationPolicy";
function serializationPolicy(options = {}) {
  const stringifyXML2 = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request, next) {
      const operationInfo = getOperationRequestInfo(request);
      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request, operationArguments, operationSpec);
        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML2);
      }
      return next(request);
    }
  };
}
function serializeHeaders(request, operationArguments, operationSpec) {
  var _a2, _b;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key of Object.keys(headerValue)) {
            request.headers.set(headerCollectionPrefix + key, headerValue[key]);
          }
        } else {
          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML2 = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a2, _b, _c, _d, _e;
  const serializerOptions = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request.body = stringifyXML2(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request.body = stringifyXML2(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request.body = JSON.stringify(request.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/pipeline.js
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/httpClientCache.js
var cachedHttpClient;
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/urlHelpers.js
var CollectionFormatToDelimiterMap = {
  CSV: ",",
  SSV: " ",
  Multi: "Multi",
  TSV: "	",
  Pipes: "|"
};
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path = replaceAll(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
      path = path.substring(1);
    }
    if (isAbsoluteUrl(path)) {
      requestUrl = path;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input, replacements) {
  let result = input;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  if ((_a2 = operationSpec.urlParameters) === null || _a2 === void 0 ? void 0 : _a2.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  const parsedUrl = new URL(url);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a2 = operationSpec.queryParameters) === null || _a2 === void 0 ? void 0 : _a2.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name, value] = pair.split("=", 2);
    const existingValue = result.get(name);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name, [existingValue, value]);
      }
    } else {
      result.set(name, value);
    }
  }
  return result;
}
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url;
  }
  const parsedUrl = new URL(url);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name, value] of queryParams) {
    const existingValue = combinedParams.get(name);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name)) {
        combinedParams.set(name, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name, value);
      }
    } else {
      combinedParams.set(name, value);
    }
  }
  const searchPieces = [];
  for (const [name, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/log.js
init_src();
var logger = createClientLogger("core-client");

// node_modules/@azure/communication-chat/node_modules/@azure/core-client/dist-esm/src/serviceClient.js
var ServiceClient = class {
  /**
   * The ServiceClient constructor
   * @param credential - The credentials used for authentication with the service.
   * @param options - The service client options that govern the behavior of the client.
   */
  constructor(options = {}) {
    var _a2, _b;
    this._requestContentType = options.requestContentType;
    this._endpoint = (_a2 = options.endpoint) !== null && _a2 !== void 0 ? _a2 : options.baseUri;
    if (options.baseUri) {
      logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
    }
    this._allowInsecureConnection = options.allowInsecureConnection;
    this._httpClient = options.httpClient || getCachedDefaultHttpClient();
    this.pipeline = options.pipeline || createDefaultPipeline(options);
    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {
      for (const { policy, position } of options.additionalPolicies) {
        const afterPhase = position === "perRetry" ? "Sign" : void 0;
        this.pipeline.addPolicy(policy, {
          afterPhase
        });
      }
    }
  }
  /**
   * Send the provided httpRequest.
   */
  async sendRequest(request) {
    return this.pipeline.sendRequest(this._httpClient, request);
  }
  /**
   * Send an HTTP request that is populated using the provided OperationSpec.
   * @typeParam T - The typed result of the request, based on the OperationSpec.
   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
   * @param operationSpec - The OperationSpec to use to populate the httpRequest.
   */
  async sendOperationRequest(operationArguments, operationSpec) {
    const endpoint2 = operationSpec.baseUrl || this._endpoint;
    if (!endpoint2) {
      throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
    }
    const url = getRequestUrl(endpoint2, operationSpec, operationArguments, this);
    const request = createPipelineRequest({
      url
    });
    request.method = operationSpec.httpMethod;
    const operationInfo = getOperationRequestInfo(request);
    operationInfo.operationSpec = operationSpec;
    operationInfo.operationArguments = operationArguments;
    const contentType2 = operationSpec.contentType || this._requestContentType;
    if (contentType2 && operationSpec.requestBody) {
      request.headers.set("Content-Type", contentType2);
    }
    const options = operationArguments.options;
    if (options) {
      const requestOptions = options.requestOptions;
      if (requestOptions) {
        if (requestOptions.timeout) {
          request.timeout = requestOptions.timeout;
        }
        if (requestOptions.onUploadProgress) {
          request.onUploadProgress = requestOptions.onUploadProgress;
        }
        if (requestOptions.onDownloadProgress) {
          request.onDownloadProgress = requestOptions.onDownloadProgress;
        }
        if (requestOptions.shouldDeserialize !== void 0) {
          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
        }
        if (requestOptions.allowInsecureConnection) {
          request.allowInsecureConnection = true;
        }
      }
      if (options.abortSignal) {
        request.abortSignal = options.abortSignal;
      }
      if (options.tracingOptions) {
        request.tracingOptions = options.tracingOptions;
      }
    }
    if (this._allowInsecureConnection) {
      request.allowInsecureConnection = true;
    }
    if (request.streamResponseStatusCodes === void 0) {
      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
    }
    try {
      const rawResponse = await this.sendRequest(request);
      const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
      if (options === null || options === void 0 ? void 0 : options.onResponse) {
        options.onResponse(rawResponse, flatResponse);
      }
      return flatResponse;
    } catch (error) {
      if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
        const rawResponse = error.response;
        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
        error.details = flatResponse;
        if (options === null || options === void 0 ? void 0 : options.onResponse) {
          options.onResponse(rawResponse, flatResponse, error);
        }
      }
      throw error;
    }
  }
};
function createDefaultPipeline(options) {
  const credentialScopes = getCredentialScopes(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    const scopes = options.credentialScopes;
    return Array.isArray(scopes) ? scopes.map((scope) => new URL(scope).toString()) : new URL(scopes).toString();
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/mappers.js
var mappers_exports = {};
__export(mappers_exports, {
  AddChatParticipantsRequest: () => AddChatParticipantsRequest,
  AddChatParticipantsResult: () => AddChatParticipantsResult,
  ChatError: () => ChatError,
  ChatMessage: () => ChatMessage,
  ChatMessageContent: () => ChatMessageContent,
  ChatMessageReadReceipt: () => ChatMessageReadReceipt,
  ChatMessageReadReceiptsCollection: () => ChatMessageReadReceiptsCollection,
  ChatMessagesCollection: () => ChatMessagesCollection,
  ChatParticipant: () => ChatParticipant,
  ChatParticipantsCollection: () => ChatParticipantsCollection,
  ChatThreadItem: () => ChatThreadItem,
  ChatThreadProperties: () => ChatThreadProperties,
  ChatThreadsItemCollection: () => ChatThreadsItemCollection,
  CommunicationErrorResponse: () => CommunicationErrorResponse,
  CommunicationIdentifierModel: () => CommunicationIdentifierModel,
  CommunicationUserIdentifierModel: () => CommunicationUserIdentifierModel,
  CreateChatThreadRequest: () => CreateChatThreadRequest,
  CreateChatThreadResult: () => CreateChatThreadResult,
  MicrosoftTeamsUserIdentifierModel: () => MicrosoftTeamsUserIdentifierModel,
  PhoneNumberIdentifierModel: () => PhoneNumberIdentifierModel,
  SendChatMessageRequest: () => SendChatMessageRequest,
  SendChatMessageResult: () => SendChatMessageResult,
  SendReadReceiptRequest: () => SendReadReceiptRequest,
  SendTypingNotificationRequest: () => SendTypingNotificationRequest,
  UpdateChatMessageRequest: () => UpdateChatMessageRequest,
  UpdateChatThreadRequest: () => UpdateChatThreadRequest
});
var ChatMessageReadReceiptsCollection = {
  type: {
    name: "Composite",
    className: "ChatMessageReadReceiptsCollection",
    modelProperties: {
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatMessageReadReceipt"
            }
          }
        }
      },
      nextLink: {
        serializedName: "nextLink",
        readOnly: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var ChatMessageReadReceipt = {
  type: {
    name: "Composite",
    className: "ChatMessageReadReceipt",
    modelProperties: {
      senderCommunicationIdentifier: {
        serializedName: "senderCommunicationIdentifier",
        type: {
          name: "Composite",
          className: "CommunicationIdentifierModel"
        }
      },
      chatMessageId: {
        serializedName: "chatMessageId",
        required: true,
        type: {
          name: "String"
        }
      },
      readOn: {
        serializedName: "readOn",
        required: true,
        type: {
          name: "DateTime"
        }
      }
    }
  }
};
var CommunicationIdentifierModel = {
  type: {
    name: "Composite",
    className: "CommunicationIdentifierModel",
    modelProperties: {
      rawId: {
        serializedName: "rawId",
        type: {
          name: "String"
        }
      },
      communicationUser: {
        serializedName: "communicationUser",
        type: {
          name: "Composite",
          className: "CommunicationUserIdentifierModel"
        }
      },
      phoneNumber: {
        serializedName: "phoneNumber",
        type: {
          name: "Composite",
          className: "PhoneNumberIdentifierModel"
        }
      },
      microsoftTeamsUser: {
        serializedName: "microsoftTeamsUser",
        type: {
          name: "Composite",
          className: "MicrosoftTeamsUserIdentifierModel"
        }
      }
    }
  }
};
var CommunicationUserIdentifierModel = {
  type: {
    name: "Composite",
    className: "CommunicationUserIdentifierModel",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var PhoneNumberIdentifierModel = {
  type: {
    name: "Composite",
    className: "PhoneNumberIdentifierModel",
    modelProperties: {
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var MicrosoftTeamsUserIdentifierModel = {
  type: {
    name: "Composite",
    className: "MicrosoftTeamsUserIdentifierModel",
    modelProperties: {
      userId: {
        serializedName: "userId",
        required: true,
        type: {
          name: "String"
        }
      },
      isAnonymous: {
        serializedName: "isAnonymous",
        type: {
          name: "Boolean"
        }
      },
      cloud: {
        serializedName: "cloud",
        type: {
          name: "String"
        }
      }
    }
  }
};
var CommunicationErrorResponse = {
  type: {
    name: "Composite",
    className: "CommunicationErrorResponse",
    modelProperties: {
      error: {
        serializedName: "error",
        type: {
          name: "Composite",
          className: "ChatError"
        }
      }
    }
  }
};
var ChatError = {
  type: {
    name: "Composite",
    className: "ChatError",
    modelProperties: {
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      message: {
        serializedName: "message",
        required: true,
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        readOnly: true,
        type: {
          name: "String"
        }
      },
      details: {
        serializedName: "details",
        readOnly: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatError"
            }
          }
        }
      },
      innerError: {
        serializedName: "innererror",
        type: {
          name: "Composite",
          className: "ChatError"
        }
      }
    }
  }
};
var SendReadReceiptRequest = {
  type: {
    name: "Composite",
    className: "SendReadReceiptRequest",
    modelProperties: {
      chatMessageId: {
        serializedName: "chatMessageId",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var SendChatMessageRequest = {
  type: {
    name: "Composite",
    className: "SendChatMessageRequest",
    modelProperties: {
      content: {
        serializedName: "content",
        required: true,
        type: {
          name: "String"
        }
      },
      senderDisplayName: {
        serializedName: "senderDisplayName",
        type: {
          name: "String"
        }
      },
      type: {
        serializedName: "type",
        type: {
          name: "Enum",
          allowedValues: [
            "text",
            "html",
            "topicUpdated",
            "participantAdded",
            "participantRemoved"
          ]
        }
      },
      metadata: {
        serializedName: "metadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      }
    }
  }
};
var SendChatMessageResult = {
  type: {
    name: "Composite",
    className: "SendChatMessageResult",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var ChatMessagesCollection = {
  type: {
    name: "Composite",
    className: "ChatMessagesCollection",
    modelProperties: {
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatMessage"
            }
          }
        }
      },
      nextLink: {
        serializedName: "nextLink",
        readOnly: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var ChatMessage = {
  type: {
    name: "Composite",
    className: "ChatMessage",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: [
            "text",
            "html",
            "topicUpdated",
            "participantAdded",
            "participantRemoved"
          ]
        }
      },
      sequenceId: {
        serializedName: "sequenceId",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      content: {
        serializedName: "content",
        type: {
          name: "Composite",
          className: "ChatMessageContent"
        }
      },
      senderDisplayName: {
        serializedName: "senderDisplayName",
        type: {
          name: "String"
        }
      },
      createdOn: {
        serializedName: "createdOn",
        required: true,
        type: {
          name: "DateTime"
        }
      },
      senderCommunicationIdentifier: {
        serializedName: "senderCommunicationIdentifier",
        type: {
          name: "Composite",
          className: "CommunicationIdentifierModel"
        }
      },
      deletedOn: {
        serializedName: "deletedOn",
        type: {
          name: "DateTime"
        }
      },
      editedOn: {
        serializedName: "editedOn",
        type: {
          name: "DateTime"
        }
      },
      metadata: {
        serializedName: "metadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      }
    }
  }
};
var ChatMessageContent = {
  type: {
    name: "Composite",
    className: "ChatMessageContent",
    modelProperties: {
      message: {
        serializedName: "message",
        type: {
          name: "String"
        }
      },
      topic: {
        serializedName: "topic",
        type: {
          name: "String"
        }
      },
      participants: {
        serializedName: "participants",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatParticipant"
            }
          }
        }
      },
      initiatorCommunicationIdentifier: {
        serializedName: "initiatorCommunicationIdentifier",
        type: {
          name: "Composite",
          className: "CommunicationIdentifierModel"
        }
      }
    }
  }
};
var ChatParticipant = {
  type: {
    name: "Composite",
    className: "ChatParticipant",
    modelProperties: {
      communicationIdentifier: {
        serializedName: "communicationIdentifier",
        type: {
          name: "Composite",
          className: "CommunicationIdentifierModel"
        }
      },
      displayName: {
        serializedName: "displayName",
        type: {
          name: "String"
        }
      },
      shareHistoryTime: {
        serializedName: "shareHistoryTime",
        type: {
          name: "DateTime"
        }
      }
    }
  }
};
var UpdateChatMessageRequest = {
  type: {
    name: "Composite",
    className: "UpdateChatMessageRequest",
    modelProperties: {
      content: {
        serializedName: "content",
        type: {
          name: "String"
        }
      },
      metadata: {
        serializedName: "metadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      }
    }
  }
};
var ChatParticipantsCollection = {
  type: {
    name: "Composite",
    className: "ChatParticipantsCollection",
    modelProperties: {
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatParticipant"
            }
          }
        }
      },
      nextLink: {
        serializedName: "nextLink",
        readOnly: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var AddChatParticipantsRequest = {
  type: {
    name: "Composite",
    className: "AddChatParticipantsRequest",
    modelProperties: {
      participants: {
        serializedName: "participants",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatParticipant"
            }
          }
        }
      }
    }
  }
};
var AddChatParticipantsResult = {
  type: {
    name: "Composite",
    className: "AddChatParticipantsResult",
    modelProperties: {
      invalidParticipants: {
        serializedName: "invalidParticipants",
        readOnly: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatError"
            }
          }
        }
      }
    }
  }
};
var CreateChatThreadRequest = {
  type: {
    name: "Composite",
    className: "CreateChatThreadRequest",
    modelProperties: {
      topic: {
        serializedName: "topic",
        required: true,
        type: {
          name: "String"
        }
      },
      participants: {
        serializedName: "participants",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatParticipant"
            }
          }
        }
      }
    }
  }
};
var CreateChatThreadResult = {
  type: {
    name: "Composite",
    className: "CreateChatThreadResult",
    modelProperties: {
      chatThread: {
        serializedName: "chatThread",
        type: {
          name: "Composite",
          className: "ChatThreadProperties"
        }
      },
      invalidParticipants: {
        serializedName: "invalidParticipants",
        readOnly: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatError"
            }
          }
        }
      }
    }
  }
};
var ChatThreadProperties = {
  type: {
    name: "Composite",
    className: "ChatThreadProperties",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      topic: {
        serializedName: "topic",
        required: true,
        type: {
          name: "String"
        }
      },
      createdOn: {
        serializedName: "createdOn",
        required: true,
        type: {
          name: "DateTime"
        }
      },
      createdByCommunicationIdentifier: {
        serializedName: "createdByCommunicationIdentifier",
        type: {
          name: "Composite",
          className: "CommunicationIdentifierModel"
        }
      },
      deletedOn: {
        serializedName: "deletedOn",
        type: {
          name: "DateTime"
        }
      }
    }
  }
};
var ChatThreadsItemCollection = {
  type: {
    name: "Composite",
    className: "ChatThreadsItemCollection",
    modelProperties: {
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ChatThreadItem"
            }
          }
        }
      },
      nextLink: {
        serializedName: "nextLink",
        readOnly: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var ChatThreadItem = {
  type: {
    name: "Composite",
    className: "ChatThreadItem",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      topic: {
        serializedName: "topic",
        required: true,
        type: {
          name: "String"
        }
      },
      deletedOn: {
        serializedName: "deletedOn",
        type: {
          name: "DateTime"
        }
      },
      lastMessageReceivedOn: {
        serializedName: "lastMessageReceivedOn",
        readOnly: true,
        type: {
          name: "DateTime"
        }
      }
    }
  }
};
var UpdateChatThreadRequest = {
  type: {
    name: "Composite",
    className: "UpdateChatThreadRequest",
    modelProperties: {
      topic: {
        serializedName: "topic",
        type: {
          name: "String"
        }
      }
    }
  }
};
var SendTypingNotificationRequest = {
  type: {
    name: "Composite",
    className: "SendTypingNotificationRequest",
    modelProperties: {
      senderDisplayName: {
        serializedName: "senderDisplayName",
        type: {
          name: "String"
        }
      }
    }
  }
};

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/parameters.js
var accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
var endpoint = {
  parameterPath: "endpoint",
  mapper: {
    serializedName: "endpoint",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
var chatThreadId = {
  parameterPath: "chatThreadId",
  mapper: {
    serializedName: "chatThreadId",
    required: true,
    type: {
      name: "String"
    }
  }
};
var maxPageSize = {
  parameterPath: ["options", "maxPageSize"],
  mapper: {
    serializedName: "maxPageSize",
    type: {
      name: "Number"
    }
  }
};
var skip = {
  parameterPath: ["options", "skip"],
  mapper: {
    serializedName: "skip",
    type: {
      name: "Number"
    }
  }
};
var apiVersion = {
  parameterPath: "apiVersion",
  mapper: {
    defaultValue: "2021-09-07",
    isConstant: true,
    serializedName: "api-version",
    type: {
      name: "String"
    }
  }
};
var contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
var sendReadReceiptRequest = {
  parameterPath: "sendReadReceiptRequest",
  mapper: SendReadReceiptRequest
};
var sendChatMessageRequest = {
  parameterPath: "sendChatMessageRequest",
  mapper: SendChatMessageRequest
};
var startTime = {
  parameterPath: ["options", "startTime"],
  mapper: {
    serializedName: "startTime",
    type: {
      name: "DateTime"
    }
  }
};
var chatMessageId = {
  parameterPath: "chatMessageId",
  mapper: {
    serializedName: "chatMessageId",
    required: true,
    type: {
      name: "String"
    }
  }
};
var contentType1 = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/merge-patch+json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
var updateChatMessageRequest = {
  parameterPath: "updateChatMessageRequest",
  mapper: UpdateChatMessageRequest
};
var participantCommunicationIdentifier = {
  parameterPath: "participantCommunicationIdentifier",
  mapper: CommunicationIdentifierModel
};
var addChatParticipantsRequest = {
  parameterPath: "addChatParticipantsRequest",
  mapper: AddChatParticipantsRequest
};
var updateChatThreadRequest = {
  parameterPath: "updateChatThreadRequest",
  mapper: UpdateChatThreadRequest
};
var sendTypingNotificationRequest = {
  parameterPath: ["options", "sendTypingNotificationRequest"],
  mapper: SendTypingNotificationRequest
};
var nextLink = {
  parameterPath: "nextLink",
  mapper: {
    serializedName: "nextLink",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
var createChatThreadRequest = {
  parameterPath: "createChatThreadRequest",
  mapper: CreateChatThreadRequest
};
var repeatabilityRequestId = {
  parameterPath: ["options", "repeatabilityRequestId"],
  mapper: {
    serializedName: "repeatability-request-id",
    type: {
      name: "String"
    }
  }
};

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/chatThread.js
var ChatThreadImpl = class {
  /**
   * Initialize a new instance of the class ChatThread class.
   * @param client Reference to the service client
   */
  constructor(client) {
    this.client = client;
  }
  /**
   * Gets chat message read receipts for a thread.
   * @param chatThreadId Thread id to get the chat message read receipts for.
   * @param options The options parameters.
   */
  listChatReadReceipts(chatThreadId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, listChatReadReceiptsOperationSpec);
  }
  /**
   * Sends a read receipt event to a thread, on behalf of a user.
   * @param chatThreadId Thread id to send the read receipt event to.
   * @param sendReadReceiptRequest Read receipt details.
   * @param options The options parameters.
   */
  sendChatReadReceipt(chatThreadId2, sendReadReceiptRequest2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, sendReadReceiptRequest: sendReadReceiptRequest2, options }, sendChatReadReceiptOperationSpec);
  }
  /**
   * Sends a message to a thread.
   * @param chatThreadId The thread id to send the message to.
   * @param sendChatMessageRequest Details of the message to send.
   * @param options The options parameters.
   */
  sendChatMessage(chatThreadId2, sendChatMessageRequest2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, sendChatMessageRequest: sendChatMessageRequest2, options }, sendChatMessageOperationSpec);
  }
  /**
   * Gets a list of messages from a thread.
   * @param chatThreadId The thread id of the message.
   * @param options The options parameters.
   */
  listChatMessages(chatThreadId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, listChatMessagesOperationSpec);
  }
  /**
   * Gets a message by id.
   * @param chatThreadId The thread id to which the message was sent.
   * @param chatMessageId The message id.
   * @param options The options parameters.
   */
  getChatMessage(chatThreadId2, chatMessageId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, chatMessageId: chatMessageId2, options }, getChatMessageOperationSpec);
  }
  /**
   * Updates a message.
   * @param chatThreadId The thread id to which the message was sent.
   * @param chatMessageId The message id.
   * @param updateChatMessageRequest Details of the request to update the message.
   * @param options The options parameters.
   */
  updateChatMessage(chatThreadId2, chatMessageId2, updateChatMessageRequest2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, chatMessageId: chatMessageId2, updateChatMessageRequest: updateChatMessageRequest2, options }, updateChatMessageOperationSpec);
  }
  /**
   * Deletes a message.
   * @param chatThreadId The thread id to which the message was sent.
   * @param chatMessageId The message id.
   * @param options The options parameters.
   */
  deleteChatMessage(chatThreadId2, chatMessageId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, chatMessageId: chatMessageId2, options }, deleteChatMessageOperationSpec);
  }
  /**
   * Gets the participants of a thread.
   * @param chatThreadId Thread id to get participants for.
   * @param options The options parameters.
   */
  listChatParticipants(chatThreadId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, listChatParticipantsOperationSpec);
  }
  /**
   * Remove a participant from a thread.
   * @param chatThreadId Thread id to remove the participant from.
   * @param participantCommunicationIdentifier Id of the thread participant to remove from the thread.
   * @param options The options parameters.
   */
  removeChatParticipant(chatThreadId2, participantCommunicationIdentifier2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, participantCommunicationIdentifier: participantCommunicationIdentifier2, options }, removeChatParticipantOperationSpec);
  }
  /**
   * Adds thread participants to a thread. If participants already exist, no change occurs.
   * @param chatThreadId Id of the thread to add participants to.
   * @param addChatParticipantsRequest Thread participants to be added to the thread.
   * @param options The options parameters.
   */
  addChatParticipants(chatThreadId2, addChatParticipantsRequest2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, addChatParticipantsRequest: addChatParticipantsRequest2, options }, addChatParticipantsOperationSpec);
  }
  /**
   * Updates a thread's properties.
   * @param chatThreadId The id of the thread to update.
   * @param updateChatThreadRequest Request payload for updating a chat thread.
   * @param options The options parameters.
   */
  updateChatThreadProperties(chatThreadId2, updateChatThreadRequest2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, updateChatThreadRequest: updateChatThreadRequest2, options }, updateChatThreadPropertiesOperationSpec);
  }
  /**
   * Gets a chat thread's properties.
   * @param chatThreadId Id of the thread.
   * @param options The options parameters.
   */
  getChatThreadProperties(chatThreadId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, getChatThreadPropertiesOperationSpec);
  }
  /**
   * Posts a typing event to a thread, on behalf of a user.
   * @param chatThreadId Id of the thread.
   * @param options The options parameters.
   */
  sendTypingNotification(chatThreadId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, sendTypingNotificationOperationSpec);
  }
  /**
   * ListChatReadReceiptsNext
   * @param chatThreadId Thread id to get the chat message read receipts for.
   * @param nextLink The nextLink from the previous successful call to the ListChatReadReceipts method.
   * @param options The options parameters.
   */
  listChatReadReceiptsNext(chatThreadId2, nextLink2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, nextLink: nextLink2, options }, listChatReadReceiptsNextOperationSpec);
  }
  /**
   * ListChatMessagesNext
   * @param chatThreadId The thread id of the message.
   * @param nextLink The nextLink from the previous successful call to the ListChatMessages method.
   * @param options The options parameters.
   */
  listChatMessagesNext(chatThreadId2, nextLink2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, nextLink: nextLink2, options }, listChatMessagesNextOperationSpec);
  }
  /**
   * ListChatParticipantsNext
   * @param chatThreadId Thread id to get participants for.
   * @param nextLink The nextLink from the previous successful call to the ListChatParticipants method.
   * @param options The options parameters.
   */
  listChatParticipantsNext(chatThreadId2, nextLink2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, nextLink: nextLink2, options }, listChatParticipantsNextOperationSpec);
  }
};
var serializer = createSerializer(
  mappers_exports,
  /* isXml */
  false
);
var listChatReadReceiptsOperationSpec = {
  path: "/chat/threads/{chatThreadId}/readReceipts",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatMessageReadReceiptsCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    skip,
    apiVersion
  ],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept],
  serializer
};
var sendChatReadReceiptOperationSpec = {
  path: "/chat/threads/{chatThreadId}/readReceipts",
  httpMethod: "POST",
  responses: {
    200: {},
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: sendReadReceiptRequest,
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
var sendChatMessageOperationSpec = {
  path: "/chat/threads/{chatThreadId}/messages",
  httpMethod: "POST",
  responses: {
    201: {
      bodyMapper: SendChatMessageResult
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: sendChatMessageRequest,
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
var listChatMessagesOperationSpec = {
  path: "/chat/threads/{chatThreadId}/messages",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatMessagesCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    apiVersion,
    startTime
  ],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept],
  serializer
};
var getChatMessageOperationSpec = {
  path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatMessage
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [apiVersion],
  urlParameters: [
    endpoint,
    chatThreadId,
    chatMessageId
  ],
  headerParameters: [accept],
  serializer
};
var updateChatMessageOperationSpec = {
  path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
  httpMethod: "PATCH",
  responses: {
    204: {},
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: updateChatMessageRequest,
  queryParameters: [apiVersion],
  urlParameters: [
    endpoint,
    chatThreadId,
    chatMessageId
  ],
  headerParameters: [accept, contentType1],
  mediaType: "json",
  serializer
};
var deleteChatMessageOperationSpec = {
  path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [apiVersion],
  urlParameters: [
    endpoint,
    chatThreadId,
    chatMessageId
  ],
  headerParameters: [accept],
  serializer
};
var listChatParticipantsOperationSpec = {
  path: "/chat/threads/{chatThreadId}/participants",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatParticipantsCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    skip,
    apiVersion
  ],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept],
  serializer
};
var removeChatParticipantOperationSpec = {
  path: "/chat/threads/{chatThreadId}/participants/:remove",
  httpMethod: "POST",
  responses: {
    204: {},
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: participantCommunicationIdentifier,
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
var addChatParticipantsOperationSpec = {
  path: "/chat/threads/{chatThreadId}/participants/:add",
  httpMethod: "POST",
  responses: {
    201: {
      bodyMapper: AddChatParticipantsResult
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: addChatParticipantsRequest,
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
var updateChatThreadPropertiesOperationSpec = {
  path: "/chat/threads/{chatThreadId}",
  httpMethod: "PATCH",
  responses: {
    204: {},
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: updateChatThreadRequest,
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept, contentType1],
  mediaType: "json",
  serializer
};
var getChatThreadPropertiesOperationSpec = {
  path: "/chat/threads/{chatThreadId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatThreadProperties
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept],
  serializer
};
var sendTypingNotificationOperationSpec = {
  path: "/chat/threads/{chatThreadId}/typing",
  httpMethod: "POST",
  responses: {
    200: {},
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: sendTypingNotificationRequest,
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
var listChatReadReceiptsNextOperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatMessageReadReceiptsCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    skip,
    apiVersion
  ],
  urlParameters: [
    endpoint,
    chatThreadId,
    nextLink
  ],
  headerParameters: [accept],
  serializer
};
var listChatMessagesNextOperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatMessagesCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    apiVersion,
    startTime
  ],
  urlParameters: [
    endpoint,
    chatThreadId,
    nextLink
  ],
  headerParameters: [accept],
  serializer
};
var listChatParticipantsNextOperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatParticipantsCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    skip,
    apiVersion
  ],
  urlParameters: [
    endpoint,
    chatThreadId,
    nextLink
  ],
  headerParameters: [accept],
  serializer
};

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/chat.js
var ChatImpl = class {
  /**
   * Initialize a new instance of the class Chat class.
   * @param client Reference to the service client
   */
  constructor(client) {
    this.client = client;
  }
  /**
   * Creates a chat thread.
   * @param createChatThreadRequest Request payload for creating a chat thread.
   * @param options The options parameters.
   */
  createChatThread(createChatThreadRequest2, options) {
    return this.client.sendOperationRequest({ createChatThreadRequest: createChatThreadRequest2, options }, createChatThreadOperationSpec);
  }
  /**
   * Gets the list of chat threads of a user.
   * @param options The options parameters.
   */
  listChatThreads(options) {
    return this.client.sendOperationRequest({ options }, listChatThreadsOperationSpec);
  }
  /**
   * Deletes a thread.
   * @param chatThreadId Id of the thread to be deleted.
   * @param options The options parameters.
   */
  deleteChatThread(chatThreadId2, options) {
    return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, deleteChatThreadOperationSpec);
  }
  /**
   * ListChatThreadsNext
   * @param nextLink The nextLink from the previous successful call to the ListChatThreads method.
   * @param options The options parameters.
   */
  listChatThreadsNext(nextLink2, options) {
    return this.client.sendOperationRequest({ nextLink: nextLink2, options }, listChatThreadsNextOperationSpec);
  }
};
var serializer2 = createSerializer(
  mappers_exports,
  /* isXml */
  false
);
var createChatThreadOperationSpec = {
  path: "/chat/threads",
  httpMethod: "POST",
  responses: {
    201: {
      bodyMapper: CreateChatThreadResult
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: createChatThreadRequest,
  queryParameters: [apiVersion],
  urlParameters: [endpoint],
  headerParameters: [
    accept,
    contentType,
    repeatabilityRequestId
  ],
  mediaType: "json",
  serializer: serializer2
};
var listChatThreadsOperationSpec = {
  path: "/chat/threads",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatThreadsItemCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    apiVersion,
    startTime
  ],
  urlParameters: [endpoint],
  headerParameters: [accept],
  serializer: serializer2
};
var deleteChatThreadOperationSpec = {
  path: "/chat/threads/{chatThreadId}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [apiVersion],
  urlParameters: [endpoint, chatThreadId],
  headerParameters: [accept],
  serializer: serializer2
};
var listChatThreadsNextOperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ChatThreadsItemCollection
    },
    401: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    maxPageSize,
    apiVersion,
    startTime
  ],
  urlParameters: [endpoint, nextLink],
  headerParameters: [accept],
  serializer: serializer2
};

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/chatApiClient.js
var ChatApiClient = class extends ServiceClient {
  /**
   * Initializes a new instance of the ChatApiClient class.
   * @param endpoint The endpoint of the Azure Communication resource.
   * @param options The parameter options
   */
  constructor(endpoint2, options) {
    var _a2, _b;
    if (endpoint2 === void 0) {
      throw new Error("'endpoint' cannot be null");
    }
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-communication-chat/1.2.0`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
      userAgentPrefix
    }, baseUri: (_b = (_a2 = options.endpoint) !== null && _a2 !== void 0 ? _a2 : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
    super(optionsWithDefaults);
    this.endpoint = endpoint2;
    this.apiVersion = options.apiVersion || "2021-09-07";
    this.chatThread = new ChatThreadImpl(this);
    this.chat = new ChatImpl(this);
  }
};

// node_modules/@azure/communication-chat/dist-esm/src/chatThreadClient.js
init_tslib_es6();

// node_modules/@azure/communication-chat/dist-esm/src/models/logger.js
init_src();
var logger2 = createClientLogger("communication-chat");

// node_modules/@azure/communication-chat/dist-esm/src/chatThreadClient.js
init_src5();

// node_modules/@azure/communication-chat/dist-esm/src/tracing.js
init_src5();
var createSpan = createSpanFunction({
  packagePrefix: "Azure.Communication",
  namespace: "Microsoft.Communication"
});

// node_modules/@azure/communication-chat/dist-esm/src/credential/communicationTokenCredentialPolicy.js
var createCommunicationTokenCredentialPolicy = (credential) => {
  const policyOptions = {
    credential: {
      getToken: (_scopes, options) => credential.getToken({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal })
    },
    scopes: []
  };
  return bearerTokenAuthenticationPolicy(policyOptions);
};

// node_modules/@azure/communication-chat/dist-esm/src/chatThreadClient.js
var minimumTypingIntervalInMilliSeconds = 8e3;
var ChatThreadClient = class {
  constructor(endpoint2, threadId, credential, options = {}) {
    this.endpoint = endpoint2;
    this.timeOfLastTypingRequest = void 0;
    this.threadId = threadId;
    this.tokenCredential = credential;
    const internalPipelineOptions = Object.assign(Object.assign({}, options), {
      loggingOptions: {
        logger: logger2.info
      }
    });
    this.client = new ChatApiClient(this.endpoint, Object.assign({ endpoint: this.endpoint }, internalPipelineOptions));
    const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
    this.client.pipeline.addPolicy(authPolicy);
  }
  /**
   * Gets a chat thread.
   * Returns the chat thread.
   * @param options -  Operation options.
   */
  async getProperties(options = {}) {
    const { span, updatedOptions } = createSpan("ChatClient-GetProperties", options);
    try {
      const result = await this.client.chatThread.getChatThreadProperties(this.threadId, updatedOptions);
      return mapToChatThreadPropertiesSdkModel(result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Updates a thread's topic.
   * @param topic - The topic needs to be updated to.
   * @param options - Operation options.
   */
  async updateTopic(topic, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-UpdateTopic", options);
    try {
      await this.client.chatThread.updateChatThreadProperties(this.threadId, { topic }, updatedOptions);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Sends a chat message to a thread identified by threadId.
   * Returns the id of the created message.
   * @param request - Request for sending a message.
   * @param options - Operation options.
   */
  async sendMessage(request, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-SendMessage", options);
    try {
      this.timeOfLastTypingRequest = void 0;
      const result = await this.client.chatThread.sendChatMessage(this.threadId, Object.assign(Object.assign({}, request), options), updatedOptions);
      return result;
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Gets a chat message identified by messageId.
   * Returns the specific message.
   * @param messageId - The message id of the message.
   * @param options - Operation options.
   */
  async getMessage(messageId, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-GetMessage", options);
    try {
      const result = await this.client.chatThread.getChatMessage(this.threadId, messageId, updatedOptions);
      return mapToChatMessageSdkModel(result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  listMessagesPage(pageSettings, options = {}) {
    return __asyncGenerator(this, arguments, function* listMessagesPage_1() {
      if (!pageSettings.continuationToken) {
        const currentSetResponse = yield __await(this.client.chatThread.listChatMessages(this.threadId, options));
        pageSettings.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
        }
      }
      while (pageSettings.continuationToken) {
        const currentSetResponse = yield __await(this.client.chatThread.listChatMessagesNext(this.threadId, pageSettings.continuationToken, options));
        pageSettings.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
        } else {
          break;
        }
      }
    });
  }
  listMessagesAll(options) {
    return __asyncGenerator(this, arguments, function* listMessagesAll_1() {
      var e_1, _a2;
      try {
        for (var _b = __asyncValues(this.listMessagesPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
          const page = _c.value;
          yield __await(yield* __asyncDelegator(__asyncValues(page)));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield __await(_a2.call(_b));
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
  }
  /**
   * Gets a list of message from a thread identified by threadId.
   * Returns the list of the messages.
   * @param options - Get messages options.
   */
  listMessages(options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-ListMessages", options);
    try {
      const iter = this.listMessagesAll(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listMessagesPage(settings, updatedOptions);
        }
      };
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Deletes a message identified by threadId and messageId
   * @param messageId - The message id of the message.
   * @param options - Operation options.
   */
  async deleteMessage(messageId, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-DeleteMessage", options);
    try {
      await this.client.chatThread.deleteChatMessage(this.threadId, messageId, updatedOptions);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Updates a message identified by threadId and messageId
   * @param messageId - The message id of the message.
   * @param options - Operation options.
   */
  async updateMessage(messageId, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-UpdateMessage", options);
    try {
      await this.client.chatThread.updateChatMessage(this.threadId, messageId, options, updatedOptions);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Adds the details of chat participants belonging to the thread identified by threadId.
   * @param request - Thread participants' details to add in the thread roster
   * @param options - Operation options.
   */
  async addParticipants(request, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-AddParticipants", options);
    try {
      const result = await this.client.chatThread.addChatParticipants(this.threadId, mapToAddChatParticipantsRequestRestModel(request), updatedOptions);
      return result;
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  listParticipantsPage(continuationState, options = {}) {
    return __asyncGenerator(this, arguments, function* listParticipantsPage_1() {
      if (!continuationState.continuationToken) {
        const currentSetResponse = yield __await(this.client.chatThread.listChatParticipants(this.threadId, options));
        continuationState.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
        }
      }
      while (continuationState.continuationToken) {
        const currentSetResponse = yield __await(this.client.chatThread.listChatParticipantsNext(this.threadId, continuationState.continuationToken, options));
        continuationState.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
        } else {
          break;
        }
      }
    });
  }
  listParticipantsAll(options) {
    return __asyncGenerator(this, arguments, function* listParticipantsAll_1() {
      var e_2, _a2;
      try {
        for (var _b = __asyncValues(this.listParticipantsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
          const page = _c.value;
          yield __await(yield* __asyncDelegator(__asyncValues(page)));
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield __await(_a2.call(_b));
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    });
  }
  /**
   * Gets the participants of the thread identified by threadId.
   * Returns the lists of the participants.
   * @param options - Operation options.
   */
  listParticipants(options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-ListParticipants", options);
    try {
      const iter = this.listParticipantsAll(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listParticipantsPage(settings, updatedOptions);
        }
      };
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Removes participant from the thread identified by threadId.
   * @param participant - Thread participant to remove from the thread roster
   * @param options - Operation options.
   */
  async removeParticipant(participant, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-RemoveParticipant", options);
    try {
      await this.client.chatThread.removeChatParticipant(this.threadId, serializeCommunicationIdentifier(participant), updatedOptions);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Sends a typing notification to the thread.
   * Doesn't attempt to send if the time since last notification is smaller than the minimum typing interval
   * @param options - - Operation options
   * @returns True if the typing message notification could be sent, otherwise false.
   */
  async sendTypingNotification(options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-SendTypingNotification", options);
    try {
      const dateNow = new Date();
      const { senderDisplayName } = updatedOptions, restOptions = __rest(updatedOptions, ["senderDisplayName"]);
      if (this.canPostTypingNotification(dateNow)) {
        this.timeOfLastTypingRequest = dateNow;
        await this.client.chatThread.sendTypingNotification(this.threadId, Object.assign({ sendTypingNotificationRequest: { senderDisplayName } }, restOptions));
        return true;
      }
      logger2.info(`Typing Notification NOT Send. [thread_id=${this.threadId}]`);
      return false;
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Sends a read receipt to the thread identified by threadId.
   * @param messageId - The message id of the message that user latest read.
   * @param request - Request for sending a read receipt
   * @param options - Operation options.
   */
  async sendReadReceipt(request, options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-SendReadReceipt", options);
    try {
      await this.client.chatThread.sendChatReadReceipt(this.threadId, request, updatedOptions);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  listReadReceiptsPage(continuationState, options = {}) {
    return __asyncGenerator(this, arguments, function* listReadReceiptsPage_1() {
      if (!continuationState.continuationToken) {
        const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceipts(this.threadId, options));
        continuationState.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
        }
      }
      while (continuationState.continuationToken) {
        const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceiptsNext(this.threadId, continuationState.continuationToken, options));
        continuationState.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
        } else {
          break;
        }
      }
    });
  }
  listReadReceiptsAll(options) {
    return __asyncGenerator(this, arguments, function* listReadReceiptsAll_1() {
      var e_3, _a2;
      try {
        for (var _b = __asyncValues(this.listReadReceiptsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
          const page = _c.value;
          yield __await(yield* __asyncDelegator(__asyncValues(page)));
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield __await(_a2.call(_b));
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    });
  }
  /**
   * Gets a list of read receipt from a thread identified by threadId.
   * Returns the list of the messages.
   * @param options - Get messages options.
   */
  listReadReceipts(options = {}) {
    const { span, updatedOptions } = createSpan("ChatThreadClient-ListChatReadReceipts", options);
    try {
      const iter = this.listReadReceiptsAll(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listReadReceiptsPage(settings, updatedOptions);
        }
      };
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  canPostTypingNotification(dateNow) {
    if (this.timeOfLastTypingRequest) {
      const timeSinceLastRequestInMilliSeconds = dateNow.getTime() - this.timeOfLastTypingRequest.getTime();
      if (timeSinceLastRequestInMilliSeconds < minimumTypingIntervalInMilliSeconds) {
        logger2.info(`Typing interval check failed. [last_request=${this.timeOfLastTypingRequest}]`);
        return false;
      }
    }
    return true;
  }
};

// node_modules/@azure/communication-chat/dist-esm/src/chatClient.js
var import_events = __toESM(require_events());
init_src5();

// node_modules/@azure/communication-chat/dist-esm/src/models/uuid.js
init_esm_browser();
function generateUuid() {
  return v4_default();
}

// node_modules/@azure/communication-chat/dist-esm/src/signaling/signalingClient.browser.js
var import_communication_signaling = __toESM(require_dist());
var getSignalingClient = (credential, logger4, options) => {
  var _a2;
  return new import_communication_signaling.CommunicationSignalingClient(credential, logger4, {
    environment: (_a2 = options === null || options === void 0 ? void 0 : options.environment) !== null && _a2 !== void 0 ? _a2 : void 0
  });
};

// node_modules/@azure/communication-chat/dist-esm/src/chatClient.js
var ChatClient = class {
  /**
   * Creates an instance of the ChatClient for a given resource and user.
   *
   * @param endpoint - The url of the Communication Services resource.
   * @param credential - The token credential. Use AzureCommunicationTokenCredential from \@azure/communication-common to create a credential.
   * @param options - Additional client options.
   */
  constructor(endpoint2, credential, options = {}) {
    this.endpoint = endpoint2;
    this.signalingClient = void 0;
    this.emitter = new import_events.EventEmitter();
    this.isRealtimeNotificationsStarted = false;
    this.tokenCredential = credential;
    this.clientOptions = Object.assign({}, options);
    const internalPipelineOptions = Object.assign(Object.assign({}, options), {
      loggingOptions: {
        logger: logger2.info
      }
    });
    this.client = new ChatApiClient(this.endpoint, Object.assign({ endpoint: this.endpoint }, internalPipelineOptions));
    const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
    this.client.pipeline.addPolicy(authPolicy);
    this.signalingClient = getSignalingClient(credential, logger2, options.signalingClientOptions);
  }
  /**
   * Returns ChatThreadClient with the specific thread id.
   * @param threadId - Thread ID for the ChatThreadClient
   */
  getChatThreadClient(threadId) {
    return new ChatThreadClient(this.endpoint, threadId, this.tokenCredential, this.clientOptions);
  }
  /**
   * Creates a chat thread.
   * Returns thread client with the id of the created thread.
   * @param request - Request for creating a chat thread.
   * @param options - Operation options.
   */
  async createChatThread(request, options = {}) {
    var _a2, _b;
    const { span, updatedOptions } = createSpan("ChatClient-CreateChatThread", options);
    try {
      updatedOptions.idempotencyToken = (_a2 = updatedOptions.idempotencyToken) !== null && _a2 !== void 0 ? _a2 : generateUuid();
      const updatedRestModelOptions = mapToCreateChatThreadOptionsRestModel(updatedOptions);
      const result = await this.client.chat.createChatThread({
        topic: request.topic,
        participants: (_b = options.participants) === null || _b === void 0 ? void 0 : _b.map((participant) => mapToChatParticipantRestModel(participant))
      }, updatedRestModelOptions);
      return mapToCreateChatThreadResultSdkModel(result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  listChatThreadsPage(continuationState, options = {}) {
    return __asyncGenerator(this, arguments, function* listChatThreadsPage_1() {
      if (!continuationState.continuationToken) {
        const currentSetResponse = yield __await(this.client.chat.listChatThreads(options));
        continuationState.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value);
        }
      }
      while (continuationState.continuationToken) {
        const currentSetResponse = yield __await(this.client.chat.listChatThreadsNext(continuationState.continuationToken, options));
        continuationState.continuationToken = currentSetResponse.nextLink;
        if (currentSetResponse.value) {
          yield yield __await(currentSetResponse.value);
        } else {
          break;
        }
      }
    });
  }
  listChatThreadsAll(options) {
    return __asyncGenerator(this, arguments, function* listChatThreadsAll_1() {
      var e_1, _a2;
      try {
        for (var _b = __asyncValues(this.listChatThreadsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
          const page = _c.value;
          yield __await(yield* __asyncDelegator(__asyncValues(page)));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield __await(_a2.call(_b));
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
  }
  /**
   * Gets the list of chat threads of a user.
   * @param options - List chat threads options.
   */
  listChatThreads(options = {}) {
    const { span, updatedOptions } = createSpan("ChatClient-ListChatThreads", options);
    try {
      const iter = this.listChatThreadsAll(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listChatThreadsPage(settings, updatedOptions);
        }
      };
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Deletes a chat thread.
   * @param threadId - The ID of the thread to delete.
   * @param options -  Operation options.
   */
  async deleteChatThread(threadId, options = {}) {
    const { span, updatedOptions } = createSpan("ChatClient-DeleteChatThread", options);
    try {
      await this.client.chat.deleteChatThread(threadId, updatedOptions);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * Start receiving realtime notifications.
   * Call this function before subscribing to any event.
   */
  async startRealtimeNotifications() {
    if (this.signalingClient === void 0) {
      throw new Error("Realtime notifications are not supported in node js.");
    }
    if (this.isRealtimeNotificationsStarted) {
      return;
    }
    this.isRealtimeNotificationsStarted = true;
    await this.signalingClient.start();
    this.subscribeToSignalingEvents();
  }
  /**
   * Stop receiving realtime notifications.
   * This function would unsubscribe to all events.
   */
  async stopRealtimeNotifications() {
    if (this.signalingClient === void 0) {
      throw new Error("Realtime notifications are not supported in node js.");
    }
    this.isRealtimeNotificationsStarted = false;
    await this.signalingClient.stop();
    this.emitter.removeAllListeners();
  }
  on(event, listener) {
    if (this.signalingClient === void 0) {
      throw new Error("Realtime notifications are only supported in the browser.");
    }
    if (!this.isRealtimeNotificationsStarted && event !== "realTimeNotificationConnected" && event !== "realTimeNotificationDisconnected") {
      throw new Error("You must call startRealtimeNotifications before you can subscribe to events.");
    }
    this.emitter.on(event, listener);
  }
  off(event, listener) {
    if (this.signalingClient === void 0) {
      throw new Error("Realtime notifications are only supported in the browser.");
    }
    this.emitter.removeListener(event, listener);
  }
  subscribeToSignalingEvents() {
    if (this.signalingClient === void 0) {
      throw new Error("Realtime notifications are only supported in the browser.");
    }
    this.signalingClient.on("connectionChanged", (payload) => {
      if (payload === 2) {
        this.emitter.emit("realTimeNotificationConnected");
      } else if (payload === 3) {
        this.emitter.emit("realTimeNotificationDisconnected");
      }
    });
    this.signalingClient.on("chatMessageReceived", (payload) => {
      this.emitter.emit("chatMessageReceived", payload);
    });
    this.signalingClient.on("chatMessageEdited", (payload) => {
      this.emitter.emit("chatMessageEdited", payload);
    });
    this.signalingClient.on("chatMessageDeleted", (payload) => {
      this.emitter.emit("chatMessageDeleted", payload);
    });
    this.signalingClient.on("typingIndicatorReceived", (payload) => {
      this.emitter.emit("typingIndicatorReceived", payload);
    });
    this.signalingClient.on("readReceiptReceived", (payload) => {
      this.emitter.emit("readReceiptReceived", payload);
    });
    this.signalingClient.on("chatThreadCreated", (payload) => {
      this.emitter.emit("chatThreadCreated", payload);
    });
    this.signalingClient.on("chatThreadDeleted", (payload) => {
      this.emitter.emit("chatThreadDeleted", payload);
    });
    this.signalingClient.on("chatThreadPropertiesUpdated", (payload) => {
      this.emitter.emit("chatThreadPropertiesUpdated", payload);
    });
    this.signalingClient.on("participantsAdded", (payload) => {
      this.emitter.emit("participantsAdded", payload);
    });
    this.signalingClient.on("participantsRemoved", (payload) => {
      this.emitter.emit("participantsRemoved", payload);
    });
  }
};

export {
  init_src6 as init_src,
  require_events,
  ChatThreadClient,
  ChatClient
};
//# sourceMappingURL=chunk-T6UFOJTO.js.map
