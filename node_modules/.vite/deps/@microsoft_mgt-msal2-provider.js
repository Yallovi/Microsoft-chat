import {
  InteractionRequiredAuthError,
  PublicClientApplication,
  init_dist
} from "./chunk-5W42CVRY.js";
import {
  IProvider,
  LoginType,
  MgtBaseProvider,
  ProviderState,
  Providers,
  createFromProvider,
  customElement,
  property
} from "./chunk-EVB4GM5G.js";
import "./chunk-TFWDKVI3.js";

// node_modules/@microsoft/mgt-msal2-provider/dist/es6/Msal2Provider.js
init_dist();
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PromptType;
(function(PromptType2) {
  PromptType2["SELECT_ACCOUNT"] = "select_account";
  PromptType2["LOGIN"] = "login";
  PromptType2["CONSENT"] = "consent";
})(PromptType || (PromptType = {}));
var Msal2Provider = class extends IProvider {
  /**
   * Gets the PublicClientApplication Instance
   *
   * @private
   * @type {PublicClientApplication}
   * @memberof Msal2Provider
   */
  get publicClientApplication() {
    return this._publicClientApplication;
  }
  /**
   * Name used for analytics
   *
   * @readonly
   * @memberof IProvider
   */
  get name() {
    return "MgtMsal2Provider";
  }
  constructor(config) {
    super();
    this.sessionStorageRequestedScopesKey = "mgt-requested-scopes";
    this.sessionStorageDeniedScopesKey = "mgt-denied-scopes";
    this.homeAccountKey = "275f3731-e4a4-468a-bf9c-baca24b31e26";
    this.initProvider(config);
  }
  /**
   * Initialize provider with configuration details
   *
   * @private
   * @param {Msal2Config} config
   * @memberof Msal2Provider
   */
  initProvider(config) {
    return __awaiter(this, void 0, void 0, function* () {
      const msalConfig = config.options || { auth: { clientId: "" } };
      this.ms_config = msalConfig;
      this.ms_config.cache = msalConfig.cache || {};
      this.ms_config.cache.cacheLocation = msalConfig.cache.cacheLocation || "localStorage";
      if (typeof this.ms_config.cache.storeAuthStateInCookie === "undefined" || this.ms_config.cache.storeAuthStateInCookie === null) {
        this.ms_config.cache.storeAuthStateInCookie = true;
      }
      this.ms_config.system = msalConfig.system || {};
      this.ms_config.system.iframeHashTimeout = msalConfig.system.iframeHashTimeout || 1e4;
      if (config.authority) {
        this.ms_config.auth.authority = config.authority;
      }
      if (config.redirectUri) {
        this.ms_config.auth.redirectUri = config.redirectUri;
      }
      if ("clientId" in config) {
        if (config.clientId) {
          this.ms_config.auth.clientId = config.clientId;
          this._publicClientApplication = new PublicClientApplication(this.ms_config);
        } else {
          throw new Error("clientId must be provided");
        }
      } else if ("publicClientApplication" in config) {
        if (config.publicClientApplication) {
          this._publicClientApplication = config.publicClientApplication;
        } else {
          throw new Error("publicClientApplication must be provided");
        }
      } else {
        throw new Error("either clientId or publicClientApplication must be provided");
      }
      this._loginType = typeof config.loginType !== "undefined" ? config.loginType : LoginType.Redirect;
      this._loginHint = typeof config.loginHint !== "undefined" ? config.loginHint : null;
      this._sid = typeof config.sid !== "undefined" ? config.sid : null;
      this.isIncrementalConsentDisabled = typeof config.isIncrementalConsentDisabled !== "undefined" ? config.isIncrementalConsentDisabled : false;
      this._domainHint = typeof config.domainHint !== "undefined" ? config.domainHint : null;
      this.scopes = typeof config.scopes !== "undefined" ? config.scopes : ["user.read"];
      this._prompt = typeof config.prompt !== "undefined" ? config.prompt : PromptType.SELECT_ACCOUNT;
      this.graph = createFromProvider(this);
      try {
        const tokenResponse = yield this._publicClientApplication.handleRedirectPromise();
        if (tokenResponse !== null) {
          this.handleResponse(tokenResponse === null || tokenResponse === void 0 ? void 0 : tokenResponse.account);
        } else {
          this.trySilentSignIn();
        }
      } catch (e) {
        throw e;
      }
    });
  }
  /**
   * Attempts to sign in user silently
   *
   * @memberof Msal2Provider
   */
  trySilentSignIn() {
    return __awaiter(this, void 0, void 0, function* () {
      let silentRequest = {
        scopes: this.scopes,
        domainHint: this._domainHint
      };
      if (this._sid || this._loginHint) {
        silentRequest.sid = this._sid;
        silentRequest.loginHint = this._loginHint;
        try {
          this.setState(ProviderState.Loading);
          const response = yield this._publicClientApplication.ssoSilent(silentRequest);
          if (response) {
            this.handleResponse(response === null || response === void 0 ? void 0 : response.account);
          }
        } catch (e) {
          this.setState(ProviderState.SignedOut);
        }
      } else {
        const account = this.getAccount();
        if (account) {
          if (yield this.getAccessToken(null)) {
            this.handleResponse(account);
            return;
          }
        }
        this.setState(ProviderState.SignedOut);
      }
    });
  }
  /**
   * Log in the user
   *
   * @return {*}  {Promise<void>}
   * @memberof Msal2Provider
   */
  login() {
    return __awaiter(this, void 0, void 0, function* () {
      const loginRequest = {
        scopes: this.scopes,
        loginHint: this._loginHint,
        prompt: this._prompt,
        domainHint: this._domainHint
      };
      if (this._loginType == LoginType.Popup) {
        const response = yield this._publicClientApplication.loginPopup(loginRequest);
        this.handleResponse(response === null || response === void 0 ? void 0 : response.account);
      } else {
        const loginRedirectRequest = Object.assign({}, loginRequest);
        this._publicClientApplication.loginRedirect(loginRedirectRequest);
      }
    });
  }
  /**
   * Get all signed in accounts
   *
   * @return {*}
   * @memberof Msal2Provider
   */
  getAllAccounts() {
    let usernames = [];
    this._publicClientApplication.getAllAccounts().forEach((account) => {
      usernames.push({ username: account.username, id: account.homeAccountId });
    });
    return usernames;
  }
  /**
   * Switching between accounts
   *
   * @param {*} user
   * @memberof Msal2Provider
   */
  setActiveAccount(user) {
    this._publicClientApplication.setActiveAccount(this._publicClientApplication.getAccountByHomeId(user.id));
    this.setStoredAccount();
    super.setActiveAccount(user);
  }
  /**
   * Once a succesful login occurs, set the active account and store it
   *
   * @param {(AuthenticationResult | null)} account
   * @memberof Msal2Provider
   */
  handleResponse(account) {
    if (account !== null) {
      this.setActiveAccount({
        username: account.name,
        id: account.homeAccountId
      });
      this.setState(ProviderState.SignedIn);
    } else {
      this.setState(ProviderState.SignedOut);
    }
    this.clearRequestedScopes();
  }
  /**
   * Store the currently signed in account in storage
   *
   * @private
   * @memberof Msal2Provider
   */
  setStoredAccount() {
    this.clearStoredAccount();
    window[this.ms_config.cache.cacheLocation].setItem(this.homeAccountKey, this._publicClientApplication.getActiveAccount().homeAccountId);
  }
  /**
   * Get the stored account from storage
   *
   * @private
   * @return {*}
   * @memberof Msal2Provider
   */
  getStoredAccount() {
    let homeId = null;
    homeId = window[this.ms_config.cache.cacheLocation].getItem(this.homeAccountKey);
    return this._publicClientApplication.getAccountByHomeId(homeId);
  }
  /**
   * Clears the stored account from storage
   *
   * @private
   * @memberof Msal2Provider
   */
  clearStoredAccount() {
    window[this.ms_config.cache.cacheLocation].removeItem(this.homeAccountKey);
  }
  /**
   * Adds scopes that have already been requested to sessionstorage
   *
   * @protected
   * @param {string[]} scopes
   * @memberof Msal2Provider
   */
  setRequestedScopes(scopes) {
    if (scopes) {
      sessionStorage.setItem(this.sessionStorageRequestedScopesKey, JSON.stringify(scopes));
    }
  }
  /**
   * Adds denied scopes to session storage
   *
   * @protected
   * @param {string[]} scopes
   * @memberof Msal2Provider
   */
  addDeniedScopes(scopes) {
    if (scopes) {
      let deniedScopes = this.getDeniedScopes() || [];
      deniedScopes = deniedScopes.concat(scopes);
      let index = deniedScopes.indexOf("openid");
      if (index !== -1) {
        deniedScopes.splice(index, 1);
      }
      index = deniedScopes.indexOf("profile");
      if (index !== -1) {
        deniedScopes.splice(index, 1);
      }
      sessionStorage.setItem(this.sessionStorageDeniedScopesKey, JSON.stringify(deniedScopes));
    }
  }
  /**
   * Gets denied scopes
   *
   * @protected
   * @return {*}
   * @memberof Msal2Provider
   */
  getDeniedScopes() {
    const scopesStr = sessionStorage.getItem(this.sessionStorageDeniedScopesKey);
    return scopesStr ? JSON.parse(scopesStr) : null;
  }
  /**
   * Checks if scopes were denied previously
   *
   * @protected
   * @param {string[]} scopes
   * @return {*}
   * @memberof Msal2Provider
   */
  areScopesDenied(scopes) {
    if (scopes) {
      const deniedScopes = this.getDeniedScopes();
      if (deniedScopes && deniedScopes.filter((s) => -1 !== scopes.indexOf(s)).length > 0) {
        return true;
      }
    }
    return false;
  }
  /**
   * Clears all requested scopes from session storage
   *
   * @protected
   * @memberof Msal2Provider
   */
  clearRequestedScopes() {
    sessionStorage.removeItem(this.sessionStorageRequestedScopesKey);
  }
  /**
   * Gets stored account if available, otherwise fetches the first account in the list of signed in accounts
   *
   * @private
   * @return {*}  {(AccountInfo | null)}
   * @memberof Msal2Provider
   */
  getAccount() {
    const account = this.getStoredAccount();
    if (account) {
      return account;
    } else if (this._publicClientApplication.getAllAccounts().length > 0) {
      return this._publicClientApplication.getAllAccounts()[0];
    }
    return null;
  }
  /**
   * Logs out user
   *
   * @memberof Msal2Provider
   */
  logout() {
    return __awaiter(this, void 0, void 0, function* () {
      const logOutAccount = this._publicClientApplication.getActiveAccount();
      const logOutRequest = {
        account: logOutAccount
      };
      this.clearStoredAccount();
      if (this._loginType == LoginType.Redirect) {
        this._publicClientApplication.logoutRedirect(logOutRequest);
        this.setState(ProviderState.SignedOut);
      } else {
        yield this._publicClientApplication.logoutPopup(Object.assign({}, logOutRequest));
        this.setState(ProviderState.SignedOut);
      }
    });
  }
  /**
   * Returns access token for scopes
   *
   * @param {AuthenticationProviderOptions} [options]
   * @return {*}  {Promise<string>}
   * @memberof Msal2Provider
   */
  getAccessToken(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const scopes = options ? options.scopes || this.scopes : this.scopes;
      const accessTokenRequest = {
        scopes,
        account: this.getAccount()
      };
      try {
        const silentRequest = accessTokenRequest;
        const response = yield this._publicClientApplication.acquireTokenSilent(silentRequest);
        return response.accessToken;
      } catch (e) {
        if (e instanceof InteractionRequiredAuthError) {
          if (this.isIncrementalConsentDisabled) {
            return null;
          }
          if (this._loginType === LoginType.Redirect) {
            if (!this.areScopesDenied(scopes)) {
              this.setRequestedScopes(scopes);
              this._publicClientApplication.acquireTokenRedirect(accessTokenRequest);
            } else {
              throw e;
            }
          } else {
            try {
              const response = yield this._publicClientApplication.acquireTokenPopup(accessTokenRequest);
              return response.accessToken;
            } catch (e2) {
              throw e2;
            }
          }
        } else {
          this.setState(ProviderState.SignedOut);
        }
      }
      throw null;
    });
  }
};

// node_modules/@microsoft/mgt-msal2-provider/dist/es6/mgt-msal2-provider.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtMsal2Provider = class MgtMsal2Provider2 extends MgtBaseProvider {
  constructor() {
    super(...arguments);
    this.clientId = "";
  }
  /**
   * Gets whether this provider can be used in this environment
   *
   * @readonly
   * @memberof MgtMsal2Provider
   */
  get isAvailable() {
    return true;
  }
  /**
   * method called to initialize the provider. Each derived class should provide their own implementation.
   *
   * @protected
   * @memberof MgtMsal2Provider
   */
  initializeProvider() {
    if (this.clientId) {
      const config = {
        clientId: this.clientId
      };
      if (this.loginType && this.loginType.length > 1) {
        let loginType = this.loginType.toLowerCase();
        loginType = loginType[0].toUpperCase() + loginType.slice(1);
        const loginTypeEnum = LoginType[loginType];
        config.loginType = loginTypeEnum;
      }
      if (this.authority) {
        config.authority = this.authority;
      }
      if (this.scopes) {
        const scope = this.scopes.split(",");
        if (scope && scope.length > 0) {
          config.scopes = scope;
        }
      }
      if (this.redirectUri) {
        config.redirectUri = this.redirectUri;
      }
      if (this.prompt) {
        let prompt = this.prompt.toUpperCase();
        const promptEnum = PromptType[prompt];
        config.prompt = promptEnum;
      }
      if (this.isIncrementalConsentDisabled) {
        config.isIncrementalConsentDisabled = true;
      }
      this.provider = new Msal2Provider(config);
      Providers.globalProvider = this.provider;
    }
  }
};
__decorate([
  property({
    attribute: "client-id",
    type: String
  }),
  __metadata("design:type", Object)
], MgtMsal2Provider.prototype, "clientId", void 0);
__decorate([
  property({
    attribute: "login-type",
    type: String
  }),
  __metadata("design:type", Object)
], MgtMsal2Provider.prototype, "loginType", void 0);
__decorate([
  property(),
  __metadata("design:type", Object)
], MgtMsal2Provider.prototype, "authority", void 0);
__decorate([
  property({
    attribute: "scopes",
    type: String
  }),
  __metadata("design:type", Object)
], MgtMsal2Provider.prototype, "scopes", void 0);
__decorate([
  property({
    attribute: "redirect-uri",
    type: String
  }),
  __metadata("design:type", Object)
], MgtMsal2Provider.prototype, "redirectUri", void 0);
__decorate([
  property({
    attribute: "prompt",
    type: String
  }),
  __metadata("design:type", String)
], MgtMsal2Provider.prototype, "prompt", void 0);
__decorate([
  property({
    attribute: "incremental-consent-disabled",
    type: Boolean
  }),
  __metadata("design:type", Boolean)
], MgtMsal2Provider.prototype, "isIncrementalConsentDisabled", void 0);
MgtMsal2Provider = __decorate([
  customElement("mgt-msal2-provider")
], MgtMsal2Provider);
export {
  MgtMsal2Provider,
  Msal2Provider,
  PromptType
};
//# sourceMappingURL=@microsoft_mgt-msal2-provider.js.map
