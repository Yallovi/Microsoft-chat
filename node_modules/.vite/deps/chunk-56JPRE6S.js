import {
  __awaiter,
  init_tslib_es6
} from "./chunk-VCF74VKF.js";
import {
  __esm,
  __require
} from "./chunk-JZQ37OGZ.js";

// node_modules/@microsoft/mgt-element/dist/es6/IBatch.js
var BatchResponse;
var init_IBatch = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/IBatch.js"() {
    BatchResponse = class {
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/IGraph.js
var MICROSOFT_GRAPH_ENDPOINTS, MICROSOFT_GRAPH_DEFAULT_ENDPOINT;
var init_IGraph = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/IGraph.js"() {
    MICROSOFT_GRAPH_ENDPOINTS = /* @__PURE__ */ new Set();
    MICROSOFT_GRAPH_DEFAULT_ENDPOINT = "https://graph.microsoft.com";
    (() => {
      const endpoints = [
        MICROSOFT_GRAPH_DEFAULT_ENDPOINT,
        "https://graph.microsoft.us",
        "https://dod-graph.microsoft.us",
        "https://graph.microsoft.de",
        "https://microsoftgraph.chinacloudapi.cn"
      ];
      endpoints.forEach((endpoint) => MICROSOFT_GRAPH_ENDPOINTS.add(endpoint));
    })();
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/RequestMethod.js
var RequestMethod;
var init_RequestMethod = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/RequestMethod.js"() {
    (function(RequestMethod2) {
      RequestMethod2["GET"] = "GET";
      RequestMethod2["PATCH"] = "PATCH";
      RequestMethod2["POST"] = "POST";
      RequestMethod2["PUT"] = "PUT";
      RequestMethod2["DELETE"] = "DELETE";
    })(RequestMethod || (RequestMethod = {}));
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/content/BatchRequestContent.js
var BatchRequestContent;
var init_BatchRequestContent = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/content/BatchRequestContent.js"() {
    init_tslib_es6();
    init_RequestMethod();
    BatchRequestContent = class {
      /**
       * @private
       * @static
       * Validates the dependency chain of the requests
       *
       * Note:
       * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:
       * 1. Parallel - no individual request states a dependency in the dependsOn property.
       * 2. Serial - all individual requests depend on the previous individual request.
       * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.
       * As JSON batching matures, these limitations will be removed.
       * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}
       *
       * @param {Map<string, BatchRequestStep>} requests - The map of requests.
       * @returns The boolean indicating the validation status
       */
      static validateDependencies(requests) {
        const isParallel = (reqs) => {
          const iterator = reqs.entries();
          let cur = iterator.next();
          while (!cur.done) {
            const curReq = cur.value[1];
            if (curReq.dependsOn !== void 0 && curReq.dependsOn.length > 0) {
              return false;
            }
            cur = iterator.next();
          }
          return true;
        };
        const isSerial = (reqs) => {
          const iterator = reqs.entries();
          let cur = iterator.next();
          const firstRequest = cur.value[1];
          if (firstRequest.dependsOn !== void 0 && firstRequest.dependsOn.length > 0) {
            return false;
          }
          let prev = cur;
          cur = iterator.next();
          while (!cur.done) {
            const curReq = cur.value[1];
            if (curReq.dependsOn === void 0 || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {
              return false;
            }
            prev = cur;
            cur = iterator.next();
          }
          return true;
        };
        const isSame = (reqs) => {
          const iterator = reqs.entries();
          let cur = iterator.next();
          const firstRequest = cur.value[1];
          let dependencyId;
          if (firstRequest.dependsOn === void 0 || firstRequest.dependsOn.length === 0) {
            dependencyId = firstRequest.id;
          } else {
            if (firstRequest.dependsOn.length === 1) {
              const fDependencyId = firstRequest.dependsOn[0];
              if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {
                dependencyId = fDependencyId;
              } else {
                return false;
              }
            } else {
              return false;
            }
          }
          cur = iterator.next();
          while (!cur.done) {
            const curReq = cur.value[1];
            if ((curReq.dependsOn === void 0 || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {
              return false;
            }
            if (curReq.dependsOn !== void 0 && curReq.dependsOn.length !== 0) {
              if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {
                return false;
              }
              if (curReq.dependsOn.length > 1) {
                return false;
              }
            }
            cur = iterator.next();
          }
          return true;
        };
        if (requests.size === 0) {
          const error = new Error("Empty requests map, Please provide at least one request.");
          error.name = "Empty Requests Error";
          throw error;
        }
        return isParallel(requests) || isSerial(requests) || isSame(requests);
      }
      /**
       * @private
       * @static
       * @async
       * Converts Request Object instance to a JSON
       * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance
       * @returns A promise that resolves to JSON representation of a request
       */
      static getRequestData(request) {
        return __awaiter(this, void 0, void 0, function* () {
          const requestData = {
            url: ""
          };
          const hasHttpRegex = new RegExp("^https?://");
          requestData.url = hasHttpRegex.test(request.url) ? "/" + request.url.split(/.*?\/\/.*?\//)[1] : request.url;
          requestData.method = request.method;
          const headers = {};
          request.headers.forEach((value, key) => {
            headers[key] = value;
          });
          if (Object.keys(headers).length) {
            requestData.headers = headers;
          }
          if (request.method === RequestMethod.PATCH || request.method === RequestMethod.POST || request.method === RequestMethod.PUT) {
            requestData.body = yield BatchRequestContent.getRequestBody(request);
          }
          return requestData;
        });
      }
      /**
       * @private
       * @static
       * @async
       * Gets the body of a Request object instance
       * @param {IsomorphicRequest} request - The IsomorphicRequest object instance
       * @returns The Promise that resolves to a body value of a Request
       */
      static getRequestBody(request) {
        return __awaiter(this, void 0, void 0, function* () {
          let bodyParsed = false;
          let body;
          try {
            const cloneReq = request.clone();
            body = yield cloneReq.json();
            bodyParsed = true;
          } catch (e) {
          }
          if (!bodyParsed) {
            try {
              if (typeof Blob !== "undefined") {
                const blob = yield request.blob();
                const reader = new FileReader();
                body = yield new Promise((resolve) => {
                  reader.addEventListener("load", () => {
                    const dataURL = reader.result;
                    const regex = new RegExp("^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$");
                    const segments = regex.exec(dataURL);
                    resolve(segments[4]);
                  }, false);
                  reader.readAsDataURL(blob);
                });
              } else if (typeof Buffer !== "undefined") {
                const buffer = yield request.buffer();
                body = buffer.toString("base64");
              }
              bodyParsed = true;
            } catch (e) {
            }
          }
          return body;
        });
      }
      /**
       * @public
       * @constructor
       * Constructs a BatchRequestContent instance
       * @param {BatchRequestStep[]} [requests] - Array of requests value
       * @returns An instance of a BatchRequestContent
       */
      constructor(requests) {
        this.requests = /* @__PURE__ */ new Map();
        if (typeof requests !== "undefined") {
          const limit = BatchRequestContent.requestLimit;
          if (requests.length > limit) {
            const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
            error.name = "Limit Exceeded Error";
            throw error;
          }
          for (const req of requests) {
            this.addRequest(req);
          }
        }
      }
      /**
       * @public
       * Adds a request to the batch request content
       * @param {BatchRequestStep} request - The request value
       * @returns The id of the added request
       */
      addRequest(request) {
        const limit = BatchRequestContent.requestLimit;
        if (request.id === "") {
          const error = new Error(`Id for a request is empty, Please provide an unique id`);
          error.name = "Empty Id For Request";
          throw error;
        }
        if (this.requests.size === limit) {
          const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
          error.name = "Limit Exceeded Error";
          throw error;
        }
        if (this.requests.has(request.id)) {
          const error = new Error(`Adding request with duplicate id ${request.id}, Make the id of the requests unique`);
          error.name = "Duplicate RequestId Error";
          throw error;
        }
        this.requests.set(request.id, request);
        return request.id;
      }
      /**
       * @public
       * Removes request from the batch payload and its dependencies from all dependents
       * @param {string} requestId - The id of a request that needs to be removed
       * @returns The boolean indicating removed status
       */
      removeRequest(requestId) {
        const deleteStatus = this.requests.delete(requestId);
        const iterator = this.requests.entries();
        let cur = iterator.next();
        while (!cur.done) {
          const dependencies = cur.value[1].dependsOn;
          if (typeof dependencies !== "undefined") {
            const index = dependencies.indexOf(requestId);
            if (index !== -1) {
              dependencies.splice(index, 1);
            }
            if (dependencies.length === 0) {
              delete cur.value[1].dependsOn;
            }
          }
          cur = iterator.next();
        }
        return deleteStatus;
      }
      /**
       * @public
       * @async
       * Serialize content from BatchRequestContent instance
       * @returns The body content to make batch request
       */
      getContent() {
        return __awaiter(this, void 0, void 0, function* () {
          const requests = [];
          const requestBody = {
            requests
          };
          const iterator = this.requests.entries();
          let cur = iterator.next();
          if (cur.done) {
            const error = new Error("No requests added yet, Please add at least one request.");
            error.name = "Empty Payload";
            throw error;
          }
          if (!BatchRequestContent.validateDependencies(this.requests)) {
            const error = new Error(`Invalid dependency found, Dependency should be:
1. Parallel - no individual request states a dependency in the dependsOn property.
2. Serial - all individual requests depend on the previous individual request.
3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.`);
            error.name = "Invalid Dependency";
            throw error;
          }
          while (!cur.done) {
            const requestStep = cur.value[1];
            const batchRequestData = yield BatchRequestContent.getRequestData(requestStep.request);
            if (batchRequestData.body !== void 0 && (batchRequestData.headers === void 0 || batchRequestData.headers["content-type"] === void 0)) {
              const error = new Error(`Content-type header is not mentioned for request #${requestStep.id}, For request having body, Content-type header should be mentioned`);
              error.name = "Invalid Content-type header";
              throw error;
            }
            batchRequestData.id = requestStep.id;
            if (requestStep.dependsOn !== void 0 && requestStep.dependsOn.length > 0) {
              batchRequestData.dependsOn = requestStep.dependsOn;
            }
            requests.push(batchRequestData);
            cur = iterator.next();
          }
          requestBody.requests = requests;
          return requestBody;
        });
      }
      /**
       * @public
       * Adds a dependency for a given dependent request
       * @param {string} dependentId - The id of the dependent request
       * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency
       * @returns Nothing
       */
      addDependency(dependentId, dependencyId) {
        if (!this.requests.has(dependentId)) {
          const error = new Error(`Dependent ${dependentId} does not exists, Please check the id`);
          error.name = "Invalid Dependent";
          throw error;
        }
        if (typeof dependencyId !== "undefined" && !this.requests.has(dependencyId)) {
          const error = new Error(`Dependency ${dependencyId} does not exists, Please check the id`);
          error.name = "Invalid Dependency";
          throw error;
        }
        if (typeof dependencyId !== "undefined") {
          const dependent = this.requests.get(dependentId);
          if (dependent.dependsOn === void 0) {
            dependent.dependsOn = [];
          }
          if (dependent.dependsOn.indexOf(dependencyId) !== -1) {
            const error = new Error(`Dependency ${dependencyId} is already added for the request ${dependentId}`);
            error.name = "Duplicate Dependency";
            throw error;
          }
          dependent.dependsOn.push(dependencyId);
        } else {
          const iterator = this.requests.entries();
          let prev;
          let cur = iterator.next();
          while (!cur.done && cur.value[1].id !== dependentId) {
            prev = cur;
            cur = iterator.next();
          }
          if (typeof prev !== "undefined") {
            const dId = prev.value[0];
            if (cur.value[1].dependsOn === void 0) {
              cur.value[1].dependsOn = [];
            }
            if (cur.value[1].dependsOn.indexOf(dId) !== -1) {
              const error = new Error(`Dependency ${dId} is already added for the request ${dependentId}`);
              error.name = "Duplicate Dependency";
              throw error;
            }
            cur.value[1].dependsOn.push(dId);
          } else {
            const error = new Error(`Can't add dependency ${dependencyId}, There is only a dependent request in the batch`);
            error.name = "Invalid Dependency Addition";
            throw error;
          }
        }
      }
      /**
       * @public
       * Removes a dependency for a given dependent request id
       * @param {string} dependentId - The id of the dependent request
       * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request
       * @returns The boolean indicating removed status
       */
      removeDependency(dependentId, dependencyId) {
        const request = this.requests.get(dependentId);
        if (typeof request === "undefined" || request.dependsOn === void 0 || request.dependsOn.length === 0) {
          return false;
        }
        if (typeof dependencyId !== "undefined") {
          const index = request.dependsOn.indexOf(dependencyId);
          if (index === -1) {
            return false;
          }
          request.dependsOn.splice(index, 1);
          return true;
        } else {
          delete request.dependsOn;
          return true;
        }
      }
    };
    BatchRequestContent.requestLimit = 20;
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/content/BatchResponseContent.js
var init_BatchResponseContent = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/content/BatchResponseContent.js"() {
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/Constants.js
var GRAPH_API_VERSION, GRAPH_BASE_URL, GRAPH_URLS;
var init_Constants = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/Constants.js"() {
    GRAPH_API_VERSION = "v1.0";
    GRAPH_BASE_URL = "https://graph.microsoft.com/";
    GRAPH_URLS = /* @__PURE__ */ new Set(["graph.microsoft.com", "graph.microsoft.us", "dod-graph.microsoft.us", "graph.microsoft.de", "microsoftgraph.chinacloudapi.cn", "canary.graph.microsoft.com"]);
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphClientError.js
var GraphClientError;
var init_GraphClientError = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphClientError.js"() {
    GraphClientError = class extends Error {
      /**
       * @public
       * @static
       * @async
       * To set the GraphClientError object
       * @param {any} error - The error returned encountered by the Graph JavaScript Client SDK while processing request
       * @returns GraphClientError object set to the error passed
       */
      static setGraphClientError(error) {
        let graphClientError;
        if (error instanceof Error) {
          graphClientError = error;
        } else {
          graphClientError = new GraphClientError();
          graphClientError.customError = error;
        }
        return graphClientError;
      }
      /**
       * @public
       * @constructor
       * Creates an instance of GraphClientError
       * @param {string} message? - Error message
       * @returns An instance of GraphClientError
       */
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, GraphClientError.prototype);
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequestUtil.js
var oDataQueryNames, urlJoin, serializeContent, isGraphURL, isCustomHost, isValidEndpoint, isCustomHostValid;
var init_GraphRequestUtil = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequestUtil.js"() {
    init_Constants();
    init_GraphClientError();
    oDataQueryNames = ["$select", "$expand", "$orderby", "$filter", "$top", "$skip", "$skipToken", "$count"];
    urlJoin = (urlSegments) => {
      const removePostSlash = (s) => s.replace(/\/+$/, "");
      const removePreSlash = (s) => s.replace(/^\/+/, "");
      const joiner = (pre, cur) => [removePostSlash(pre), removePreSlash(cur)].join("/");
      const parts = Array.prototype.slice.call(urlSegments);
      return parts.reduce(joiner);
    };
    serializeContent = (content) => {
      const className = content && content.constructor && content.constructor.name;
      if (className === "Buffer" || className === "Blob" || className === "File" || className === "FormData" || typeof content === "string") {
        return content;
      }
      if (className === "ArrayBuffer") {
        content = Buffer.from(content);
      } else if (className === "Int8Array" || className === "Int16Array" || className === "Int32Array" || className === "Uint8Array" || className === "Uint16Array" || className === "Uint32Array" || className === "Uint8ClampedArray" || className === "Float32Array" || className === "Float64Array" || className === "DataView") {
        content = Buffer.from(content.buffer);
      } else {
        try {
          content = JSON.stringify(content);
        } catch (error) {
          throw new Error("Unable to stringify the content");
        }
      }
      return content;
    };
    isGraphURL = (url) => {
      return isValidEndpoint(url);
    };
    isCustomHost = (url, customHosts) => {
      customHosts.forEach((host) => isCustomHostValid(host));
      return isValidEndpoint(url, customHosts);
    };
    isValidEndpoint = (url, allowedHosts = GRAPH_URLS) => {
      url = url.toLowerCase();
      if (url.indexOf("https://") !== -1) {
        url = url.replace("https://", "");
        const startofPortNoPos = url.indexOf(":");
        const endOfHostStrPos = url.indexOf("/");
        let hostName = "";
        if (endOfHostStrPos !== -1) {
          if (startofPortNoPos !== -1 && startofPortNoPos < endOfHostStrPos) {
            hostName = url.substring(0, startofPortNoPos);
            return allowedHosts.has(hostName);
          }
          hostName = url.substring(0, endOfHostStrPos);
          return allowedHosts.has(hostName);
        }
      }
      return false;
    };
    isCustomHostValid = (host) => {
      if (host.indexOf("/") !== -1) {
        throw new GraphClientError("Please add only hosts or hostnames to the CustomHosts config. If the url is `http://example.com:3000/`, host is `example:3000`");
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareControl.js
var MiddlewareControl;
var init_MiddlewareControl = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareControl.js"() {
    MiddlewareControl = class {
      /**
       * @public
       * @constructor
       * Creates an instance of MiddlewareControl
       * @param {MiddlewareOptions[]} [middlewareOptions = []] - The array of middlewareOptions
       * @returns The instance of MiddlewareControl
       */
      constructor(middlewareOptions = []) {
        this.middlewareOptions = /* @__PURE__ */ new Map();
        for (const option of middlewareOptions) {
          const fn = option.constructor;
          this.middlewareOptions.set(fn, option);
        }
      }
      /**
       * @public
       * To get the middleware option using the class of the option
       * @param {Function} fn - The class of the strongly typed option class
       * @returns The middleware option
       * @example
       * // if you wanted to return the middleware option associated with this class (MiddlewareControl)
       * // call this function like this:
       * getMiddlewareOptions(MiddlewareControl)
       */
      getMiddlewareOptions(fn) {
        return this.middlewareOptions.get(fn);
      }
      /**
       * @public
       * To set the middleware options using the class of the option
       * @param {Function} fn - The class of the strongly typed option class
       * @param {MiddlewareOptions} option - The strongly typed middleware option
       * @returns nothing
       */
      setMiddlewareOptions(fn, option) {
        this.middlewareOptions.set(fn, option);
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareUtil.js
var generateUUID, getRequestHeader, setRequestHeader, appendRequestHeader, cloneRequestWithNewUrl;
var init_MiddlewareUtil = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareUtil.js"() {
    init_tslib_es6();
    generateUUID = () => {
      let uuid = "";
      for (let j = 0; j < 32; j++) {
        if (j === 8 || j === 12 || j === 16 || j === 20) {
          uuid += "-";
        }
        uuid += Math.floor(Math.random() * 16).toString(16);
      }
      return uuid;
    };
    getRequestHeader = (request, options, key) => {
      let value = null;
      if (typeof Request !== "undefined" && request instanceof Request) {
        value = request.headers.get(key);
      } else if (typeof options !== "undefined" && options.headers !== void 0) {
        if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
          value = options.headers.get(key);
        } else if (options.headers instanceof Array) {
          const headers = options.headers;
          for (let i = 0, l = headers.length; i < l; i++) {
            if (headers[i][0] === key) {
              value = headers[i][1];
              break;
            }
          }
        } else if (options.headers[key] !== void 0) {
          value = options.headers[key];
        }
      }
      return value;
    };
    setRequestHeader = (request, options, key, value) => {
      if (typeof Request !== "undefined" && request instanceof Request) {
        request.headers.set(key, value);
      } else if (typeof options !== "undefined") {
        if (options.headers === void 0) {
          options.headers = new Headers({
            [key]: value
          });
        } else {
          if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
            options.headers.set(key, value);
          } else if (options.headers instanceof Array) {
            let i = 0;
            const l = options.headers.length;
            for (; i < l; i++) {
              const header = options.headers[i];
              if (header[0] === key) {
                header[1] = value;
                break;
              }
            }
            if (i === l) {
              options.headers.push([key, value]);
            }
          } else {
            Object.assign(options.headers, { [key]: value });
          }
        }
      }
    };
    appendRequestHeader = (request, options, key, value) => {
      if (typeof Request !== "undefined" && request instanceof Request) {
        request.headers.append(key, value);
      } else if (typeof options !== "undefined") {
        if (options.headers === void 0) {
          options.headers = new Headers({
            [key]: value
          });
        } else {
          if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
            options.headers.append(key, value);
          } else if (options.headers instanceof Array) {
            options.headers.push([key, value]);
          } else if (options.headers === void 0) {
            options.headers = { [key]: value };
          } else if (options.headers[key] === void 0) {
            options.headers[key] = value;
          } else {
            options.headers[key] += `, ${value}`;
          }
        }
      }
    };
    cloneRequestWithNewUrl = (newUrl, request) => __awaiter(void 0, void 0, void 0, function* () {
      const body = request.headers.get("Content-Type") ? yield request.blob() : yield Promise.resolve(void 0);
      const { method, headers, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal } = request;
      return new Request(newUrl, { method, headers, body, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal });
    });
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/AuthenticationHandlerOptions.js
var AuthenticationHandlerOptions;
var init_AuthenticationHandlerOptions = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/AuthenticationHandlerOptions.js"() {
    AuthenticationHandlerOptions = class {
      /**
       * @public
       * @constructor
       * To create an instance of AuthenticationHandlerOptions
       * @param {AuthenticationProvider} [authenticationProvider] - The authentication provider instance
       * @param {AuthenticationProviderOptions} [authenticationProviderOptions] - The authentication provider options instance
       * @returns An instance of AuthenticationHandlerOptions
       */
      constructor(authenticationProvider, authenticationProviderOptions) {
        this.authenticationProvider = authenticationProvider;
        this.authenticationProviderOptions = authenticationProviderOptions;
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/TelemetryHandlerOptions.js
var FeatureUsageFlag, TelemetryHandlerOptions;
var init_TelemetryHandlerOptions = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/TelemetryHandlerOptions.js"() {
    init_MiddlewareControl();
    (function(FeatureUsageFlag2) {
      FeatureUsageFlag2[FeatureUsageFlag2["NONE"] = 0] = "NONE";
      FeatureUsageFlag2[FeatureUsageFlag2["REDIRECT_HANDLER_ENABLED"] = 1] = "REDIRECT_HANDLER_ENABLED";
      FeatureUsageFlag2[FeatureUsageFlag2["RETRY_HANDLER_ENABLED"] = 2] = "RETRY_HANDLER_ENABLED";
      FeatureUsageFlag2[FeatureUsageFlag2["AUTHENTICATION_HANDLER_ENABLED"] = 4] = "AUTHENTICATION_HANDLER_ENABLED";
    })(FeatureUsageFlag || (FeatureUsageFlag = {}));
    TelemetryHandlerOptions = class {
      constructor() {
        this.featureUsage = FeatureUsageFlag.NONE;
      }
      /**
       * @public
       * @static
       * To update the feature usage in the context object
       * @param {Context} context - The request context object containing middleware options
       * @param {FeatureUsageFlag} flag - The flag value
       * @returns nothing
       */
      static updateFeatureUsageFlag(context, flag) {
        let options;
        if (context.middlewareControl instanceof MiddlewareControl) {
          options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);
        } else {
          context.middlewareControl = new MiddlewareControl();
        }
        if (typeof options === "undefined") {
          options = new TelemetryHandlerOptions();
          context.middlewareControl.setMiddlewareOptions(TelemetryHandlerOptions, options);
        }
        options.setFeatureUsage(flag);
      }
      /**
       * @private
       * To set the feature usage flag
       * @param {FeatureUsageFlag} flag - The flag value
       * @returns nothing
       */
      setFeatureUsage(flag) {
        this.featureUsage = this.featureUsage | flag;
      }
      /**
       * @public
       * To get the feature usage
       * @returns A feature usage flag as hexadecimal string
       */
      getFeatureUsage() {
        return this.featureUsage.toString(16);
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/AuthenticationHandler.js
var AuthenticationHandler;
var init_AuthenticationHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/AuthenticationHandler.js"() {
    init_tslib_es6();
    init_GraphRequestUtil();
    init_MiddlewareControl();
    init_MiddlewareUtil();
    init_AuthenticationHandlerOptions();
    init_TelemetryHandlerOptions();
    AuthenticationHandler = class {
      /**
       * @public
       * @constructor
       * Creates an instance of AuthenticationHandler
       * @param {AuthenticationProvider} authenticationProvider - The authentication provider for the authentication handler
       */
      constructor(authenticationProvider) {
        this.authenticationProvider = authenticationProvider;
      }
      /**
       * @public
       * @async
       * To execute the current middleware
       * @param {Context} context - The context object of the request
       * @returns A Promise that resolves to nothing
       */
      execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = typeof context.request === "string" ? context.request : context.request.url;
          if (isGraphURL(url) || context.customHosts && isCustomHost(url, context.customHosts)) {
            let options;
            if (context.middlewareControl instanceof MiddlewareControl) {
              options = context.middlewareControl.getMiddlewareOptions(AuthenticationHandlerOptions);
            }
            let authenticationProvider;
            let authenticationProviderOptions;
            if (options) {
              authenticationProvider = options.authenticationProvider;
              authenticationProviderOptions = options.authenticationProviderOptions;
            }
            if (!authenticationProvider) {
              authenticationProvider = this.authenticationProvider;
            }
            const token = yield authenticationProvider.getAccessToken(authenticationProviderOptions);
            const bearerKey = `Bearer ${token}`;
            appendRequestHeader(context.request, context.options, AuthenticationHandler.AUTHORIZATION_HEADER, bearerKey);
            TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.AUTHENTICATION_HANDLER_ENABLED);
          } else {
            if (context.options.headers) {
              delete context.options.headers[AuthenticationHandler.AUTHORIZATION_HEADER];
            }
          }
          return yield this.nextMiddleware.execute(context);
        });
      }
      /**
       * @public
       * To set the next middleware in the chain
       * @param {Middleware} next - The middleware instance
       * @returns Nothing
       */
      setNext(next) {
        this.nextMiddleware = next;
      }
    };
    AuthenticationHandler.AUTHORIZATION_HEADER = "Authorization";
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/HTTPMessageHandler.js
var HTTPMessageHandler;
var init_HTTPMessageHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/HTTPMessageHandler.js"() {
    init_tslib_es6();
    HTTPMessageHandler = class {
      /**
       * @public
       * @async
       * To execute the current middleware
       * @param {Context} context - The request context object
       * @returns A promise that resolves to nothing
       */
      execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
          context.response = yield fetch(context.request, context.options);
        });
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RetryHandlerOptions.js
var RetryHandlerOptions;
var init_RetryHandlerOptions = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RetryHandlerOptions.js"() {
    RetryHandlerOptions = class {
      /**
       * @public
       * @constructor
       * To create an instance of RetryHandlerOptions
       * @param {number} [delay = RetryHandlerOptions.DEFAULT_DELAY] - The delay value in seconds
       * @param {number} [maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES] - The maxRetries value
       * @param {ShouldRetry} [shouldRetry = RetryHandlerOptions.DEFAULT_SHOULD_RETRY] - The shouldRetry callback function
       * @returns An instance of RetryHandlerOptions
       */
      constructor(delay2 = RetryHandlerOptions.DEFAULT_DELAY, maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES, shouldRetry = RetryHandlerOptions.defaultShouldRetry) {
        if (delay2 > RetryHandlerOptions.MAX_DELAY && maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
          const error = new Error(`Delay and MaxRetries should not be more than ${RetryHandlerOptions.MAX_DELAY} and ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
          error.name = "MaxLimitExceeded";
          throw error;
        } else if (delay2 > RetryHandlerOptions.MAX_DELAY) {
          const error = new Error(`Delay should not be more than ${RetryHandlerOptions.MAX_DELAY}`);
          error.name = "MaxLimitExceeded";
          throw error;
        } else if (maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
          const error = new Error(`MaxRetries should not be more than ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
          error.name = "MaxLimitExceeded";
          throw error;
        } else if (delay2 < 0 && maxRetries < 0) {
          const error = new Error(`Delay and MaxRetries should not be negative`);
          error.name = "MinExpectationNotMet";
          throw error;
        } else if (delay2 < 0) {
          const error = new Error(`Delay should not be negative`);
          error.name = "MinExpectationNotMet";
          throw error;
        } else if (maxRetries < 0) {
          const error = new Error(`MaxRetries should not be negative`);
          error.name = "MinExpectationNotMet";
          throw error;
        }
        this.delay = Math.min(delay2, RetryHandlerOptions.MAX_DELAY);
        this.maxRetries = Math.min(maxRetries, RetryHandlerOptions.MAX_MAX_RETRIES);
        this.shouldRetry = shouldRetry;
      }
      /**
       * @public
       * To get the maximum delay
       * @returns A maximum delay
       */
      getMaxDelay() {
        return RetryHandlerOptions.MAX_DELAY;
      }
    };
    RetryHandlerOptions.DEFAULT_DELAY = 3;
    RetryHandlerOptions.DEFAULT_MAX_RETRIES = 3;
    RetryHandlerOptions.MAX_DELAY = 180;
    RetryHandlerOptions.MAX_MAX_RETRIES = 10;
    RetryHandlerOptions.defaultShouldRetry = () => true;
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RetryHandler.js
var RetryHandler;
var init_RetryHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RetryHandler.js"() {
    init_tslib_es6();
    init_RequestMethod();
    init_MiddlewareControl();
    init_MiddlewareUtil();
    init_RetryHandlerOptions();
    init_TelemetryHandlerOptions();
    RetryHandler = class {
      /**
       * @public
       * @constructor
       * To create an instance of RetryHandler
       * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value
       * @returns An instance of RetryHandler
       */
      constructor(options = new RetryHandlerOptions()) {
        this.options = options;
      }
      /**
       *
       * @private
       * To check whether the response has the retry status code
       * @param {Response} response - The response object
       * @returns Whether the response has retry status code or not
       */
      isRetry(response) {
        return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;
      }
      /**
       * @private
       * To check whether the payload is buffered or not
       * @param {RequestInfo} request - The url string or the request object value
       * @param {FetchOptions} options - The options of a request
       * @returns Whether the payload is buffered or not
       */
      isBuffered(request, options) {
        const method = typeof request === "string" ? options.method : request.method;
        const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;
        if (isPutPatchOrPost) {
          const isStream = getRequestHeader(request, options, "Content-Type") === "application/octet-stream";
          if (isStream) {
            return false;
          }
        }
        return true;
      }
      /**
       * @private
       * To get the delay for a retry
       * @param {Response} response - The response object
       * @param {number} retryAttempts - The current attempt count
       * @param {number} delay - The delay value in seconds
       * @returns A delay for a retry
       */
      getDelay(response, retryAttempts, delay2) {
        const getRandomness = () => Number(Math.random().toFixed(3));
        const retryAfter = response.headers !== void 0 ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;
        let newDelay;
        if (retryAfter !== null) {
          if (Number.isNaN(Number(retryAfter))) {
            newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1e3);
          } else {
            newDelay = Number(retryAfter);
          }
        } else {
          newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay2 + getRandomness() : delay2 + getRandomness();
        }
        return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());
      }
      /**
       * @private
       * To get an exponential back off value
       * @param {number} attempts - The current attempt count
       * @returns An exponential back off value
       */
      getExponentialBackOffTime(attempts) {
        return Math.round(1 / 2 * (Math.pow(2, attempts) - 1));
      }
      /**
       * @private
       * @async
       * To add delay for the execution
       * @param {number} delaySeconds - The delay value in seconds
       * @returns Nothing
       */
      sleep(delaySeconds) {
        return __awaiter(this, void 0, void 0, function* () {
          const delayMilliseconds = delaySeconds * 1e3;
          return new Promise((resolve) => setTimeout(resolve, delayMilliseconds));
        });
      }
      getOptions(context) {
        let options;
        if (context.middlewareControl instanceof MiddlewareControl) {
          options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);
        }
        if (typeof options === "undefined") {
          options = Object.assign(new RetryHandlerOptions(), this.options);
        }
        return options;
      }
      /**
       * @private
       * @async
       * To execute the middleware with retries
       * @param {Context} context - The context object
       * @param {number} retryAttempts - The current attempt count
       * @param {RetryHandlerOptions} options - The retry middleware options instance
       * @returns A Promise that resolves to nothing
       */
      executeWithRetry(context, retryAttempts, options) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.nextMiddleware.execute(context);
          if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {
            ++retryAttempts;
            setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());
            const delay2 = this.getDelay(context.response, retryAttempts, options.delay);
            yield this.sleep(delay2);
            return yield this.executeWithRetry(context, retryAttempts, options);
          } else {
            return;
          }
        });
      }
      /**
       * @public
       * @async
       * To execute the current middleware
       * @param {Context} context - The context object of the request
       * @returns A Promise that resolves to nothing
       */
      execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
          const retryAttempts = 0;
          const options = this.getOptions(context);
          TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);
          return yield this.executeWithRetry(context, retryAttempts, options);
        });
      }
      /**
       * @public
       * To set the next middleware in the chain
       * @param {Middleware} next - The middleware instance
       * @returns Nothing
       */
      setNext(next) {
        this.nextMiddleware = next;
      }
    };
    RetryHandler.RETRY_STATUS_CODES = [
      429,
      503,
      504
      // Gateway timeout
    ];
    RetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt";
    RetryHandler.RETRY_AFTER_HEADER = "Retry-After";
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RedirectHandlerOptions.js
var RedirectHandlerOptions;
var init_RedirectHandlerOptions = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RedirectHandlerOptions.js"() {
    RedirectHandlerOptions = class {
      /**
       * @public
       * @constructor
       * To create an instance of RedirectHandlerOptions
       * @param {number} [maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS] - The max redirects value
       * @param {ShouldRedirect} [shouldRedirect = RedirectHandlerOptions.DEFAULT_SHOULD_RETRY] - The should redirect callback
       * @returns An instance of RedirectHandlerOptions
       */
      constructor(maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS, shouldRedirect = RedirectHandlerOptions.defaultShouldRedirect) {
        if (maxRedirects > RedirectHandlerOptions.MAX_MAX_REDIRECTS) {
          const error = new Error(`MaxRedirects should not be more than ${RedirectHandlerOptions.MAX_MAX_REDIRECTS}`);
          error.name = "MaxLimitExceeded";
          throw error;
        }
        if (maxRedirects < 0) {
          const error = new Error(`MaxRedirects should not be negative`);
          error.name = "MinExpectationNotMet";
          throw error;
        }
        this.maxRedirects = maxRedirects;
        this.shouldRedirect = shouldRedirect;
      }
    };
    RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS = 5;
    RedirectHandlerOptions.MAX_MAX_REDIRECTS = 20;
    RedirectHandlerOptions.defaultShouldRedirect = () => true;
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RedirectHandler.js
var RedirectHandler;
var init_RedirectHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RedirectHandler.js"() {
    init_tslib_es6();
    init_RequestMethod();
    init_MiddlewareControl();
    init_MiddlewareUtil();
    init_RedirectHandlerOptions();
    init_TelemetryHandlerOptions();
    RedirectHandler = class {
      /**
       * @public
       * @constructor
       * To create an instance of RedirectHandler
       * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance
       * @returns An instance of RedirectHandler
       */
      constructor(options = new RedirectHandlerOptions()) {
        this.options = options;
      }
      /**
       * @private
       * To check whether the response has the redirect status code or not
       * @param {Response} response - The response object
       * @returns A boolean representing whether the response contains the redirect status code or not
       */
      isRedirect(response) {
        return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;
      }
      /**
       * @private
       * To check whether the response has location header or not
       * @param {Response} response - The response object
       * @returns A boolean representing the whether the response has location header or not
       */
      hasLocationHeader(response) {
        return response.headers.has(RedirectHandler.LOCATION_HEADER);
      }
      /**
       * @private
       * To get the redirect url from location header in response object
       * @param {Response} response - The response object
       * @returns A redirect url from location header
       */
      getLocationHeader(response) {
        return response.headers.get(RedirectHandler.LOCATION_HEADER);
      }
      /**
       * @private
       * To check whether the given url is a relative url or not
       * @param {string} url - The url string value
       * @returns A boolean representing whether the given url is a relative url or not
       */
      isRelativeURL(url) {
        return url.indexOf("://") === -1;
      }
      /**
       * @private
       * To check whether the authorization header in the request should be dropped for consequent redirected requests
       * @param {string} requestUrl - The request url value
       * @param {string} redirectUrl - The redirect url value
       * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests
       */
      shouldDropAuthorizationHeader(requestUrl, redirectUrl) {
        const schemeHostRegex = /^[A-Za-z].+?:\/\/.+?(?=\/|$)/;
        const requestMatches = schemeHostRegex.exec(requestUrl);
        let requestAuthority;
        let redirectAuthority;
        if (requestMatches !== null) {
          requestAuthority = requestMatches[0];
        }
        const redirectMatches = schemeHostRegex.exec(redirectUrl);
        if (redirectMatches !== null) {
          redirectAuthority = redirectMatches[0];
        }
        return typeof requestAuthority !== "undefined" && typeof redirectAuthority !== "undefined" && requestAuthority !== redirectAuthority;
      }
      /**
       * @private
       * @async
       * To update a request url with the redirect url
       * @param {string} redirectUrl - The redirect url value
       * @param {Context} context - The context object value
       * @returns Nothing
       */
      updateRequestUrl(redirectUrl, context) {
        return __awaiter(this, void 0, void 0, function* () {
          context.request = typeof context.request === "string" ? redirectUrl : yield cloneRequestWithNewUrl(redirectUrl, context.request);
        });
      }
      /**
       * @private
       * To get the options for execution of the middleware
       * @param {Context} context - The context object
       * @returns A options for middleware execution
       */
      getOptions(context) {
        let options;
        if (context.middlewareControl instanceof MiddlewareControl) {
          options = context.middlewareControl.getMiddlewareOptions(RedirectHandlerOptions);
        }
        if (typeof options === "undefined") {
          options = Object.assign(new RedirectHandlerOptions(), this.options);
        }
        return options;
      }
      /**
       * @private
       * @async
       * To execute the next middleware and to handle in case of redirect response returned by the server
       * @param {Context} context - The context object
       * @param {number} redirectCount - The redirect count value
       * @param {RedirectHandlerOptions} options - The redirect handler options instance
       * @returns A promise that resolves to nothing
       */
      executeWithRedirect(context, redirectCount, options) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.nextMiddleware.execute(context);
          const response = context.response;
          if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {
            ++redirectCount;
            if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {
              context.options.method = RequestMethod.GET;
              delete context.options.body;
            } else {
              const redirectUrl = this.getLocationHeader(response);
              if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {
                delete context.options.headers[RedirectHandler.AUTHORIZATION_HEADER];
              }
              yield this.updateRequestUrl(redirectUrl, context);
            }
            yield this.executeWithRedirect(context, redirectCount, options);
          } else {
            return;
          }
        });
      }
      /**
       * @public
       * @async
       * To execute the current middleware
       * @param {Context} context - The context object of the request
       * @returns A Promise that resolves to nothing
       */
      execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
          const redirectCount = 0;
          const options = this.getOptions(context);
          context.options.redirect = RedirectHandler.MANUAL_REDIRECT;
          TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.REDIRECT_HANDLER_ENABLED);
          return yield this.executeWithRedirect(context, redirectCount, options);
        });
      }
      /**
       * @public
       * To set the next middleware in the chain
       * @param {Middleware} next - The middleware instance
       * @returns Nothing
       */
      setNext(next) {
        this.nextMiddleware = next;
      }
    };
    RedirectHandler.REDIRECT_STATUS_CODES = [
      301,
      302,
      303,
      307,
      308
      // Moved Permanently
    ];
    RedirectHandler.STATUS_CODE_SEE_OTHER = 303;
    RedirectHandler.LOCATION_HEADER = "Location";
    RedirectHandler.AUTHORIZATION_HEADER = "Authorization";
    RedirectHandler.MANUAL_REDIRECT = "manual";
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/Version.js
var PACKAGE_VERSION;
var init_Version = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/Version.js"() {
    PACKAGE_VERSION = "3.0.5";
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/TelemetryHandler.js
var TelemetryHandler;
var init_TelemetryHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/TelemetryHandler.js"() {
    init_tslib_es6();
    init_GraphRequestUtil();
    init_Version();
    init_MiddlewareControl();
    init_MiddlewareUtil();
    init_TelemetryHandlerOptions();
    TelemetryHandler = class {
      /**
       * @public
       * @async
       * To execute the current middleware
       * @param {Context} context - The context object of the request
       * @returns A Promise that resolves to nothing
       */
      execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = typeof context.request === "string" ? context.request : context.request.url;
          if (isGraphURL(url) || context.customHosts && isCustomHost(url, context.customHosts)) {
            let clientRequestId = getRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER);
            if (!clientRequestId) {
              clientRequestId = generateUUID();
              setRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER, clientRequestId);
            }
            let sdkVersionValue = `${TelemetryHandler.PRODUCT_NAME}/${PACKAGE_VERSION}`;
            let options;
            if (context.middlewareControl instanceof MiddlewareControl) {
              options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);
            }
            if (options) {
              const featureUsage = options.getFeatureUsage();
              sdkVersionValue += ` (${TelemetryHandler.FEATURE_USAGE_STRING}=${featureUsage})`;
            }
            appendRequestHeader(context.request, context.options, TelemetryHandler.SDK_VERSION_HEADER, sdkVersionValue);
          } else {
            delete context.options.headers[TelemetryHandler.CLIENT_REQUEST_ID_HEADER];
            delete context.options.headers[TelemetryHandler.SDK_VERSION_HEADER];
          }
          return yield this.nextMiddleware.execute(context);
        });
      }
      /**
       * @public
       * To set the next middleware in the chain
       * @param {Middleware} next - The middleware instance
       * @returns Nothing
       */
      setNext(next) {
        this.nextMiddleware = next;
      }
    };
    TelemetryHandler.CLIENT_REQUEST_ID_HEADER = "client-request-id";
    TelemetryHandler.SDK_VERSION_HEADER = "SdkVersion";
    TelemetryHandler.PRODUCT_NAME = "graph-js";
    TelemetryHandler.FEATURE_USAGE_STRING = "featureUsage";
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareFactory.js
var init_MiddlewareFactory = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareFactory.js"() {
    init_AuthenticationHandler();
    init_HTTPMessageHandler();
    init_RedirectHandlerOptions();
    init_RetryHandlerOptions();
    init_RedirectHandler();
    init_RetryHandler();
    init_TelemetryHandler();
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosStrategy.js
var ChaosStrategy;
var init_ChaosStrategy = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosStrategy.js"() {
    (function(ChaosStrategy2) {
      ChaosStrategy2[ChaosStrategy2["MANUAL"] = 0] = "MANUAL";
      ChaosStrategy2[ChaosStrategy2["RANDOM"] = 1] = "RANDOM";
    })(ChaosStrategy || (ChaosStrategy = {}));
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosHandlerOptions.js
var init_ChaosHandlerOptions = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosHandlerOptions.js"() {
    init_ChaosStrategy();
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosHandlerData.js
var init_ChaosHandlerData = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosHandlerData.js"() {
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/ChaosHandler.js
var init_ChaosHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/ChaosHandler.js"() {
    init_tslib_es6();
    init_MiddlewareControl();
    init_MiddlewareUtil();
    init_ChaosHandlerData();
    init_ChaosHandlerOptions();
    init_ChaosStrategy();
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/ResponseType.js
var ResponseType;
var init_ResponseType = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/ResponseType.js"() {
    (function(ResponseType2) {
      ResponseType2["ARRAYBUFFER"] = "arraybuffer";
      ResponseType2["BLOB"] = "blob";
      ResponseType2["DOCUMENT"] = "document";
      ResponseType2["JSON"] = "json";
      ResponseType2["RAW"] = "raw";
      ResponseType2["STREAM"] = "stream";
      ResponseType2["TEXT"] = "text";
    })(ResponseType || (ResponseType = {}));
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphResponseHandler.js
var DocumentType, ContentType, ContentTypeRegexStr, GraphResponseHandler;
var init_GraphResponseHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphResponseHandler.js"() {
    init_tslib_es6();
    init_ResponseType();
    (function(DocumentType2) {
      DocumentType2["TEXT_HTML"] = "text/html";
      DocumentType2["TEXT_XML"] = "text/xml";
      DocumentType2["APPLICATION_XML"] = "application/xml";
      DocumentType2["APPLICATION_XHTML"] = "application/xhtml+xml";
    })(DocumentType || (DocumentType = {}));
    (function(ContentType2) {
      ContentType2["TEXT_PLAIN"] = "text/plain";
      ContentType2["APPLICATION_JSON"] = "application/json";
    })(ContentType || (ContentType = {}));
    (function(ContentTypeRegexStr2) {
      ContentTypeRegexStr2["DOCUMENT"] = "^(text\\/(html|xml))|(application\\/(xml|xhtml\\+xml))$";
      ContentTypeRegexStr2["IMAGE"] = "^image\\/.+";
    })(ContentTypeRegexStr || (ContentTypeRegexStr = {}));
    GraphResponseHandler = class {
      /**
       * @private
       * @static
       * To parse Document response
       * @param {Response} rawResponse - The response object
       * @param {DocumentType} type - The type to which the document needs to be parsed
       * @returns A promise that resolves to a document content
       */
      static parseDocumentResponse(rawResponse, type) {
        if (typeof DOMParser !== "undefined") {
          return new Promise((resolve, reject) => {
            rawResponse.text().then((xmlString) => {
              try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, type);
                resolve(xmlDoc);
              } catch (error) {
                reject(error);
              }
            });
          });
        } else {
          return Promise.resolve(rawResponse.body);
        }
      }
      /**
       * @private
       * @static
       * @async
       * To convert the native Response to response content
       * @param {Response} rawResponse - The response object
       * @param {ResponseType} [responseType] - The response type value
       * @returns A promise that resolves to the converted response content
       */
      static convertResponse(rawResponse, responseType) {
        return __awaiter(this, void 0, void 0, function* () {
          if (rawResponse.status === 204) {
            return Promise.resolve();
          }
          let responseValue;
          const contentType = rawResponse.headers.get("Content-type");
          switch (responseType) {
            case ResponseType.ARRAYBUFFER:
              responseValue = yield rawResponse.arrayBuffer();
              break;
            case ResponseType.BLOB:
              responseValue = yield rawResponse.blob();
              break;
            case ResponseType.DOCUMENT:
              responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);
              break;
            case ResponseType.JSON:
              responseValue = yield rawResponse.json();
              break;
            case ResponseType.STREAM:
              responseValue = yield Promise.resolve(rawResponse.body);
              break;
            case ResponseType.TEXT:
              responseValue = yield rawResponse.text();
              break;
            default:
              if (contentType !== null) {
                const mimeType = contentType.split(";")[0];
                if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {
                  responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);
                } else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {
                  responseValue = rawResponse.blob();
                } else if (mimeType === ContentType.TEXT_PLAIN) {
                  responseValue = yield rawResponse.text();
                } else if (mimeType === ContentType.APPLICATION_JSON) {
                  responseValue = yield rawResponse.json();
                } else {
                  responseValue = Promise.resolve(rawResponse.body);
                }
              } else {
                responseValue = Promise.resolve(rawResponse.body);
              }
              break;
          }
          return responseValue;
        });
      }
      /**
       * @public
       * @static
       * @async
       * To get the parsed response
       * @param {Response} rawResponse - The response object
       * @param {ResponseType} [responseType] - The response type value
       * @param {GraphRequestCallback} [callback] - The graph request callback function
       * @returns The parsed response
       */
      static getResponse(rawResponse, responseType, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          if (responseType === ResponseType.RAW) {
            return Promise.resolve(rawResponse);
          } else {
            const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);
            if (rawResponse.ok) {
              if (typeof callback === "function") {
                callback(null, response);
              } else {
                return response;
              }
            } else {
              throw response;
            }
          }
        });
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/Range.js
var Range;
var init_Range = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/Range.js"() {
    Range = class {
      /**
       * @public
       * @constructor
       * Creates a range for given min and max values
       * @param {number} [minVal = -1] - The minimum value.
       * @param {number} [maxVal = -1] - The maximum value.
       * @returns An instance of a Range
       */
      constructor(minVal = -1, maxVal = -1) {
        this.minValue = minVal;
        this.maxValue = maxVal;
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/UploadResult.js
var UploadResult;
var init_UploadResult = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/UploadResult.js"() {
    UploadResult = class {
      /**
       * @public
       * Get of the location value.
       * Location value is looked up in the response header
       */
      get location() {
        return this._location;
      }
      /**
       * @public
       * Set the location value
       * Location value is looked up in the response header
       */
      set location(location) {
        this._location = location;
      }
      /**
       * @public
       * Get The response body from the completed upload response
       */
      get responseBody() {
        return this._responseBody;
      }
      /**
       * @public
       * Set the response body from the completed upload response
       */
      set responseBody(responseBody) {
        this._responseBody = responseBody;
      }
      /**
       * @public
       * @param {responseBody} responsebody - The response body from the completed upload response
       * @param {location} location - The location value from the headers from the completed upload response
       */
      constructor(responseBody, location) {
        this._location = location;
        this._responseBody = responseBody;
      }
      /**
       * @public
       * @param {responseBody} responseBody - The response body from the completed upload response
       * @param {responseHeaders} responseHeaders - The headers from the completed upload response
       */
      static CreateUploadResult(responseBody, responseHeaders) {
        return new UploadResult(responseBody, responseHeaders.get("location"));
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/LargeFileUploadTask.js
var LargeFileUploadTask;
var init_LargeFileUploadTask = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/LargeFileUploadTask.js"() {
    init_tslib_es6();
    init_GraphClientError();
    init_GraphResponseHandler();
    init_ResponseType();
    init_Range();
    init_UploadResult();
    LargeFileUploadTask = class {
      /**
       * @public
       * @static
       * @async
       * Makes request to the server to create an upload session
       * @param {Client} client - The GraphClient instance
       * @param {string} requestUrl - The URL to create the upload session
       * @param {any} payload - The payload that needs to be sent
       * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent
       * @returns The promise that resolves to LargeFileUploadSession
       */
      static createUploadSession(client, requestUrl, payload, headers = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const session = yield client.api(requestUrl).headers(headers).post(payload);
          const largeFileUploadSession = {
            url: session.uploadUrl,
            expiry: new Date(session.expirationDateTime),
            isCancelled: false
          };
          return largeFileUploadSession;
        });
      }
      /**
       * @public
       * @constructor
       * Constructs a LargeFileUploadTask
       * @param {Client} client - The GraphClient instance
       * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded
       * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done
       * @param {LargeFileUploadTaskOptions} options - The upload task options
       * @returns An instance of LargeFileUploadTask
       */
      constructor(client, file, uploadSession, options = {}) {
        this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
        this.client = client;
        if (!file.sliceFile) {
          throw new GraphClientError("Please pass the FileUpload object, StreamUpload object or any custom implementation of the FileObject interface");
        } else {
          this.file = file;
        }
        this.file = file;
        if (!options.rangeSize) {
          options.rangeSize = this.DEFAULT_FILE_SIZE;
        }
        this.options = options;
        this.uploadSession = uploadSession;
        this.nextRange = new Range(0, this.options.rangeSize - 1);
      }
      /**
       * @private
       * Parses given range string to the Range instance
       * @param {string[]} ranges - The ranges value
       * @returns The range instance
       */
      parseRange(ranges) {
        const rangeStr = ranges[0];
        if (typeof rangeStr === "undefined" || rangeStr === "") {
          return new Range();
        }
        const firstRange = rangeStr.split("-");
        const minVal = parseInt(firstRange[0], 10);
        let maxVal = parseInt(firstRange[1], 10);
        if (Number.isNaN(maxVal)) {
          maxVal = this.file.size - 1;
        }
        return new Range(minVal, maxVal);
      }
      /**
       * @private
       * Updates the expiration date and the next range
       * @param {UploadStatusResponse} response - The response of the upload status
       * @returns Nothing
       */
      updateTaskStatus(response) {
        this.uploadSession.expiry = new Date(response.expirationDateTime);
        this.nextRange = this.parseRange(response.nextExpectedRanges);
      }
      /**
       * @public
       * Gets next range that needs to be uploaded
       * @returns The range instance
       */
      getNextRange() {
        if (this.nextRange.minValue === -1) {
          return this.nextRange;
        }
        const minVal = this.nextRange.minValue;
        let maxValue = minVal + this.options.rangeSize - 1;
        if (maxValue >= this.file.size) {
          maxValue = this.file.size - 1;
        }
        return new Range(minVal, maxValue);
      }
      /**
       * @deprecated This function has been moved into FileObject interface.
       * @public
       * Slices the file content to the given range
       * @param {Range} range - The range value
       * @returns The sliced ArrayBuffer or Blob
       */
      sliceFile(range) {
        console.warn("The LargeFileUploadTask.sliceFile() function has been deprecated and moved into the FileObject interface.");
        if (this.file.content instanceof ArrayBuffer || this.file.content instanceof Blob || this.file.content instanceof Uint8Array) {
          return this.file.content.slice(range.minValue, range.maxValue + 1);
        }
        throw new GraphClientError("The LargeFileUploadTask.sliceFile() function expects only Blob, ArrayBuffer or Uint8Array file content. Please note that the sliceFile() function is deprecated.");
      }
      /**
       * @public
       * @async
       * Uploads file to the server in a sequential order by slicing the file
       * @returns The promise resolves to uploaded response
       */
      upload() {
        return __awaiter(this, void 0, void 0, function* () {
          const uploadEventHandlers = this.options && this.options.uploadEventHandlers;
          while (!this.uploadSession.isCancelled) {
            const nextRange = this.getNextRange();
            if (nextRange.maxValue === -1) {
              const err = new Error("Task with which you are trying to upload is already completed, Please check for your uploaded file");
              err.name = "Invalid Session";
              throw err;
            }
            const fileSlice = yield this.file.sliceFile(nextRange);
            const rawResponse = yield this.uploadSliceGetRawResponse(fileSlice, nextRange, this.file.size);
            if (!rawResponse) {
              throw new GraphClientError("Something went wrong! Large file upload slice response is null.");
            }
            const responseBody = yield GraphResponseHandler.getResponse(rawResponse);
            if (rawResponse.status === 201 || rawResponse.status === 200 && responseBody.id) {
              this.reportProgress(uploadEventHandlers, nextRange);
              return UploadResult.CreateUploadResult(responseBody, rawResponse.headers);
            }
            const res = {
              expirationDateTime: responseBody.expirationDateTime || responseBody.ExpirationDateTime,
              nextExpectedRanges: responseBody.NextExpectedRanges || responseBody.nextExpectedRanges
            };
            this.updateTaskStatus(res);
            this.reportProgress(uploadEventHandlers, nextRange);
          }
        });
      }
      reportProgress(uploadEventHandlers, nextRange) {
        if (uploadEventHandlers && uploadEventHandlers.progress) {
          uploadEventHandlers.progress(nextRange, uploadEventHandlers.extraCallbackParam);
        }
      }
      /**
       * @public
       * @async
       * Uploads given slice to the server
       * @param {ArrayBuffer | Blob | File} fileSlice - The file slice
       * @param {Range} range - The range value
       * @param {number} totalSize - The total size of a complete file
       * @returns The response body of the upload slice result
       */
      uploadSlice(fileSlice, range, totalSize) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.client.api(this.uploadSession.url).headers({
            "Content-Length": `${range.maxValue - range.minValue + 1}`,
            "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,
            "Content-Type": "application/octet-stream"
          }).put(fileSlice);
        });
      }
      /**
       * @public
       * @async
       * Uploads given slice to the server
       * @param {unknown} fileSlice - The file slice
       * @param {Range} range - The range value
       * @param {number} totalSize - The total size of a complete file
       * @returns The raw response of the upload slice result
       */
      uploadSliceGetRawResponse(fileSlice, range, totalSize) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.client.api(this.uploadSession.url).headers({
            "Content-Length": `${range.maxValue - range.minValue + 1}`,
            "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,
            "Content-Type": "application/octet-stream"
          }).responseType(ResponseType.RAW).put(fileSlice);
        });
      }
      /**
       * @public
       * @async
       * Deletes upload session in the server
       * @returns The promise resolves to cancelled response
       */
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          const cancelResponse = yield this.client.api(this.uploadSession.url).responseType(ResponseType.RAW).delete();
          if (cancelResponse.status === 204) {
            this.uploadSession.isCancelled = true;
          }
          return cancelResponse;
        });
      }
      /**
       * @public
       * @async
       * Gets status for the upload session
       * @returns The promise resolves to the status enquiry response
       */
      getStatus() {
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield this.client.api(this.uploadSession.url).get();
          this.updateTaskStatus(response);
          return response;
        });
      }
      /**
       * @public
       * @async
       * Resumes upload session and continue uploading the file from the last sent range
       * @returns The promise resolves to the uploaded response
       */
      resume() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.getStatus();
          return yield this.upload();
        });
      }
      /**
       * @public
       * @async
       * Get the upload session information
       * @returns The large file upload session
       */
      getUploadSession() {
        return this.uploadSession;
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/FileObjectClasses/FileUpload.js
var FileUpload;
var init_FileUpload = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/FileObjectClasses/FileUpload.js"() {
    init_GraphClientError();
    FileUpload = class {
      /**
       * @public
       * @constructor
       * @param {ArrayBuffer | Blob | Uint8Array} content - The file to be uploaded
       * @param {string} name - The name of the file to be uploaded
       * @param {number} size - The total size of the file to be uploaded
       * @returns An instance of the FileUpload class
       */
      constructor(content, name, size) {
        this.content = content;
        this.name = name;
        this.size = size;
        if (!content || !name || !size) {
          throw new GraphClientError("Please provide the upload content, name of the file and size of the file");
        }
      }
      /**
       * @public
       * Slices the file content to the given range
       * @param {Range} range - The range value
       * @returns The sliced file part
       */
      sliceFile(range) {
        return this.content.slice(range.minValue, range.maxValue + 1);
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTaskUtil.js
var DEFAULT_FILE_SIZE, roundTo320KB, getValidRangeSize;
var init_OneDriveLargeFileUploadTaskUtil = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTaskUtil.js"() {
    DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
    roundTo320KB = (value) => {
      if (value > 320 * 1024) {
        value = Math.floor(value / (320 * 1024)) * 320 * 1024;
      }
      return value;
    };
    getValidRangeSize = (rangeSize = DEFAULT_FILE_SIZE) => {
      const sixtyMB = 60 * 1024 * 1024;
      if (rangeSize > sixtyMB) {
        rangeSize = sixtyMB;
      }
      return roundTo320KB(rangeSize);
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTask.js
var OneDriveLargeFileUploadTask;
var init_OneDriveLargeFileUploadTask = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTask.js"() {
    init_tslib_es6();
    init_GraphClientError();
    init_FileUpload();
    init_LargeFileUploadTask();
    init_OneDriveLargeFileUploadTaskUtil();
    OneDriveLargeFileUploadTask = class extends LargeFileUploadTask {
      /**
       * @private
       * @static
       * Constructs the create session url for Onedrive
       * @param {string} fileName - The name of the file
       * @param {path} [path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH] - The path for the upload
       * @returns The constructed create session url
       */
      static constructCreateSessionUrl(fileName, path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH) {
        fileName = fileName.trim();
        path = path.trim();
        if (path === "") {
          path = "/";
        }
        if (path[0] !== "/") {
          path = `/${path}`;
        }
        if (path[path.length - 1] !== "/") {
          path = `${path}/`;
        }
        return `/me/drive/root:${path.split("/").map((p) => encodeURIComponent(p)).join("/")}${encodeURIComponent(fileName)}:/createUploadSession`;
      }
      /**
       * @private
       * @static
       * Get file information
       * @param {Blob | Uint8Array | File} file - The file entity
       * @param {string} fileName - The file name
       * @returns {FileInfo} The file information
       */
      static getFileInfo(file, fileName) {
        let content;
        let size;
        if (typeof Blob !== "undefined" && file instanceof Blob) {
          content = new File([file], fileName);
          size = content.size;
        } else if (typeof File !== "undefined" && file instanceof File) {
          content = file;
          size = content.size;
        } else if (typeof Uint8Array !== "undefined" && file instanceof Uint8Array) {
          const b = file;
          size = b.byteLength;
          content = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
        }
        return {
          content,
          size
        };
      }
      /**
       * @public
       * @static
       * @async
       * Creates a OneDriveLargeFileUploadTask
       * @param {Client} client - The GraphClient instance
       * @param {Blob | Uint8Array | File} file - File represented as Blob, Uint8Array or File
       * @param {OneDriveLargeFileUploadOptions} options - The options for upload task
       * @returns The promise that will be resolves to OneDriveLargeFileUploadTask instance
       */
      static create(client, file, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!client || !file || !options) {
            throw new GraphClientError("Please provide the Graph client instance, file object and OneDriveLargeFileUploadOptions value");
          }
          const fileName = options.fileName;
          const fileInfo = OneDriveLargeFileUploadTask.getFileInfo(file, fileName);
          const fileObj = new FileUpload(fileInfo.content, fileName, fileInfo.size);
          return this.createTaskWithFileObject(client, fileObj, options);
        });
      }
      /**
       * @public
       * @static
       * @async
       * Creates a OneDriveLargeFileUploadTask
       * @param {Client} client - The GraphClient instance
       * @param {FileObject} fileObject - FileObject instance
       * @param {OneDriveLargeFileUploadOptions} options - The options for upload task
       * @returns The promise that will be resolves to OneDriveLargeFileUploadTask instance
       */
      static createTaskWithFileObject(client, fileObject, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!client || !fileObject || !options) {
            throw new GraphClientError("Please provide the Graph client instance, FileObject interface implementation and OneDriveLargeFileUploadOptions value");
          }
          const requestUrl = options.uploadSessionURL ? options.uploadSessionURL : OneDriveLargeFileUploadTask.constructCreateSessionUrl(options.fileName, options.path);
          const uploadSessionPayload = {
            fileName: options.fileName,
            fileDescription: options.fileDescription,
            conflictBehavior: options.conflictBehavior
          };
          const session = yield OneDriveLargeFileUploadTask.createUploadSession(client, requestUrl, uploadSessionPayload);
          const rangeSize = getValidRangeSize(options.rangeSize);
          return new OneDriveLargeFileUploadTask(client, fileObject, session, {
            rangeSize,
            uploadEventHandlers: options.uploadEventHandlers
          });
        });
      }
      /**
       * @public
       * @static
       * @async
       * Makes request to the server to create an upload session
       * @param {Client} client - The GraphClient instance
       * @param {string} requestUrl - The URL to create the upload session
       * @param {string} payloadOptions - The payload option. Default conflictBehavior is 'rename'
       * @returns The promise that resolves to LargeFileUploadSession
       */
      static createUploadSession(client, requestUrl, payloadOptions) {
        const _super = Object.create(null, {
          createUploadSession: { get: () => super.createUploadSession }
        });
        return __awaiter(this, void 0, void 0, function* () {
          const payload = {
            item: {
              "@microsoft.graph.conflictBehavior": (payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.conflictBehavior) || "rename",
              name: payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.fileName,
              description: payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.fileDescription
            }
          };
          return _super.createUploadSession.call(this, client, requestUrl, payload);
        });
      }
      /**
       * @public
       * @constructor
       * Constructs a OneDriveLargeFileUploadTask
       * @param {Client} client - The GraphClient instance
       * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded
       * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done
       * @param {LargeFileUploadTaskOptions} options - The upload task options
       * @returns An instance of OneDriveLargeFileUploadTask
       */
      constructor(client, file, uploadSession, options) {
        super(client, file, uploadSession, options);
      }
      /**
       * @public
       * Commits upload session to end uploading
       * @param {string} requestUrl - The URL to commit the upload session
       * @param {string} conflictBehavior - Conflict behaviour option. Default is 'rename'
       * @returns The promise resolves to committed response
       */
      commit(requestUrl, conflictBehavior = "rename") {
        return __awaiter(this, void 0, void 0, function* () {
          const payload = {
            name: this.file.name,
            "@microsoft.graph.conflictBehavior": conflictBehavior,
            "@microsoft.graph.sourceUrl": this.uploadSession.url
          };
          return yield this.client.api(requestUrl).put(payload);
        });
      }
    };
    OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH = "/";
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/FileObjectClasses/StreamUpload.js
var init_StreamUpload = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/FileObjectClasses/StreamUpload.js"() {
    init_tslib_es6();
    init_GraphClientError();
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/PageIterator.js
var init_PageIterator = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/PageIterator.js"() {
    init_tslib_es6();
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/CustomAuthenticationProvider.js
var CustomAuthenticationProvider;
var init_CustomAuthenticationProvider = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/CustomAuthenticationProvider.js"() {
    init_tslib_es6();
    init_GraphClientError();
    CustomAuthenticationProvider = class {
      /**
       * @public
       * @constructor
       * Creates an instance of CustomAuthenticationProvider
       * @param {AuthProviderCallback} provider - An authProvider function
       * @returns An instance of CustomAuthenticationProvider
       */
      constructor(provider) {
        this.provider = provider;
      }
      /**
       * @public
       * @async
       * To get the access token
       * @returns The promise that resolves to an access token
       */
      getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.provider((error, accessToken) => __awaiter(this, void 0, void 0, function* () {
              if (accessToken) {
                resolve(accessToken);
              } else {
                if (!error) {
                  const invalidTokenMessage = "Access token is undefined or empty.						Please provide a valid token.						For more help - https://github.com/microsoftgraph/msgraph-sdk-javascript/blob/dev/docs/CustomAuthenticationProvider.md";
                  error = new GraphClientError(invalidTokenMessage);
                }
                const err = yield GraphClientError.setGraphClientError(error);
                reject(err);
              }
            }));
          });
        });
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphError.js
var GraphError;
var init_GraphError = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphError.js"() {
    GraphError = class extends Error {
      /**
       * @public
       * @constructor
       * Creates an instance of GraphError
       * @param {number} [statusCode = -1] - The status code of the error
       * @param {string} [message] - The message of the error
       * @param {Error} [baseError] - The base error
       * @returns An instance of GraphError
       */
      constructor(statusCode = -1, message, baseError) {
        super(message || baseError && baseError.message);
        Object.setPrototypeOf(this, GraphError.prototype);
        this.statusCode = statusCode;
        this.code = null;
        this.requestId = null;
        this.date = /* @__PURE__ */ new Date();
        this.body = null;
        this.stack = baseError ? baseError.stack : this.stack;
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphErrorHandler.js
var GraphErrorHandler;
var init_GraphErrorHandler = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphErrorHandler.js"() {
    init_tslib_es6();
    init_GraphError();
    GraphErrorHandler = class {
      /**
       * @private
       * @static
       * Populates the GraphError instance with Error instance values
       * @param {Error} error - The error returned by graph service or some native error
       * @param {number} [statusCode] - The status code of the response
       * @returns The GraphError instance
       */
      static constructError(error, statusCode, rawResponse) {
        const gError = new GraphError(statusCode, "", error);
        if (error.name !== void 0) {
          gError.code = error.name;
        }
        gError.body = error.toString();
        gError.date = /* @__PURE__ */ new Date();
        gError.headers = rawResponse === null || rawResponse === void 0 ? void 0 : rawResponse.headers;
        return gError;
      }
      /**
       * @private
       * @static
       * @async
       * Populates the GraphError instance from the Error returned by graph service
       * @param {GraphAPIErrorResponse} graphError - The error possibly returned by graph service or some native error
       * @param {number} statusCode - The status code of the response
       * @returns A promise that resolves to GraphError instance
       *
       * Example error for https://graph.microsoft.com/v1.0/me/events?$top=3&$search=foo
       * {
       *      "error": {
       *          "code": "SearchEvents",
       *          "message": "The parameter $search is not currently supported on the Events resource.",
       *          "innerError": {
       *              "request-id": "b31c83fd-944c-4663-aa50-5d9ceb367e19",
       *              "date": "2016-11-17T18:37:45"
       *          }
       *      }
       *  }
       */
      static constructErrorFromResponse(graphError, statusCode, rawResponse) {
        const error = graphError.error;
        const gError = new GraphError(statusCode, error.message);
        gError.code = error.code;
        if (error.innerError !== void 0) {
          gError.requestId = error.innerError["request-id"];
          gError.date = new Date(error.innerError.date);
        }
        gError.body = JSON.stringify(error);
        gError.headers = rawResponse === null || rawResponse === void 0 ? void 0 : rawResponse.headers;
        return gError;
      }
      /**
       * @public
       * @static
       * @async
       * To get the GraphError object
       * Reference - https://docs.microsoft.com/en-us/graph/errors
       * @param {any} [error = null] - The error returned by graph service or some native error
       * @param {number} [statusCode = -1] - The status code of the response
       * @param {GraphRequestCallback} [callback] - The graph request callback function
       * @returns A promise that resolves to GraphError instance
       */
      static getError(error = null, statusCode = -1, callback, rawResponse) {
        return __awaiter(this, void 0, void 0, function* () {
          let gError;
          if (error && error.error) {
            gError = GraphErrorHandler.constructErrorFromResponse(error, statusCode, rawResponse);
          } else if (error instanceof Error) {
            gError = GraphErrorHandler.constructError(error, statusCode, rawResponse);
          } else {
            gError = new GraphError(statusCode);
            gError.body = error;
          }
          if (typeof callback === "function") {
            callback(gError, null);
          } else {
            return gError;
          }
        });
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequest.js
var GraphRequest;
var init_GraphRequest = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequest.js"() {
    init_tslib_es6();
    init_GraphClientError();
    init_GraphErrorHandler();
    init_GraphRequestUtil();
    init_GraphResponseHandler();
    init_MiddlewareControl();
    init_RequestMethod();
    init_ResponseType();
    GraphRequest = class {
      /**
       * @public
       * @constructor
       * Creates an instance of GraphRequest
       * @param {HTTPClient} httpClient - The HTTPClient instance
       * @param {ClientOptions} config - The options for making request
       * @param {string} path - A path string
       */
      constructor(httpClient, config, path) {
        this.parsePath = (path2) => {
          if (path2.indexOf("https://") !== -1) {
            path2 = path2.replace("https://", "");
            const endOfHostStrPos = path2.indexOf("/");
            if (endOfHostStrPos !== -1) {
              this.urlComponents.host = "https://" + path2.substring(0, endOfHostStrPos);
              path2 = path2.substring(endOfHostStrPos + 1, path2.length);
            }
            const endOfVersionStrPos = path2.indexOf("/");
            if (endOfVersionStrPos !== -1) {
              this.urlComponents.version = path2.substring(0, endOfVersionStrPos);
              path2 = path2.substring(endOfVersionStrPos + 1, path2.length);
            }
          }
          if (path2.charAt(0) === "/") {
            path2 = path2.substr(1);
          }
          const queryStrPos = path2.indexOf("?");
          if (queryStrPos === -1) {
            this.urlComponents.path = path2;
          } else {
            this.urlComponents.path = path2.substr(0, queryStrPos);
            const queryParams = path2.substring(queryStrPos + 1, path2.length).split("&");
            for (const queryParam of queryParams) {
              this.parseQueryParameter(queryParam);
            }
          }
        };
        this.httpClient = httpClient;
        this.config = config;
        this.urlComponents = {
          host: this.config.baseUrl,
          version: this.config.defaultVersion,
          oDataQueryParams: {},
          otherURLQueryParams: {},
          otherURLQueryOptions: []
        };
        this._headers = {};
        this._options = {};
        this._middlewareOptions = [];
        this.parsePath(path);
      }
      /**
       * @private
       * Adds the query parameter as comma separated values
       * @param {string} propertyName - The name of a property
       * @param {string|string[]} propertyValue - The vale of a property
       * @param {IArguments} additionalProperties - The additional properties
       * @returns Nothing
       */
      addCsvQueryParameter(propertyName, propertyValue, additionalProperties) {
        this.urlComponents.oDataQueryParams[propertyName] = this.urlComponents.oDataQueryParams[propertyName] ? this.urlComponents.oDataQueryParams[propertyName] + "," : "";
        let allValues = [];
        if (additionalProperties.length > 1 && typeof propertyValue === "string") {
          allValues = Array.prototype.slice.call(additionalProperties);
        } else if (typeof propertyValue === "string") {
          allValues.push(propertyValue);
        } else {
          allValues = allValues.concat(propertyValue);
        }
        this.urlComponents.oDataQueryParams[propertyName] += allValues.join(",");
      }
      /**
       * @private
       * Builds the full url from the URLComponents to make a request
       * @returns The URL string that is qualified to make a request to graph endpoint
       */
      buildFullUrl() {
        const url = urlJoin([this.urlComponents.host, this.urlComponents.version, this.urlComponents.path]) + this.createQueryString();
        if (this.config.debugLogging) {
          console.log(url);
        }
        return url;
      }
      /**
       * @private
       * Builds the query string from the URLComponents
       * @returns The Constructed query string
       */
      createQueryString() {
        const urlComponents = this.urlComponents;
        const query = [];
        if (Object.keys(urlComponents.oDataQueryParams).length !== 0) {
          for (const property2 in urlComponents.oDataQueryParams) {
            if (Object.prototype.hasOwnProperty.call(urlComponents.oDataQueryParams, property2)) {
              query.push(property2 + "=" + urlComponents.oDataQueryParams[property2]);
            }
          }
        }
        if (Object.keys(urlComponents.otherURLQueryParams).length !== 0) {
          for (const property2 in urlComponents.otherURLQueryParams) {
            if (Object.prototype.hasOwnProperty.call(urlComponents.otherURLQueryParams, property2)) {
              query.push(property2 + "=" + urlComponents.otherURLQueryParams[property2]);
            }
          }
        }
        if (urlComponents.otherURLQueryOptions.length !== 0) {
          for (const str of urlComponents.otherURLQueryOptions) {
            query.push(str);
          }
        }
        return query.length > 0 ? "?" + query.join("&") : "";
      }
      /**
       * @private
       * Parses the query parameters to set the urlComponents property of the GraphRequest object
       * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query parameter
       * @returns The same GraphRequest instance that is being called with
       */
      parseQueryParameter(queryDictionaryOrString) {
        if (typeof queryDictionaryOrString === "string") {
          if (queryDictionaryOrString.charAt(0) === "?") {
            queryDictionaryOrString = queryDictionaryOrString.substring(1);
          }
          if (queryDictionaryOrString.indexOf("&") !== -1) {
            const queryParams = queryDictionaryOrString.split("&");
            for (const str of queryParams) {
              this.parseQueryParamenterString(str);
            }
          } else {
            this.parseQueryParamenterString(queryDictionaryOrString);
          }
        } else if (queryDictionaryOrString.constructor === Object) {
          for (const key in queryDictionaryOrString) {
            if (Object.prototype.hasOwnProperty.call(queryDictionaryOrString, key)) {
              this.setURLComponentsQueryParamater(key, queryDictionaryOrString[key]);
            }
          }
        }
        return this;
      }
      /**
       * @private
       * Parses the query parameter of string type to set the urlComponents property of the GraphRequest object
       * @param {string} queryParameter - the query parameters
       * returns nothing
       */
      parseQueryParamenterString(queryParameter) {
        if (this.isValidQueryKeyValuePair(queryParameter)) {
          const indexOfFirstEquals = queryParameter.indexOf("=");
          const paramKey = queryParameter.substring(0, indexOfFirstEquals);
          const paramValue = queryParameter.substring(indexOfFirstEquals + 1);
          this.setURLComponentsQueryParamater(paramKey, paramValue);
        } else {
          this.urlComponents.otherURLQueryOptions.push(queryParameter);
        }
      }
      /**
       * @private
       * Sets values into the urlComponents property of GraphRequest object.
       * @param {string} paramKey - the query parameter key
       * @param {string} paramValue - the query paramter value
       * @returns nothing
       */
      setURLComponentsQueryParamater(paramKey, paramValue) {
        if (oDataQueryNames.indexOf(paramKey) !== -1) {
          const currentValue = this.urlComponents.oDataQueryParams[paramKey];
          const isValueAppendable = currentValue && (paramKey === "$expand" || paramKey === "$select" || paramKey === "$orderby");
          this.urlComponents.oDataQueryParams[paramKey] = isValueAppendable ? currentValue + "," + paramValue : paramValue;
        } else {
          this.urlComponents.otherURLQueryParams[paramKey] = paramValue;
        }
      }
      /**
       * @private
       * Check if the query parameter string has a valid key-value structure
       * @param {string} queryString - the query parameter string. Example -> "name=value"
       * #returns true if the query string has a valid key-value structure else false
       */
      isValidQueryKeyValuePair(queryString) {
        const indexofFirstEquals = queryString.indexOf("=");
        if (indexofFirstEquals === -1) {
          return false;
        }
        const indexofOpeningParanthesis = queryString.indexOf("(");
        if (indexofOpeningParanthesis !== -1 && queryString.indexOf("(") < indexofFirstEquals) {
          return false;
        }
        return true;
      }
      /**
       * @private
       * Updates the custom headers and options for a request
       * @param {FetchOptions} options - The request options object
       * @returns Nothing
       */
      updateRequestOptions(options) {
        const optionsHeaders = Object.assign({}, options.headers);
        if (this.config.fetchOptions !== void 0) {
          const fetchOptions = Object.assign({}, this.config.fetchOptions);
          Object.assign(options, fetchOptions);
          if (typeof this.config.fetchOptions.headers !== void 0) {
            options.headers = Object.assign({}, this.config.fetchOptions.headers);
          }
        }
        Object.assign(options, this._options);
        if (options.headers !== void 0) {
          Object.assign(optionsHeaders, options.headers);
        }
        Object.assign(optionsHeaders, this._headers);
        options.headers = optionsHeaders;
      }
      /**
       * @private
       * @async
       * Adds the custom headers and options to the request and makes the HTTPClient send request call
       * @param {RequestInfo} request - The request url string or the Request object value
       * @param {FetchOptions} options - The options to make a request
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the response content
       */
      send(request, options, callback) {
        var _a5;
        return __awaiter(this, void 0, void 0, function* () {
          let rawResponse;
          const middlewareControl = new MiddlewareControl(this._middlewareOptions);
          this.updateRequestOptions(options);
          const customHosts = (_a5 = this.config) === null || _a5 === void 0 ? void 0 : _a5.customHosts;
          try {
            const context = yield this.httpClient.sendRequest({
              request,
              options,
              middlewareControl,
              customHosts
            });
            rawResponse = context.response;
            const response = yield GraphResponseHandler.getResponse(rawResponse, this._responseType, callback);
            return response;
          } catch (error) {
            if (error instanceof GraphClientError) {
              throw error;
            }
            let statusCode;
            if (rawResponse) {
              statusCode = rawResponse.status;
            }
            const gError = yield GraphErrorHandler.getError(error, statusCode, callback, rawResponse);
            throw gError;
          }
        });
      }
      /**
       * @private
       * Checks if the content-type is present in the _headers property. If not present, defaults the content-type to application/json
       * @param none
       * @returns nothing
       */
      setHeaderContentType() {
        if (!this._headers) {
          this.header("Content-Type", "application/json");
          return;
        }
        const headerKeys = Object.keys(this._headers);
        for (const headerKey of headerKeys) {
          if (headerKey.toLowerCase() === "content-type") {
            return;
          }
        }
        this.header("Content-Type", "application/json");
      }
      /**
       * @public
       * Sets the custom header for a request
       * @param {string} headerKey - A header key
       * @param {string} headerValue - A header value
       * @returns The same GraphRequest instance that is being called with
       */
      header(headerKey, headerValue) {
        this._headers[headerKey] = headerValue;
        return this;
      }
      /**
       * @public
       * Sets the custom headers for a request
       * @param {KeyValuePairObjectStringNumber | HeadersInit} headers - The request headers
       * @returns The same GraphRequest instance that is being called with
       */
      headers(headers) {
        for (const key in headers) {
          if (Object.prototype.hasOwnProperty.call(headers, key)) {
            this._headers[key] = headers[key];
          }
        }
        return this;
      }
      /**
       * @public
       * Sets the option for making a request
       * @param {string} key - The key value
       * @param {any} value - The value
       * @returns The same GraphRequest instance that is being called with
       */
      option(key, value) {
        this._options[key] = value;
        return this;
      }
      /**
       * @public
       * Sets the options for making a request
       * @param {{ [key: string]: any }} options - The options key value pair
       * @returns The same GraphRequest instance that is being called with
       */
      options(options) {
        for (const key in options) {
          if (Object.prototype.hasOwnProperty.call(options, key)) {
            this._options[key] = options[key];
          }
        }
        return this;
      }
      /**
       * @public
       * Sets the middleware options for a request
       * @param {MiddlewareOptions[]} options - The array of middleware options
       * @returns The same GraphRequest instance that is being called with
       */
      middlewareOptions(options) {
        this._middlewareOptions = options;
        return this;
      }
      /**
       * @public
       * Sets the api endpoint version for a request
       * @param {string} version - The version value
       * @returns The same GraphRequest instance that is being called with
       */
      version(version) {
        this.urlComponents.version = version;
        return this;
      }
      /**
       * @public
       * Sets the api endpoint version for a request
       * @param {ResponseType} responseType - The response type value
       * @returns The same GraphRequest instance that is being called with
       */
      responseType(responseType) {
        this._responseType = responseType;
        return this;
      }
      /**
       * @public
       * To add properties for select OData Query param
       * @param {string|string[]} properties - The Properties value
       * @returns The same GraphRequest instance that is being called with, after adding the properties for $select query
       */
      /*
       * Accepts .select("displayName,birthday")
       *     and .select(["displayName", "birthday"])
       *     and .select("displayName", "birthday")
       *
       */
      select(properties) {
        this.addCsvQueryParameter("$select", properties, arguments);
        return this;
      }
      /**
       * @public
       * To add properties for expand OData Query param
       * @param {string|string[]} properties - The Properties value
       * @returns The same GraphRequest instance that is being called with, after adding the properties for $expand query
       */
      expand(properties) {
        this.addCsvQueryParameter("$expand", properties, arguments);
        return this;
      }
      /**
       * @public
       * To add properties for orderby OData Query param
       * @param {string|string[]} properties - The Properties value
       * @returns The same GraphRequest instance that is being called with, after adding the properties for $orderby query
       */
      orderby(properties) {
        this.addCsvQueryParameter("$orderby", properties, arguments);
        return this;
      }
      /**
       * @public
       * To add query string for filter OData Query param. The request URL accepts only one $filter Odata Query option and its value is set to the most recently passed filter query string.
       * @param {string} filterStr - The filter query string
       * @returns The same GraphRequest instance that is being called with, after adding the $filter query
       */
      filter(filterStr) {
        this.urlComponents.oDataQueryParams.$filter = filterStr;
        return this;
      }
      /**
       * @public
       * To add criterion for search OData Query param. The request URL accepts only one $search Odata Query option and its value is set to the most recently passed search criterion string.
       * @param {string} searchStr - The search criterion string
       * @returns The same GraphRequest instance that is being called with, after adding the $search query criteria
       */
      search(searchStr) {
        this.urlComponents.oDataQueryParams.$search = searchStr;
        return this;
      }
      /**
       * @public
       * To add number for top OData Query param. The request URL accepts only one $top Odata Query option and its value is set to the most recently passed number value.
       * @param {number} n - The number value
       * @returns The same GraphRequest instance that is being called with, after adding the number for $top query
       */
      top(n) {
        this.urlComponents.oDataQueryParams.$top = n;
        return this;
      }
      /**
       * @public
       * To add number for skip OData Query param. The request URL accepts only one $skip Odata Query option and its value is set to the most recently passed number value.
       * @param {number} n - The number value
       * @returns The same GraphRequest instance that is being called with, after adding the number for the $skip query
       */
      skip(n) {
        this.urlComponents.oDataQueryParams.$skip = n;
        return this;
      }
      /**
       * @public
       * To add token string for skipToken OData Query param. The request URL accepts only one $skipToken Odata Query option and its value is set to the most recently passed token value.
       * @param {string} token - The token value
       * @returns The same GraphRequest instance that is being called with, after adding the token string for $skipToken query option
       */
      skipToken(token) {
        this.urlComponents.oDataQueryParams.$skipToken = token;
        return this;
      }
      /**
       * @public
       * To add boolean for count OData Query param. The URL accepts only one $count Odata Query option and its value is set to the most recently passed boolean value.
       * @param {boolean} isCount - The count boolean
       * @returns The same GraphRequest instance that is being called with, after adding the boolean value for the $count query option
       */
      count(isCount = true) {
        this.urlComponents.oDataQueryParams.$count = isCount.toString();
        return this;
      }
      /**
       * @public
       * Appends query string to the urlComponent
       * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query value
       * @returns The same GraphRequest instance that is being called with, after appending the query string to the url component
       */
      /*
       * Accepts .query("displayName=xyz")
       *     and .select({ name: "value" })
       */
      query(queryDictionaryOrString) {
        return this.parseQueryParameter(queryDictionaryOrString);
      }
      /**
       * @public
       * @async
       * Makes a http request with GET method
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the get response
       */
      get(callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.buildFullUrl();
          const options = {
            method: RequestMethod.GET
          };
          const response = yield this.send(url, options, callback);
          return response;
        });
      }
      /**
       * @public
       * @async
       * Makes a http request with POST method
       * @param {any} content - The content that needs to be sent with the request
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the post response
       */
      post(content, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.buildFullUrl();
          const options = {
            method: RequestMethod.POST,
            body: serializeContent(content)
          };
          const className = content && content.constructor && content.constructor.name;
          if (className === "FormData") {
            options.headers = {};
          } else {
            this.setHeaderContentType();
            options.headers = this._headers;
          }
          return yield this.send(url, options, callback);
        });
      }
      /**
       * @public
       * @async
       * Alias for Post request call
       * @param {any} content - The content that needs to be sent with the request
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the post response
       */
      create(content, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.post(content, callback);
        });
      }
      /**
       * @public
       * @async
       * Makes http request with PUT method
       * @param {any} content - The content that needs to be sent with the request
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the put response
       */
      put(content, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.buildFullUrl();
          this.setHeaderContentType();
          const options = {
            method: RequestMethod.PUT,
            body: serializeContent(content)
          };
          return yield this.send(url, options, callback);
        });
      }
      /**
       * @public
       * @async
       * Makes http request with PATCH method
       * @param {any} content - The content that needs to be sent with the request
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the patch response
       */
      patch(content, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.buildFullUrl();
          this.setHeaderContentType();
          const options = {
            method: RequestMethod.PATCH,
            body: serializeContent(content)
          };
          return yield this.send(url, options, callback);
        });
      }
      /**
       * @public
       * @async
       * Alias for PATCH request
       * @param {any} content - The content that needs to be sent with the request
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the patch response
       */
      update(content, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.patch(content, callback);
        });
      }
      /**
       * @public
       * @async
       * Makes http request with DELETE method
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the delete response
       */
      delete(callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.buildFullUrl();
          const options = {
            method: RequestMethod.DELETE
          };
          return yield this.send(url, options, callback);
        });
      }
      /**
       * @public
       * @async
       * Alias for delete request call
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the delete response
       */
      del(callback) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.delete(callback);
        });
      }
      /**
       * @public
       * @async
       * Makes a http request with GET method to read response as a stream.
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the getStream response
       */
      getStream(callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.buildFullUrl();
          const options = {
            method: RequestMethod.GET
          };
          this.responseType(ResponseType.STREAM);
          return yield this.send(url, options, callback);
        });
      }
      /**
       * @public
       * @async
       * Makes a http request with GET method to read response as a stream.
       * @param {any} stream - The stream instance
       * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
       * @returns A promise that resolves to the putStream response
       */
      putStream(stream, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.buildFullUrl();
          const options = {
            method: RequestMethod.PUT,
            headers: {
              "Content-Type": "application/octet-stream"
            },
            body: stream
          };
          return yield this.send(url, options, callback);
        });
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClient.js
var HTTPClient;
var init_HTTPClient = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClient.js"() {
    init_tslib_es6();
    HTTPClient = class {
      /**
       * @public
       * @constructor
       * Creates an instance of a HTTPClient
       * @param {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers
       */
      constructor(...middleware) {
        if (!middleware || !middleware.length) {
          const error = new Error();
          error.name = "InvalidMiddlewareChain";
          error.message = "Please provide a default middleware chain or custom middleware chain";
          throw error;
        }
        this.setMiddleware(...middleware);
      }
      /**
       * @private
       * Processes the middleware parameter passed to set this.middleware property
       * The calling function should validate if middleware is not undefined or not empty.
       * @param {...Middleware} middleware - The middleware passed
       * @returns Nothing
       */
      setMiddleware(...middleware) {
        if (middleware.length > 1) {
          this.parseMiddleWareArray(middleware);
        } else {
          this.middleware = middleware[0];
        }
      }
      /**
       * @private
       * Processes the middleware array to construct the chain
       * and sets this.middleware property to the first middleware handler of the array
       * The calling function should validate if middleware is not undefined or not empty
       * @param {Middleware[]} middlewareArray - The array of middleware handlers
       * @returns Nothing
       */
      parseMiddleWareArray(middlewareArray) {
        middlewareArray.forEach((element, index) => {
          if (index < middlewareArray.length - 1) {
            element.setNext(middlewareArray[index + 1]);
          }
        });
        this.middleware = middlewareArray[0];
      }
      /**
       * @public
       * @async
       * To send the request through the middleware chain
       * @param {Context} context - The context of a request
       * @returns A promise that resolves to the Context
       */
      sendRequest(context) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof context.request === "string" && context.options === void 0) {
            const error = new Error();
            error.name = "InvalidRequestOptions";
            error.message = "Unable to execute the middleware, Please provide valid options for a request";
            throw error;
          }
          yield this.middleware.execute(context);
          return context;
        });
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClientFactory.js
var isNodeEnvironment, HTTPClientFactory;
var init_HTTPClientFactory = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClientFactory.js"() {
    init_HTTPClient();
    init_AuthenticationHandler();
    init_HTTPMessageHandler();
    init_RedirectHandlerOptions();
    init_RetryHandlerOptions();
    init_RedirectHandler();
    init_RetryHandler();
    init_TelemetryHandler();
    isNodeEnvironment = () => {
      return typeof process === "object" && typeof __require === "function";
    };
    HTTPClientFactory = class {
      /**
       * @public
       * @static
       * Creates HTTPClient with default middleware chain
       * @param {AuthenticationProvider} authProvider - The authentication provider instance
       * @returns A HTTPClient instance
       *
       * NOTE: These are the things that we need to remember while doing modifications in the below default pipeline.
       * 		* HTTPMessageHandler should be the last one in the middleware pipeline, because this makes the actual network call of the request
       * 		* TelemetryHandler should be the one prior to the last middleware in the chain, because this is the one which actually collects and appends the usage flag and placing this handler 	*		  before making the actual network call ensures that the usage of all features are recorded in the flag.
       * 		* The best place for AuthenticationHandler is in the starting of the pipeline, because every other handler might have to work for multiple times for a request but the auth token for
       * 		  them will remain same. For example, Retry and Redirect handlers might be working multiple times for a request based on the response but their auth token would remain same.
       */
      static createWithAuthenticationProvider(authProvider) {
        const authenticationHandler = new AuthenticationHandler(authProvider);
        const retryHandler = new RetryHandler(new RetryHandlerOptions());
        const telemetryHandler = new TelemetryHandler();
        const httpMessageHandler = new HTTPMessageHandler();
        authenticationHandler.setNext(retryHandler);
        if (isNodeEnvironment()) {
          const redirectHandler = new RedirectHandler(new RedirectHandlerOptions());
          retryHandler.setNext(redirectHandler);
          redirectHandler.setNext(telemetryHandler);
        } else {
          retryHandler.setNext(telemetryHandler);
        }
        telemetryHandler.setNext(httpMessageHandler);
        return HTTPClientFactory.createWithMiddleware(authenticationHandler);
      }
      /**
       * @public
       * @static
       * Creates a middleware chain with the given one
       * @property {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers
       * @returns A HTTPClient instance
       */
      static createWithMiddleware(...middleware) {
        return new HTTPClient(...middleware);
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/ValidatePolyFilling.js
var validatePolyFilling;
var init_ValidatePolyFilling = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/ValidatePolyFilling.js"() {
    validatePolyFilling = () => {
      if (typeof Promise === "undefined" && typeof fetch === "undefined") {
        const error = new Error("Library cannot function without Promise and fetch. So, please provide polyfill for them.");
        error.name = "PolyFillNotAvailable";
        throw error;
      } else if (typeof Promise === "undefined") {
        const error = new Error("Library cannot function without Promise. So, please provide polyfill for it.");
        error.name = "PolyFillNotAvailable";
        throw error;
      } else if (typeof fetch === "undefined") {
        const error = new Error("Library cannot function without fetch. So, please provide polyfill for it.");
        error.name = "PolyFillNotAvailable";
        throw error;
      }
      return true;
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/Client.js
var Client;
var init_Client = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/Client.js"() {
    init_Constants();
    init_CustomAuthenticationProvider();
    init_GraphRequest();
    init_HTTPClient();
    init_HTTPClientFactory();
    init_ValidatePolyFilling();
    Client = class {
      /**
       * @public
       * @static
       * To create a client instance with options and initializes the default middleware chain
       * @param {Options} options - The options for client instance
       * @returns The Client instance
       */
      static init(options) {
        const clientOptions = {};
        for (const i in options) {
          if (Object.prototype.hasOwnProperty.call(options, i)) {
            clientOptions[i] = i === "authProvider" ? new CustomAuthenticationProvider(options[i]) : options[i];
          }
        }
        return Client.initWithMiddleware(clientOptions);
      }
      /**
       * @public
       * @static
       * To create a client instance with the Client Options
       * @param {ClientOptions} clientOptions - The options object for initializing the client
       * @returns The Client instance
       */
      static initWithMiddleware(clientOptions) {
        return new Client(clientOptions);
      }
      /**
       * @private
       * @constructor
       * Creates an instance of Client
       * @param {ClientOptions} clientOptions - The options to instantiate the client object
       */
      constructor(clientOptions) {
        this.config = {
          baseUrl: GRAPH_BASE_URL,
          debugLogging: false,
          defaultVersion: GRAPH_API_VERSION
        };
        validatePolyFilling();
        for (const key in clientOptions) {
          if (Object.prototype.hasOwnProperty.call(clientOptions, key)) {
            this.config[key] = clientOptions[key];
          }
        }
        let httpClient;
        if (clientOptions.authProvider !== void 0 && clientOptions.middleware !== void 0) {
          const error = new Error();
          error.name = "AmbiguityInInitialization";
          error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain not both";
          throw error;
        } else if (clientOptions.authProvider !== void 0) {
          httpClient = HTTPClientFactory.createWithAuthenticationProvider(clientOptions.authProvider);
        } else if (clientOptions.middleware !== void 0) {
          httpClient = new HTTPClient(...[].concat(clientOptions.middleware));
        } else {
          const error = new Error();
          error.name = "InvalidMiddlewareChain";
          error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain";
          throw error;
        }
        this.httpClient = httpClient;
      }
      /**
       * @public
       * Entry point to make requests
       * @param {string} path - The path string value
       * @returns The graph request instance
       */
      api(path) {
        return new GraphRequest(this.httpClient, this.config, path);
      }
    };
  }
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/browser/index.js
var init_browser = __esm({
  "node_modules/@microsoft/microsoft-graph-client/lib/es/src/browser/index.js"() {
    init_BatchRequestContent();
    init_BatchResponseContent();
    init_AuthenticationHandler();
    init_HTTPMessageHandler();
    init_RetryHandler();
    init_RedirectHandler();
    init_TelemetryHandler();
    init_MiddlewareFactory();
    init_AuthenticationHandlerOptions();
    init_RetryHandlerOptions();
    init_RedirectHandlerOptions();
    init_TelemetryHandlerOptions();
    init_ChaosHandlerOptions();
    init_ChaosStrategy();
    init_ChaosHandler();
    init_LargeFileUploadTask();
    init_OneDriveLargeFileUploadTask();
    init_OneDriveLargeFileUploadTaskUtil();
    init_StreamUpload();
    init_FileUpload();
    init_UploadResult();
    init_Range();
    init_PageIterator();
    init_Client();
    init_CustomAuthenticationProvider();
    init_GraphError();
    init_GraphClientError();
    init_GraphRequest();
    init_ResponseType();
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/index.js
var delay;
var init_utils = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/index.js"() {
    delay = (ms) => {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/EventDispatcher.js
var EventDispatcher;
var init_EventDispatcher = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/EventDispatcher.js"() {
    EventDispatcher = class {
      constructor() {
        this.eventHandlers = [];
      }
      /**
       * fires event handler
       *
       * @param {E} event
       * @memberof EventDispatcher
       */
      fire(event) {
        for (const handler of this.eventHandlers) {
          handler(event);
        }
      }
      /**
       * adds eventHandler
       *
       * @param {EventHandler<E>} eventHandler
       * @memberof EventDispatcher
       */
      add(eventHandler) {
        this.eventHandlers.push(eventHandler);
      }
      /**
       * removes eventHandler
       *
       * @param {EventHandler<E>} eventHandler
       * @memberof EventDispatcher
       */
      remove(eventHandler) {
        for (let i = 0; i < this.eventHandlers.length; i++) {
          if (this.eventHandlers[i] === eventHandler) {
            this.eventHandlers.splice(i, 1);
            i--;
          }
        }
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/providers/IProvider.js
var IProvider, LoginType, ProviderState;
var init_IProvider = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/providers/IProvider.js"() {
    init_GraphHelpers();
    init_IGraph();
    init_EventDispatcher();
    IProvider = class {
      /**
       * Specifies if Multi account functionality is supported by the provider and enabled.
       *
       * @readonly
       * @type {boolean}
       * @memberof IProvider
       */
      get isMultiAccountSupportedAndEnabled() {
        return false;
      }
      /**
       * The base URL to be used in the graph client config.
       */
      set baseURL(url) {
        if (validateBaseURL(url)) {
          this._baseURL = url;
          return;
        } else {
          throw new Error(`${url} is not a valid Graph URL endpoint.`);
        }
      }
      get baseURL() {
        return this._baseURL;
      }
      get isMultiAccountSupported() {
        return this.isMultipleAccountSupported;
      }
      /**
       * returns state of Provider
       *
       * @readonly
       * @type {ProviderState}
       * @memberof IProvider
       */
      get state() {
        return this._state;
      }
      /**
       * Incremental consent setting
       *
       * @readonly
       * @memberof IProvider
       */
      get isIncrementalConsentDisabled() {
        return this._isIncrementalConsentDisabled;
      }
      /**
       * Enable/Disable incremental consent
       *
       * @readonly
       * @memberof IProvider
       */
      set isIncrementalConsentDisabled(disabled) {
        this._isIncrementalConsentDisabled = disabled;
      }
      /**
       * Name used for analytics
       *
       * @readonly
       * @memberof IProvider
       */
      get name() {
        return "MgtIProvider";
      }
      constructor() {
        this.isMultipleAccountDisabled = true;
        this._loginChangedDispatcher = new EventDispatcher();
        this._activeAccountChangedDispatcher = new EventDispatcher();
        this._baseURL = MICROSOFT_GRAPH_DEFAULT_ENDPOINT;
        this._isIncrementalConsentDisabled = false;
        this.isMultipleAccountSupported = false;
        this._state = ProviderState.Loading;
      }
      /**
       * sets state of Provider and fires loginchangedDispatcher
       *
       * @param {ProviderState} state
       * @memberof IProvider
       */
      setState(state2) {
        if (state2 !== this._state) {
          this._state = state2;
          this._loginChangedDispatcher.fire({});
        }
      }
      /**
       * event handler when login changes
       *
       * @param {EventHandler<LoginChangedEvent>} eventHandler
       * @memberof IProvider
       */
      onStateChanged(eventHandler) {
        this._loginChangedDispatcher.add(eventHandler);
      }
      /**
       * removes event handler for when login changes
       *
       * @param {EventHandler<LoginChangedEvent>} eventHandler
       * @memberof IProvider
       */
      removeStateChangedHandler(eventHandler) {
        this._loginChangedDispatcher.remove(eventHandler);
      }
      /**
       * Switch between two signed in accounts
       *
       * @param {*} user
       * @memberof IProvider
       */
      setActiveAccount(user) {
        this.fireActiveAccountChanged();
      }
      /**
       * Event handler when Active account changes
       *
       * @param {EventHandler<ActiveAccountChanged>} eventHandler
       * @memberof IProvider
       */
      onActiveAccountChanged(eventHandler) {
        this._activeAccountChangedDispatcher.add(eventHandler);
      }
      /**
       * Removes event handler for when Active account changes
       *
       * @param {EventHandler<ActiveAccountChanged>} eventHandler
       * @memberof IProvider
       */
      removeActiveAccountChangedHandler(eventHandler) {
        this._activeAccountChangedDispatcher.remove(eventHandler);
      }
      /**
       * Fires event when active account changes
       *
       * @memberof IProvider
       */
      fireActiveAccountChanged() {
        this._activeAccountChangedDispatcher.fire({});
      }
      /**
       * uses scopes to recieve access token
       *
       * @param {...string[]} scopes
       * @returns {Promise<string>}
       * @memberof IProvider
       */
      getAccessTokenForScopes(...scopes) {
        return this.getAccessToken({ scopes });
      }
    };
    (function(LoginType2) {
      LoginType2[LoginType2["Popup"] = 0] = "Popup";
      LoginType2[LoginType2["Redirect"] = 1] = "Redirect";
    })(LoginType || (LoginType = {}));
    (function(ProviderState2) {
      ProviderState2[ProviderState2["Loading"] = 0] = "Loading";
      ProviderState2[ProviderState2["SignedOut"] = 1] = "SignedOut";
      ProviderState2[ProviderState2["SignedIn"] = 2] = "SignedIn";
    })(ProviderState || (ProviderState = {}));
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/providers/Providers.js
var __awaiter2, Providers, ProvidersChangedState;
var init_Providers = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/providers/Providers.js"() {
    init_EventDispatcher();
    init_IProvider();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Providers = class {
      /**
       * returns the value of provider used globally. All components use this property to get a reference to the provider.
       *
       * @static
       * @type {IProvider}
       * @memberof Providers
       */
      static get globalProvider() {
        return this._globalProvider;
      }
      static set globalProvider(provider) {
        if (provider !== this._globalProvider) {
          if (this._globalProvider) {
            this._globalProvider.removeStateChangedHandler(this.handleProviderStateChanged);
            if (this._globalProvider.isMultiAccountSupportedAndEnabled) {
              this._globalProvider.removeActiveAccountChangedHandler(this.handleActiveAccountChanged);
            }
          }
          if (provider) {
            provider.onStateChanged(this.handleProviderStateChanged);
            if (provider.isMultiAccountSupportedAndEnabled) {
              provider.onActiveAccountChanged(this.handleActiveAccountChanged);
            }
          }
          this._globalProvider = provider;
          this._eventDispatcher.fire(ProvidersChangedState.ProviderChanged);
        }
      }
      /**
       * Fires event when Provider changes state
       *
       * @static
       * @param {EventHandler<ProvidersChangedState>} event
       * @memberof Providers
       */
      static onProviderUpdated(event) {
        this._eventDispatcher.add(event);
      }
      /**
       * Remove event handler
       *
       * @static
       * @param {EventHandler<ProvidersChangedState>} event
       * @memberof Providers
       */
      static removeProviderUpdatedListener(event) {
        this._eventDispatcher.remove(event);
      }
      /**
       * Fires event when Provider changes state
       *
       * @static
       * @param {EventHandler<ProvidersChangedState>} event
       * @memberof Providers
       */
      static onActiveAccountChanged(event) {
        this._activeAccountChangedDispatcher.add(event);
      }
      /**
       * Remove event handler
       *
       * @static
       * @param {EventHandler<ProvidersChangedState>} event
       * @memberof Providers
       */
      static removeActiveAccountChangedListener(event) {
        this._activeAccountChangedDispatcher.remove(event);
      }
      /**
       * Gets the current signed in user
       *
       * @static
       * @memberof Providers
       */
      static me() {
        if (!this.client) {
          this._mePromise = null;
          return null;
        }
        if (!this._mePromise) {
          this._mePromise = this.getMe();
        }
        return this._mePromise;
      }
      /**
       * Get current signed in user details
       *
       * @private
       * @static
       * @return {*}  {Promise<User>}
       * @memberof Providers
       */
      static getMe() {
        return __awaiter2(this, void 0, void 0, function* () {
          try {
            const response = yield this.client.api("me").get();
            if (response && response.id) {
              return response;
            }
          } catch (_a5) {
          }
          return null;
        });
      }
      /**
       * Gets the cache ID, creates one if it does not exist
       *
       * @static
       * @memberof Providers
       */
      static getCacheId() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this._cacheId) {
            return this._cacheId;
          }
          if (Providers.globalProvider && Providers.globalProvider.state == ProviderState.SignedIn) {
            if (!this._cacheId) {
              const client = this.client;
              if (client) {
                try {
                  this._cacheId = yield this.createCacheId();
                } catch (_a5) {
                }
              }
            }
          }
          return this._cacheId;
        });
      }
      /**
       * Unset the cache ID
       *
       * @static
       * @memberof Providers
       */
      static unsetCacheId() {
        this._cacheId = null;
        this._mePromise = null;
      }
      /**
       * Create cache ID
       *
       * @private
       * @static
       * @return {*}  {Promise<string>}
       * @memberof Providers
       */
      static createCacheId() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (Providers.globalProvider.isMultiAccountSupportedAndEnabled) {
            const cacheId = this.createCacheIdWithAccountDetails();
            if (cacheId) {
              return cacheId;
            }
          }
          return yield this.createCacheIdWithUserDetails();
        });
      }
      /**
       * Create a cache ID with user userID and principal name
       *
       * @static
       * @param {User} response
       * @return {*}
       * @memberof Providers
       */
      static createCacheIdWithUserDetails() {
        return __awaiter2(this, void 0, void 0, function* () {
          const response = yield this.me();
          if (response && response.id) {
            return response.id + "-" + response.userPrincipalName;
          } else
            return null;
        });
      }
      /**
       * Create cache ID with tenant ID and user ID
       *
       * @private
       * @static
       * @return {*}  {string}
       * @memberof Providers
       */
      static createCacheIdWithAccountDetails() {
        const user = Providers.globalProvider.getActiveAccount();
        if (user.tenantId && user.id) {
          return user.tenantId + user.id;
        } else
          return null;
      }
      /**
       * Gets the current graph client
       *
       * @readonly
       * @static
       * @type {Client}
       * @memberof Providers
       */
      static get client() {
        if (Providers.globalProvider && Providers.globalProvider.state === ProviderState.SignedIn) {
          return Providers.globalProvider.graph.client;
        }
        return null;
      }
      static handleProviderStateChanged() {
        if (!Providers.globalProvider || Providers.globalProvider.state !== ProviderState.SignedIn) {
          Providers._mePromise = null;
        }
        Providers._eventDispatcher.fire(ProvidersChangedState.ProviderStateChanged);
      }
      static handleActiveAccountChanged() {
        Providers.unsetCacheId();
        Providers._activeAccountChangedDispatcher.fire(null);
      }
    };
    Providers._eventDispatcher = new EventDispatcher();
    Providers._activeAccountChangedDispatcher = new EventDispatcher();
    (function(ProvidersChangedState2) {
      ProvidersChangedState2[ProvidersChangedState2["ProviderChanged"] = 0] = "ProviderChanged";
      ProvidersChangedState2[ProvidersChangedState2["ProviderStateChanged"] = 1] = "ProviderStateChanged";
    })(ProvidersChangedState || (ProvidersChangedState = {}));
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/GraphHelpers.js
function prepScopes(...scopes) {
  const authProviderOptions = {
    scopes
  };
  if (!Providers.globalProvider.isIncrementalConsentDisabled) {
    return [new AuthenticationHandlerOptions(void 0, authProviderOptions)];
  } else {
    return [];
  }
}
function chainMiddleware(...middleware) {
  const rootMiddleware = middleware[0];
  let current = rootMiddleware;
  for (let i = 1; i < middleware.length; ++i) {
    const next = middleware[i];
    if (current.setNext) {
      current.setNext(next);
    }
    current = next;
  }
  return rootMiddleware;
}
function validateBaseURL(url) {
  try {
    const urlObj = new URL(url);
    const originAsEndpoint = urlObj.origin;
    if (MICROSOFT_GRAPH_ENDPOINTS.has(originAsEndpoint)) {
      return originAsEndpoint;
    }
  } catch (error) {
    return;
  }
}
var init_GraphHelpers = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/GraphHelpers.js"() {
    init_browser();
    init_IGraph();
    init_Providers();
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/Batch.js
var __awaiter3, BatchRequest, Batch;
var init_Batch = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/Batch.js"() {
    init_IBatch();
    init_browser();
    init_utils();
    init_GraphHelpers();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    BatchRequest = class {
      constructor(index, id, resource, method) {
        if (resource.charAt(0) !== "/") {
          resource = "/" + resource;
        }
        this.resource = resource;
        this.method = method;
        this.index = index;
        this.id = id;
      }
    };
    Batch = class {
      constructor(graph) {
        this.graph = graph;
        this.allRequests = [];
        this.requestsQueue = [];
        this.scopes = [];
        this.nextIndex = 0;
        this.retryAfter = 0;
      }
      /**
       * Get whether there are requests that have not been executed
       *
       * @readonly
       * @memberof Batch
       */
      get hasRequests() {
        return this.requestsQueue.length > 0;
      }
      /**
       * sets new request and scopes
       *
       * @param {string} id
       * @param {string} resource
       * @param {string[]} [scopes]
       * @memberof Batch
       */
      get(id, resource, scopes, headers) {
        const index = this.nextIndex++;
        const request = new BatchRequest(index, id, resource, "GET");
        request.headers = headers;
        this.allRequests.push(request);
        this.requestsQueue.push(index);
        if (scopes) {
          this.scopes = this.scopes.concat(scopes);
        }
      }
      /**
       * Execute the next set of requests.
       * This will execute up to 20 requests at a time
       *
       * @returns {Promise<Map<string, BatchResponse>>}
       * @memberof Batch
       */
      executeNext() {
        return __awaiter3(this, void 0, void 0, function* () {
          const responses = /* @__PURE__ */ new Map();
          if (this.retryAfter) {
            yield delay(this.retryAfter * 1e3);
            this.retryAfter = 0;
          }
          if (!this.hasRequests) {
            return responses;
          }
          const nextBatch = this.requestsQueue.splice(0, 20);
          const batchRequestContent = new BatchRequestContent();
          for (const request of nextBatch.map((i) => this.allRequests[i])) {
            batchRequestContent.addRequest({
              id: request.index.toString(),
              request: new Request(Batch.baseUrl + request.resource, {
                method: request.method,
                headers: request.headers
              })
            });
          }
          const middlewareOptions = this.scopes.length ? prepScopes(...this.scopes) : [];
          const batchRequest = this.graph.api("$batch").middlewareOptions(middlewareOptions);
          const batchRequestBody = yield batchRequestContent.getContent();
          const batchResponse = yield batchRequest.post(batchRequestBody);
          for (const r of batchResponse.responses) {
            const response = new BatchResponse();
            const request = this.allRequests[r.id];
            response.id = request.id;
            response.index = request.index;
            response.headers = r.headers;
            if (r.status !== 200) {
              if (r.status === 429) {
                this.requestsQueue.unshift(r.id);
                this.retryAfter = Math.max(this.retryAfter, parseInt(r.headers["Retry-After"], 10) || 1);
              }
              continue;
            } else if (r.headers["Content-Type"].includes("image/jpeg")) {
              response.content = "data:image/jpeg;base64," + r.body;
            } else if (r.headers["Content-Type"].includes("image/pjpeg")) {
              response.content = "data:image/pjpeg;base64," + r.body;
            } else if (r.headers["Content-Type"].includes("image/png")) {
              response.content = "data:image/png;base64," + r.body;
            } else {
              response.content = r.body;
            }
            responses.set(request.id, response);
          }
          return responses;
        });
      }
      /**
       * Execute all requests, up to 20 at a time until
       * all requests have been executed
       *
       * @returns {Promise<Map<string, BatchResponse>>}
       * @memberof Batch
       */
      executeAll() {
        return __awaiter3(this, void 0, void 0, function* () {
          const responses = /* @__PURE__ */ new Map();
          while (this.hasRequests) {
            const r = yield this.executeNext();
            for (const [key, value] of r) {
              responses.set(key, value);
            }
          }
          return responses;
        });
      }
    };
    Batch.baseUrl = "https://graph.microsoft.com";
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/ComponentMiddlewareOptions.js
var ComponentMiddlewareOptions;
var init_ComponentMiddlewareOptions = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/ComponentMiddlewareOptions.js"() {
    ComponentMiddlewareOptions = class {
      constructor(component) {
        if (typeof component === "string") {
          this.componentName = component;
        } else {
          this.componentName = component.tagName.toLowerCase();
        }
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/SdkVersionMiddleware.js
var __awaiter4, SdkVersionMiddleware;
var init_SdkVersionMiddleware = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/SdkVersionMiddleware.js"() {
    init_MiddlewareUtil();
    init_ComponentMiddlewareOptions();
    init_GraphHelpers();
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    SdkVersionMiddleware = class {
      constructor(packageVersion, providerName) {
        this._packageVersion = packageVersion;
        this._providerName = providerName;
      }
      // tslint:disable-next-line: completed-docs
      execute(context) {
        var _a5;
        return __awaiter4(this, void 0, void 0, function* () {
          try {
            if (typeof context.request === "string") {
              if (validateBaseURL(context.request)) {
                const headerParts = [];
                const componentOptions = context.middlewareControl.getMiddlewareOptions(ComponentMiddlewareOptions);
                if (componentOptions) {
                  const componentVersion = `${componentOptions.componentName}/${this._packageVersion}`;
                  headerParts.push(componentVersion);
                }
                if (this._providerName) {
                  const providerVersion = `${this._providerName}/${this._packageVersion}`;
                  headerParts.push(providerVersion);
                }
                const packageVersion = `mgt/${this._packageVersion}`;
                headerParts.push(packageVersion);
                headerParts.push(getRequestHeader(context.request, context.options, "SdkVersion"));
                const sdkVersionHeaderValue = headerParts.join(", ");
                setRequestHeader(context.request, context.options, "SdkVersion", sdkVersionHeaderValue);
              } else {
                (_a5 = context === null || context === void 0 ? void 0 : context.options) === null || _a5 === void 0 ? true : delete _a5.headers["SdkVersion"];
              }
            }
          } catch (error) {
          }
          return yield this._nextMiddleware.execute(context);
        });
      }
      /**
       * Handles setting of next middleware
       *
       * @param {Middleware} next
       * @memberof SdkVersionMiddleware
       */
      setNext(next) {
        this._nextMiddleware = next;
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/version.js
var PACKAGE_VERSION2;
var init_version = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/version.js"() {
    PACKAGE_VERSION2 = "3.0.0-preview.1-next.mgt-chat.97255fa";
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/components/customElementHelper.js
var CustomElementHelper, customElementHelper;
var init_customElementHelper = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/components/customElementHelper.js"() {
    CustomElementHelper = class {
      constructor() {
        this.defaultPrefix = "mgt";
        this._disambiguation = "";
      }
      /**
       * Adds a disambiguation segment to the custom elements registered with the browser
       *
       * @param {string} disambiguation
       * @return {CustomElementHelper} the current object
       * @memberof CustomElementHelper
       */
      withDisambiguation(disambiguation) {
        if (disambiguation && !this._disambiguation)
          this._disambiguation = disambiguation;
        return this;
      }
      /**
       * Provides the prefix to be used for mgt web component tags
       *
       * @readonly
       * @type {string}
       * @memberof CustomElementHelper
       */
      get prefix() {
        return this._disambiguation ? `${this.defaultPrefix}-${this._disambiguation}` : this.defaultPrefix;
      }
      /**
       * Returns the current value for the disambiguation
       *
       * @readonly
       * @type {string}
       * @memberof CustomElementHelper
       */
      get disambiguation() {
        return this._disambiguation;
      }
      /**
       * Returns true if a value has been provided for the disambiguation
       *
       * @readonly
       * @type {boolean}
       * @memberof CustomElementHelper
       */
      get isDisambiguated() {
        return Boolean(this._disambiguation);
      }
      /**
       * Removes disambiguation from the provided tagName.
       * Intended for use when providing tag names in analytics headers passed by the Graph client
       *
       * @param {string} tagName
       * @return {*}  {string}
       * @memberof CustomElementHelper
       */
      normalize(tagName) {
        return this.isDisambiguated ? tagName.toUpperCase().replace(this.prefix.toUpperCase(), this.defaultPrefix.toUpperCase()) : tagName;
      }
    };
    customElementHelper = new CustomElementHelper();
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/Graph.js
function createFromProvider(provider, version, component) {
  const middleware = [
    new AuthenticationHandler(provider),
    new RetryHandler(new RetryHandlerOptions()),
    new TelemetryHandler(),
    new SdkVersionMiddleware(PACKAGE_VERSION2, provider.name),
    new HTTPMessageHandler()
  ];
  let baseURL = provider.baseURL ? provider.baseURL : MICROSOFT_GRAPH_DEFAULT_ENDPOINT;
  const client = Client.initWithMiddleware({
    middleware: chainMiddleware(...middleware),
    baseUrl: baseURL
  });
  const graph = new Graph(client, version);
  return component ? graph.forComponent(component) : graph;
}
var GRAPH_VERSION, Graph;
var init_Graph = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/Graph.js"() {
    init_browser();
    init_IGraph();
    init_Batch();
    init_ComponentMiddlewareOptions();
    init_GraphHelpers();
    init_SdkVersionMiddleware();
    init_version();
    init_customElementHelper();
    GRAPH_VERSION = "v1.0";
    Graph = class {
      /**
       * the internal client used to make graph calls
       *
       * @readonly
       * @type {Client}
       * @memberof Graph
       */
      get client() {
        return this._client;
      }
      /**
       * the component name appended to Graph request headers
       *
       * @readonly
       * @type {string}
       * @memberof Graph
       */
      get componentName() {
        return this._componentName;
      }
      /**
       * the version of the graph to query
       *
       * @readonly
       * @type {string}
       * @memberof Graph
       */
      get version() {
        return this._version;
      }
      constructor(client, version = GRAPH_VERSION) {
        this._client = client;
        this._version = version;
      }
      /**
       * Returns a new instance of the Graph using the same
       * client within the context of the provider.
       *
       * @param {Element} component
       * @returns {IGraph}
       * @memberof Graph
       */
      forComponent(component) {
        const graph = new Graph(this._client, this._version);
        graph.setComponent(component);
        return graph;
      }
      /**
       * Returns a new graph request for a specific component
       * Used internally for analytics purposes
       *
       * @param {string} path
       * @memberof Graph
       */
      api(path) {
        let request = this._client.api(path).version(this._version);
        if (this._componentName) {
          request.middlewareOptions = (options) => {
            const requestObj = request;
            requestObj._middlewareOptions = requestObj._middlewareOptions.concat(options);
            return request;
          };
          request = request.middlewareOptions([new ComponentMiddlewareOptions(this._componentName)]);
        }
        return request;
      }
      /**
       * creates a new batch request
       *
       * @returns {Batch}
       * @memberof Graph
       */
      createBatch() {
        return new Batch(this);
      }
      /**
       * sets the component name used in request headers.
       *
       * @protected
       * @param {Element} component
       * @memberof Graph
       */
      setComponent(component) {
        this._componentName = component instanceof Element ? customElementHelper.normalize(component.tagName) : component;
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/BetaGraph.js
var GRAPH_VERSION2, BetaGraph;
var init_BetaGraph = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/BetaGraph.js"() {
    init_Graph();
    GRAPH_VERSION2 = "beta";
    BetaGraph = class extends Graph {
      /**
       * get a BetaGraph instance based on an existing IGraph implementation.
       *
       * @static
       * @param {Graph} graph
       * @returns {BetaGraph}
       * @memberof BetaGraph
       */
      static fromGraph(graph) {
        const betaGraph = new BetaGraph(graph.client);
        betaGraph.setComponent(graph.componentName);
        return betaGraph;
      }
      constructor(client, version = GRAPH_VERSION2) {
        super(client, version);
      }
      /**
       * Returns a new instance of the Graph using the same
       * client within the context of the provider.
       *
       * @param {Element} component
       * @returns {BetaGraph}
       * @memberof BetaGraph
       */
      forComponent(component) {
        const graph = new BetaGraph(this.client);
        this.setComponent(component);
        return graph;
      }
    };
  }
});

// node_modules/@lit/reactive-element/development/css-tag.js
var NODE_MODE, global, supportsAdoptingStyleSheets, constructionToken, cssTagCache, CSSResult, textFromCSSResult, unsafeCSS, css, adoptStyles, cssResultFromStyleSheet, getCompatibleStyle;
var init_css_tag = __esm({
  "node_modules/@lit/reactive-element/development/css-tag.js"() {
    NODE_MODE = false;
    global = NODE_MODE ? globalThis : window;
    supportsAdoptingStyleSheets = global.ShadowRoot && (global.ShadyCSS === void 0 || global.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
    constructionToken = Symbol();
    cssTagCache = /* @__PURE__ */ new WeakMap();
    CSSResult = class {
      constructor(cssText, strings, safeToken) {
        this["_$cssResult$"] = true;
        if (safeToken !== constructionToken) {
          throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        }
        this.cssText = cssText;
        this._strings = strings;
      }
      // This is a getter so that it's lazy. In practice, this means stylesheets
      // are not created until the first element instance is made.
      get styleSheet() {
        let styleSheet = this._styleSheet;
        const strings = this._strings;
        if (supportsAdoptingStyleSheets && styleSheet === void 0) {
          const cacheable = strings !== void 0 && strings.length === 1;
          if (cacheable) {
            styleSheet = cssTagCache.get(strings);
          }
          if (styleSheet === void 0) {
            (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
            if (cacheable) {
              cssTagCache.set(strings, styleSheet);
            }
          }
        }
        return styleSheet;
      }
      toString() {
        return this.cssText;
      }
    };
    textFromCSSResult = (value) => {
      if (value["_$cssResult$"] === true) {
        return value.cssText;
      } else if (typeof value === "number") {
        return value;
      } else {
        throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
      }
    };
    unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), void 0, constructionToken);
    css = (strings, ...values) => {
      const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
      return new CSSResult(cssText, strings, constructionToken);
    };
    adoptStyles = (renderRoot, styles) => {
      if (supportsAdoptingStyleSheets) {
        renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
      } else {
        styles.forEach((s) => {
          const style = document.createElement("style");
          const nonce = global["litNonce"];
          if (nonce !== void 0) {
            style.setAttribute("nonce", nonce);
          }
          style.textContent = s.cssText;
          renderRoot.appendChild(style);
        });
      }
    };
    cssResultFromStyleSheet = (sheet) => {
      let cssText = "";
      for (const rule of sheet.cssRules) {
        cssText += rule.cssText;
      }
      return unsafeCSS(cssText);
    };
    getCompatibleStyle = supportsAdoptingStyleSheets || NODE_MODE && global.CSSStyleSheet === void 0 ? (s) => s : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;
  }
});

// node_modules/@lit/reactive-element/development/reactive-element.js
var _a, _b, _c, _d, _e, NODE_MODE2, global2, DEV_MODE, requestUpdateThenable, issueWarning, trustedTypes, emptyStringForBooleanAttribute, polyfillSupport, debugLogEvent, JSCompiler_renameProperty, defaultConverter, notEqual, defaultPropertyDeclaration, finalized, ReactiveElement;
var init_reactive_element = __esm({
  "node_modules/@lit/reactive-element/development/reactive-element.js"() {
    init_css_tag();
    init_css_tag();
    NODE_MODE2 = false;
    global2 = NODE_MODE2 ? globalThis : window;
    if (NODE_MODE2) {
      (_a = global2.customElements) !== null && _a !== void 0 ? _a : global2.customElements = customElements;
    }
    DEV_MODE = true;
    trustedTypes = global2.trustedTypes;
    emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : "";
    polyfillSupport = DEV_MODE ? global2.reactiveElementPolyfillSupportDevMode : global2.reactiveElementPolyfillSupport;
    if (DEV_MODE) {
      const issuedWarnings = (_b = global2.litIssuedWarnings) !== null && _b !== void 0 ? _b : global2.litIssuedWarnings = /* @__PURE__ */ new Set();
      issueWarning = (code, warning) => {
        warning += ` See https://lit.dev/msg/${code} for more information.`;
        if (!issuedWarnings.has(warning)) {
          console.warn(warning);
          issuedWarnings.add(warning);
        }
      };
      issueWarning("dev-mode", `Lit is in dev mode. Not recommended for production!`);
      if (((_c = global2.ShadyDOM) === null || _c === void 0 ? void 0 : _c.inUse) && polyfillSupport === void 0) {
        issueWarning("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
      }
      requestUpdateThenable = (name) => ({
        then: (onfulfilled, _onrejected) => {
          issueWarning("request-update-promise", `The \`requestUpdate\` method should no longer return a Promise but does so on \`${name}\`. Use \`updateComplete\` instead.`);
          if (onfulfilled !== void 0) {
            onfulfilled(false);
          }
        }
      });
    }
    debugLogEvent = DEV_MODE ? (event) => {
      const shouldEmit = global2.emitLitDebugLogEvents;
      if (!shouldEmit) {
        return;
      }
      global2.dispatchEvent(new CustomEvent("lit-debug", {
        detail: event
      }));
    } : void 0;
    JSCompiler_renameProperty = (prop, _obj) => prop;
    defaultConverter = {
      toAttribute(value, type) {
        switch (type) {
          case Boolean:
            value = value ? emptyStringForBooleanAttribute : null;
            break;
          case Object:
          case Array:
            value = value == null ? value : JSON.stringify(value);
            break;
        }
        return value;
      },
      fromAttribute(value, type) {
        let fromValue = value;
        switch (type) {
          case Boolean:
            fromValue = value !== null;
            break;
          case Number:
            fromValue = value === null ? null : Number(value);
            break;
          case Object:
          case Array:
            try {
              fromValue = JSON.parse(value);
            } catch (e) {
              fromValue = null;
            }
            break;
        }
        return fromValue;
      }
    };
    notEqual = (value, old) => {
      return old !== value && (old === old || value === value);
    };
    defaultPropertyDeclaration = {
      attribute: true,
      type: String,
      converter: defaultConverter,
      reflect: false,
      hasChanged: notEqual
    };
    finalized = "finalized";
    ReactiveElement = class extends HTMLElement {
      constructor() {
        super();
        this.__instanceProperties = /* @__PURE__ */ new Map();
        this.isUpdatePending = false;
        this.hasUpdated = false;
        this.__reflectingProperty = null;
        this._initialize();
      }
      /**
       * Adds an initializer function to the class that is called during instance
       * construction.
       *
       * This is useful for code that runs against a `ReactiveElement`
       * subclass, such as a decorator, that needs to do work for each
       * instance, such as setting up a `ReactiveController`.
       *
       * ```ts
       * const myDecorator = (target: typeof ReactiveElement, key: string) => {
       *   target.addInitializer((instance: ReactiveElement) => {
       *     // This is run during construction of the element
       *     new MyController(instance);
       *   });
       * }
       * ```
       *
       * Decorating a field will then cause each instance to run an initializer
       * that adds a controller:
       *
       * ```ts
       * class MyElement extends LitElement {
       *   @myDecorator foo;
       * }
       * ```
       *
       * Initializers are stored per-constructor. Adding an initializer to a
       * subclass does not add it to a superclass. Since initializers are run in
       * constructors, initializers will run in order of the class hierarchy,
       * starting with superclasses and progressing to the instance's class.
       *
       * @nocollapse
       */
      static addInitializer(initializer) {
        var _a5;
        this.finalize();
        ((_a5 = this._initializers) !== null && _a5 !== void 0 ? _a5 : this._initializers = []).push(initializer);
      }
      /**
       * Returns a list of attributes corresponding to the registered properties.
       * @nocollapse
       * @category attributes
       */
      static get observedAttributes() {
        this.finalize();
        const attributes = [];
        this.elementProperties.forEach((v, p) => {
          const attr = this.__attributeNameForProperty(p, v);
          if (attr !== void 0) {
            this.__attributeToPropertyMap.set(attr, p);
            attributes.push(attr);
          }
        });
        return attributes;
      }
      /**
       * Creates a property accessor on the element prototype if one does not exist
       * and stores a {@linkcode PropertyDeclaration} for the property with the
       * given options. The property setter calls the property's `hasChanged`
       * property option or uses a strict identity check to determine whether or not
       * to request an update.
       *
       * This method may be overridden to customize properties; however,
       * when doing so, it's important to call `super.createProperty` to ensure
       * the property is setup correctly. This method calls
       * `getPropertyDescriptor` internally to get a descriptor to install.
       * To customize what properties do when they are get or set, override
       * `getPropertyDescriptor`. To customize the options for a property,
       * implement `createProperty` like this:
       *
       * ```ts
       * static createProperty(name, options) {
       *   options = Object.assign(options, {myOption: true});
       *   super.createProperty(name, options);
       * }
       * ```
       *
       * @nocollapse
       * @category properties
       */
      static createProperty(name, options = defaultPropertyDeclaration) {
        var _a5;
        if (options.state) {
          options.attribute = false;
        }
        this.finalize();
        this.elementProperties.set(name, options);
        if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
          const key = typeof name === "symbol" ? Symbol() : `__${name}`;
          const descriptor = this.getPropertyDescriptor(name, key, options);
          if (descriptor !== void 0) {
            Object.defineProperty(this.prototype, name, descriptor);
            if (DEV_MODE) {
              if (!this.hasOwnProperty("__reactivePropertyKeys")) {
                this.__reactivePropertyKeys = new Set((_a5 = this.__reactivePropertyKeys) !== null && _a5 !== void 0 ? _a5 : []);
              }
              this.__reactivePropertyKeys.add(name);
            }
          }
        }
      }
      /**
       * Returns a property descriptor to be defined on the given named property.
       * If no descriptor is returned, the property will not become an accessor.
       * For example,
       *
       * ```ts
       * class MyElement extends LitElement {
       *   static getPropertyDescriptor(name, key, options) {
       *     const defaultDescriptor =
       *         super.getPropertyDescriptor(name, key, options);
       *     const setter = defaultDescriptor.set;
       *     return {
       *       get: defaultDescriptor.get,
       *       set(value) {
       *         setter.call(this, value);
       *         // custom action.
       *       },
       *       configurable: true,
       *       enumerable: true
       *     }
       *   }
       * }
       * ```
       *
       * @nocollapse
       * @category properties
       */
      static getPropertyDescriptor(name, key, options) {
        return {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          get() {
            return this[key];
          },
          set(value) {
            const oldValue = this[name];
            this[key] = value;
            this.requestUpdate(name, oldValue, options);
          },
          configurable: true,
          enumerable: true
        };
      }
      /**
       * Returns the property options associated with the given property.
       * These options are defined with a `PropertyDeclaration` via the `properties`
       * object or the `@property` decorator and are registered in
       * `createProperty(...)`.
       *
       * Note, this method should be considered "final" and not overridden. To
       * customize the options for a given property, override
       * {@linkcode createProperty}.
       *
       * @nocollapse
       * @final
       * @category properties
       */
      static getPropertyOptions(name) {
        return this.elementProperties.get(name) || defaultPropertyDeclaration;
      }
      /**
       * Creates property accessors for registered properties, sets up element
       * styling, and ensures any superclasses are also finalized. Returns true if
       * the element was finalized.
       * @nocollapse
       */
      static finalize() {
        if (this.hasOwnProperty(finalized)) {
          return false;
        }
        this[finalized] = true;
        const superCtor = Object.getPrototypeOf(this);
        superCtor.finalize();
        if (superCtor._initializers !== void 0) {
          this._initializers = [...superCtor._initializers];
        }
        this.elementProperties = new Map(superCtor.elementProperties);
        this.__attributeToPropertyMap = /* @__PURE__ */ new Map();
        if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
          const props = this.properties;
          const propKeys = [
            ...Object.getOwnPropertyNames(props),
            ...Object.getOwnPropertySymbols(props)
          ];
          for (const p of propKeys) {
            this.createProperty(p, props[p]);
          }
        }
        this.elementStyles = this.finalizeStyles(this.styles);
        if (DEV_MODE) {
          const warnRemovedOrRenamed = (name, renamed = false) => {
            if (this.prototype.hasOwnProperty(name)) {
              issueWarning(renamed ? "renamed-api" : "removed-api", `\`${name}\` is implemented on class ${this.name}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
            }
          };
          warnRemovedOrRenamed("initialize");
          warnRemovedOrRenamed("requestUpdateInternal");
          warnRemovedOrRenamed("_getUpdateComplete", true);
        }
        return true;
      }
      /**
       * Takes the styles the user supplied via the `static styles` property and
       * returns the array of styles to apply to the element.
       * Override this method to integrate into a style management system.
       *
       * Styles are deduplicated preserving the _last_ instance in the list. This
       * is a performance optimization to avoid duplicated styles that can occur
       * especially when composing via subclassing. The last item is kept to try
       * to preserve the cascade order with the assumption that it's most important
       * that last added styles override previous styles.
       *
       * @nocollapse
       * @category styles
       */
      static finalizeStyles(styles) {
        const elementStyles = [];
        if (Array.isArray(styles)) {
          const set = new Set(styles.flat(Infinity).reverse());
          for (const s of set) {
            elementStyles.unshift(getCompatibleStyle(s));
          }
        } else if (styles !== void 0) {
          elementStyles.push(getCompatibleStyle(styles));
        }
        return elementStyles;
      }
      /**
       * Returns the property name for the given attribute `name`.
       * @nocollapse
       */
      static __attributeNameForProperty(name, options) {
        const attribute = options.attribute;
        return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
      }
      /**
       * Internal only override point for customizing work done when elements
       * are constructed.
       *
       * @internal
       */
      _initialize() {
        var _a5;
        this.__updatePromise = new Promise((res) => this.enableUpdating = res);
        this._$changedProperties = /* @__PURE__ */ new Map();
        this.__saveInstanceProperties();
        this.requestUpdate();
        (_a5 = this.constructor._initializers) === null || _a5 === void 0 ? void 0 : _a5.forEach((i) => i(this));
      }
      /**
       * Registers a `ReactiveController` to participate in the element's reactive
       * update cycle. The element automatically calls into any registered
       * controllers during its lifecycle callbacks.
       *
       * If the element is connected when `addController()` is called, the
       * controller's `hostConnected()` callback will be immediately called.
       * @category controllers
       */
      addController(controller) {
        var _a5, _b4;
        ((_a5 = this.__controllers) !== null && _a5 !== void 0 ? _a5 : this.__controllers = []).push(controller);
        if (this.renderRoot !== void 0 && this.isConnected) {
          (_b4 = controller.hostConnected) === null || _b4 === void 0 ? void 0 : _b4.call(controller);
        }
      }
      /**
       * Removes a `ReactiveController` from the element.
       * @category controllers
       */
      removeController(controller) {
        var _a5;
        (_a5 = this.__controllers) === null || _a5 === void 0 ? void 0 : _a5.splice(this.__controllers.indexOf(controller) >>> 0, 1);
      }
      /**
       * Fixes any properties set on the instance before upgrade time.
       * Otherwise these would shadow the accessor and break these properties.
       * The properties are stored in a Map which is played back after the
       * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
       * (<=41), properties created for native platform properties like (`id` or
       * `name`) may not have default values set in the element constructor. On
       * these browsers native properties appear on instances and therefore their
       * default value will overwrite any element default (e.g. if the element sets
       * this.id = 'id' in the constructor, the 'id' will become '' since this is
       * the native platform default).
       */
      __saveInstanceProperties() {
        this.constructor.elementProperties.forEach((_v, p) => {
          if (this.hasOwnProperty(p)) {
            this.__instanceProperties.set(p, this[p]);
            delete this[p];
          }
        });
      }
      /**
       * Returns the node into which the element should render and by default
       * creates and returns an open shadowRoot. Implement to customize where the
       * element's DOM is rendered. For example, to render into the element's
       * childNodes, return `this`.
       *
       * @return Returns a node into which to render.
       * @category rendering
       */
      createRenderRoot() {
        var _a5;
        const renderRoot = (_a5 = this.shadowRoot) !== null && _a5 !== void 0 ? _a5 : this.attachShadow(this.constructor.shadowRootOptions);
        adoptStyles(renderRoot, this.constructor.elementStyles);
        return renderRoot;
      }
      /**
       * On first connection, creates the element's renderRoot, sets up
       * element styling, and enables updating.
       * @category lifecycle
       */
      connectedCallback() {
        var _a5;
        if (this.renderRoot === void 0) {
          this.renderRoot = this.createRenderRoot();
        }
        this.enableUpdating(true);
        (_a5 = this.__controllers) === null || _a5 === void 0 ? void 0 : _a5.forEach((c) => {
          var _a6;
          return (_a6 = c.hostConnected) === null || _a6 === void 0 ? void 0 : _a6.call(c);
        });
      }
      /**
       * Note, this method should be considered final and not overridden. It is
       * overridden on the element instance with a function that triggers the first
       * update.
       * @category updates
       */
      enableUpdating(_requestedUpdate) {
      }
      /**
       * Allows for `super.disconnectedCallback()` in extensions while
       * reserving the possibility of making non-breaking feature additions
       * when disconnecting at some point in the future.
       * @category lifecycle
       */
      disconnectedCallback() {
        var _a5;
        (_a5 = this.__controllers) === null || _a5 === void 0 ? void 0 : _a5.forEach((c) => {
          var _a6;
          return (_a6 = c.hostDisconnected) === null || _a6 === void 0 ? void 0 : _a6.call(c);
        });
      }
      /**
       * Synchronizes property values when attributes change.
       *
       * Specifically, when an attribute is set, the corresponding property is set.
       * You should rarely need to implement this callback. If this method is
       * overridden, `super.attributeChangedCallback(name, _old, value)` must be
       * called.
       *
       * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)
       * on MDN for more information about the `attributeChangedCallback`.
       * @category attributes
       */
      attributeChangedCallback(name, _old, value) {
        this._$attributeToProperty(name, value);
      }
      __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
        var _a5;
        const attr = this.constructor.__attributeNameForProperty(name, options);
        if (attr !== void 0 && options.reflect === true) {
          const converter = ((_a5 = options.converter) === null || _a5 === void 0 ? void 0 : _a5.toAttribute) !== void 0 ? options.converter : defaultConverter;
          const attrValue = converter.toAttribute(value, options.type);
          if (DEV_MODE && this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
            issueWarning("undefined-attribute-value", `The attribute value for the ${name} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
          }
          this.__reflectingProperty = name;
          if (attrValue == null) {
            this.removeAttribute(attr);
          } else {
            this.setAttribute(attr, attrValue);
          }
          this.__reflectingProperty = null;
        }
      }
      /** @internal */
      _$attributeToProperty(name, value) {
        var _a5;
        const ctor = this.constructor;
        const propName = ctor.__attributeToPropertyMap.get(name);
        if (propName !== void 0 && this.__reflectingProperty !== propName) {
          const options = ctor.getPropertyOptions(propName);
          const converter = typeof options.converter === "function" ? { fromAttribute: options.converter } : ((_a5 = options.converter) === null || _a5 === void 0 ? void 0 : _a5.fromAttribute) !== void 0 ? options.converter : defaultConverter;
          this.__reflectingProperty = propName;
          this[propName] = converter.fromAttribute(
            value,
            options.type
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          );
          this.__reflectingProperty = null;
        }
      }
      /**
       * Requests an update which is processed asynchronously. This should be called
       * when an element should update based on some state not triggered by setting
       * a reactive property. In this case, pass no arguments. It should also be
       * called when manually implementing a property setter. In this case, pass the
       * property `name` and `oldValue` to ensure that any configured property
       * options are honored.
       *
       * @param name name of requesting property
       * @param oldValue old value of requesting property
       * @param options property options to use instead of the previously
       *     configured options
       * @category updates
       */
      requestUpdate(name, oldValue, options) {
        let shouldRequestUpdate = true;
        if (name !== void 0) {
          options = options || this.constructor.getPropertyOptions(name);
          const hasChanged = options.hasChanged || notEqual;
          if (hasChanged(this[name], oldValue)) {
            if (!this._$changedProperties.has(name)) {
              this._$changedProperties.set(name, oldValue);
            }
            if (options.reflect === true && this.__reflectingProperty !== name) {
              if (this.__reflectingProperties === void 0) {
                this.__reflectingProperties = /* @__PURE__ */ new Map();
              }
              this.__reflectingProperties.set(name, options);
            }
          } else {
            shouldRequestUpdate = false;
          }
        }
        if (!this.isUpdatePending && shouldRequestUpdate) {
          this.__updatePromise = this.__enqueueUpdate();
        }
        return DEV_MODE ? requestUpdateThenable(this.localName) : void 0;
      }
      /**
       * Sets up the element to asynchronously update.
       */
      async __enqueueUpdate() {
        this.isUpdatePending = true;
        try {
          await this.__updatePromise;
        } catch (e) {
          Promise.reject(e);
        }
        const result = this.scheduleUpdate();
        if (result != null) {
          await result;
        }
        return !this.isUpdatePending;
      }
      /**
       * Schedules an element update. You can override this method to change the
       * timing of updates by returning a Promise. The update will await the
       * returned Promise, and you should resolve the Promise to allow the update
       * to proceed. If this method is overridden, `super.scheduleUpdate()`
       * must be called.
       *
       * For instance, to schedule updates to occur just before the next frame:
       *
       * ```ts
       * override protected async scheduleUpdate(): Promise<unknown> {
       *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
       *   super.scheduleUpdate();
       * }
       * ```
       * @category updates
       */
      scheduleUpdate() {
        return this.performUpdate();
      }
      /**
       * Performs an element update. Note, if an exception is thrown during the
       * update, `firstUpdated` and `updated` will not be called.
       *
       * Call `performUpdate()` to immediately process a pending update. This should
       * generally not be needed, but it can be done in rare cases when you need to
       * update synchronously.
       *
       * Note: To ensure `performUpdate()` synchronously completes a pending update,
       * it should not be overridden. In LitElement 2.x it was suggested to override
       * `performUpdate()` to also customizing update scheduling. Instead, you should now
       * override `scheduleUpdate()`. For backwards compatibility with LitElement 2.x,
       * scheduling updates via `performUpdate()` continues to work, but will make
       * also calling `performUpdate()` to synchronously process updates difficult.
       *
       * @category updates
       */
      performUpdate() {
        var _a5, _b4;
        if (!this.isUpdatePending) {
          return;
        }
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({ kind: "update" });
        if (!this.hasUpdated) {
          if (DEV_MODE) {
            const shadowedProperties = [];
            (_a5 = this.constructor.__reactivePropertyKeys) === null || _a5 === void 0 ? void 0 : _a5.forEach((p) => {
              var _a6;
              if (this.hasOwnProperty(p) && !((_a6 = this.__instanceProperties) === null || _a6 === void 0 ? void 0 : _a6.has(p))) {
                shadowedProperties.push(p);
              }
            });
            if (shadowedProperties.length) {
              throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
            }
          }
        }
        if (this.__instanceProperties) {
          this.__instanceProperties.forEach((v, p) => this[p] = v);
          this.__instanceProperties = void 0;
        }
        let shouldUpdate = false;
        const changedProperties = this._$changedProperties;
        try {
          shouldUpdate = this.shouldUpdate(changedProperties);
          if (shouldUpdate) {
            this.willUpdate(changedProperties);
            (_b4 = this.__controllers) === null || _b4 === void 0 ? void 0 : _b4.forEach((c) => {
              var _a6;
              return (_a6 = c.hostUpdate) === null || _a6 === void 0 ? void 0 : _a6.call(c);
            });
            this.update(changedProperties);
          } else {
            this.__markUpdated();
          }
        } catch (e) {
          shouldUpdate = false;
          this.__markUpdated();
          throw e;
        }
        if (shouldUpdate) {
          this._$didUpdate(changedProperties);
        }
      }
      /**
       * Invoked before `update()` to compute values needed during the update.
       *
       * Implement `willUpdate` to compute property values that depend on other
       * properties and are used in the rest of the update process.
       *
       * ```ts
       * willUpdate(changedProperties) {
       *   // only need to check changed properties for an expensive computation.
       *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
       *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
       *   }
       * }
       *
       * render() {
       *   return html`SHA: ${this.sha}`;
       * }
       * ```
       *
       * @category updates
       */
      willUpdate(_changedProperties) {
      }
      // Note, this is an override point for polyfill-support.
      // @internal
      _$didUpdate(changedProperties) {
        var _a5;
        (_a5 = this.__controllers) === null || _a5 === void 0 ? void 0 : _a5.forEach((c) => {
          var _a6;
          return (_a6 = c.hostUpdated) === null || _a6 === void 0 ? void 0 : _a6.call(c);
        });
        if (!this.hasUpdated) {
          this.hasUpdated = true;
          this.firstUpdated(changedProperties);
        }
        this.updated(changedProperties);
        if (DEV_MODE && this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
          issueWarning("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
        }
      }
      __markUpdated() {
        this._$changedProperties = /* @__PURE__ */ new Map();
        this.isUpdatePending = false;
      }
      /**
       * Returns a Promise that resolves when the element has completed updating.
       * The Promise value is a boolean that is `true` if the element completed the
       * update without triggering another update. The Promise result is `false` if
       * a property was set inside `updated()`. If the Promise is rejected, an
       * exception was thrown during the update.
       *
       * To await additional asynchronous work, override the `getUpdateComplete`
       * method. For example, it is sometimes useful to await a rendered element
       * before fulfilling this Promise. To do this, first await
       * `super.getUpdateComplete()`, then any subsequent state.
       *
       * @return A promise of a boolean that resolves to true if the update completed
       *     without triggering another update.
       * @category updates
       */
      get updateComplete() {
        return this.getUpdateComplete();
      }
      /**
       * Override point for the `updateComplete` promise.
       *
       * It is not safe to override the `updateComplete` getter directly due to a
       * limitation in TypeScript which means it is not possible to call a
       * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
       * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
       * This method should be overridden instead. For example:
       *
       * ```ts
       * class MyElement extends LitElement {
       *   override async getUpdateComplete() {
       *     const result = await super.getUpdateComplete();
       *     await this._myChild.updateComplete;
       *     return result;
       *   }
       * }
       * ```
       *
       * @return A promise of a boolean that resolves to true if the update completed
       *     without triggering another update.
       * @category updates
       */
      getUpdateComplete() {
        return this.__updatePromise;
      }
      /**
       * Controls whether or not `update()` should be called when the element requests
       * an update. By default, this method always returns `true`, but this can be
       * customized to control when to update.
       *
       * @param _changedProperties Map of changed properties with old values
       * @category updates
       */
      shouldUpdate(_changedProperties) {
        return true;
      }
      /**
       * Updates the element. This method reflects property values to attributes.
       * It can be overridden to render and keep updated element DOM.
       * Setting properties inside this method will *not* trigger
       * another update.
       *
       * @param _changedProperties Map of changed properties with old values
       * @category updates
       */
      update(_changedProperties) {
        if (this.__reflectingProperties !== void 0) {
          this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));
          this.__reflectingProperties = void 0;
        }
        this.__markUpdated();
      }
      /**
       * Invoked whenever the element is updated. Implement to perform
       * post-updating tasks via DOM APIs, for example, focusing an element.
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * @param _changedProperties Map of changed properties with old values
       * @category updates
       */
      updated(_changedProperties) {
      }
      /**
       * Invoked when the element is first updated. Implement to perform one time
       * work on the element after update.
       *
       * ```ts
       * firstUpdated() {
       *   this.renderRoot.getElementById('my-text-area').focus();
       * }
       * ```
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * @param _changedProperties Map of changed properties with old values
       * @category updates
       */
      firstUpdated(_changedProperties) {
      }
    };
    _e = finalized;
    ReactiveElement[_e] = true;
    ReactiveElement.elementProperties = /* @__PURE__ */ new Map();
    ReactiveElement.elementStyles = [];
    ReactiveElement.shadowRootOptions = { mode: "open" };
    polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ ReactiveElement });
    if (DEV_MODE) {
      ReactiveElement.enabledWarnings = ["change-in-update"];
      const ensureOwnWarnings = function(ctor) {
        if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings", ctor))) {
          ctor.enabledWarnings = ctor.enabledWarnings.slice();
        }
      };
      ReactiveElement.enableWarning = function(warning) {
        ensureOwnWarnings(this);
        if (this.enabledWarnings.indexOf(warning) < 0) {
          this.enabledWarnings.push(warning);
        }
      };
      ReactiveElement.disableWarning = function(warning) {
        ensureOwnWarnings(this);
        const i = this.enabledWarnings.indexOf(warning);
        if (i >= 0) {
          this.enabledWarnings.splice(i, 1);
        }
      };
    }
    ((_d = global2.reactiveElementVersions) !== null && _d !== void 0 ? _d : global2.reactiveElementVersions = []).push("1.6.1");
    if (DEV_MODE && global2.reactiveElementVersions.length > 1) {
      issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
    }
  }
});

// node_modules/lit-html/development/lit-html.js
function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a5, _b4, _c4;
  var _d3;
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a5 = parent.__directives) === null || _a5 === void 0 ? void 0 : _a5[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : (
    // This property needs to remain unminified.
    value["_$litDirective$"]
  );
  if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b4 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b4 === void 0 ? void 0 : _b4.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      ((_c4 = (_d3 = parent).__directives) !== null && _c4 !== void 0 ? _c4 : _d3.__directives = [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
var _a2, _b2, _c2, _d2, DEV_MODE2, ENABLE_EXTRA_SECURITY_HOOKS, ENABLE_SHADYDOM_NOPATCH, NODE_MODE3, global3, debugLogEvent2, debugLogRenderId, issueWarning2, wrap, trustedTypes2, policy, identityFunction, noopSanitizer, setSanitizer, _testOnlyClearSanitizerFactoryDoNotCallOrElse, createSanitizer, boundAttributeSuffix, marker, markerMatch, nodeMarker, d, createMarker, isPrimitive, isArray, isIterable, SPACE_CHAR, ATTR_VALUE_CHAR, NAME_CHAR, textEndRegex, COMMENT_START, TAG_NAME, DYNAMIC_TAG_NAME, commentEndRegex, comment2EndRegex, tagEndRegex, ENTIRE_MATCH, ATTRIBUTE_NAME, SPACES_AND_EQUALS, QUOTE_CHAR, singleQuoteAttrEndRegex, doubleQuoteAttrEndRegex, rawTextElement, HTML_RESULT, SVG_RESULT, ATTRIBUTE_PART, CHILD_PART, PROPERTY_PART, BOOLEAN_ATTRIBUTE_PART, EVENT_PART, ELEMENT_PART, COMMENT_PART, tag, html, svg, noChange, nothing, templateCache, walker, sanitizerFactoryInternal, getTemplateHtml, Template, TemplateInstance, ChildPart, AttributePart, PropertyPart, emptyStringForBooleanAttribute2, BooleanAttributePart, EventPart, ElementPart, _$LH, polyfillSupport2, render;
var init_lit_html = __esm({
  "node_modules/lit-html/development/lit-html.js"() {
    DEV_MODE2 = true;
    ENABLE_EXTRA_SECURITY_HOOKS = true;
    ENABLE_SHADYDOM_NOPATCH = true;
    NODE_MODE3 = false;
    global3 = NODE_MODE3 ? globalThis : window;
    debugLogEvent2 = DEV_MODE2 ? (event) => {
      const shouldEmit = global3.emitLitDebugLogEvents;
      if (!shouldEmit) {
        return;
      }
      global3.dispatchEvent(new CustomEvent("lit-debug", {
        detail: event
      }));
    } : void 0;
    debugLogRenderId = 0;
    if (DEV_MODE2) {
      (_a2 = global3.litIssuedWarnings) !== null && _a2 !== void 0 ? _a2 : global3.litIssuedWarnings = /* @__PURE__ */ new Set();
      issueWarning2 = (code, warning) => {
        warning += code ? ` See https://lit.dev/msg/${code} for more information.` : "";
        if (!global3.litIssuedWarnings.has(warning)) {
          console.warn(warning);
          global3.litIssuedWarnings.add(warning);
        }
      };
      issueWarning2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
    }
    wrap = ENABLE_SHADYDOM_NOPATCH && ((_b2 = global3.ShadyDOM) === null || _b2 === void 0 ? void 0 : _b2.inUse) && ((_c2 = global3.ShadyDOM) === null || _c2 === void 0 ? void 0 : _c2.noPatch) === true ? global3.ShadyDOM.wrap : (node) => node;
    trustedTypes2 = global3.trustedTypes;
    policy = trustedTypes2 ? trustedTypes2.createPolicy("lit-html", {
      createHTML: (s) => s
    }) : void 0;
    identityFunction = (value) => value;
    noopSanitizer = (_node, _name, _type) => identityFunction;
    setSanitizer = (newSanitizer) => {
      if (!ENABLE_EXTRA_SECURITY_HOOKS) {
        return;
      }
      if (sanitizerFactoryInternal !== noopSanitizer) {
        throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
      }
      sanitizerFactoryInternal = newSanitizer;
    };
    _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
      sanitizerFactoryInternal = noopSanitizer;
    };
    createSanitizer = (node, name, type) => {
      return sanitizerFactoryInternal(node, name, type);
    };
    boundAttributeSuffix = "$lit$";
    marker = `lit$${String(Math.random()).slice(9)}$`;
    markerMatch = "?" + marker;
    nodeMarker = `<${markerMatch}>`;
    d = NODE_MODE3 && global3.document === void 0 ? {
      createTreeWalker() {
        return {};
      }
    } : document;
    createMarker = () => d.createComment("");
    isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
    isArray = Array.isArray;
    isIterable = (value) => isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof (value === null || value === void 0 ? void 0 : value[Symbol.iterator]) === "function";
    SPACE_CHAR = `[ 	
\f\r]`;
    ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
    NAME_CHAR = `[^\\s"'>=/]`;
    textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    COMMENT_START = 1;
    TAG_NAME = 2;
    DYNAMIC_TAG_NAME = 3;
    commentEndRegex = /-->/g;
    comment2EndRegex = />/g;
    tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
    ENTIRE_MATCH = 0;
    ATTRIBUTE_NAME = 1;
    SPACES_AND_EQUALS = 2;
    QUOTE_CHAR = 3;
    singleQuoteAttrEndRegex = /'/g;
    doubleQuoteAttrEndRegex = /"/g;
    rawTextElement = /^(?:script|style|textarea|title)$/i;
    HTML_RESULT = 1;
    SVG_RESULT = 2;
    ATTRIBUTE_PART = 1;
    CHILD_PART = 2;
    PROPERTY_PART = 3;
    BOOLEAN_ATTRIBUTE_PART = 4;
    EVENT_PART = 5;
    ELEMENT_PART = 6;
    COMMENT_PART = 7;
    tag = (type) => (strings, ...values) => {
      if (DEV_MODE2 && strings.some((s) => s === void 0)) {
        console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
      }
      return {
        // This property needs to remain unminified.
        ["_$litType$"]: type,
        strings,
        values
      };
    };
    html = tag(HTML_RESULT);
    svg = tag(SVG_RESULT);
    noChange = Symbol.for("lit-noChange");
    nothing = Symbol.for("lit-nothing");
    templateCache = /* @__PURE__ */ new WeakMap();
    walker = d.createTreeWalker(d, 129, null, false);
    sanitizerFactoryInternal = noopSanitizer;
    getTemplateHtml = (strings, type) => {
      const l = strings.length - 1;
      const attrNames = [];
      let html2 = type === SVG_RESULT ? "<svg>" : "";
      let rawTextEndRegex;
      let regex = textEndRegex;
      for (let i = 0; i < l; i++) {
        const s = strings[i];
        let attrNameEndIndex = -1;
        let attrName;
        let lastIndex = 0;
        let match;
        while (lastIndex < s.length) {
          regex.lastIndex = lastIndex;
          match = regex.exec(s);
          if (match === null) {
            break;
          }
          lastIndex = regex.lastIndex;
          if (regex === textEndRegex) {
            if (match[COMMENT_START] === "!--") {
              regex = commentEndRegex;
            } else if (match[COMMENT_START] !== void 0) {
              regex = comment2EndRegex;
            } else if (match[TAG_NAME] !== void 0) {
              if (rawTextElement.test(match[TAG_NAME])) {
                rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, "g");
              }
              regex = tagEndRegex;
            } else if (match[DYNAMIC_TAG_NAME] !== void 0) {
              if (DEV_MODE2) {
                throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
              }
              regex = tagEndRegex;
            }
          } else if (regex === tagEndRegex) {
            if (match[ENTIRE_MATCH] === ">") {
              regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
              attrNameEndIndex = -1;
            } else if (match[ATTRIBUTE_NAME] === void 0) {
              attrNameEndIndex = -2;
            } else {
              attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
              attrName = match[ATTRIBUTE_NAME];
              regex = match[QUOTE_CHAR] === void 0 ? tagEndRegex : match[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
            }
          } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
            regex = tagEndRegex;
          } else if (regex === commentEndRegex || regex === comment2EndRegex) {
            regex = textEndRegex;
          } else {
            regex = tagEndRegex;
            rawTextEndRegex = void 0;
          }
        }
        if (DEV_MODE2) {
          console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
        }
        const end = regex === tagEndRegex && strings[i + 1].startsWith("/>") ? " " : "";
        html2 += regex === textEndRegex ? s + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s.slice(0, attrNameEndIndex) + boundAttributeSuffix + s.slice(attrNameEndIndex)) + marker + end : s + marker + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
      }
      const htmlResult = html2 + (strings[l] || "<?>") + (type === SVG_RESULT ? "</svg>" : "");
      if (!Array.isArray(strings) || !strings.hasOwnProperty("raw")) {
        let message = "invalid template strings array";
        if (DEV_MODE2) {
          message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.

          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g, "\n");
        }
        throw new Error(message);
      }
      return [
        policy !== void 0 ? policy.createHTML(htmlResult) : htmlResult,
        attrNames
      ];
    };
    Template = class {
      constructor({ strings, ["_$litType$"]: type }, options) {
        this.parts = [];
        let node;
        let nodeIndex = 0;
        let attrNameIndex = 0;
        const partCount = strings.length - 1;
        const parts = this.parts;
        const [html2, attrNames] = getTemplateHtml(strings, type);
        this.el = Template.createElement(html2, options);
        walker.currentNode = this.el.content;
        if (type === SVG_RESULT) {
          const content = this.el.content;
          const svgElement = content.firstChild;
          svgElement.remove();
          content.append(...svgElement.childNodes);
        }
        while ((node = walker.nextNode()) !== null && parts.length < partCount) {
          if (node.nodeType === 1) {
            if (DEV_MODE2) {
              const tag3 = node.localName;
              if (/^(?:textarea|template)$/i.test(tag3) && node.innerHTML.includes(marker)) {
                const m = `Expressions are not supported inside \`${tag3}\` elements. See https://lit.dev/msg/expression-in-${tag3} for more information.`;
                if (tag3 === "template") {
                  throw new Error(m);
                } else
                  issueWarning2("", m);
              }
            }
            if (node.hasAttributes()) {
              const attrsToRemove = [];
              for (const name of node.getAttributeNames()) {
                if (name.endsWith(boundAttributeSuffix) || name.startsWith(marker)) {
                  const realName = attrNames[attrNameIndex++];
                  attrsToRemove.push(name);
                  if (realName !== void 0) {
                    const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                    const statics = value.split(marker);
                    const m = /([.?@])?(.*)/.exec(realName);
                    parts.push({
                      type: ATTRIBUTE_PART,
                      index: nodeIndex,
                      name: m[2],
                      strings: statics,
                      ctor: m[1] === "." ? PropertyPart : m[1] === "?" ? BooleanAttributePart : m[1] === "@" ? EventPart : AttributePart
                    });
                  } else {
                    parts.push({
                      type: ELEMENT_PART,
                      index: nodeIndex
                    });
                  }
                }
              }
              for (const name of attrsToRemove) {
                node.removeAttribute(name);
              }
            }
            if (rawTextElement.test(node.tagName)) {
              const strings2 = node.textContent.split(marker);
              const lastIndex = strings2.length - 1;
              if (lastIndex > 0) {
                node.textContent = trustedTypes2 ? trustedTypes2.emptyScript : "";
                for (let i = 0; i < lastIndex; i++) {
                  node.append(strings2[i], createMarker());
                  walker.nextNode();
                  parts.push({ type: CHILD_PART, index: ++nodeIndex });
                }
                node.append(strings2[lastIndex], createMarker());
              }
            }
          } else if (node.nodeType === 8) {
            const data = node.data;
            if (data === markerMatch) {
              parts.push({ type: CHILD_PART, index: nodeIndex });
            } else {
              let i = -1;
              while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                parts.push({ type: COMMENT_PART, index: nodeIndex });
                i += marker.length - 1;
              }
            }
          }
          nodeIndex++;
        }
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "template prep",
          template: this,
          clonableTemplate: this.el,
          parts: this.parts,
          strings
        });
      }
      // Overridden via `litHtmlPolyfillSupport` to provide platform support.
      /** @nocollapse */
      static createElement(html2, _options) {
        const el = d.createElement("template");
        el.innerHTML = html2;
        return el;
      }
    };
    TemplateInstance = class {
      constructor(template, parent) {
        this._parts = [];
        this._$disconnectableChildren = void 0;
        this._$template = template;
        this._$parent = parent;
      }
      // Called by ChildPart parentNode getter
      get parentNode() {
        return this._$parent.parentNode;
      }
      // See comment in Disconnectable interface for why this is a getter
      get _$isConnected() {
        return this._$parent._$isConnected;
      }
      // This method is separate from the constructor because we need to return a
      // DocumentFragment and we don't want to hold onto it with an instance field.
      _clone(options) {
        var _a5;
        const { el: { content }, parts } = this._$template;
        const fragment = ((_a5 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a5 !== void 0 ? _a5 : d).importNode(content, true);
        walker.currentNode = fragment;
        let node = walker.nextNode();
        let nodeIndex = 0;
        let partIndex = 0;
        let templatePart = parts[0];
        while (templatePart !== void 0) {
          if (nodeIndex === templatePart.index) {
            let part;
            if (templatePart.type === CHILD_PART) {
              part = new ChildPart(node, node.nextSibling, this, options);
            } else if (templatePart.type === ATTRIBUTE_PART) {
              part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
            } else if (templatePart.type === ELEMENT_PART) {
              part = new ElementPart(node, this, options);
            }
            this._parts.push(part);
            templatePart = parts[++partIndex];
          }
          if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
            node = walker.nextNode();
            nodeIndex++;
          }
        }
        return fragment;
      }
      _update(values) {
        let i = 0;
        for (const part of this._parts) {
          if (part !== void 0) {
            debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
              kind: "set part",
              part,
              value: values[i],
              valueIndex: i,
              values,
              templateInstance: this
            });
            if (part.strings !== void 0) {
              part._$setValue(values, part, i);
              i += part.strings.length - 2;
            } else {
              part._$setValue(values[i]);
            }
          }
          i++;
        }
      }
    };
    ChildPart = class {
      constructor(startNode, endNode, parent, options) {
        var _a5;
        this.type = CHILD_PART;
        this._$committedValue = nothing;
        this._$disconnectableChildren = void 0;
        this._$startNode = startNode;
        this._$endNode = endNode;
        this._$parent = parent;
        this.options = options;
        this.__isConnected = (_a5 = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a5 !== void 0 ? _a5 : true;
        if (ENABLE_EXTRA_SECURITY_HOOKS) {
          this._textSanitizer = void 0;
        }
      }
      // See comment in Disconnectable interface for why this is a getter
      get _$isConnected() {
        var _a5, _b4;
        return (_b4 = (_a5 = this._$parent) === null || _a5 === void 0 ? void 0 : _a5._$isConnected) !== null && _b4 !== void 0 ? _b4 : this.__isConnected;
      }
      /**
       * The parent node into which the part renders its content.
       *
       * A ChildPart's content consists of a range of adjacent child nodes of
       * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
       * `.endNode`).
       *
       * - If both `.startNode` and `.endNode` are non-null, then the part's content
       * consists of all siblings between `.startNode` and `.endNode`, exclusively.
       *
       * - If `.startNode` is non-null but `.endNode` is null, then the part's
       * content consists of all siblings following `.startNode`, up to and
       * including the last child of `.parentNode`. If `.endNode` is non-null, then
       * `.startNode` will always be non-null.
       *
       * - If both `.endNode` and `.startNode` are null, then the part's content
       * consists of all child nodes of `.parentNode`.
       */
      get parentNode() {
        let parentNode = wrap(this._$startNode).parentNode;
        const parent = this._$parent;
        if (parent !== void 0 && (parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 11) {
          parentNode = parent.parentNode;
        }
        return parentNode;
      }
      /**
       * The part's leading marker node, if any. See `.parentNode` for more
       * information.
       */
      get startNode() {
        return this._$startNode;
      }
      /**
       * The part's trailing marker node, if any. See `.parentNode` for more
       * information.
       */
      get endNode() {
        return this._$endNode;
      }
      _$setValue(value, directiveParent = this) {
        var _a5;
        if (DEV_MODE2 && this.parentNode === null) {
          throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
        }
        value = resolveDirective(this, value, directiveParent);
        if (isPrimitive(value)) {
          if (value === nothing || value == null || value === "") {
            if (this._$committedValue !== nothing) {
              debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
                kind: "commit nothing to child",
                start: this._$startNode,
                end: this._$endNode,
                parent: this._$parent,
                options: this.options
              });
              this._$clear();
            }
            this._$committedValue = nothing;
          } else if (value !== this._$committedValue && value !== noChange) {
            this._commitText(value);
          }
        } else if (value["_$litType$"] !== void 0) {
          this._commitTemplateResult(value);
        } else if (value.nodeType !== void 0) {
          if (DEV_MODE2 && ((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.host) === value) {
            this._commitText(`[probable mistake: rendered a template's host in itself (commonly caused by writing \${this} in a template]`);
            console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);
            return;
          }
          this._commitNode(value);
        } else if (isIterable(value)) {
          this._commitIterable(value);
        } else {
          this._commitText(value);
        }
      }
      _insert(node) {
        return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);
      }
      _commitNode(value) {
        var _a5;
        if (this._$committedValue !== value) {
          this._$clear();
          if (ENABLE_EXTRA_SECURITY_HOOKS && sanitizerFactoryInternal !== noopSanitizer) {
            const parentNodeName = (_a5 = this._$startNode.parentNode) === null || _a5 === void 0 ? void 0 : _a5.nodeName;
            if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
              let message = "Forbidden";
              if (DEV_MODE2) {
                if (parentNodeName === "STYLE") {
                  message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
                } else {
                  message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
                }
              }
              throw new Error(message);
            }
          }
          debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
            kind: "commit node",
            start: this._$startNode,
            parent: this._$parent,
            value,
            options: this.options
          });
          this._$committedValue = this._insert(value);
        }
      }
      _commitText(value) {
        if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
          const node = wrap(this._$startNode).nextSibling;
          if (ENABLE_EXTRA_SECURITY_HOOKS) {
            if (this._textSanitizer === void 0) {
              this._textSanitizer = createSanitizer(node, "data", "property");
            }
            value = this._textSanitizer(value);
          }
          debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
            kind: "commit text",
            node,
            value,
            options: this.options
          });
          node.data = value;
        } else {
          if (ENABLE_EXTRA_SECURITY_HOOKS) {
            const textNode = d.createTextNode("");
            this._commitNode(textNode);
            if (this._textSanitizer === void 0) {
              this._textSanitizer = createSanitizer(textNode, "data", "property");
            }
            value = this._textSanitizer(value);
            debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
              kind: "commit text",
              node: textNode,
              value,
              options: this.options
            });
            textNode.data = value;
          } else {
            this._commitNode(d.createTextNode(value));
            debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
              kind: "commit text",
              node: wrap(this._$startNode).nextSibling,
              value,
              options: this.options
            });
          }
        }
        this._$committedValue = value;
      }
      _commitTemplateResult(result) {
        var _a5;
        const { values, ["_$litType$"]: type } = result;
        const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template.createElement(type.h, this.options)), type);
        if (((_a5 = this._$committedValue) === null || _a5 === void 0 ? void 0 : _a5._$template) === template) {
          debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
            kind: "template updating",
            template,
            instance: this._$committedValue,
            parts: this._$committedValue._parts,
            options: this.options,
            values
          });
          this._$committedValue._update(values);
        } else {
          const instance = new TemplateInstance(template, this);
          const fragment = instance._clone(this.options);
          debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
            kind: "template instantiated",
            template,
            instance,
            parts: instance._parts,
            options: this.options,
            fragment,
            values
          });
          instance._update(values);
          debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
            kind: "template instantiated and updated",
            template,
            instance,
            parts: instance._parts,
            options: this.options,
            fragment,
            values
          });
          this._commitNode(fragment);
          this._$committedValue = instance;
        }
      }
      // Overridden via `litHtmlPolyfillSupport` to provide platform support.
      /** @internal */
      _$getTemplate(result) {
        let template = templateCache.get(result.strings);
        if (template === void 0) {
          templateCache.set(result.strings, template = new Template(result));
        }
        return template;
      }
      _commitIterable(value) {
        if (!isArray(this._$committedValue)) {
          this._$committedValue = [];
          this._$clear();
        }
        const itemParts = this._$committedValue;
        let partIndex = 0;
        let itemPart;
        for (const item of value) {
          if (partIndex === itemParts.length) {
            itemParts.push(itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
          } else {
            itemPart = itemParts[partIndex];
          }
          itemPart._$setValue(item);
          partIndex++;
        }
        if (partIndex < itemParts.length) {
          this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
          itemParts.length = partIndex;
        }
      }
      /**
       * Removes the nodes contained within this Part from the DOM.
       *
       * @param start Start node to clear from, for clearing a subset of the part's
       *     DOM (used when truncating iterables)
       * @param from  When `start` is specified, the index within the iterable from
       *     which ChildParts are being removed, used for disconnecting directives in
       *     those Parts.
       *
       * @internal
       */
      _$clear(start = wrap(this._$startNode).nextSibling, from) {
        var _a5;
        (_a5 = this._$notifyConnectionChanged) === null || _a5 === void 0 ? void 0 : _a5.call(this, false, true, from);
        while (start && start !== this._$endNode) {
          const n = wrap(start).nextSibling;
          wrap(start).remove();
          start = n;
        }
      }
      /**
       * Implementation of RootPart's `isConnected`. Note that this metod
       * should only be called on `RootPart`s (the `ChildPart` returned from a
       * top-level `render()` call). It has no effect on non-root ChildParts.
       * @param isConnected Whether to set
       * @internal
       */
      setConnected(isConnected) {
        var _a5;
        if (this._$parent === void 0) {
          this.__isConnected = isConnected;
          (_a5 = this._$notifyConnectionChanged) === null || _a5 === void 0 ? void 0 : _a5.call(this, isConnected);
        } else if (DEV_MODE2) {
          throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
        }
      }
    };
    AttributePart = class {
      constructor(element, name, strings, parent, options) {
        this.type = ATTRIBUTE_PART;
        this._$committedValue = nothing;
        this._$disconnectableChildren = void 0;
        this.element = element;
        this.name = name;
        this._$parent = parent;
        this.options = options;
        if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
          this._$committedValue = new Array(strings.length - 1).fill(new String());
          this.strings = strings;
        } else {
          this._$committedValue = nothing;
        }
        if (ENABLE_EXTRA_SECURITY_HOOKS) {
          this._sanitizer = void 0;
        }
      }
      get tagName() {
        return this.element.tagName;
      }
      // See comment in Disconnectable interface for why this is a getter
      get _$isConnected() {
        return this._$parent._$isConnected;
      }
      /**
       * Sets the value of this part by resolving the value from possibly multiple
       * values and static strings and committing it to the DOM.
       * If this part is single-valued, `this._strings` will be undefined, and the
       * method will be called with a single value argument. If this part is
       * multi-value, `this._strings` will be defined, and the method is called
       * with the value array of the part's owning TemplateInstance, and an offset
       * into the value array from which the values should be read.
       * This method is overloaded this way to eliminate short-lived array slices
       * of the template instance values, and allow a fast-path for single-valued
       * parts.
       *
       * @param value The part value, or an array of values for multi-valued parts
       * @param valueIndex the index to start reading values from. `undefined` for
       *   single-valued parts
       * @param noCommit causes the part to not commit its value to the DOM. Used
       *   in hydration to prime attribute parts with their first-rendered value,
       *   but not set the attribute, and in SSR to no-op the DOM operation and
       *   capture the value for serialization.
       *
       * @internal
       */
      _$setValue(value, directiveParent = this, valueIndex, noCommit) {
        const strings = this.strings;
        let change = false;
        if (strings === void 0) {
          value = resolveDirective(this, value, directiveParent, 0);
          change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
          if (change) {
            this._$committedValue = value;
          }
        } else {
          const values = value;
          value = strings[0];
          let i, v;
          for (i = 0; i < strings.length - 1; i++) {
            v = resolveDirective(this, values[valueIndex + i], directiveParent, i);
            if (v === noChange) {
              v = this._$committedValue[i];
            }
            change || (change = !isPrimitive(v) || v !== this._$committedValue[i]);
            if (v === nothing) {
              value = nothing;
            } else if (value !== nothing) {
              value += (v !== null && v !== void 0 ? v : "") + strings[i + 1];
            }
            this._$committedValue[i] = v;
          }
        }
        if (change && !noCommit) {
          this._commitValue(value);
        }
      }
      /** @internal */
      _commitValue(value) {
        if (value === nothing) {
          wrap(this.element).removeAttribute(this.name);
        } else {
          if (ENABLE_EXTRA_SECURITY_HOOKS) {
            if (this._sanitizer === void 0) {
              this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
            }
            value = this._sanitizer(value !== null && value !== void 0 ? value : "");
          }
          debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
            kind: "commit attribute",
            element: this.element,
            name: this.name,
            value,
            options: this.options
          });
          wrap(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
        }
      }
    };
    PropertyPart = class extends AttributePart {
      constructor() {
        super(...arguments);
        this.type = PROPERTY_PART;
      }
      /** @internal */
      _commitValue(value) {
        if (ENABLE_EXTRA_SECURITY_HOOKS) {
          if (this._sanitizer === void 0) {
            this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
          }
          value = this._sanitizer(value);
        }
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "commit property",
          element: this.element,
          name: this.name,
          value,
          options: this.options
        });
        this.element[this.name] = value === nothing ? void 0 : value;
      }
    };
    emptyStringForBooleanAttribute2 = trustedTypes2 ? trustedTypes2.emptyScript : "";
    BooleanAttributePart = class extends AttributePart {
      constructor() {
        super(...arguments);
        this.type = BOOLEAN_ATTRIBUTE_PART;
      }
      /** @internal */
      _commitValue(value) {
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "commit boolean attribute",
          element: this.element,
          name: this.name,
          value: !!(value && value !== nothing),
          options: this.options
        });
        if (value && value !== nothing) {
          wrap(this.element).setAttribute(this.name, emptyStringForBooleanAttribute2);
        } else {
          wrap(this.element).removeAttribute(this.name);
        }
      }
    };
    EventPart = class extends AttributePart {
      constructor(element, name, strings, parent, options) {
        super(element, name, strings, parent, options);
        this.type = EVENT_PART;
        if (DEV_MODE2 && this.strings !== void 0) {
          throw new Error(`A \`<${element.localName}>\` has a \`@${name}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
        }
      }
      // EventPart does not use the base _$setValue/_resolveValue implementation
      // since the dirty checking is more complex
      /** @internal */
      _$setValue(newListener, directiveParent = this) {
        var _a5;
        newListener = (_a5 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a5 !== void 0 ? _a5 : nothing;
        if (newListener === noChange) {
          return;
        }
        const oldListener = this._$committedValue;
        const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
        const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "commit event listener",
          element: this.element,
          name: this.name,
          value: newListener,
          options: this.options,
          removeListener: shouldRemoveListener,
          addListener: shouldAddListener,
          oldListener
        });
        if (shouldRemoveListener) {
          this.element.removeEventListener(this.name, this, oldListener);
        }
        if (shouldAddListener) {
          this.element.addEventListener(this.name, this, newListener);
        }
        this._$committedValue = newListener;
      }
      handleEvent(event) {
        var _a5, _b4;
        if (typeof this._$committedValue === "function") {
          this._$committedValue.call((_b4 = (_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.host) !== null && _b4 !== void 0 ? _b4 : this.element, event);
        } else {
          this._$committedValue.handleEvent(event);
        }
      }
    };
    ElementPart = class {
      constructor(element, parent, options) {
        this.element = element;
        this.type = ELEMENT_PART;
        this._$disconnectableChildren = void 0;
        this._$parent = parent;
        this.options = options;
      }
      // See comment in Disconnectable interface for why this is a getter
      get _$isConnected() {
        return this._$parent._$isConnected;
      }
      _$setValue(value) {
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "commit to element binding",
          element: this.element,
          value,
          options: this.options
        });
        resolveDirective(this, value);
      }
    };
    _$LH = {
      // Used in lit-ssr
      _boundAttributeSuffix: boundAttributeSuffix,
      _marker: marker,
      _markerMatch: markerMatch,
      _HTML_RESULT: HTML_RESULT,
      _getTemplateHtml: getTemplateHtml,
      // Used in hydrate
      _TemplateInstance: TemplateInstance,
      _isIterable: isIterable,
      _resolveDirective: resolveDirective,
      // Used in tests and private-ssr-support
      _ChildPart: ChildPart,
      _AttributePart: AttributePart,
      _BooleanAttributePart: BooleanAttributePart,
      _EventPart: EventPart,
      _PropertyPart: PropertyPart,
      _ElementPart: ElementPart
    };
    polyfillSupport2 = DEV_MODE2 ? global3.litHtmlPolyfillSupportDevMode : global3.litHtmlPolyfillSupport;
    polyfillSupport2 === null || polyfillSupport2 === void 0 ? void 0 : polyfillSupport2(Template, ChildPart);
    ((_d2 = global3.litHtmlVersions) !== null && _d2 !== void 0 ? _d2 : global3.litHtmlVersions = []).push("2.7.0");
    if (DEV_MODE2 && global3.litHtmlVersions.length > 1) {
      issueWarning2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
    }
    render = (value, container, options) => {
      var _a5, _b4;
      if (DEV_MODE2 && container == null) {
        throw new TypeError(`The container to render into may not be ${container}`);
      }
      const renderId = DEV_MODE2 ? debugLogRenderId++ : 0;
      const partOwnerNode = (_a5 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a5 !== void 0 ? _a5 : container;
      let part = partOwnerNode["_$litPart$"];
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "begin render",
        id: renderId,
        value,
        container,
        options,
        part
      });
      if (part === void 0) {
        const endNode = (_b4 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b4 !== void 0 ? _b4 : null;
        partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options !== null && options !== void 0 ? options : {});
      }
      part._$setValue(value);
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "end render",
        id: renderId,
        value,
        container,
        options,
        part
      });
      return part;
    };
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      render.setSanitizer = setSanitizer;
      render.createSanitizer = createSanitizer;
      if (DEV_MODE2) {
        render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
      }
    }
  }
});

// node_modules/lit-element/development/lit-element.js
var _a3, _b3, _c3, DEV_MODE3, issueWarning3, LitElement, polyfillSupport3;
var init_lit_element = __esm({
  "node_modules/lit-element/development/lit-element.js"() {
    init_reactive_element();
    init_lit_html();
    init_reactive_element();
    init_lit_html();
    DEV_MODE3 = true;
    if (DEV_MODE3) {
      const issuedWarnings = (_a3 = globalThis.litIssuedWarnings) !== null && _a3 !== void 0 ? _a3 : globalThis.litIssuedWarnings = /* @__PURE__ */ new Set();
      issueWarning3 = (code, warning) => {
        warning += ` See https://lit.dev/msg/${code} for more information.`;
        if (!issuedWarnings.has(warning)) {
          console.warn(warning);
          issuedWarnings.add(warning);
        }
      };
    }
    LitElement = class extends ReactiveElement {
      constructor() {
        super(...arguments);
        this.renderOptions = { host: this };
        this.__childPart = void 0;
      }
      /**
       * @category rendering
       */
      createRenderRoot() {
        var _a5;
        var _b4;
        const renderRoot = super.createRenderRoot();
        (_a5 = (_b4 = this.renderOptions).renderBefore) !== null && _a5 !== void 0 ? _a5 : _b4.renderBefore = renderRoot.firstChild;
        return renderRoot;
      }
      /**
       * Updates the element. This method reflects property values to attributes
       * and calls `render` to render DOM via lit-html. Setting properties inside
       * this method will *not* trigger another update.
       * @param changedProperties Map of changed properties with old values
       * @category updates
       */
      update(changedProperties) {
        const value = this.render();
        if (!this.hasUpdated) {
          this.renderOptions.isConnected = this.isConnected;
        }
        super.update(changedProperties);
        this.__childPart = render(value, this.renderRoot, this.renderOptions);
      }
      /**
       * Invoked when the component is added to the document's DOM.
       *
       * In `connectedCallback()` you should setup tasks that should only occur when
       * the element is connected to the document. The most common of these is
       * adding event listeners to nodes external to the element, like a keydown
       * event handler added to the window.
       *
       * ```ts
       * connectedCallback() {
       *   super.connectedCallback();
       *   addEventListener('keydown', this._handleKeydown);
       * }
       * ```
       *
       * Typically, anything done in `connectedCallback()` should be undone when the
       * element is disconnected, in `disconnectedCallback()`.
       *
       * @category lifecycle
       */
      connectedCallback() {
        var _a5;
        super.connectedCallback();
        (_a5 = this.__childPart) === null || _a5 === void 0 ? void 0 : _a5.setConnected(true);
      }
      /**
       * Invoked when the component is removed from the document's DOM.
       *
       * This callback is the main signal to the element that it may no longer be
       * used. `disconnectedCallback()` should ensure that nothing is holding a
       * reference to the element (such as event listeners added to nodes external
       * to the element), so that it is free to be garbage collected.
       *
       * ```ts
       * disconnectedCallback() {
       *   super.disconnectedCallback();
       *   window.removeEventListener('keydown', this._handleKeydown);
       * }
       * ```
       *
       * An element may be re-connected after being disconnected.
       *
       * @category lifecycle
       */
      disconnectedCallback() {
        var _a5;
        super.disconnectedCallback();
        (_a5 = this.__childPart) === null || _a5 === void 0 ? void 0 : _a5.setConnected(false);
      }
      /**
       * Invoked on each update to perform rendering tasks. This method may return
       * any value renderable by lit-html's `ChildPart` - typically a
       * `TemplateResult`. Setting properties inside this method will *not* trigger
       * the element to update.
       * @category rendering
       */
      render() {
        return noChange;
      }
    };
    LitElement["finalized"] = true;
    LitElement["_$litElement$"] = true;
    (_b3 = globalThis.litElementHydrateSupport) === null || _b3 === void 0 ? void 0 : _b3.call(globalThis, { LitElement });
    polyfillSupport3 = DEV_MODE3 ? globalThis.litElementPolyfillSupportDevMode : globalThis.litElementPolyfillSupport;
    polyfillSupport3 === null || polyfillSupport3 === void 0 ? void 0 : polyfillSupport3({ LitElement });
    if (DEV_MODE3) {
      LitElement["finalize"] = function() {
        const finalized2 = ReactiveElement.finalize.call(this);
        if (!finalized2) {
          return false;
        }
        const warnRemovedOrRenamed = (obj, name, renamed = false) => {
          if (obj.hasOwnProperty(name)) {
            const ctorName = (typeof obj === "function" ? obj : obj.constructor).name;
            issueWarning3(renamed ? "renamed-api" : "removed-api", `\`${name}\` is implemented on class ${ctorName}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
          }
        };
        warnRemovedOrRenamed(this, "render");
        warnRemovedOrRenamed(this, "getStyles", true);
        warnRemovedOrRenamed(this.prototype, "adoptStyles");
        return true;
      };
    }
    ((_c3 = globalThis.litElementVersions) !== null && _c3 !== void 0 ? _c3 : globalThis.litElementVersions = []).push("3.3.0");
    if (DEV_MODE3 && globalThis.litElementVersions.length > 1) {
      issueWarning3("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
    }
  }
});

// node_modules/lit-html/development/is-server.js
var init_is_server = __esm({
  "node_modules/lit-html/development/is-server.js"() {
  }
});

// node_modules/lit/index.js
var init_lit = __esm({
  "node_modules/lit/index.js"() {
    init_reactive_element();
    init_lit_html();
    init_lit_element();
    init_is_server();
  }
});

// node_modules/@lit/reactive-element/development/decorators/custom-element.js
var legacyCustomElement, standardCustomElement, customElement;
var init_custom_element = __esm({
  "node_modules/@lit/reactive-element/development/decorators/custom-element.js"() {
    legacyCustomElement = (tagName, clazz) => {
      customElements.define(tagName, clazz);
      return clazz;
    };
    standardCustomElement = (tagName, descriptor) => {
      const { kind, elements } = descriptor;
      return {
        kind,
        elements,
        // This callback is called once the class is otherwise fully defined
        finisher(clazz) {
          customElements.define(tagName, clazz);
        }
      };
    };
    customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  }
});

// node_modules/@lit/reactive-element/development/decorators/property.js
function property(options) {
  return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
}
var standardProperty, legacyProperty;
var init_property = __esm({
  "node_modules/@lit/reactive-element/development/decorators/property.js"() {
    standardProperty = (options, element) => {
      if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
        return {
          ...element,
          finisher(clazz) {
            clazz.createProperty(element.key, options);
          }
        };
      } else {
        return {
          kind: "field",
          key: Symbol(),
          placement: "own",
          descriptor: {},
          // store the original key so subsequent decorators have access to it.
          originalKey: element.key,
          // When @babel/plugin-proposal-decorators implements initializers,
          // do this instead of the initializer below. See:
          // https://github.com/babel/babel/issues/9260 extras: [
          //   {
          //     kind: 'initializer',
          //     placement: 'own',
          //     initializer: descriptor.initializer,
          //   }
          // ],
          initializer() {
            if (typeof element.initializer === "function") {
              this[element.key] = element.initializer.call(this);
            }
          },
          finisher(clazz) {
            clazz.createProperty(element.key, options);
          }
        };
      }
    };
    legacyProperty = (options, proto, name) => {
      proto.constructor.createProperty(name, options);
    };
  }
});

// node_modules/@lit/reactive-element/development/decorators/state.js
function state(options) {
  return property({
    ...options,
    state: true
  });
}
var init_state = __esm({
  "node_modules/@lit/reactive-element/development/decorators/state.js"() {
    init_property();
  }
});

// node_modules/@lit/reactive-element/development/decorators/base.js
var init_base = __esm({
  "node_modules/@lit/reactive-element/development/decorators/base.js"() {
  }
});

// node_modules/@lit/reactive-element/development/decorators/event-options.js
var init_event_options = __esm({
  "node_modules/@lit/reactive-element/development/decorators/event-options.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/development/decorators/query.js
var init_query = __esm({
  "node_modules/@lit/reactive-element/development/decorators/query.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/development/decorators/query-all.js
var init_query_all = __esm({
  "node_modules/@lit/reactive-element/development/decorators/query-all.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/development/decorators/query-async.js
var init_query_async = __esm({
  "node_modules/@lit/reactive-element/development/decorators/query-async.js"() {
    init_base();
  }
});

// node_modules/@lit/reactive-element/development/decorators/query-assigned-elements.js
var _a4, NODE_MODE4, global4, slotAssignedElements;
var init_query_assigned_elements = __esm({
  "node_modules/@lit/reactive-element/development/decorators/query-assigned-elements.js"() {
    init_base();
    NODE_MODE4 = false;
    global4 = NODE_MODE4 ? globalThis : window;
    slotAssignedElements = ((_a4 = global4.HTMLSlotElement) === null || _a4 === void 0 ? void 0 : _a4.prototype.assignedElements) != null ? (slot, opts) => slot.assignedElements(opts) : (slot, opts) => slot.assignedNodes(opts).filter((node) => node.nodeType === Node.ELEMENT_NODE);
  }
});

// node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js
var init_query_assigned_nodes = __esm({
  "node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js"() {
    init_base();
    init_query_assigned_elements();
  }
});

// node_modules/lit/decorators.js
var init_decorators = __esm({
  "node_modules/lit/decorators.js"() {
    init_custom_element();
    init_property();
    init_state();
    init_event_options();
    init_query();
    init_query_all();
    init_query_async();
    init_query_assigned_elements();
    init_query_assigned_nodes();
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/LocalizationHelper.js
var LocalizationHelper;
var init_LocalizationHelper = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/LocalizationHelper.js"() {
    init_EventDispatcher();
    LocalizationHelper = class {
      static get strings() {
        return this._strings;
      }
      /**
       * Set strings to be localized
       *
       * @static
       * @memberof LocalizationHelper
       */
      static set strings(value) {
        this._strings = value;
        this._stringsEventDispatcher.fire(null);
      }
      /**
       * returns body dir attribute to determine rtl or ltr
       *
       * @static
       * @returns {string} dir
       * @memberof LocalizationHelper
       */
      static getDocumentDirection() {
        var _a5, _b4;
        return ((_a5 = document.body) === null || _a5 === void 0 ? void 0 : _a5.getAttribute("dir")) || ((_b4 = document.documentElement) === null || _b4 === void 0 ? void 0 : _b4.getAttribute("dir")) || "ltr";
      }
      /**
       * Fires event when LocalizationHelper changes state
       *
       * @static
       * @param {EventHandler<ProvidersChangedState>} event
       * @memberof LocalizationHelper
       */
      static onStringsUpdated(event) {
        this._stringsEventDispatcher.add(event);
      }
      static removeOnStringsUpdated(event) {
        this._stringsEventDispatcher.remove(event);
      }
      static onDirectionUpdated(event) {
        this._directionEventDispatcher.add(event);
        this.initDirection();
      }
      static removeOnDirectionUpdated(event) {
        this._directionEventDispatcher.remove(event);
      }
      /**
       * Checks for direction setup and adds mutationObserver
       *
       * @private
       * @static
       * @returns
       * @memberof LocalizationHelper
       */
      static initDirection() {
        if (this._isDirectionInit) {
          return;
        }
        this._isDirectionInit = true;
        this.mutationObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.attributeName == "dir") {
              this._directionEventDispatcher.fire(null);
            }
          });
        });
        const options = { attributes: true, attributeFilter: ["dir"] };
        this.mutationObserver.observe(document.body, options);
        this.mutationObserver.observe(document.documentElement, options);
      }
      /**
       * Provided helper method to determine localized or defaultString for specific string is returned
       *
       * @static updateStringsForTag
       * @param {string} tagName
       * @param  stringsObj
       * @returns
       * @memberof LocalizationHelper
       */
      static updateStringsForTag(tagName, stringObj) {
        tagName = tagName.toLowerCase();
        if (tagName.startsWith("mgt-")) {
          tagName = tagName.substring(4);
        }
        if (this._strings && stringObj) {
          for (let prop of Object.entries(stringObj)) {
            if (this._strings[prop[0]]) {
              stringObj[prop[0]] = this._strings[prop[0]];
            }
          }
          if (this._strings["_components"] && this._strings["_components"][tagName]) {
            let strings = this._strings["_components"][tagName];
            for (let key of Object.keys(strings)) {
              if (stringObj[key]) {
                stringObj[key] = strings[key];
              }
            }
          }
        }
        return stringObj;
      }
    };
    LocalizationHelper._stringsEventDispatcher = new EventDispatcher();
    LocalizationHelper._directionEventDispatcher = new EventDispatcher();
    LocalizationHelper._isDirectionInit = false;
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/components/baseComponent.js
var __decorate, __metadata, __awaiter5, ComponentMediaQuery, MgtBaseComponent;
var init_baseComponent = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/components/baseComponent.js"() {
    init_lit();
    init_decorators();
    init_IProvider();
    init_Providers();
    init_LocalizationHelper();
    init_version();
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d2 = decorators[i])
            r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __metadata = function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    __awaiter5 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    (function(ComponentMediaQuery2) {
      ComponentMediaQuery2["mobile"] = "";
      ComponentMediaQuery2["tablet"] = "tablet";
      ComponentMediaQuery2["desktop"] = "desktop";
    })(ComponentMediaQuery || (ComponentMediaQuery = {}));
    MgtBaseComponent = class extends LitElement {
      static get version() {
        return PACKAGE_VERSION2;
      }
      /**
       * Gets the ComponentMediaQuery of the component
       *
       * @readonly
       * @type {MgtElement.ComponentMediaQuery}
       * @memberof MgtBaseComponent
       */
      get mediaQuery() {
        if (this.offsetWidth < 768) {
          return ComponentMediaQuery.mobile;
        } else if (this.offsetWidth < 1200) {
          return ComponentMediaQuery.tablet;
        } else {
          return ComponentMediaQuery.desktop;
        }
      }
      /**
       * A flag to check if the component is loading data state.
       *
       * @protected
       * @memberof MgtBaseComponent
       */
      get isLoadingState() {
        return this._isLoadingState;
      }
      /**
       * A flag to check if the component has updated once.
       *
       * @readonly
       * @protected
       * @type {boolean}
       * @memberof MgtBaseComponent
       */
      get isFirstUpdated() {
        return this._isFirstUpdated;
      }
      /**
       * returns component strings
       *
       * @readonly
       * @protected
       * @memberof MgtBaseComponent
       */
      get strings() {
        return {};
      }
      constructor() {
        super();
        this.direction = "ltr";
        this._isLoadingState = false;
        this._isFirstUpdated = false;
        this.handleLocalizationChanged = this.handleLocalizationChanged.bind(this);
        this.handleDirectionChanged = this.handleDirectionChanged.bind(this);
        this.handleProviderUpdates = this.handleProviderUpdates.bind(this);
        this.handleActiveAccountUpdates = this.handleActiveAccountUpdates.bind(this);
        this.handleDirectionChanged();
        this.handleLocalizationChanged();
      }
      /**
       * Invoked each time the custom element is appended into a document-connected element
       *
       * @memberof MgtBaseComponent
       */
      connectedCallback() {
        super.connectedCallback();
        LocalizationHelper.onStringsUpdated(this.handleLocalizationChanged);
        LocalizationHelper.onDirectionUpdated(this.handleDirectionChanged);
      }
      /**
       * Invoked each time the custom element is removed from a document-connected element
       *
       * @memberof MgtBaseComponent
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        LocalizationHelper.removeOnStringsUpdated(this.handleLocalizationChanged);
        LocalizationHelper.removeOnDirectionUpdated(this.handleDirectionChanged);
        Providers.removeProviderUpdatedListener(this.handleProviderUpdates);
        Providers.removeActiveAccountChangedListener(this.handleActiveAccountUpdates);
      }
      /**
       * Invoked when the element is first updated. Implement to perform one time
       * work on the element after update.
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * @param _changedProperties Map of changed properties with old values
       */
      firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        this._isFirstUpdated = true;
        Providers.onProviderUpdated(this.handleProviderUpdates);
        Providers.onActiveAccountChanged(this.handleActiveAccountUpdates);
        this.requestStateUpdate();
      }
      /**
       * load state into the component.
       * Override this function to provide additional loading logic.
       */
      loadState() {
        return Promise.resolve();
      }
      clearState() {
      }
      /**
       * helps facilitate creation of events across components
       *
       * @protected
       * @param {string} eventName
       * @param {*} [detail]
       * @param {boolean} [bubbles=false]
       * @param {boolean} [cancelable=false]
       * @return {*}  {boolean}
       * @memberof MgtBaseComponent
       */
      fireCustomEvent(eventName, detail, bubbles = false, cancelable = false) {
        const event = new CustomEvent(eventName, {
          bubbles,
          cancelable,
          detail
        });
        return this.dispatchEvent(event);
      }
      /**
       * Invoked whenever the element is updated. Implement to perform
       * post-updating tasks via DOM APIs, for example, focusing an element.
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * * @param changedProperties Map of changed properties with old values
       */
      updated(changedProperties) {
        super.updated(changedProperties);
        const event = new CustomEvent("updated", {
          bubbles: true,
          cancelable: true
        });
        this.dispatchEvent(event);
      }
      /**
       * Request to reload the state.
       * Use reload instead of load to ensure loading events are fired.
       *
       * @protected
       * @memberof MgtBaseComponent
       */
      requestStateUpdate(force = false) {
        return __awaiter5(this, void 0, void 0, function* () {
          if (!this._isFirstUpdated) {
            return;
          }
          if (this.isLoadingState && !force) {
            yield this._currentLoadStatePromise;
          }
          const provider = Providers.globalProvider;
          if (!provider) {
            return Promise.resolve();
          }
          if (provider.state === ProviderState.SignedOut) {
            this.clearState();
            return;
          } else if (provider.state === ProviderState.Loading) {
            return Promise.resolve();
          } else {
            const loadStatePromise = new Promise((resolve, reject) => __awaiter5(this, void 0, void 0, function* () {
              try {
                this.setLoadingState(true);
                this.fireCustomEvent("loadingInitiated");
                yield this.loadState();
                this.setLoadingState(false);
                this.fireCustomEvent("loadingCompleted");
                resolve();
              } catch (e) {
                this.clearState();
                this.setLoadingState(false);
                this.fireCustomEvent("loadingFailed");
                reject(e);
              }
              return this._currentLoadStatePromise = this.isLoadingState && !!this._currentLoadStatePromise && force ? this._currentLoadStatePromise.then(() => loadStatePromise) : loadStatePromise;
            }));
          }
        });
      }
      setLoadingState(value) {
        if (this._isLoadingState === value) {
          return;
        }
        this._isLoadingState = value;
        this.requestUpdate("isLoadingState");
      }
      handleProviderUpdates() {
        this.requestStateUpdate();
      }
      handleActiveAccountUpdates() {
        return __awaiter5(this, void 0, void 0, function* () {
          this.clearState();
          this.requestStateUpdate();
        });
      }
      handleLocalizationChanged() {
        LocalizationHelper.updateStringsForTag(this.tagName, this.strings);
        this.requestUpdate();
      }
      handleDirectionChanged() {
        this.direction = LocalizationHelper.getDocumentDirection();
      }
    };
    __decorate([
      state(),
      __metadata("design:type", Object)
    ], MgtBaseComponent.prototype, "direction", void 0);
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/components/baseProvider.js
var __decorate2, __metadata2, MgtBaseProvider;
var init_baseProvider = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/components/baseProvider.js"() {
    init_decorators();
    init_baseComponent();
    __decorate2 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d2 = decorators[i])
            r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __metadata2 = function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    MgtBaseProvider = class extends MgtBaseComponent {
      /**
       * The IProvider created by this component
       *
       * @memberof MgtBaseProvider
       */
      get provider() {
        return this._provider;
      }
      set provider(value) {
        if (this._provider) {
          this.provider.removeStateChangedHandler(() => this.stateChangedHandler);
        }
        this._provider = value;
        if (this._provider) {
          this.provider.onStateChanged(() => this.stateChangedHandler);
        }
      }
      /**
       * Gets weather this provider can be used in this environment
       *
       * @readonly
       * @type {boolean}
       * @memberof MgtBaseProvider
       */
      get isAvailable() {
        return true;
      }
      /**
       * Invoked when the element is first updated. Implement to perform one time
       * work on the element after update.
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * * @param _changedProperties Map of changed properties with old values
       */
      firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        let higherPriority = false;
        if (this.dependsOn) {
          let higherPriorityProvider = this.dependsOn;
          while (higherPriorityProvider) {
            if (higherPriorityProvider.isAvailable) {
              higherPriority = true;
              break;
            }
            higherPriorityProvider = higherPriorityProvider.dependsOn;
          }
        }
        if (!higherPriority && this.isAvailable) {
          this.initializeProvider();
        }
      }
      /**
       * method called to initialize the provider. Each derived class should provide
       * their own implementation
       *
       * @protected
       * @memberof MgtBaseProvider
       */
      // tslint:disable-next-line: no-empty
      initializeProvider() {
      }
      stateChangedHandler() {
        this.fireCustomEvent("onStateChanged", this.provider.state);
      }
    };
    __decorate2([
      property({
        attribute: "depends-on",
        converter: (newValue) => {
          return document.querySelector(newValue);
        },
        type: String
      }),
      __metadata2("design:type", MgtBaseProvider)
    ], MgtBaseProvider.prototype, "dependsOn", void 0);
    __decorate2([
      property({
        attribute: "base-url",
        type: String
      }),
      __metadata2("design:type", String)
    ], MgtBaseProvider.prototype, "baseUrl", void 0);
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/equals.js
function equals(o1, o2) {
  return equalsInternal(o1, o2, /* @__PURE__ */ new Set());
}
function equalsInternal(o1, o2, refs) {
  const o1Label = Object.prototype.toString.call(o1);
  const o2Label = Object.prototype.toString.call(o2);
  if (o1Label === o2Label && o1Label === "[object Object]" && !refs.has(o1)) {
    refs.add(o1);
    for (const k in o1) {
      if (!equalsInternal(o1[k], o2[k], refs)) {
        return false;
      }
    }
    for (const k in o2) {
      if (!o1.hasOwnProperty(k)) {
        return false;
      }
    }
    return true;
  }
  if (o1Label === o2Label && o1Label === "[object Array]" && !refs.has(o1)) {
    refs.add(o1);
    if (o1.length !== o2.length) {
      return false;
    }
    for (let i = 0; i < o1.length; i++) {
      if (!equalsInternal(o1[i], o2[i], refs)) {
        return false;
      }
    }
    return true;
  }
  return o1 === o2;
}
function arraysAreEqual(arr1, arr2) {
  if (arr1 === arr2) {
    return true;
  }
  if (!arr1 || !arr2) {
    return false;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  if (arr1.length === 0) {
    return true;
  }
  const setArr1 = new Set(arr1);
  for (const i of arr2) {
    if (!setArr1.has(i)) {
      return false;
    }
  }
  return true;
}
var init_equals = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/equals.js"() {
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/TemplateHelper.js
var TemplateHelper;
var init_TemplateHelper = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/TemplateHelper.js"() {
    TemplateHelper = class {
      /**
       * Render a template into a HTMLElement with the appropriate data context
       *
       * Ex:
       * ```
       * <template>
       *  <div>{{myObj.someStr}}</div>
       *  <div data-for="key in myObj.list">
       *    <div>{{key.anotherStr}}</div>
       *  </div>
       * </template>
       * ```
       *
       * @param root the root element to parent the rendered content
       * @param template the template to render
       * @param context the data context to be applied
       */
      static renderTemplate(root, template, context) {
        if (template.$parentTemplateContext) {
          context = Object.assign(Object.assign({}, context), { $parent: template.$parentTemplateContext });
        }
        let rendered;
        if (template.content && template.content.childNodes.length) {
          const templateContent = template.content.cloneNode(true);
          rendered = this.renderNode(templateContent, root, context);
        } else if (template.childNodes.length) {
          const div = document.createElement("div");
          for (let i = 0; i < template.childNodes.length; i++) {
            div.appendChild(this.simpleCloneNode(template.childNodes[i]));
          }
          rendered = this.renderNode(div, root, context);
        }
        if (rendered) {
          root.appendChild(rendered);
        }
      }
      /**
       * Set an alternative binding syntax. Default is {{ <value> }}
       *
       * @static
       * @param {string} startStr start of binding syntax
       * @param {string} endStr end of binding syntax
       * @memberof TemplateHelper
       */
      static setBindingSyntax(startStr, endStr) {
        this._startExpression = startStr;
        this._endExpression = endStr;
        const start = this.escapeRegex(this._startExpression);
        const end = this.escapeRegex(this._endExpression);
        this._expression = new RegExp(`${start}\\s*([$\\w\\.,'"\\s()\\[\\]]+)\\s*${end}`, "g");
      }
      /**
       * Global context containing data or functions available to
       * all templates for binding
       *
       * @readonly
       * @static
       * @memberof TemplateHelper
       */
      static get globalContext() {
        return this._globalContext;
      }
      static get expression() {
        if (!this._expression) {
          this.setBindingSyntax("{{", "}}");
        }
        return this._expression;
      }
      static escapeRegex(string) {
        return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      // simple implementation of deep cloneNode
      // required for nested templates in polyfilled browsers
      static simpleCloneNode(node) {
        if (!node) {
          return null;
        }
        const clone = node.cloneNode(false);
        for (let i = 0; i < node.childNodes.length; i++) {
          const childClone = this.simpleCloneNode(node.childNodes[i]);
          if (childClone) {
            clone.appendChild(childClone);
          }
        }
        return clone;
      }
      static expandExpressionsAsString(str, context) {
        return str.replace(this.expression, (match, p1) => {
          const value = this.evalInContext(p1 || this.trimExpression(match), context);
          if (value) {
            if (typeof value === "object") {
              return JSON.stringify(value);
            } else {
              return value.toString();
            }
          }
          return "";
        });
      }
      static renderNode(node, root, context) {
        if (node.nodeName === "#text") {
          node.textContent = this.expandExpressionsAsString(node.textContent, context);
          return node;
        } else if (node.nodeName === "TEMPLATE") {
          node.$parentTemplateContext = context;
          return node;
        }
        let nodeElement = node;
        if (nodeElement.attributes) {
          for (let i = 0; i < nodeElement.attributes.length; i++) {
            const attribute = nodeElement.attributes[i];
            if (attribute.name === "data-props") {
              const propsValue = this.trimExpression(attribute.value);
              for (const prop of propsValue.split(",")) {
                const keyValue = prop.trim().split(":");
                if (keyValue.length === 2) {
                  const key = keyValue[0].trim();
                  const value = this.evalInContext(keyValue[1].trim(), context);
                  if (key.startsWith("@")) {
                    if (typeof value === "function") {
                      nodeElement.addEventListener(key.substring(1), (e) => value(e, context, root));
                    }
                  } else {
                    nodeElement[key] = value;
                  }
                }
              }
            } else {
              nodeElement.setAttribute(attribute.name, this.expandExpressionsAsString(attribute.value, context));
            }
          }
        }
        const loopChildren = [];
        const removeChildren = [];
        let previousChildWasIfAndTrue = false;
        for (let i = 0; i < node.childNodes.length; i++) {
          const childNode = node.childNodes[i];
          const childElement = childNode;
          let previousChildWasIfAndTrueSet = false;
          if (childElement.dataset) {
            let childWillBeRemoved = false;
            if (childElement.dataset.if) {
              const expression = childElement.dataset.if;
              if (!this.evalBoolInContext(this.trimExpression(expression), context)) {
                removeChildren.push(childElement);
                childWillBeRemoved = true;
              } else {
                childElement.removeAttribute("data-if");
                previousChildWasIfAndTrue = true;
                previousChildWasIfAndTrueSet = true;
              }
            } else if (typeof childElement.dataset.else !== "undefined") {
              if (previousChildWasIfAndTrue) {
                removeChildren.push(childElement);
                childWillBeRemoved = true;
              } else {
                childElement.removeAttribute("data-else");
              }
            }
            if (childElement.dataset.for && !childWillBeRemoved) {
              loopChildren.push(childElement);
            } else if (!childWillBeRemoved) {
              this.renderNode(childNode, root, context);
            }
          } else {
            this.renderNode(childNode, root, context);
          }
          if (!previousChildWasIfAndTrueSet && childNode.nodeName !== "#text") {
            previousChildWasIfAndTrue = false;
          }
        }
        for (const child of removeChildren) {
          nodeElement.removeChild(child);
        }
        for (let i = 0; i < loopChildren.length; i++) {
          const childElement = loopChildren[i];
          const loopExpression = childElement.dataset.for;
          const loopTokens = this.trimExpression(loopExpression).split(/\s(in|of)\s/i);
          if (loopTokens.length === 3) {
            const itemName = loopTokens[0].trim();
            const listKey = loopTokens[2].trim();
            const list = this.evalInContext(listKey, context);
            if (Array.isArray(list)) {
              childElement.removeAttribute("data-for");
              for (let j = 0; j < list.length; j++) {
                const newContext = Object.assign({ $index: j }, context);
                newContext[itemName] = list[j];
                const clone = childElement.cloneNode(true);
                this.renderNode(clone, root, newContext);
                nodeElement.insertBefore(clone, childElement);
              }
            }
            nodeElement.removeChild(childElement);
          }
        }
        return node;
      }
      static evalBoolInContext(expression, context) {
        context = Object.assign(Object.assign({}, context), this.globalContext);
        return new Function("with(this) { return !!(" + expression + ")}").call(context);
      }
      static evalInContext(expression, context) {
        context = Object.assign(Object.assign({}, context), this.globalContext);
        const func = new Function("with(this) { return " + expression + ";}");
        let result;
        try {
          result = func.call(context);
        } catch (e) {
        }
        return result;
      }
      static trimExpression(expression) {
        expression = expression.trim();
        if (expression.startsWith(this._startExpression) && expression.endsWith(this._endExpression)) {
          expression = expression.substr(this._startExpression.length, expression.length - this._startExpression.length - this._endExpression.length);
          expression = expression.trim();
        }
        return expression;
      }
    };
    TemplateHelper._globalContext = {};
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/components/templatedComponent.js
var __decorate3, __metadata3, MgtTemplatedComponent;
var init_templatedComponent = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/components/templatedComponent.js"() {
    init_lit();
    init_decorators();
    init_equals();
    init_baseComponent();
    init_TemplateHelper();
    __decorate3 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d2 = decorators[i])
            r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __metadata3 = function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    MgtTemplatedComponent = class extends MgtBaseComponent {
      constructor() {
        super();
        this.templates = {};
        this._renderedSlots = false;
        this._renderedTemplates = {};
        this._slotNamesAddedDuringRender = [];
        this.templateContext = this.templateContext || {};
      }
      /**
       * Updates the element. This method reflects property values to attributes.
       * It can be overridden to render and keep updated element DOM.
       * Setting properties inside this method will *not* trigger
       * another update.
       *
       * * @param _changedProperties Map of changed properties with old values
       */
      update(changedProperties) {
        this.templates = this.getTemplates();
        this._slotNamesAddedDuringRender = [];
        super.update(changedProperties);
      }
      /**
       * Invoked whenever the element is updated. Implement to perform
       * post-updating tasks via DOM APIs, for example, focusing an element.
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * * @param changedProperties Map of changed properties with old values
       */
      updated(changedProperties) {
        super.updated(changedProperties);
        this.removeUnusedSlottedElements();
      }
      /**
       * Render a <template> by type and return content to render
       *
       * @param templateType type of template (indicated by the data-type attribute)
       * @param context the data context that should be expanded in template
       * @param slotName the slot name that will be used to host the new rendered template. set to a unique value if multiple templates of this type will be rendered. default is templateType
       */
      renderTemplate(templateType, context, slotName) {
        if (!this.hasTemplate(templateType)) {
          return null;
        }
        slotName = slotName || templateType;
        this._slotNamesAddedDuringRender.push(slotName);
        this._renderedSlots = true;
        const template = html`
      <slot name=${slotName}></slot>
    `;
        const dataContext = Object.assign(Object.assign({}, context), this.templateContext);
        if (this._renderedTemplates.hasOwnProperty(slotName)) {
          const { context: existingContext, slot } = this._renderedTemplates[slotName];
          if (equals(existingContext, dataContext)) {
            return template;
          }
          this.removeChild(slot);
        }
        const div = document.createElement("div");
        div.slot = slotName;
        div.dataset.generated = "template";
        TemplateHelper.renderTemplate(div, this.templates[templateType], dataContext);
        this.appendChild(div);
        this._renderedTemplates[slotName] = { context: dataContext, slot: div };
        const templateRenderedData = { templateType, context: dataContext, element: div };
        this.fireCustomEvent("templateRendered", templateRenderedData);
        return template;
      }
      /**
       * Check if a specific template has been provided.
       *
       * @protected
       * @param {string} templateName
       * @returns {boolean}
       * @memberof MgtTemplatedComponent
       */
      hasTemplate(templateName) {
        return this.templates && this.templates[templateName];
      }
      getTemplates() {
        const templates = {};
        for (let i = 0; i < this.children.length; i++) {
          const child = this.children[i];
          if (child.nodeName === "TEMPLATE") {
            const template = child;
            if (template.dataset.type) {
              templates[template.dataset.type] = template;
            } else {
              templates.default = template;
            }
            template.templateOrder = i;
          }
        }
        return templates;
      }
      removeUnusedSlottedElements() {
        if (this._renderedSlots) {
          for (let i = 0; i < this.children.length; i++) {
            const child = this.children[i];
            if (child.dataset && child.dataset.generated && !this._slotNamesAddedDuringRender.includes(child.slot)) {
              this.removeChild(child);
              delete this._renderedTemplates[child.slot];
              i--;
            }
          }
          this._renderedSlots = false;
        }
      }
    };
    __decorate3([
      property({ attribute: false }),
      __metadata3("design:type", Object)
    ], MgtTemplatedComponent.prototype, "templateContext", void 0);
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/providers/SimpleProvider.js
var SimpleProvider;
var init_SimpleProvider = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/providers/SimpleProvider.js"() {
    init_Graph();
    init_IProvider();
    SimpleProvider = class extends IProvider {
      /**
       * Name used for analytics
       *
       * @readonly
       * @memberof IProvider
       */
      get name() {
        return "MgtSimpleProvider";
      }
      constructor(getAccessTokenHandler, loginHandler, logoutHandler) {
        super();
        this._getAccessTokenHandler = getAccessTokenHandler;
        this._loginHandler = loginHandler;
        this._logoutHandler = logoutHandler;
        this.graph = createFromProvider(this);
      }
      /**
       * Invokes the getAccessToken function
       *
       * @param {AuthenticationProviderOptions} [options]
       * @returns {Promise<string>}
       * @memberof SimpleProvider
       */
      getAccessToken(options) {
        return this._getAccessTokenHandler(options === null || options === void 0 ? void 0 : options.scopes);
      }
      /**
       * Invokes login function
       *
       * @returns {Promise<void>}
       * @memberof SimpleProvider
       */
      login() {
        return this._loginHandler();
      }
      /**
       * Invokes logout function
       *
       * @returns {Promise<void>}
       * @memberof SimpleProvider
       */
      logout() {
        return this._logoutHandler();
      }
    };
  }
});

// node_modules/idb/build/esm/wrap-idb-value.js
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap2(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap2(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap2(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap2(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap2(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, cursorRequestMap, transactionDoneMap, transactionStoreNamesMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap;
var init_wrap_idb_value = __esm({
  "node_modules/idb/build/esm/wrap-idb-value.js"() {
    instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
    cursorRequestMap = /* @__PURE__ */ new WeakMap();
    transactionDoneMap = /* @__PURE__ */ new WeakMap();
    transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
    transformCache = /* @__PURE__ */ new WeakMap();
    reverseTransformCache = /* @__PURE__ */ new WeakMap();
    idbProxyTraps = {
      get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
          if (prop === "done")
            return transactionDoneMap.get(target);
          if (prop === "objectStoreNames") {
            return target.objectStoreNames || transactionStoreNamesMap.get(target);
          }
          if (prop === "store") {
            return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
          }
        }
        return wrap2(target[prop]);
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
      has(target, prop) {
        if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
          return true;
        }
        return prop in target;
      }
    };
    unwrap = (value) => reverseTransformCache.get(value);
  }
});

// node_modules/idb/build/esm/index.js
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = wrap2(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap2(request.result), event.oldVersion, event.newVersion, wrap2(request.transaction));
    });
  }
  if (blocked)
    request.addEventListener("blocked", () => blocked());
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking)
      db.addEventListener("versionchange", () => blocking());
  }).catch(() => {
  });
  return openPromise;
}
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
var readMethods, writeMethods, cachedMethods;
var init_esm = __esm({
  "node_modules/idb/build/esm/index.js"() {
    init_wrap_idb_value();
    init_wrap_idb_value();
    readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
    writeMethods = ["put", "add", "delete", "clear"];
    cachedMethods = /* @__PURE__ */ new Map();
    replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
    }));
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/Cache.js
var __awaiter6, dbListKey, CacheService, CacheStore;
var init_Cache = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/Cache.js"() {
    init_esm();
    init_Providers();
    init_IProvider();
    __awaiter6 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    dbListKey = "mgt-db-list";
    CacheService = class {
      /**
       *  Looks for existing cache, otherwise creates a new one
       *
       * @static
       * @template T
       * @param {CacheSchema} schema
       * @param {string} storeName
       * @returns {CacheStore<T>}
       * @memberof CacheService
       */
      static getCache(schema, storeName) {
        const key = `${schema.name}/${storeName}`;
        if (!this.isInitialized) {
          this.init();
        }
        if (!this.cacheStore.has(storeName)) {
          this.cacheStore.set(key, new CacheStore(schema, storeName));
        }
        return this.cacheStore.get(key);
      }
      /**
       * Clears cache for a single user when ID is passed
       *
       * @static
       * @param {string} id
       * @memberof CacheService
       */
      static clearCacheById(id) {
        const oldDbArray = JSON.parse(localStorage.getItem(dbListKey));
        if (oldDbArray) {
          let newDbArray = [];
          oldDbArray.forEach((x) => __awaiter6(this, void 0, void 0, function* () {
            if (x.includes(id)) {
              indexedDB.deleteDatabase(x);
            } else {
              newDbArray.push(x);
            }
          }));
          newDbArray.length > 0 ? localStorage.setItem(dbListKey, JSON.stringify(newDbArray)) : localStorage.removeItem(dbListKey);
        }
      }
      /**
       * returns the cacheconfig object
       *
       * @readonly
       * @static
       * @type {CacheConfig}
       * @memberof CacheService
       */
      static get config() {
        return this.cacheConfig;
      }
      /**
       * Checks for current sign in state and see if it has changed from signed-in to signed out
       *
       *
       * @private
       * @static
       * @memberof CacheService
       */
      static init() {
        let previousState;
        if (Providers.globalProvider) {
          previousState = Providers.globalProvider.state;
        }
        Providers.onProviderUpdated(() => __awaiter6(this, void 0, void 0, function* () {
          if (previousState === ProviderState.SignedIn && Providers.globalProvider.state === ProviderState.SignedOut) {
            const id = yield Providers.getCacheId();
            if (id !== null) {
              this.clearCacheById(id);
            }
          }
          previousState = Providers.globalProvider.state;
        }));
        this.isInitialized = true;
      }
    };
    CacheService.cacheStore = /* @__PURE__ */ new Map();
    CacheService.isInitialized = false;
    CacheService.cacheConfig = {
      defaultInvalidationPeriod: 36e5,
      groups: {
        invalidationPeriod: null,
        isEnabled: true
      },
      isEnabled: true,
      people: {
        invalidationPeriod: null,
        isEnabled: true
      },
      photos: {
        invalidationPeriod: null,
        isEnabled: true
      },
      presence: {
        invalidationPeriod: 3e5,
        isEnabled: true
      },
      users: {
        invalidationPeriod: null,
        isEnabled: true
      },
      response: {
        invalidationPeriod: null,
        isEnabled: true
      },
      files: {
        invalidationPeriod: null,
        isEnabled: true
      },
      fileLists: {
        invalidationPeriod: null,
        isEnabled: true
      }
    };
    CacheStore = class {
      constructor(schema, store) {
        if (!(store in schema.stores)) {
          throw Error('"store" must be defined in the "schema"');
        }
        this.schema = schema;
        this.store = store;
      }
      /**
       * gets value from cache for the given key
       *
       * @param {string} key
       * @returns {Promise<T>}
       * @memberof Cache
       */
      getValue(key) {
        return __awaiter6(this, void 0, void 0, function* () {
          if (!window.indexedDB) {
            return null;
          }
          try {
            const db = yield this.getDb();
            return db.get(this.store, key);
          } catch (e) {
            return null;
          }
        });
      }
      /**
       * inserts value into cache for the given key
       *
       * @param {string} key
       * @param {T} item
       * @returns
       * @memberof Cache
       */
      putValue(key, item) {
        return __awaiter6(this, void 0, void 0, function* () {
          if (!window.indexedDB) {
            return;
          }
          try {
            yield (yield this.getDb()).put(this.store, Object.assign(Object.assign({}, item), { timeCached: Date.now() }), key);
          } catch (e) {
            return;
          }
        });
      }
      /**
       * Clears the store of all stored values
       *
       * @returns
       * @memberof Cache
       */
      clearStore() {
        return __awaiter6(this, void 0, void 0, function* () {
          if (!window.indexedDB) {
            return;
          }
          try {
            (yield this.getDb()).clear(this.store);
          } catch (e) {
            return;
          }
        });
      }
      /**
       * Returns the name of the parent DB that the cache store belongs to
       */
      getDBName() {
        return __awaiter6(this, void 0, void 0, function* () {
          const id = yield Providers.getCacheId();
          if (id) {
            return `mgt-${this.schema.name}-${id}`;
          }
        });
      }
      getDb() {
        return __awaiter6(this, void 0, void 0, function* () {
          const dbName = yield this.getDBName();
          if (dbName) {
            return openDB(dbName, this.schema.version, {
              upgrade: (db, oldVersion, newVersion, transaction) => {
                let dbArray = JSON.parse(localStorage.getItem(dbListKey)) || [];
                if (!dbArray.includes(dbName)) {
                  dbArray.push(dbName);
                }
                localStorage.setItem(dbListKey, JSON.stringify(dbArray));
                for (const storeName in this.schema.stores) {
                  if (this.schema.stores.hasOwnProperty(storeName)) {
                    db.objectStoreNames.contains(storeName) || db.createObjectStore(storeName);
                  }
                }
              }
            });
          }
        });
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/TeamsHelper.js
var TeamsHelper;
var init_TeamsHelper = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/TeamsHelper.js"() {
    TeamsHelper = class {
      /**
       * Optional entry point to the teams library
       * If this value is not set, the provider will attempt to use
       * the microsoftTeams global variable.
       *
       * @static
       * @type {*}
       * @memberof TeamsHelper
       */
      static get microsoftTeamsLib() {
        return this._microsoftTeamsLib || window["microsoftTeams"];
      }
      static set microsoftTeamsLib(value) {
        this._microsoftTeamsLib = value;
      }
      /**
       * Gets whether the Teams provider can be used in the current context
       * (Whether the app is running in Microsoft Teams)
       *
       * @readonly
       * @static
       * @memberof TeamsHelper
       */
      static get isAvailable() {
        if (!this.microsoftTeamsLib) {
          return false;
        }
        if (window.parent === window.self && window.nativeInterface) {
          return true;
        } else if (window.name === "embedded-page-container" || window.name === "extension-tab-frame") {
          return true;
        }
        return false;
      }
      /**
       * Execute a deeplink against the Teams lib.
       *
       * @static
       * @param {string} deeplink
       * @param {(status: boolean, reason?: string) => void} [onComplete]
       * @memberof TeamsHelper
       */
      static executeDeepLink(deeplink, onComplete) {
        const teams = this.microsoftTeamsLib;
        teams.initialize();
        teams.executeDeepLink(deeplink, onComplete);
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/TemplateContext.js
var init_TemplateContext = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/TemplateContext.js"() {
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/GraphPageIterator.js
var __awaiter7, GraphPageIterator;
var init_GraphPageIterator = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/GraphPageIterator.js"() {
    __awaiter7 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    GraphPageIterator = class {
      /**
       * Gets all the items already fetched for this request
       *
       * @readonly
       * @type {T[]}
       * @memberof GraphPageIterator
       */
      get value() {
        return this._value;
      }
      /**
       * Gets wheather this request has more pages
       *
       * @readonly
       * @type {boolean}
       * @memberof GraphPageIterator
       */
      get hasNext() {
        return !!this._nextLink;
      }
      /**
       * Creates a new GraphPageIterator
       *
       * @static
       * @template T - the type of entities expected from this request
       * @param {IGraph} graph - the graph instance to use for making requests
       * @param {GraphRequest} request - the initial request
       * @param {string} [version] - optional version to use for the requests - by default uses the default version
       * from the graph parameter
       * @returns a GraphPageIterator
       * @memberof GraphPageIterator
       */
      static create(graph, request, version) {
        return __awaiter7(this, void 0, void 0, function* () {
          const response = yield request.get();
          if (response && response.value) {
            const iterator = new GraphPageIterator();
            iterator._graph = graph;
            iterator._value = response.value;
            iterator._nextLink = response["@odata.nextLink"];
            iterator._version = version || graph.version;
            return iterator;
          }
          return null;
        });
      }
      /**
       * Creates a new GraphPageIterator from existing value
       *
       * @static
       * @template T - the type of entities expected from this request
       * @param {IGraph} graph - the graph instance to use for making requests
       * @param value - the existing value
       * @param nextLink - optional nextLink to use to get the next page
       * from the graph parameter
       * @returns a GraphPageIterator
       * @memberof GraphPageIterator
       */
      static createFromValue(graph, value, nextLink) {
        let iterator = new GraphPageIterator();
        iterator._graph = graph;
        iterator._value = value;
        iterator._nextLink = nextLink ? nextLink : null;
        iterator._version = graph.version;
        return iterator || null;
      }
      /**
       * Gets the next page for this request
       *
       * @returns {Promise<T[]>}
       * @memberof GraphPageIterator
       */
      next() {
        return __awaiter7(this, void 0, void 0, function* () {
          if (this._nextLink) {
            const nextResource = this._nextLink.split(this._version)[1];
            const response = yield this._graph.api(nextResource).version(this._version).get();
            if (response && response.value && response.value.length) {
              this._value = this._value.concat(response.value);
              this._nextLink = response["@odata.nextLink"];
              return response.value;
            }
          }
          return null;
        });
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/mgtHtml.js
var stringsCache, rewriteStrings, tag2, mgtHtml;
var init_mgtHtml = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/mgtHtml.js"() {
    init_lit();
    init_customElementHelper();
    stringsCache = /* @__PURE__ */ new WeakMap();
    rewriteStrings = (strings, matcher, replacement) => {
      const temp = [];
      for (const s of strings) {
        temp.push(s.replace(matcher, replacement));
      }
      return temp;
    };
    tag2 = (strings, ...values) => {
      if (customElementHelper.isDisambiguated) {
        let cached = stringsCache.get(strings);
        if (!Boolean(cached)) {
          const matcher = new RegExp("(</?)mgt-(?!" + customElementHelper.disambiguation + "-)");
          const newPrefix = `$1${customElementHelper.prefix}-`;
          cached = Object.assign(rewriteStrings(strings, matcher, newPrefix), {
            raw: rewriteStrings(strings.raw, matcher, newPrefix)
          });
          stringsCache.set(strings, cached);
        }
        strings = cached;
      }
      return html(strings, ...values);
    };
    mgtHtml = tag2;
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/CustomElement.js
var customElement2;
var init_CustomElement = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/CustomElement.js"() {
    init_decorators();
    init_customElementHelper();
    customElement2 = (tagName) => {
      const mgtTagName = `${customElementHelper.prefix}-${tagName}`;
      const mgtElement = customElements.get(mgtTagName);
      const unknownVersion = " Unknown likely <3.0.0";
      const version = (element) => element.version || unknownVersion;
      if (mgtElement) {
        return (classOrDescriptor) => {
          console.error(`Tag name ${mgtTagName} is already defined using class ${mgtElement.name} version ${version(mgtElement)}
`, `Currently registering class ${classOrDescriptor.name} with version ${version(classOrDescriptor)}
`, "Please use the disambiguation feature to define a unique tag name for this component see: https://github.com/microsoftgraph/microsoft-graph-toolkit/tree/main/packages/mgt-components#disambiguation");
          return classOrDescriptor;
        };
      }
      return customElement(mgtTagName);
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/utils/SessionCache.js
function storageAvailable(storageType) {
  let storage;
  try {
    storage = window[storageType];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e) {
    return e instanceof DOMException && // everything except Firefox
    (e.code === 22 || // Firefox
    e.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    e.name === "QuotaExceededError" || // Firefox
    e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0;
  }
}
var SessionCache;
var init_SessionCache = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/utils/SessionCache.js"() {
    SessionCache = class {
      constructor() {
        this.session = window.sessionStorage;
      }
      setItem(key, value) {
        this.session.setItem(key, value);
      }
      getItem(key) {
        return this.session.getItem(key);
      }
      clear() {
        this.session.clear();
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/mock/MockGraph.js
var __awaiter8, MockGraph, MockMiddleware;
var init_MockGraph = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/mock/MockGraph.js"() {
    init_browser();
    init_SessionCache();
    init_Graph();
    init_GraphHelpers();
    __awaiter8 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MockGraph = class extends Graph {
      /**
       * Creates a new MockGraph instance. Use this static method instead of the constructor.
       *
       * @static
       * @param {MockProvider} provider
       * @return {*}  {Promise<MockGraph>}
       * @memberof MockGraph
       */
      static create(provider) {
        return __awaiter8(this, void 0, void 0, function* () {
          const middleware = [
            new AuthenticationHandler(provider),
            new RetryHandler(new RetryHandlerOptions()),
            new TelemetryHandler(),
            new MockMiddleware(),
            new HTTPMessageHandler()
          ];
          return new MockGraph(Client.initWithMiddleware({
            middleware: chainMiddleware(...middleware),
            customHosts: /* @__PURE__ */ new Set([new URL(yield MockMiddleware.getBaseUrl()).hostname])
          }));
        });
      }
      /**
       * Returns an instance of the Graph in the context of the provided component.
       *
       * @param {MgtBaseComponent} component
       * @returns
       * @memberof Graph
       */
      forComponent(component) {
        return this;
      }
    };
    MockMiddleware = class {
      static get _sessionCache() {
        if (!this._cache && storageAvailable("sessionStorage")) {
          this._cache = new SessionCache();
        }
        return this._cache;
      }
      // tslint:disable-next-line: completed-docs
      execute(context) {
        return __awaiter8(this, void 0, void 0, function* () {
          try {
            const baseUrl = yield MockMiddleware.getBaseUrl();
            context.request = baseUrl + encodeURIComponent(context.request);
          } catch (error) {
          }
          return yield this._nextMiddleware.execute(context);
        });
      }
      /**
       * Handles setting of next middleware
       *
       * @param {Middleware} next
       * @memberof SdkVersionMiddleware
       */
      setNext(next) {
        this._nextMiddleware = next;
      }
      /**
       * Gets the base url for the mock graph, either from the session cache or from the endpoint service
       *
       * @static
       * @return {string} the base url for the mock graph to use.
       * @memberof MockMiddleware
       */
      static getBaseUrl() {
        var _a5, _b4;
        return __awaiter8(this, void 0, void 0, function* () {
          if (!this._baseUrl) {
            const sessionEndpoint = (_a5 = this._sessionCache) === null || _a5 === void 0 ? void 0 : _a5.getItem("endpointURL");
            if (sessionEndpoint) {
              this._baseUrl = sessionEndpoint;
            } else {
              try {
                const response = yield fetch("https://cdn.graph.office.net/en-us/graph/api/proxy/endpoint");
                this._baseUrl = (yield response.json()) + "?url=";
              } catch (_c4) {
                this._baseUrl = "https://proxy.apisandbox.msdn.microsoft.com/svc?url=";
              }
              (_b4 = this._sessionCache) === null || _b4 === void 0 ? void 0 : _b4.setItem("endpointURL", this._baseUrl);
            }
          }
          return this._baseUrl;
        });
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/mock/MockProvider.js
var __awaiter9, MockProvider;
var init_MockProvider = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/mock/MockProvider.js"() {
    init_IProvider();
    init_MockGraph();
    __awaiter9 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MockProvider = class extends IProvider {
      constructor(signedIn = false, signedInAccounts = []) {
        super();
        this._accounts = [];
        this._mockGraphPromise = MockGraph.create(this);
        const enableMultipleLogin = Boolean(signedInAccounts.length);
        this.isMultipleAccountSupported = enableMultipleLogin;
        this.isMultipleAccountDisabled = !enableMultipleLogin;
        this._accounts = signedInAccounts;
        this.initializeMockGraph(signedIn);
      }
      /**
       * Indicates if the MockProvider is configured to support multi account mode
       * This is only true if the Mock provider has been configured with signedInAccounts in the constructor
       *
       * @readonly
       * @type {boolean}
       * @memberof MockProvider
       */
      get isMultiAccountSupportedAndEnabled() {
        return !this.isMultipleAccountDisabled && this.isMultipleAccountSupported;
      }
      /**
       * Returns the array of accounts the MockProviders has been configured with
       *
       * @return {*}  {IProviderAccount[]}
       * @memberof MockProvider
       */
      getAllAccounts() {
        return this._accounts;
      }
      /**
       * Returns the first account in the set of accounts the MockProvider has been configured with
       *
       * @return {*}  {IProviderAccount}
       * @memberof MockProvider
       */
      getActiveAccount() {
        if (this._accounts.length) {
          return this._accounts[0];
        }
      }
      /**
       * sets Provider state to SignedIn
       *
       * @returns {Promise<void>}
       * @memberof MockProvider
       */
      login() {
        return __awaiter9(this, void 0, void 0, function* () {
          this.setState(ProviderState.Loading);
          yield this._mockGraphPromise;
          yield new Promise((resolve) => setTimeout(resolve, 3e3));
          this.setState(ProviderState.SignedIn);
        });
      }
      /**
       * sets Provider state to signed out
       *
       * @returns {Promise<void>}
       * @memberof MockProvider
       */
      logout() {
        return __awaiter9(this, void 0, void 0, function* () {
          this.setState(ProviderState.Loading);
          yield this._mockGraphPromise;
          yield new Promise((resolve) => setTimeout(resolve, 3e3));
          this.setState(ProviderState.SignedOut);
        });
      }
      /**
       * Promise returning token from graph.microsoft.com
       *
       * @returns {Promise<string>}
       * @memberof MockProvider
       */
      getAccessToken() {
        return Promise.resolve("{token:https://graph.microsoft.com/}");
      }
      /**
       * Name used for analytics
       *
       * @readonly
       * @memberof IProvider
       */
      get name() {
        return "MgtMockProvider";
      }
      initializeMockGraph(signedIn = false) {
        return __awaiter9(this, void 0, void 0, function* () {
          this.graph = yield this._mockGraphPromise;
          if (signedIn) {
            this.setState(ProviderState.SignedIn);
          } else {
            this.setState(ProviderState.SignedOut);
          }
        });
      }
    };
  }
});

// node_modules/@microsoft/mgt-element/dist/es6/index.js
var init_es6 = __esm({
  "node_modules/@microsoft/mgt-element/dist/es6/index.js"() {
    init_IBatch();
    init_IGraph();
    init_Graph();
    init_BetaGraph();
    init_baseComponent();
    init_baseProvider();
    init_templatedComponent();
    init_customElementHelper();
    init_IProvider();
    init_Providers();
    init_SimpleProvider();
    init_Cache();
    init_EventDispatcher();
    init_equals();
    init_GraphHelpers();
    init_TeamsHelper();
    init_TemplateContext();
    init_TemplateHelper();
    init_GraphPageIterator();
    init_LocalizationHelper();
    init_mgtHtml();
    init_CustomElement();
    init_version();
    init_MockProvider();
  }
});

export {
  BatchResponse,
  MICROSOFT_GRAPH_ENDPOINTS,
  MICROSOFT_GRAPH_DEFAULT_ENDPOINT,
  ResponseType,
  init_browser,
  EventDispatcher,
  IProvider,
  LoginType,
  ProviderState,
  Providers,
  ProvidersChangedState,
  prepScopes,
  chainMiddleware,
  validateBaseURL,
  PACKAGE_VERSION2 as PACKAGE_VERSION,
  customElementHelper,
  Graph,
  createFromProvider,
  BetaGraph,
  css,
  html,
  noChange,
  _$LH,
  init_lit_html,
  init_lit,
  property,
  state,
  init_decorators,
  LocalizationHelper,
  ComponentMediaQuery,
  MgtBaseComponent,
  MgtBaseProvider,
  equals,
  arraysAreEqual,
  TemplateHelper,
  MgtTemplatedComponent,
  SimpleProvider,
  CacheService,
  CacheStore,
  TeamsHelper,
  GraphPageIterator,
  mgtHtml,
  customElement2 as customElement,
  MockProvider,
  init_es6
};
/*! Bundled license information:

@lit/reactive-element/development/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/development/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-56JPRE6S.js.map
