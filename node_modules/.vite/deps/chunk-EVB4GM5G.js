import {
  __require
} from "./chunk-TFWDKVI3.js";

// node_modules/@microsoft/mgt-element/dist/es6/IBatch.js
var BatchResponse = class {
};

// node_modules/@microsoft/mgt-element/dist/es6/IGraph.js
var MICROSOFT_GRAPH_ENDPOINTS = /* @__PURE__ */ new Set();
var MICROSOFT_GRAPH_DEFAULT_ENDPOINT = "https://graph.microsoft.com";
(() => {
  const endpoints = [
    MICROSOFT_GRAPH_DEFAULT_ENDPOINT,
    "https://graph.microsoft.us",
    "https://dod-graph.microsoft.us",
    "https://graph.microsoft.de",
    "https://microsoftgraph.chinacloudapi.cn"
  ];
  endpoints.forEach((endpoint) => MICROSOFT_GRAPH_ENDPOINTS.add(endpoint));
})();

// node_modules/@microsoft/mgt-element/node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/RequestMethod.js
var RequestMethod;
(function(RequestMethod2) {
  RequestMethod2["GET"] = "GET";
  RequestMethod2["PATCH"] = "PATCH";
  RequestMethod2["POST"] = "POST";
  RequestMethod2["PUT"] = "PUT";
  RequestMethod2["DELETE"] = "DELETE";
})(RequestMethod || (RequestMethod = {}));

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/content/BatchRequestContent.js
var BatchRequestContent = class {
  /**
   * @public
   * @constructor
   * Constructs a BatchRequestContent instance
   * @param {BatchRequestStep[]} [requests] - Array of requests value
   * @returns An instance of a BatchRequestContent
   */
  constructor(requests) {
    this.requests = /* @__PURE__ */ new Map();
    if (typeof requests !== "undefined") {
      const limit = BatchRequestContent.requestLimit;
      if (requests.length > limit) {
        const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
        error.name = "Limit Exceeded Error";
        throw error;
      }
      for (const req of requests) {
        this.addRequest(req);
      }
    }
  }
  /**
   * @private
   * @static
   * Validates the dependency chain of the requests
   *
   * Note:
   * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:
   * 1. Parallel - no individual request states a dependency in the dependsOn property.
   * 2. Serial - all individual requests depend on the previous individual request.
   * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.
   * As JSON batching matures, these limitations will be removed.
   * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}
   *
   * @param {Map<string, BatchRequestStep>} requests - The map of requests.
   * @returns The boolean indicating the validation status
   */
  static validateDependencies(requests) {
    const isParallel = (reqs) => {
      const iterator = reqs.entries();
      let cur = iterator.next();
      while (!cur.done) {
        const curReq = cur.value[1];
        if (curReq.dependsOn !== void 0 && curReq.dependsOn.length > 0) {
          return false;
        }
        cur = iterator.next();
      }
      return true;
    };
    const isSerial = (reqs) => {
      const iterator = reqs.entries();
      let cur = iterator.next();
      const firstRequest = cur.value[1];
      if (firstRequest.dependsOn !== void 0 && firstRequest.dependsOn.length > 0) {
        return false;
      }
      let prev = cur;
      cur = iterator.next();
      while (!cur.done) {
        const curReq = cur.value[1];
        if (curReq.dependsOn === void 0 || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {
          return false;
        }
        prev = cur;
        cur = iterator.next();
      }
      return true;
    };
    const isSame = (reqs) => {
      const iterator = reqs.entries();
      let cur = iterator.next();
      const firstRequest = cur.value[1];
      let dependencyId;
      if (firstRequest.dependsOn === void 0 || firstRequest.dependsOn.length === 0) {
        dependencyId = firstRequest.id;
      } else {
        if (firstRequest.dependsOn.length === 1) {
          const fDependencyId = firstRequest.dependsOn[0];
          if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {
            dependencyId = fDependencyId;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      cur = iterator.next();
      while (!cur.done) {
        const curReq = cur.value[1];
        if ((curReq.dependsOn === void 0 || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {
          return false;
        }
        if (curReq.dependsOn !== void 0 && curReq.dependsOn.length !== 0) {
          if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {
            return false;
          }
          if (curReq.dependsOn.length > 1) {
            return false;
          }
        }
        cur = iterator.next();
      }
      return true;
    };
    if (requests.size === 0) {
      const error = new Error("Empty requests map, Please provide at least one request.");
      error.name = "Empty Requests Error";
      throw error;
    }
    return isParallel(requests) || isSerial(requests) || isSame(requests);
  }
  /**
   * @private
   * @static
   * @async
   * Converts Request Object instance to a JSON
   * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance
   * @returns A promise that resolves to JSON representation of a request
   */
  static getRequestData(request) {
    return __awaiter(this, void 0, void 0, function* () {
      const requestData = {
        url: ""
      };
      const hasHttpRegex = new RegExp("^https?://");
      requestData.url = hasHttpRegex.test(request.url) ? "/" + request.url.split(/.*?\/\/.*?\//)[1] : request.url;
      requestData.method = request.method;
      const headers = {};
      request.headers.forEach((value, key) => {
        headers[key] = value;
      });
      if (Object.keys(headers).length) {
        requestData.headers = headers;
      }
      if (request.method === RequestMethod.PATCH || request.method === RequestMethod.POST || request.method === RequestMethod.PUT) {
        requestData.body = yield BatchRequestContent.getRequestBody(request);
      }
      return requestData;
    });
  }
  /**
   * @private
   * @static
   * @async
   * Gets the body of a Request object instance
   * @param {IsomorphicRequest} request - The IsomorphicRequest object instance
   * @returns The Promise that resolves to a body value of a Request
   */
  static getRequestBody(request) {
    return __awaiter(this, void 0, void 0, function* () {
      let bodyParsed = false;
      let body;
      try {
        const cloneReq = request.clone();
        body = yield cloneReq.json();
        bodyParsed = true;
      } catch (e) {
      }
      if (!bodyParsed) {
        try {
          if (typeof Blob !== "undefined") {
            const blob = yield request.blob();
            const reader = new FileReader();
            body = yield new Promise((resolve) => {
              reader.addEventListener("load", () => {
                const dataURL = reader.result;
                const regex = new RegExp("^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$");
                const segments = regex.exec(dataURL);
                resolve(segments[4]);
              }, false);
              reader.readAsDataURL(blob);
            });
          } else if (typeof Buffer !== "undefined") {
            const buffer = yield request.buffer();
            body = buffer.toString("base64");
          }
          bodyParsed = true;
        } catch (e) {
        }
      }
      return body;
    });
  }
  /**
   * @public
   * Adds a request to the batch request content
   * @param {BatchRequestStep} request - The request value
   * @returns The id of the added request
   */
  addRequest(request) {
    const limit = BatchRequestContent.requestLimit;
    if (request.id === "") {
      const error = new Error(`Id for a request is empty, Please provide an unique id`);
      error.name = "Empty Id For Request";
      throw error;
    }
    if (this.requests.size === limit) {
      const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
      error.name = "Limit Exceeded Error";
      throw error;
    }
    if (this.requests.has(request.id)) {
      const error = new Error(`Adding request with duplicate id ${request.id}, Make the id of the requests unique`);
      error.name = "Duplicate RequestId Error";
      throw error;
    }
    this.requests.set(request.id, request);
    return request.id;
  }
  /**
   * @public
   * Removes request from the batch payload and its dependencies from all dependents
   * @param {string} requestId - The id of a request that needs to be removed
   * @returns The boolean indicating removed status
   */
  removeRequest(requestId) {
    const deleteStatus = this.requests.delete(requestId);
    const iterator = this.requests.entries();
    let cur = iterator.next();
    while (!cur.done) {
      const dependencies = cur.value[1].dependsOn;
      if (typeof dependencies !== "undefined") {
        const index = dependencies.indexOf(requestId);
        if (index !== -1) {
          dependencies.splice(index, 1);
        }
        if (dependencies.length === 0) {
          delete cur.value[1].dependsOn;
        }
      }
      cur = iterator.next();
    }
    return deleteStatus;
  }
  /**
   * @public
   * @async
   * Serialize content from BatchRequestContent instance
   * @returns The body content to make batch request
   */
  getContent() {
    return __awaiter(this, void 0, void 0, function* () {
      const requests = [];
      const requestBody = {
        requests
      };
      const iterator = this.requests.entries();
      let cur = iterator.next();
      if (cur.done) {
        const error = new Error("No requests added yet, Please add at least one request.");
        error.name = "Empty Payload";
        throw error;
      }
      if (!BatchRequestContent.validateDependencies(this.requests)) {
        const error = new Error(`Invalid dependency found, Dependency should be:
1. Parallel - no individual request states a dependency in the dependsOn property.
2. Serial - all individual requests depend on the previous individual request.
3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.`);
        error.name = "Invalid Dependency";
        throw error;
      }
      while (!cur.done) {
        const requestStep = cur.value[1];
        const batchRequestData = yield BatchRequestContent.getRequestData(requestStep.request);
        if (batchRequestData.body !== void 0 && (batchRequestData.headers === void 0 || batchRequestData.headers["content-type"] === void 0)) {
          const error = new Error(`Content-type header is not mentioned for request #${requestStep.id}, For request having body, Content-type header should be mentioned`);
          error.name = "Invalid Content-type header";
          throw error;
        }
        batchRequestData.id = requestStep.id;
        if (requestStep.dependsOn !== void 0 && requestStep.dependsOn.length > 0) {
          batchRequestData.dependsOn = requestStep.dependsOn;
        }
        requests.push(batchRequestData);
        cur = iterator.next();
      }
      requestBody.requests = requests;
      return requestBody;
    });
  }
  /**
   * @public
   * Adds a dependency for a given dependent request
   * @param {string} dependentId - The id of the dependent request
   * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency
   * @returns Nothing
   */
  addDependency(dependentId, dependencyId) {
    if (!this.requests.has(dependentId)) {
      const error = new Error(`Dependent ${dependentId} does not exists, Please check the id`);
      error.name = "Invalid Dependent";
      throw error;
    }
    if (typeof dependencyId !== "undefined" && !this.requests.has(dependencyId)) {
      const error = new Error(`Dependency ${dependencyId} does not exists, Please check the id`);
      error.name = "Invalid Dependency";
      throw error;
    }
    if (typeof dependencyId !== "undefined") {
      const dependent = this.requests.get(dependentId);
      if (dependent.dependsOn === void 0) {
        dependent.dependsOn = [];
      }
      if (dependent.dependsOn.indexOf(dependencyId) !== -1) {
        const error = new Error(`Dependency ${dependencyId} is already added for the request ${dependentId}`);
        error.name = "Duplicate Dependency";
        throw error;
      }
      dependent.dependsOn.push(dependencyId);
    } else {
      const iterator = this.requests.entries();
      let prev;
      let cur = iterator.next();
      while (!cur.done && cur.value[1].id !== dependentId) {
        prev = cur;
        cur = iterator.next();
      }
      if (typeof prev !== "undefined") {
        const dId = prev.value[0];
        if (cur.value[1].dependsOn === void 0) {
          cur.value[1].dependsOn = [];
        }
        if (cur.value[1].dependsOn.indexOf(dId) !== -1) {
          const error = new Error(`Dependency ${dId} is already added for the request ${dependentId}`);
          error.name = "Duplicate Dependency";
          throw error;
        }
        cur.value[1].dependsOn.push(dId);
      } else {
        const error = new Error(`Can't add dependency ${dependencyId}, There is only a dependent request in the batch`);
        error.name = "Invalid Dependency Addition";
        throw error;
      }
    }
  }
  /**
   * @public
   * Removes a dependency for a given dependent request id
   * @param {string} dependentId - The id of the dependent request
   * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request
   * @returns The boolean indicating removed status
   */
  removeDependency(dependentId, dependencyId) {
    const request = this.requests.get(dependentId);
    if (typeof request === "undefined" || request.dependsOn === void 0 || request.dependsOn.length === 0) {
      return false;
    }
    if (typeof dependencyId !== "undefined") {
      const index = request.dependsOn.indexOf(dependencyId);
      if (index === -1) {
        return false;
      }
      request.dependsOn.splice(index, 1);
      return true;
    } else {
      delete request.dependsOn;
      return true;
    }
  }
};
BatchRequestContent.requestLimit = 20;

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/MiddlewareControl.js
var MiddlewareControl = class {
  /**
   * @public
   * @constructor
   * Creates an instance of MiddlewareControl
   * @param {MiddlewareOptions[]} [middlewareOptions = []] - The array of middlewareOptions
   * @returns The instance of MiddlewareControl
   */
  constructor(middlewareOptions = []) {
    this.middlewareOptions = /* @__PURE__ */ new Map();
    for (const option of middlewareOptions) {
      const fn = option.constructor;
      this.middlewareOptions.set(fn, option);
    }
  }
  /**
   * @public
   * To get the middleware option using the class of the option
   * @param {Function} fn - The class of the strongly typed option class
   * @returns The middleware option
   * @example
   * // if you wanted to return the middleware option associated with this class (MiddlewareControl)
   * // call this function like this:
   * getMiddlewareOptions(MiddlewareControl)
   */
  // tslint:disable-next-line:ban-types
  getMiddlewareOptions(fn) {
    return this.middlewareOptions.get(fn);
  }
  /**
   * @public
   * To set the middleware options using the class of the option
   * @param {Function} fn - The class of the strongly typed option class
   * @param {MiddlewareOptions} option - The strongly typed middleware option
   * @returns nothing
   */
  // tslint:disable-next-line:ban-types
  setMiddlewareOptions(fn, option) {
    this.middlewareOptions.set(fn, option);
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/MiddlewareUtil.js
var generateUUID = () => {
  let uuid = "";
  for (let j = 0; j < 32; j++) {
    if (j === 8 || j === 12 || j === 16 || j === 20) {
      uuid += "-";
    }
    uuid += Math.floor(Math.random() * 16).toString(16);
  }
  return uuid;
};
var getRequestHeader = (request, options, key) => {
  let value = null;
  if (typeof Request !== "undefined" && request instanceof Request) {
    value = request.headers.get(key);
  } else if (typeof options !== "undefined" && options.headers !== void 0) {
    if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
      value = options.headers.get(key);
    } else if (options.headers instanceof Array) {
      const headers = options.headers;
      for (let i = 0, l = headers.length; i < l; i++) {
        if (headers[i][0] === key) {
          value = headers[i][1];
          break;
        }
      }
    } else if (options.headers[key] !== void 0) {
      value = options.headers[key];
    }
  }
  return value;
};
var setRequestHeader = (request, options, key, value) => {
  if (typeof Request !== "undefined" && request instanceof Request) {
    request.headers.set(key, value);
  } else if (typeof options !== "undefined") {
    if (options.headers === void 0) {
      options.headers = new Headers({
        [key]: value
      });
    } else {
      if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
        options.headers.set(key, value);
      } else if (options.headers instanceof Array) {
        let i = 0;
        const l = options.headers.length;
        for (; i < l; i++) {
          const header = options.headers[i];
          if (header[0] === key) {
            header[1] = value;
            break;
          }
        }
        if (i === l) {
          options.headers.push([key, value]);
        }
      } else {
        Object.assign(options.headers, { [key]: value });
      }
    }
  }
};
var appendRequestHeader = (request, options, key, value) => {
  if (typeof Request !== "undefined" && request instanceof Request) {
    request.headers.append(key, value);
  } else if (typeof options !== "undefined") {
    if (options.headers === void 0) {
      options.headers = new Headers({
        [key]: value
      });
    } else {
      if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
        options.headers.append(key, value);
      } else if (options.headers instanceof Array) {
        options.headers.push([key, value]);
      } else if (options.headers === void 0) {
        options.headers = { [key]: value };
      } else if (options.headers[key] === void 0) {
        options.headers[key] = value;
      } else {
        options.headers[key] += `, ${value}`;
      }
    }
  }
};
var cloneRequestWithNewUrl = (newUrl, request) => __awaiter(void 0, void 0, void 0, function* () {
  const body = request.headers.get("Content-Type") ? yield request.blob() : yield Promise.resolve(void 0);
  const { method, headers, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal } = request;
  return new Request(newUrl, { method, headers, body, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal });
});

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/AuthenticationHandlerOptions.js
var AuthenticationHandlerOptions = class {
  /**
   * @public
   * @constructor
   * To create an instance of AuthenticationHandlerOptions
   * @param {AuthenticationProvider} [authenticationProvider] - The authentication provider instance
   * @param {AuthenticationProviderOptions} [authenticationProviderOptions] - The authentication provider options instance
   * @returns An instance of AuthenticationHandlerOptions
   */
  constructor(authenticationProvider, authenticationProviderOptions) {
    this.authenticationProvider = authenticationProvider;
    this.authenticationProviderOptions = authenticationProviderOptions;
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/TelemetryHandlerOptions.js
var FeatureUsageFlag;
(function(FeatureUsageFlag2) {
  FeatureUsageFlag2[FeatureUsageFlag2["NONE"] = 0] = "NONE";
  FeatureUsageFlag2[FeatureUsageFlag2["REDIRECT_HANDLER_ENABLED"] = 1] = "REDIRECT_HANDLER_ENABLED";
  FeatureUsageFlag2[FeatureUsageFlag2["RETRY_HANDLER_ENABLED"] = 2] = "RETRY_HANDLER_ENABLED";
  FeatureUsageFlag2[FeatureUsageFlag2["AUTHENTICATION_HANDLER_ENABLED"] = 4] = "AUTHENTICATION_HANDLER_ENABLED";
})(FeatureUsageFlag || (FeatureUsageFlag = {}));
var TelemetryHandlerOptions = class {
  constructor() {
    this.featureUsage = FeatureUsageFlag.NONE;
  }
  /**
   * @public
   * @static
   * To update the feature usage in the context object
   * @param {Context} context - The request context object containing middleware options
   * @param {FeatureUsageFlag} flag - The flag value
   * @returns nothing
   */
  static updateFeatureUsageFlag(context, flag) {
    let options;
    if (context.middlewareControl instanceof MiddlewareControl) {
      options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);
    } else {
      context.middlewareControl = new MiddlewareControl();
    }
    if (typeof options === "undefined") {
      options = new TelemetryHandlerOptions();
      context.middlewareControl.setMiddlewareOptions(TelemetryHandlerOptions, options);
    }
    options.setFeatureUsage(flag);
  }
  /**
   * @private
   * To set the feature usage flag
   * @param {FeatureUsageFlag} flag - The flag value
   * @returns nothing
   */
  setFeatureUsage(flag) {
    this.featureUsage = this.featureUsage | flag;
  }
  /**
   * @public
   * To get the feature usage
   * @returns A feature usage flag as hexadecimal string
   */
  getFeatureUsage() {
    return this.featureUsage.toString(16);
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/AuthenticationHandler.js
var AuthenticationHandler = class {
  /**
   * @public
   * @constructor
   * Creates an instance of AuthenticationHandler
   * @param {AuthenticationProvider} authenticationProvider - The authentication provider for the authentication handler
   */
  constructor(authenticationProvider) {
    this.authenticationProvider = authenticationProvider;
  }
  /**
   * @public
   * @async
   * To execute the current middleware
   * @param {Context} context - The context object of the request
   * @returns A Promise that resolves to nothing
   */
  execute(context) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let options;
        if (context.middlewareControl instanceof MiddlewareControl) {
          options = context.middlewareControl.getMiddlewareOptions(AuthenticationHandlerOptions);
        }
        let authenticationProvider;
        let authenticationProviderOptions;
        if (typeof options !== "undefined") {
          authenticationProvider = options.authenticationProvider;
          authenticationProviderOptions = options.authenticationProviderOptions;
        }
        if (typeof authenticationProvider === "undefined") {
          authenticationProvider = this.authenticationProvider;
        }
        const token = yield authenticationProvider.getAccessToken(authenticationProviderOptions);
        const bearerKey = `Bearer ${token}`;
        appendRequestHeader(context.request, context.options, AuthenticationHandler.AUTHORIZATION_HEADER, bearerKey);
        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.AUTHENTICATION_HANDLER_ENABLED);
        return yield this.nextMiddleware.execute(context);
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * To set the next middleware in the chain
   * @param {Middleware} next - The middleware instance
   * @returns Nothing
   */
  setNext(next) {
    this.nextMiddleware = next;
  }
};
AuthenticationHandler.AUTHORIZATION_HEADER = "Authorization";

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/HTTPMessageHandler.js
var HTTPMessageHandler = class {
  /**
   * @public
   * @async
   * To execute the current middleware
   * @param {Context} context - The request context object
   * @returns A promise that resolves to nothing
   */
  execute(context) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        context.response = yield fetch(context.request, context.options);
        return;
      } catch (error) {
        throw error;
      }
    });
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/RetryHandlerOptions.js
var RetryHandlerOptions = class {
  /**
   * @public
   * @constructor
   * To create an instance of RetryHandlerOptions
   * @param {number} [delay = RetryHandlerOptions.DEFAULT_DELAY] - The delay value in seconds
   * @param {number} [maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES] - The maxRetries value
   * @param {ShouldRetry} [shouldRetry = RetryHandlerOptions.DEFAULT_SHOULD_RETRY] - The shouldRetry callback function
   * @returns An instance of RetryHandlerOptions
   */
  constructor(delay2 = RetryHandlerOptions.DEFAULT_DELAY, maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES, shouldRetry = RetryHandlerOptions.DEFAULT_SHOULD_RETRY) {
    if (delay2 > RetryHandlerOptions.MAX_DELAY && maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
      const error = new Error(`Delay and MaxRetries should not be more than ${RetryHandlerOptions.MAX_DELAY} and ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
      error.name = "MaxLimitExceeded";
      throw error;
    } else if (delay2 > RetryHandlerOptions.MAX_DELAY) {
      const error = new Error(`Delay should not be more than ${RetryHandlerOptions.MAX_DELAY}`);
      error.name = "MaxLimitExceeded";
      throw error;
    } else if (maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
      const error = new Error(`MaxRetries should not be more than ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
      error.name = "MaxLimitExceeded";
      throw error;
    } else if (delay2 < 0 && maxRetries < 0) {
      const error = new Error(`Delay and MaxRetries should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    } else if (delay2 < 0) {
      const error = new Error(`Delay should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    } else if (maxRetries < 0) {
      const error = new Error(`MaxRetries should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    }
    this.delay = Math.min(delay2, RetryHandlerOptions.MAX_DELAY);
    this.maxRetries = Math.min(maxRetries, RetryHandlerOptions.MAX_MAX_RETRIES);
    this.shouldRetry = shouldRetry;
  }
  /**
   * @public
   * To get the maximum delay
   * @returns A maximum delay
   */
  getMaxDelay() {
    return RetryHandlerOptions.MAX_DELAY;
  }
};
RetryHandlerOptions.DEFAULT_DELAY = 3;
RetryHandlerOptions.DEFAULT_MAX_RETRIES = 3;
RetryHandlerOptions.MAX_DELAY = 180;
RetryHandlerOptions.MAX_MAX_RETRIES = 10;
RetryHandlerOptions.DEFAULT_SHOULD_RETRY = () => true;

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/RetryHandler.js
var RetryHandler = class {
  /**
   * @public
   * @constructor
   * To create an instance of RetryHandler
   * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value
   * @returns An instance of RetryHandler
   */
  constructor(options = new RetryHandlerOptions()) {
    this.options = options;
  }
  /**
   *
   * @private
   * To check whether the response has the retry status code
   * @param {Response} response - The response object
   * @returns Whether the response has retry status code or not
   */
  isRetry(response) {
    return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;
  }
  /**
   * @private
   * To check whether the payload is buffered or not
   * @param {RequestInfo} request - The url string or the request object value
   * @param {FetchOptions} options - The options of a request
   * @returns Whether the payload is buffered or not
   */
  isBuffered(request, options) {
    const method = typeof request === "string" ? options.method : request.method;
    const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;
    if (isPutPatchOrPost) {
      const isStream = getRequestHeader(request, options, "Content-Type") === "application/octet-stream";
      if (isStream) {
        return false;
      }
    }
    return true;
  }
  /**
   * @private
   * To get the delay for a retry
   * @param {Response} response - The response object
   * @param {number} retryAttempts - The current attempt count
   * @param {number} delay - The delay value in seconds
   * @returns A delay for a retry
   */
  getDelay(response, retryAttempts, delay2) {
    const getRandomness = () => Number(Math.random().toFixed(3));
    const retryAfter = response.headers !== void 0 ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;
    let newDelay;
    if (retryAfter !== null) {
      if (Number.isNaN(Number(retryAfter))) {
        newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1e3);
      } else {
        newDelay = Number(retryAfter);
      }
    } else {
      newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay2 + getRandomness() : delay2 + getRandomness();
    }
    return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());
  }
  /**
   * @private
   * To get an exponential back off value
   * @param {number} attempts - The current attempt count
   * @returns An exponential back off value
   */
  getExponentialBackOffTime(attempts) {
    return Math.round(1 / 2 * (Math.pow(2, attempts) - 1));
  }
  /**
   * @private
   * @async
   * To add delay for the execution
   * @param {number} delaySeconds - The delay value in seconds
   * @returns Nothing
   */
  sleep(delaySeconds) {
    return __awaiter(this, void 0, void 0, function* () {
      const delayMilliseconds = delaySeconds * 1e3;
      return new Promise((resolve) => setTimeout(resolve, delayMilliseconds));
    });
  }
  getOptions(context) {
    let options;
    if (context.middlewareControl instanceof MiddlewareControl) {
      options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);
    }
    if (typeof options === "undefined") {
      options = Object.assign(new RetryHandlerOptions(), this.options);
    }
    return options;
  }
  /**
   * @private
   * @async
   * To execute the middleware with retries
   * @param {Context} context - The context object
   * @param {number} retryAttempts - The current attempt count
   * @param {RetryHandlerOptions} options - The retry middleware options instance
   * @returns A Promise that resolves to nothing
   */
  executeWithRetry(context, retryAttempts, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.nextMiddleware.execute(context);
        if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {
          ++retryAttempts;
          setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());
          const delay2 = this.getDelay(context.response, retryAttempts, options.delay);
          yield this.sleep(delay2);
          return yield this.executeWithRetry(context, retryAttempts, options);
        } else {
          return;
        }
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * To execute the current middleware
   * @param {Context} context - The context object of the request
   * @returns A Promise that resolves to nothing
   */
  execute(context) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const retryAttempts = 0;
        const options = this.getOptions(context);
        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);
        return yield this.executeWithRetry(context, retryAttempts, options);
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * To set the next middleware in the chain
   * @param {Middleware} next - The middleware instance
   * @returns Nothing
   */
  setNext(next) {
    this.nextMiddleware = next;
  }
};
RetryHandler.RETRY_STATUS_CODES = [
  429,
  503,
  504
];
RetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt";
RetryHandler.RETRY_AFTER_HEADER = "Retry-After";

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/RedirectHandlerOptions.js
var RedirectHandlerOptions = class {
  /**
   * @public
   * @constructor
   * To create an instance of RedirectHandlerOptions
   * @param {number} [maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS] - The max redirects value
   * @param {ShouldRedirect} [shouldRedirect = RedirectHandlerOptions.DEFAULT_SHOULD_RETRY] - The should redirect callback
   * @returns An instance of RedirectHandlerOptions
   */
  constructor(maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS, shouldRedirect = RedirectHandlerOptions.DEFAULT_SHOULD_RETRY) {
    if (maxRedirects > RedirectHandlerOptions.MAX_MAX_REDIRECTS) {
      const error = new Error(`MaxRedirects should not be more than ${RedirectHandlerOptions.MAX_MAX_REDIRECTS}`);
      error.name = "MaxLimitExceeded";
      throw error;
    }
    if (maxRedirects < 0) {
      const error = new Error(`MaxRedirects should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    }
    this.maxRedirects = maxRedirects;
    this.shouldRedirect = shouldRedirect;
  }
};
RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS = 5;
RedirectHandlerOptions.MAX_MAX_REDIRECTS = 20;
RedirectHandlerOptions.DEFAULT_SHOULD_RETRY = () => true;

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/RedirectHandler.js
var RedirectHandler = class {
  /**
   * @public
   * @constructor
   * To create an instance of RedirectHandler
   * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance
   * @returns An instance of RedirectHandler
   */
  constructor(options = new RedirectHandlerOptions()) {
    this.options = options;
  }
  /**
   * @private
   * To check whether the response has the redirect status code or not
   * @param {Response} response - The response object
   * @returns A boolean representing whether the response contains the redirect status code or not
   */
  isRedirect(response) {
    return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;
  }
  /**
   * @private
   * To check whether the response has location header or not
   * @param {Response} response - The response object
   * @returns A boolean representing the whether the response has location header or not
   */
  hasLocationHeader(response) {
    return response.headers.has(RedirectHandler.LOCATION_HEADER);
  }
  /**
   * @private
   * To get the redirect url from location header in response object
   * @param {Response} response - The response object
   * @returns A redirect url from location header
   */
  getLocationHeader(response) {
    return response.headers.get(RedirectHandler.LOCATION_HEADER);
  }
  /**
   * @private
   * To check whether the given url is a relative url or not
   * @param {string} url - The url string value
   * @returns A boolean representing whether the given url is a relative url or not
   */
  isRelativeURL(url) {
    return url.indexOf("://") === -1;
  }
  /**
   * @private
   * To check whether the authorization header in the request should be dropped for consequent redirected requests
   * @param {string} requestUrl - The request url value
   * @param {string} redirectUrl - The redirect url value
   * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests
   */
  shouldDropAuthorizationHeader(requestUrl, redirectUrl) {
    const schemeHostRegex = /^[A-Za-z].+?:\/\/.+?(?=\/|$)/;
    const requestMatches = schemeHostRegex.exec(requestUrl);
    let requestAuthority;
    let redirectAuthority;
    if (requestMatches !== null) {
      requestAuthority = requestMatches[0];
    }
    const redirectMatches = schemeHostRegex.exec(redirectUrl);
    if (redirectMatches !== null) {
      redirectAuthority = redirectMatches[0];
    }
    return typeof requestAuthority !== "undefined" && typeof redirectAuthority !== "undefined" && requestAuthority !== redirectAuthority;
  }
  /**
   * @private
   * @async
   * To update a request url with the redirect url
   * @param {string} redirectUrl - The redirect url value
   * @param {Context} context - The context object value
   * @returns Nothing
   */
  updateRequestUrl(redirectUrl, context) {
    return __awaiter(this, void 0, void 0, function* () {
      context.request = typeof context.request === "string" ? redirectUrl : yield cloneRequestWithNewUrl(redirectUrl, context.request);
    });
  }
  /**
   * @private
   * To get the options for execution of the middleware
   * @param {Context} context - The context object
   * @returns A options for middleware execution
   */
  getOptions(context) {
    let options;
    if (context.middlewareControl instanceof MiddlewareControl) {
      options = context.middlewareControl.getMiddlewareOptions(RedirectHandlerOptions);
    }
    if (typeof options === "undefined") {
      options = Object.assign(new RedirectHandlerOptions(), this.options);
    }
    return options;
  }
  /**
   * @private
   * @async
   * To execute the next middleware and to handle in case of redirect response returned by the server
   * @param {Context} context - The context object
   * @param {number} redirectCount - The redirect count value
   * @param {RedirectHandlerOptions} options - The redirect handler options instance
   * @returns A promise that resolves to nothing
   */
  executeWithRedirect(context, redirectCount, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.nextMiddleware.execute(context);
        const response = context.response;
        if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {
          ++redirectCount;
          if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {
            context.options.method = RequestMethod.GET;
            delete context.options.body;
          } else {
            const redirectUrl = this.getLocationHeader(response);
            if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {
              delete context.options.headers[RedirectHandler.AUTHORIZATION_HEADER];
            }
            yield this.updateRequestUrl(redirectUrl, context);
          }
          yield this.executeWithRedirect(context, redirectCount, options);
        } else {
          return;
        }
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * To execute the current middleware
   * @param {Context} context - The context object of the request
   * @returns A Promise that resolves to nothing
   */
  execute(context) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const redirectCount = 0;
        const options = this.getOptions(context);
        context.options.redirect = RedirectHandler.MANUAL_REDIRECT;
        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.REDIRECT_HANDLER_ENABLED);
        return yield this.executeWithRedirect(context, redirectCount, options);
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * To set the next middleware in the chain
   * @param {Middleware} next - The middleware instance
   * @returns Nothing
   */
  setNext(next) {
    this.nextMiddleware = next;
  }
};
RedirectHandler.REDIRECT_STATUS_CODES = [
  301,
  302,
  303,
  307,
  308
];
RedirectHandler.STATUS_CODE_SEE_OTHER = 303;
RedirectHandler.LOCATION_HEADER = "Location";
RedirectHandler.AUTHORIZATION_HEADER = "Authorization";
RedirectHandler.MANUAL_REDIRECT = "manual";

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/Constants.js
var GRAPH_API_VERSION = "v1.0";
var GRAPH_BASE_URL = "https://graph.microsoft.com/";
var GRAPH_URLS = /* @__PURE__ */ new Set(["graph.microsoft.com", "graph.microsoft.us", "dod-graph.microsoft.us", "graph.microsoft.de", "microsoftgraph.chinacloudapi.cn"]);

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphRequestUtil.js
var oDataQueryNames = ["$select", "$expand", "$orderby", "$filter", "$top", "$skip", "$skipToken", "$count"];
var urlJoin = (urlSegments) => {
  const removePostSlash = (s) => s.replace(/\/+$/, "");
  const removePreSlash = (s) => s.replace(/^\/+/, "");
  const joiner = (pre, cur) => [removePostSlash(pre), removePreSlash(cur)].join("/");
  const parts2 = Array.prototype.slice.call(urlSegments);
  return parts2.reduce(joiner);
};
var serializeContent = (content) => {
  const className = content && content.constructor && content.constructor.name;
  if (className === "Buffer" || className === "Blob" || className === "File" || className === "FormData" || typeof content === "string") {
    return content;
  }
  if (className === "ArrayBuffer") {
    content = Buffer.from(content);
  } else if (className === "Int8Array" || className === "Int16Array" || className === "Int32Array" || className === "Uint8Array" || className === "Uint16Array" || className === "Uint32Array" || className === "Uint8ClampedArray" || className === "Float32Array" || className === "Float64Array" || className === "DataView") {
    content = Buffer.from(content.buffer);
  } else {
    try {
      content = JSON.stringify(content);
    } catch (error) {
      throw new Error("Unable to stringify the content");
    }
  }
  return content;
};
var isGraphURL = (url) => {
  url = url.toLowerCase();
  if (url.indexOf("https://") !== -1) {
    url = url.replace("https://", "");
    const startofPortNoPos = url.indexOf(":");
    const endOfHostStrPos = url.indexOf("/");
    let hostName = "";
    if (endOfHostStrPos !== -1) {
      if (startofPortNoPos !== -1 && startofPortNoPos < endOfHostStrPos) {
        hostName = url.substring(0, startofPortNoPos);
        return GRAPH_URLS.has(hostName);
      }
      hostName = url.substring(0, endOfHostStrPos);
      return GRAPH_URLS.has(hostName);
    }
  }
  return false;
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/Version.js
var PACKAGE_VERSION = "2.2.1";

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/TelemetryHandler.js
var TelemetryHandler = class {
  /**
   * @public
   * @async
   * To execute the current middleware
   * @param {Context} context - The context object of the request
   * @returns A Promise that resolves to nothing
   */
  execute(context) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const url = typeof context.request === "string" ? context.request : context.request.url;
        if (isGraphURL(url)) {
          let clientRequestId = getRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER);
          if (!clientRequestId) {
            clientRequestId = generateUUID();
            setRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER, clientRequestId);
          }
          let sdkVersionValue = `${TelemetryHandler.PRODUCT_NAME}/${PACKAGE_VERSION}`;
          let options;
          if (context.middlewareControl instanceof MiddlewareControl) {
            options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);
          }
          if (options) {
            const featureUsage = options.getFeatureUsage();
            sdkVersionValue += ` (${TelemetryHandler.FEATURE_USAGE_STRING}=${featureUsage})`;
          }
          appendRequestHeader(context.request, context.options, TelemetryHandler.SDK_VERSION_HEADER, sdkVersionValue);
        } else {
          delete context.options.headers[TelemetryHandler.CLIENT_REQUEST_ID_HEADER];
          delete context.options.headers[TelemetryHandler.SDK_VERSION_HEADER];
        }
        return yield this.nextMiddleware.execute(context);
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * To set the next middleware in the chain
   * @param {Middleware} next - The middleware instance
   * @returns Nothing
   */
  setNext(next) {
    this.nextMiddleware = next;
  }
};
TelemetryHandler.CLIENT_REQUEST_ID_HEADER = "client-request-id";
TelemetryHandler.SDK_VERSION_HEADER = "SdkVersion";
TelemetryHandler.PRODUCT_NAME = "graph-js";
TelemetryHandler.FEATURE_USAGE_STRING = "featureUsage";

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/ChaosStrategy.js
var ChaosStrategy;
(function(ChaosStrategy2) {
  ChaosStrategy2[ChaosStrategy2["MANUAL"] = 0] = "MANUAL";
  ChaosStrategy2[ChaosStrategy2["RANDOM"] = 1] = "RANDOM";
})(ChaosStrategy || (ChaosStrategy = {}));

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/Range.js
var Range = class {
  /**
   * @public
   * @constructor
   * Creates a range for given min and max values
   * @param {number} [minVal = -1] - The minimum value.
   * @param {number} [maxVal = -1] - The maximum value.
   * @returns An instance of a Range
   */
  constructor(minVal = -1, maxVal = -1) {
    this.minValue = minVal;
    this.maxValue = maxVal;
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/tasks/LargeFileUploadTask.js
var LargeFileUploadTask = class {
  /**
   * @public
   * @constructor
   * Constructs a LargeFileUploadTask
   * @param {Client} client - The GraphClient instance
   * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded
   * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done
   * @param {LargeFileUploadTaskOptions} options - The upload task options
   * @returns An instance of LargeFileUploadTask
   */
  constructor(client, file, uploadSession, options = {}) {
    this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
    this.client = client;
    this.file = file;
    if (options.rangeSize === void 0) {
      options.rangeSize = this.DEFAULT_FILE_SIZE;
    }
    this.options = options;
    this.uploadSession = uploadSession;
    this.nextRange = new Range(0, this.options.rangeSize - 1);
  }
  /**
   * @public
   * @static
   * @async
   * Makes request to the server to create an upload session
   * @param {Client} client - The GraphClient instance
   * @param {any} payload - The payload that needs to be sent
   * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent
   * @returns The promise that resolves to LargeFileUploadSession
   */
  static createUploadSession(client, requestUrl, payload, headers = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const session = yield client.api(requestUrl).headers(headers).post(payload);
        const largeFileUploadSession = {
          url: session.uploadUrl,
          expiry: new Date(session.expirationDateTime)
        };
        return largeFileUploadSession;
      } catch (err) {
        throw err;
      }
    });
  }
  /**
   * @private
   * Parses given range string to the Range instance
   * @param {string[]} ranges - The ranges value
   * @returns The range instance
   */
  parseRange(ranges) {
    const rangeStr = ranges[0];
    if (typeof rangeStr === "undefined" || rangeStr === "") {
      return new Range();
    }
    const firstRange = rangeStr.split("-");
    const minVal = parseInt(firstRange[0], 10);
    let maxVal = parseInt(firstRange[1], 10);
    if (Number.isNaN(maxVal)) {
      maxVal = this.file.size - 1;
    }
    return new Range(minVal, maxVal);
  }
  /**
   * @private
   * Updates the expiration date and the next range
   * @param {UploadStatusResponse} response - The response of the upload status
   * @returns Nothing
   */
  updateTaskStatus(response) {
    this.uploadSession.expiry = new Date(response.expirationDateTime);
    this.nextRange = this.parseRange(response.nextExpectedRanges);
  }
  /**
   * @public
   * Gets next range that needs to be uploaded
   * @returns The range instance
   */
  getNextRange() {
    if (this.nextRange.minValue === -1) {
      return this.nextRange;
    }
    const minVal = this.nextRange.minValue;
    let maxValue = minVal + this.options.rangeSize - 1;
    if (maxValue >= this.file.size) {
      maxValue = this.file.size - 1;
    }
    return new Range(minVal, maxValue);
  }
  /**
   * @public
   * Slices the file content to the given range
   * @param {Range} range - The range value
   * @returns The sliced ArrayBuffer or Blob
   */
  sliceFile(range) {
    const blob = this.file.content.slice(range.minValue, range.maxValue + 1);
    return blob;
  }
  /**
   * @public
   * @async
   * Uploads file to the server in a sequential order by slicing the file
   * @returns The promise resolves to uploaded response
   */
  upload() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        while (true) {
          const nextRange = this.getNextRange();
          if (nextRange.maxValue === -1) {
            const err = new Error("Task with which you are trying to upload is already completed, Please check for your uploaded file");
            err.name = "Invalid Session";
            throw err;
          }
          const fileSlice = this.sliceFile(nextRange);
          const response = yield this.uploadSlice(fileSlice, nextRange, this.file.size);
          if (response.id !== void 0) {
            return response;
          } else {
            this.updateTaskStatus(response);
          }
        }
      } catch (err) {
        throw err;
      }
    });
  }
  /**
   * @public
   * @async
   * Uploads given slice to the server
   * @param {ArrayBuffer | Blob | File} fileSlice - The file slice
   * @param {Range} range - The range value
   * @param {number} totalSize - The total size of a complete file
   */
  uploadSlice(fileSlice, range, totalSize) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.client.api(this.uploadSession.url).headers({
          "Content-Length": `${range.maxValue - range.minValue + 1}`,
          "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`
        }).put(fileSlice);
      } catch (err) {
        throw err;
      }
    });
  }
  /**
   * @public
   * @async
   * Deletes upload session in the server
   * @returns The promise resolves to cancelled response
   */
  cancel() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.client.api(this.uploadSession.url).delete();
      } catch (err) {
        throw err;
      }
    });
  }
  /**
   * @public
   * @async
   * Gets status for the upload session
   * @returns The promise resolves to the status enquiry response
   */
  getStatus() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const response = yield this.client.api(this.uploadSession.url).get();
        this.updateTaskStatus(response);
        return response;
      } catch (err) {
        throw err;
      }
    });
  }
  /**
   * @public
   * @async
   * Resumes upload session and continue uploading the file from the last sent range
   * @returns The promise resolves to the uploaded response
   */
  resume() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.getStatus();
        return yield this.upload();
      } catch (err) {
        throw err;
      }
    });
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/tasks/OneDriveLargeFileUploadTaskUtil.js
var DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
var roundTo320KB = (value) => {
  if (value > 320 * 1024) {
    value = Math.floor(value / (320 * 1024)) * 320 * 1024;
  }
  return value;
};
var getValidRangeSize = (rangeSize = DEFAULT_FILE_SIZE) => {
  const sixtyMB = 60 * 1024 * 1024;
  if (rangeSize > sixtyMB) {
    rangeSize = sixtyMB;
  }
  return roundTo320KB(rangeSize);
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/tasks/OneDriveLargeFileUploadTask.js
var OneDriveLargeFileUploadTask = class extends LargeFileUploadTask {
  /**
   * @public
   * @constructor
   * Constructs a OneDriveLargeFileUploadTask
   * @param {Client} client - The GraphClient instance
   * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded
   * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done
   * @param {LargeFileUploadTaskOptions} options - The upload task options
   * @returns An instance of OneDriveLargeFileUploadTask
   */
  constructor(client, file, uploadSession, options) {
    super(client, file, uploadSession, options);
  }
  /**
   * @private
   * @static
   * Constructs the create session url for Onedrive
   * @param {string} fileName - The name of the file
   * @param {path} [path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH] - The path for the upload
   * @returns The constructed create session url
   */
  static constructCreateSessionUrl(fileName, path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH) {
    fileName = fileName.trim();
    path = path.trim();
    if (path === "") {
      path = "/";
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path[path.length - 1] !== "/") {
      path = `${path}/`;
    }
    return `/me/drive/root:${path.split("/").map((p) => encodeURIComponent(p)).join("/")}${encodeURIComponent(fileName)}:/createUploadSession`;
  }
  /**
   * @public
   * @static
   * @async
   * Creates a OneDriveLargeFileUploadTask
   * @param {Client} client - The GraphClient instance
   * @param {Blob | Buffer | File} file - File represented as Blob, Buffer or File
   * @param {OneDriveLargeFileUploadOptions} options - The options for upload task
   * @returns The promise that will be resolves to OneDriveLargeFileUploadTask instance
   */
  static create(client, file, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const name = options.fileName;
      let content;
      let size;
      if (typeof Blob !== "undefined" && file instanceof Blob) {
        content = new File([file], name);
        size = content.size;
      } else if (typeof File !== "undefined" && file instanceof File) {
        content = file;
        size = content.size;
      } else if (typeof Buffer !== "undefined" && file instanceof Buffer) {
        const b = file;
        size = b.byteLength - b.byteOffset;
        content = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
      }
      try {
        const requestUrl = OneDriveLargeFileUploadTask.constructCreateSessionUrl(options.fileName, options.path);
        const session = yield OneDriveLargeFileUploadTask.createUploadSession(client, requestUrl, options.fileName);
        const rangeSize = getValidRangeSize(options.rangeSize);
        const fileObj = {
          name,
          content,
          size
        };
        return new OneDriveLargeFileUploadTask(client, fileObj, session, {
          rangeSize
        });
      } catch (err) {
        throw err;
      }
    });
  }
  /**
   * @public
   * @static
   * @async
   * Makes request to the server to create an upload session
   * @param {Client} client - The GraphClient instance
   * @param {string} requestUrl - The URL to create the upload session
   * @param {string} fileName - The name of a file to upload, (with extension)
   * @returns The promise that resolves to LargeFileUploadSession
   */
  static createUploadSession(client, requestUrl, fileName) {
    const _super = Object.create(null, {
      createUploadSession: { get: () => super.createUploadSession }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const payload = {
        item: {
          "@microsoft.graph.conflictBehavior": "rename",
          name: fileName
        }
      };
      try {
        return _super.createUploadSession.call(this, client, requestUrl, payload);
      } catch (err) {
        throw err;
      }
    });
  }
  /**
   * @public
   * Commits upload session to end uploading
   * @param {string} requestUrl - The URL to commit the upload session
   * @returns The promise resolves to committed response
   */
  commit(requestUrl) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const payload = {
          name: this.file.name,
          "@microsoft.graph.conflictBehavior": "rename",
          "@microsoft.graph.sourceUrl": this.uploadSession.url
        };
        return yield this.client.api(requestUrl).put(payload);
      } catch (err) {
        throw err;
      }
    });
  }
};
OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH = "/";

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/CustomAuthenticationProvider.js
var CustomAuthenticationProvider = class {
  /**
   * @public
   * @constructor
   * Creates an instance of CustomAuthenticationProvider
   * @param {AuthProviderCallback} provider - An authProvider function
   * @returns An instance of CustomAuthenticationProvider
   */
  constructor(provider) {
    this.provider = provider;
  }
  /**
   * @public
   * @async
   * To get the access token
   * @returns The promise that resolves to an access token
   */
  getAccessToken() {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        this.provider((error, accessToken) => {
          if (accessToken) {
            resolve(accessToken);
          } else {
            reject(error);
          }
        });
      });
    });
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphError.js
var GraphError = class extends Error {
  /**
   * @public
   * @constructor
   * Creates an instance of GraphError
   * @param {number} [statusCode = -1] - The status code of the error
   * @returns An instance of GraphError
   */
  constructor(statusCode = -1, message, baseError) {
    super(message || baseError && baseError.message);
    Object.setPrototypeOf(this, GraphError.prototype);
    this.statusCode = statusCode;
    this.code = null;
    this.requestId = null;
    this.date = new Date();
    this.body = null;
    this.stack = baseError ? baseError.stack : this.stack;
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphErrorHandler.js
var GraphErrorHandler = class {
  /**
   * @private
   * @static
   * Populates the GraphError instance with Error instance values
   * @param {Error} error - The error returned by graph service or some native error
   * @param {number} [statusCode] - The status code of the response
   * @returns The GraphError instance
   */
  static constructError(error, statusCode) {
    const gError = new GraphError(statusCode, "", error);
    if (error.name !== void 0) {
      gError.code = error.name;
    }
    gError.body = error.toString();
    gError.date = new Date();
    return gError;
  }
  /**
   * @private
   * @static
   * @async
   * Populates the GraphError instance from the Error returned by graph service
   * @param {any} error - The error returned by graph service or some native error
   * @param {number} statusCode - The status code of the response
   * @returns A promise that resolves to GraphError instance
   *
   * Example error for https://graph.microsoft.com/v1.0/me/events?$top=3&$search=foo
   * {
   *      "error": {
   *          "code": "SearchEvents",
   *          "message": "The parameter $search is not currently supported on the Events resource.",
   *          "innerError": {
   *              "request-id": "b31c83fd-944c-4663-aa50-5d9ceb367e19",
   *              "date": "2016-11-17T18:37:45"
   *          }
   *      }
   *  }
   */
  static constructErrorFromResponse(error, statusCode) {
    error = error.error;
    const gError = new GraphError(statusCode, error.message);
    gError.code = error.code;
    if (error.innerError !== void 0) {
      gError.requestId = error.innerError["request-id"];
      gError.date = new Date(error.innerError.date);
    }
    try {
      gError.body = JSON.stringify(error);
    } catch (error2) {
    }
    return gError;
  }
  /**
   * @public
   * @static
   * @async
   * To get the GraphError object
   * @param {any} [error = null] - The error returned by graph service or some native error
   * @param {number} [statusCode = -1] - The status code of the response
   * @param {GraphRequestCallback} [callback] - The graph request callback function
   * @returns A promise that resolves to GraphError instance
   */
  static getError(error = null, statusCode = -1, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      let gError;
      if (error && error.error) {
        gError = GraphErrorHandler.constructErrorFromResponse(error, statusCode);
      } else if (typeof Error !== "undefined" && error instanceof Error) {
        gError = GraphErrorHandler.constructError(error, statusCode);
      } else {
        gError = new GraphError(statusCode);
      }
      if (typeof callback === "function") {
        callback(gError, null);
      } else {
        return gError;
      }
    });
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/ResponseType.js
var ResponseType;
(function(ResponseType2) {
  ResponseType2["ARRAYBUFFER"] = "arraybuffer";
  ResponseType2["BLOB"] = "blob";
  ResponseType2["DOCUMENT"] = "document";
  ResponseType2["JSON"] = "json";
  ResponseType2["RAW"] = "raw";
  ResponseType2["STREAM"] = "stream";
  ResponseType2["TEXT"] = "text";
})(ResponseType || (ResponseType = {}));

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphResponseHandler.js
var DocumentType;
(function(DocumentType2) {
  DocumentType2["TEXT_HTML"] = "text/html";
  DocumentType2["TEXT_XML"] = "text/xml";
  DocumentType2["APPLICATION_XML"] = "application/xml";
  DocumentType2["APPLICATION_XHTML"] = "application/xhtml+xml";
})(DocumentType || (DocumentType = {}));
var ContentType;
(function(ContentType2) {
  ContentType2["TEXT_PLAIN"] = "text/plain";
  ContentType2["APPLICATION_JSON"] = "application/json";
})(ContentType || (ContentType = {}));
var ContentTypeRegexStr;
(function(ContentTypeRegexStr2) {
  ContentTypeRegexStr2["DOCUMENT"] = "^(text\\/(html|xml))|(application\\/(xml|xhtml\\+xml))$";
  ContentTypeRegexStr2["IMAGE"] = "^image\\/.+";
})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));
var GraphResponseHandler = class {
  /**
   * @private
   * @static
   * To parse Document response
   * @param {Response} rawResponse - The response object
   * @param {DocumentType} type - The type to which the document needs to be parsed
   * @returns A promise that resolves to a document content
   */
  static parseDocumentResponse(rawResponse, type) {
    try {
      if (typeof DOMParser !== "undefined") {
        return new Promise((resolve, reject) => {
          rawResponse.text().then((xmlString) => {
            try {
              const parser = new DOMParser();
              const xmlDoc = parser.parseFromString(xmlString, type);
              resolve(xmlDoc);
            } catch (error) {
              reject(error);
            }
          });
        });
      } else {
        return Promise.resolve(rawResponse.body);
      }
    } catch (error) {
      throw error;
    }
  }
  /**
   * @private
   * @static
   * @async
   * To convert the native Response to response content
   * @param {Response} rawResponse - The response object
   * @param {ResponseType} [responseType] - The response type value
   * @returns A promise that resolves to the converted response content
   */
  static convertResponse(rawResponse, responseType) {
    return __awaiter(this, void 0, void 0, function* () {
      if (rawResponse.status === 204) {
        return Promise.resolve();
      }
      let responseValue;
      try {
        switch (responseType) {
          case ResponseType.ARRAYBUFFER:
            responseValue = yield rawResponse.arrayBuffer();
            break;
          case ResponseType.BLOB:
            responseValue = yield rawResponse.blob();
            break;
          case ResponseType.DOCUMENT:
            responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);
            break;
          case ResponseType.JSON:
            responseValue = yield rawResponse.json();
            break;
          case ResponseType.STREAM:
            responseValue = yield Promise.resolve(rawResponse.body);
            break;
          case ResponseType.TEXT:
            responseValue = yield rawResponse.text();
            break;
          default:
            const contentType = rawResponse.headers.get("Content-type");
            if (contentType !== null) {
              const mimeType = contentType.split(";")[0];
              if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {
                responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);
              } else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {
                responseValue = rawResponse.blob();
              } else if (mimeType === ContentType.TEXT_PLAIN) {
                responseValue = yield rawResponse.text();
              } else if (mimeType === ContentType.APPLICATION_JSON) {
                responseValue = yield rawResponse.json();
              } else {
                responseValue = Promise.resolve(rawResponse.body);
              }
            } else {
              responseValue = Promise.resolve(rawResponse.body);
            }
            break;
        }
      } catch (error) {
        throw error;
      }
      return responseValue;
    });
  }
  /**
   * @public
   * @static
   * @async
   * To get the parsed response
   * @param {Response} rawResponse - The response object
   * @param {ResponseType} [responseType] - The response type value
   * @param {GraphRequestCallback} [callback] - The graph request callback function
   * @returns The parsed response
   */
  static getResponse(rawResponse, responseType, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (responseType === ResponseType.RAW) {
          return Promise.resolve(rawResponse);
        } else {
          const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);
          if (rawResponse.ok) {
            if (typeof callback === "function") {
              callback(null, response);
            } else {
              return response;
            }
          } else {
            throw response;
          }
        }
      } catch (error) {
        throw error;
      }
    });
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphRequest.js
var GraphRequest = class {
  /* tslint:enable: variable-name */
  /**
   * @public
   * @constructor
   * Creates an instance of GraphRequest
   * @param {HTTPClient} httpClient - The HTTPClient instance
   * @param {ClientOptions} config - The options for making request
   * @param {string} path - A path string
   */
  constructor(httpClient, config, path) {
    this.parsePath = (path2) => {
      if (path2.indexOf("https://") !== -1) {
        path2 = path2.replace("https://", "");
        const endOfHostStrPos = path2.indexOf("/");
        if (endOfHostStrPos !== -1) {
          this.urlComponents.host = "https://" + path2.substring(0, endOfHostStrPos);
          path2 = path2.substring(endOfHostStrPos + 1, path2.length);
        }
        const endOfVersionStrPos = path2.indexOf("/");
        if (endOfVersionStrPos !== -1) {
          this.urlComponents.version = path2.substring(0, endOfVersionStrPos);
          path2 = path2.substring(endOfVersionStrPos + 1, path2.length);
        }
      }
      if (path2.charAt(0) === "/") {
        path2 = path2.substr(1);
      }
      const queryStrPos = path2.indexOf("?");
      if (queryStrPos === -1) {
        this.urlComponents.path = path2;
      } else {
        this.urlComponents.path = path2.substr(0, queryStrPos);
        const queryParams = path2.substring(queryStrPos + 1, path2.length).split("&");
        for (const queryParam of queryParams) {
          this.parseQueryParameter(queryParam);
        }
      }
    };
    this.httpClient = httpClient;
    this.config = config;
    this.urlComponents = {
      host: this.config.baseUrl,
      version: this.config.defaultVersion,
      oDataQueryParams: {},
      otherURLQueryParams: {},
      otherURLQueryOptions: []
    };
    this._headers = {};
    this._options = {};
    this._middlewareOptions = [];
    this.parsePath(path);
  }
  /**
   * @private
   * Adds the query parameter as comma separated values
   * @param {string} propertyName - The name of a property
   * @param {string|string[]} propertyValue - The vale of a property
   * @param {IArguments} additionalProperties - The additional properties
   * @returns Nothing
   */
  addCsvQueryParameter(propertyName, propertyValue, additionalProperties) {
    this.urlComponents.oDataQueryParams[propertyName] = this.urlComponents.oDataQueryParams[propertyName] ? this.urlComponents.oDataQueryParams[propertyName] + "," : "";
    let allValues = [];
    if (additionalProperties.length > 1 && typeof propertyValue === "string") {
      allValues = Array.prototype.slice.call(additionalProperties);
    } else if (typeof propertyValue === "string") {
      allValues.push(propertyValue);
    } else {
      allValues = allValues.concat(propertyValue);
    }
    this.urlComponents.oDataQueryParams[propertyName] += allValues.join(",");
  }
  /**
   * @private
   * Builds the full url from the URLComponents to make a request
   * @returns The URL string that is qualified to make a request to graph endpoint
   */
  buildFullUrl() {
    const url = urlJoin([this.urlComponents.host, this.urlComponents.version, this.urlComponents.path]) + this.createQueryString();
    if (this.config.debugLogging) {
      console.log(url);
    }
    return url;
  }
  /**
   * @private
   * Builds the query string from the URLComponents
   * @returns The Constructed query string
   */
  createQueryString() {
    const urlComponents = this.urlComponents;
    const query = [];
    if (Object.keys(urlComponents.oDataQueryParams).length !== 0) {
      for (const property2 in urlComponents.oDataQueryParams) {
        if (urlComponents.oDataQueryParams.hasOwnProperty(property2)) {
          query.push(property2 + "=" + urlComponents.oDataQueryParams[property2]);
        }
      }
    }
    if (Object.keys(urlComponents.otherURLQueryParams).length !== 0) {
      for (const property2 in urlComponents.otherURLQueryParams) {
        if (urlComponents.otherURLQueryParams.hasOwnProperty(property2)) {
          query.push(property2 + "=" + urlComponents.otherURLQueryParams[property2]);
        }
      }
    }
    if (urlComponents.otherURLQueryOptions.length !== 0) {
      for (const str of urlComponents.otherURLQueryOptions) {
        query.push(str);
      }
    }
    return query.length > 0 ? "?" + query.join("&") : "";
  }
  /**
   * @private
   * Parses the query parameters to set the urlComponents property of the GraphRequest object
   * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query parameter
   * @returns The same GraphRequest instance that is being called with
   */
  parseQueryParameter(queryDictionaryOrString) {
    if (typeof queryDictionaryOrString === "string") {
      if (queryDictionaryOrString.charAt(0) === "?") {
        queryDictionaryOrString = queryDictionaryOrString.substring(1);
      }
      if (queryDictionaryOrString.indexOf("&") !== -1) {
        const queryParams = queryDictionaryOrString.split("&");
        for (const str of queryParams) {
          this.parseQueryParamenterString(str);
        }
      } else {
        this.parseQueryParamenterString(queryDictionaryOrString);
      }
    } else if (queryDictionaryOrString.constructor === Object) {
      for (const key in queryDictionaryOrString) {
        if (queryDictionaryOrString.hasOwnProperty(key)) {
          this.setURLComponentsQueryParamater(key, queryDictionaryOrString[key]);
        }
      }
    }
    return this;
  }
  /**
   * @private
   * Parses the query parameter of string type to set the urlComponents property of the GraphRequest object
   * @param {string} queryParameter - the query parameters
   * returns nothing
   */
  parseQueryParamenterString(queryParameter) {
    if (this.isValidQueryKeyValuePair(queryParameter)) {
      const indexOfFirstEquals = queryParameter.indexOf("=");
      const paramKey = queryParameter.substring(0, indexOfFirstEquals);
      const paramValue = queryParameter.substring(indexOfFirstEquals + 1);
      this.setURLComponentsQueryParamater(paramKey, paramValue);
    } else {
      this.urlComponents.otherURLQueryOptions.push(queryParameter);
    }
  }
  /**
   * @private
   * Sets values into the urlComponents property of GraphRequest object.
   * @param {string} paramKey - the query parameter key
   * @param {string} paramValue - the query paramter value
   * @returns nothing
   */
  setURLComponentsQueryParamater(paramKey, paramValue) {
    if (oDataQueryNames.indexOf(paramKey) !== -1) {
      const currentValue = this.urlComponents.oDataQueryParams[paramKey];
      const isValueAppendable = currentValue && (paramKey === "$expand" || paramKey === "$select" || paramKey === "$orderby");
      this.urlComponents.oDataQueryParams[paramKey] = isValueAppendable ? currentValue + "," + paramValue : paramValue;
    } else {
      this.urlComponents.otherURLQueryParams[paramKey] = paramValue;
    }
  }
  /**
   * @private
   * Check if the query parameter string has a valid key-value structure
   * @param {string} queryString - the query parameter string. Example -> "name=value"
   * #returns true if the query string has a valid key-value structure else false
   */
  isValidQueryKeyValuePair(queryString) {
    const indexofFirstEquals = queryString.indexOf("=");
    if (indexofFirstEquals === -1) {
      return false;
    }
    const indexofOpeningParanthesis = queryString.indexOf("(");
    if (indexofOpeningParanthesis !== -1 && queryString.indexOf("(") < indexofFirstEquals) {
      return false;
    }
    return true;
  }
  /**
   * @private
   * Updates the custom headers and options for a request
   * @param {FetchOptions} options - The request options object
   * @returns Nothing
   */
  updateRequestOptions(options) {
    const optionsHeaders = Object.assign({}, options.headers);
    if (this.config.fetchOptions !== void 0) {
      const fetchOptions = Object.assign({}, this.config.fetchOptions);
      Object.assign(options, fetchOptions);
      if (typeof this.config.fetchOptions.headers !== void 0) {
        options.headers = Object.assign({}, this.config.fetchOptions.headers);
      }
    }
    Object.assign(options, this._options);
    if (options.headers !== void 0) {
      Object.assign(optionsHeaders, options.headers);
    }
    Object.assign(optionsHeaders, this._headers);
    options.headers = optionsHeaders;
  }
  /**
   * @private
   * @async
   * Adds the custom headers and options to the request and makes the HTTPClient send request call
   * @param {RequestInfo} request - The request url string or the Request object value
   * @param {FetchOptions} options - The options to make a request
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the response content
   */
  send(request, options, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      let rawResponse;
      const middlewareControl = new MiddlewareControl(this._middlewareOptions);
      this.updateRequestOptions(options);
      try {
        const context = yield this.httpClient.sendRequest({
          request,
          options,
          middlewareControl
        });
        rawResponse = context.response;
        const response = yield GraphResponseHandler.getResponse(rawResponse, this._responseType, callback);
        return response;
      } catch (error) {
        let statusCode;
        if (typeof rawResponse !== "undefined") {
          statusCode = rawResponse.status;
        }
        const gError = yield GraphErrorHandler.getError(error, statusCode, callback);
        throw gError;
      }
    });
  }
  /**
   * @private
   * Checks if the content-type is present in the _headers property. If not present, defaults the content-type to application/json
   * @param none
   * @returns nothing
   */
  setHeaderContentType() {
    if (!this._headers) {
      this.header("Content-Type", "application/json");
      return;
    }
    const headerKeys = Object.keys(this._headers);
    for (const headerKey of headerKeys) {
      if (headerKey.toLowerCase() === "content-type") {
        return;
      }
    }
    this.header("Content-Type", "application/json");
  }
  /**
   * @public
   * Sets the custom header for a request
   * @param {string} headerKey - A header key
   * @param {string} headerValue - A header value
   * @returns The same GraphRequest instance that is being called with
   */
  header(headerKey, headerValue) {
    this._headers[headerKey] = headerValue;
    return this;
  }
  /**
   * @public
   * Sets the custom headers for a request
   * @param {KeyValuePairObjectStringNumber | HeadersInit} headers - The request headers
   * @returns The same GraphRequest instance that is being called with
   */
  headers(headers) {
    for (const key in headers) {
      if (headers.hasOwnProperty(key)) {
        this._headers[key] = headers[key];
      }
    }
    return this;
  }
  /**
   * @public
   * Sets the option for making a request
   * @param {string} key - The key value
   * @param {any} value - The value
   * @returns The same GraphRequest instance that is being called with
   */
  option(key, value) {
    this._options[key] = value;
    return this;
  }
  /**
   * @public
   * Sets the options for making a request
   * @param {{ [key: string]: any }} options - The options key value pair
   * @returns The same GraphRequest instance that is being called with
   */
  options(options) {
    for (const key in options) {
      if (options.hasOwnProperty(key)) {
        this._options[key] = options[key];
      }
    }
    return this;
  }
  /**
   * @public
   * Sets the middleware options for a request
   * @param {MiddlewareOptions[]} options - The array of middleware options
   * @returns The same GraphRequest instance that is being called with
   */
  middlewareOptions(options) {
    this._middlewareOptions = options;
    return this;
  }
  /**
   * @public
   * Sets the api endpoint version for a request
   * @param {string} version - The version value
   * @returns The same GraphRequest instance that is being called with
   */
  version(version2) {
    this.urlComponents.version = version2;
    return this;
  }
  /**
   * @public
   * Sets the api endpoint version for a request
   * @param {ResponseType} responseType - The response type value
   * @returns The same GraphRequest instance that is being called with
   */
  responseType(responseType) {
    this._responseType = responseType;
    return this;
  }
  /**
   * @public
   * To add properties for select OData Query param
   * @param {string|string[]} properties - The Properties value
   * @returns The same GraphRequest instance that is being called with, after adding the properties for $select query
   */
  /*
   * Accepts .select("displayName,birthday")
   *     and .select(["displayName", "birthday"])
   *     and .select("displayName", "birthday")
   *
   */
  select(properties) {
    this.addCsvQueryParameter("$select", properties, arguments);
    return this;
  }
  /**
   * @public
   * To add properties for expand OData Query param
   * @param {string|string[]} properties - The Properties value
   * @returns The same GraphRequest instance that is being called with, after adding the properties for $expand query
   */
  expand(properties) {
    this.addCsvQueryParameter("$expand", properties, arguments);
    return this;
  }
  /**
   * @public
   * To add properties for orderby OData Query param
   * @param {string|string[]} properties - The Properties value
   * @returns The same GraphRequest instance that is being called with, after adding the properties for $orderby query
   */
  orderby(properties) {
    this.addCsvQueryParameter("$orderby", properties, arguments);
    return this;
  }
  /**
   * @public
   * To add query string for filter OData Query param. The request URL accepts only one $filter Odata Query option and its value is set to the most recently passed filter query string.
   * @param {string} filterStr - The filter query string
   * @returns The same GraphRequest instance that is being called with, after adding the $filter query
   */
  filter(filterStr) {
    this.urlComponents.oDataQueryParams.$filter = filterStr;
    return this;
  }
  /**
   * @public
   * To add criterion for search OData Query param. The request URL accepts only one $search Odata Query option and its value is set to the most recently passed search criterion string.
   * @param {string} searchStr - The search criterion string
   * @returns The same GraphRequest instance that is being called with, after adding the $search query criteria
   */
  search(searchStr) {
    this.urlComponents.oDataQueryParams.$search = searchStr;
    return this;
  }
  /**
   * @public
   * To add number for top OData Query param. The request URL accepts only one $top Odata Query option and its value is set to the most recently passed number value.
   * @param {number} n - The number value
   * @returns The same GraphRequest instance that is being called with, after adding the number for $top query
   */
  top(n) {
    this.urlComponents.oDataQueryParams.$top = n;
    return this;
  }
  /**
   * @public
   * To add number for skip OData Query param. The request URL accepts only one $skip Odata Query option and its value is set to the most recently passed number value.
   * @param {number} n - The number value
   * @returns The same GraphRequest instance that is being called with, after adding the number for the $skip query
   */
  skip(n) {
    this.urlComponents.oDataQueryParams.$skip = n;
    return this;
  }
  /**
   * @public
   * To add token string for skipToken OData Query param. The request URL accepts only one $skipToken Odata Query option and its value is set to the most recently passed token value.
   * @param {string} token - The token value
   * @returns The same GraphRequest instance that is being called with, after adding the token string for $skipToken query option
   */
  skipToken(token) {
    this.urlComponents.oDataQueryParams.$skipToken = token;
    return this;
  }
  /**
   * @public
   * To add boolean for count OData Query param. The URL accepts only one $count Odata Query option and its value is set to the most recently passed boolean value.
   * @param {boolean} isCount - The count boolean
   * @returns The same GraphRequest instance that is being called with, after adding the boolean value for the $count query option
   */
  count(isCount = false) {
    this.urlComponents.oDataQueryParams.$count = isCount.toString();
    return this;
  }
  /**
   * @public
   * Appends query string to the urlComponent
   * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query value
   * @returns The same GraphRequest instance that is being called with, after appending the query string to the url component
   */
  /*
   * Accepts .query("displayName=xyz")
   *     and .select({ name: "value" })
   */
  query(queryDictionaryOrString) {
    return this.parseQueryParameter(queryDictionaryOrString);
  }
  /**
   * @public
   * @async
   * Makes a http request with GET method
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the get response
   */
  get(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.GET
      };
      try {
        const response = yield this.send(url, options, callback);
        return response;
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Makes a http request with POST method
   * @param {any} content - The content that needs to be sent with the request
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the post response
   */
  post(content, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.POST,
        body: serializeContent(content)
      };
      const className = content && content.constructor && content.constructor.name;
      if (className === "FormData") {
        options.headers = {};
      } else {
        this.setHeaderContentType();
        options.headers = this._headers;
      }
      try {
        const response = yield this.send(url, options, callback);
        return response;
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Alias for Post request call
   * @param {any} content - The content that needs to be sent with the request
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the post response
   */
  create(content, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.post(content, callback);
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Makes http request with PUT method
   * @param {any} content - The content that needs to be sent with the request
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the put response
   */
  put(content, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      this.setHeaderContentType();
      const options = {
        method: RequestMethod.PUT,
        body: serializeContent(content)
      };
      try {
        const response = yield this.send(url, options, callback);
        return response;
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Makes http request with PATCH method
   * @param {any} content - The content that needs to be sent with the request
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the patch response
   */
  patch(content, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      this.setHeaderContentType();
      const options = {
        method: RequestMethod.PATCH,
        body: serializeContent(content)
      };
      try {
        const response = yield this.send(url, options, callback);
        return response;
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Alias for PATCH request
   * @param {any} content - The content that needs to be sent with the request
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the patch response
   */
  update(content, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.patch(content, callback);
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Makes http request with DELETE method
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the delete response
   */
  delete(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.DELETE
      };
      try {
        const response = yield this.send(url, options, callback);
        return response;
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Alias for delete request call
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the delete response
   */
  del(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.delete(callback);
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Makes a http request with GET method to read response as a stream.
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the getStream response
   */
  getStream(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.GET
      };
      this.responseType(ResponseType.STREAM);
      try {
        const stream = yield this.send(url, options, callback);
        return stream;
      } catch (error) {
        throw error;
      }
    });
  }
  /**
   * @public
   * @async
   * Makes a http request with GET method to read response as a stream.
   * @param {any} stream - The stream instance
   * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
   * @returns A promise that resolves to the putStream response
   */
  putStream(stream, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.PUT,
        headers: {
          "Content-Type": "application/octet-stream"
        },
        body: stream
      };
      try {
        const response = yield this.send(url, options, callback);
        return response;
      } catch (error) {
        throw error;
      }
    });
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/HTTPClient.js
var HTTPClient = class {
  /**
   * @public
   * @constructor
   * Creates an instance of a HTTPClient
   * @param {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers
   */
  constructor(...middleware) {
    if (!middleware || !middleware.length) {
      const error = new Error();
      error.name = "InvalidMiddlewareChain";
      error.message = "Please provide a default middleware chain or custom middleware chain";
      throw error;
    }
    this.setMiddleware(...middleware);
  }
  /**
   * @private
   * Processes the middleware parameter passed to set this.middleware property
   * The calling function should validate if middleware is not undefined or not empty.
   * @param {...Middleware} middleware - The middleware passed
   * @returns Nothing
   */
  setMiddleware(...middleware) {
    if (middleware.length > 1) {
      this.parseMiddleWareArray(middleware);
    } else {
      this.middleware = middleware[0];
    }
  }
  /**
   * @private
   * Processes the middleware array to construct the chain
   * and sets this.middleware property to the first middlware handler of the array
   * The calling function should validate if middleware is not undefined or not empty
   * @param {Middleware[]} middlewareArray - The array of middleware handlers
   * @returns Nothing
   */
  parseMiddleWareArray(middlewareArray) {
    middlewareArray.forEach((element, index) => {
      if (index < middlewareArray.length - 1) {
        element.setNext(middlewareArray[index + 1]);
      }
    });
    this.middleware = middlewareArray[0];
  }
  /**
   * @public
   * @async
   * To send the request through the middleware chain
   * @param {Context} context - The context of a request
   * @returns A promise that resolves to the Context
   */
  sendRequest(context) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (typeof context.request === "string" && context.options === void 0) {
          const error = new Error();
          error.name = "InvalidRequestOptions";
          error.message = "Unable to execute the middleware, Please provide valid options for a request";
          throw error;
        }
        yield this.middleware.execute(context);
        return context;
      } catch (error) {
        throw error;
      }
    });
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/HTTPClientFactory.js
var isNodeEnvironment = () => {
  return typeof process === "object" && typeof __require === "function";
};
var HTTPClientFactory = class {
  /**
   * @public
   * @static
   * Creates HTTPClient with default middleware chain
   * @param {AuthenticationProvider} authProvider - The authentication provider instance
   * @returns A HTTPClient instance
   *
   * NOTE: These are the things that we need to remember while doing modifications in the below default pipeline.
   * 		* HTTPMessageHander should be the last one in the middleware pipeline, because this makes the actual network call of the request
   * 		* TelemetryHandler should be the one prior to the last middleware in the chain, because this is the one which actually collects and appends the usage flag and placing this handler 	*		  before making the actual network call ensures that the usage of all features are recorded in the flag.
   * 		* The best place for AuthenticationHandler is in the starting of the pipeline, because every other handler might have to work for multiple times for a request but the auth token for
   * 		  them will remain same. For example, Retry and Redirect handlers might be working multiple times for a request based on the response but their auth token would remain same.
   */
  static createWithAuthenticationProvider(authProvider) {
    const authenticationHandler = new AuthenticationHandler(authProvider);
    const retryHandler = new RetryHandler(new RetryHandlerOptions());
    const telemetryHandler = new TelemetryHandler();
    const httpMessageHandler = new HTTPMessageHandler();
    authenticationHandler.setNext(retryHandler);
    if (isNodeEnvironment()) {
      const redirectHandler = new RedirectHandler(new RedirectHandlerOptions());
      retryHandler.setNext(redirectHandler);
      redirectHandler.setNext(telemetryHandler);
    } else {
      retryHandler.setNext(telemetryHandler);
    }
    telemetryHandler.setNext(httpMessageHandler);
    return HTTPClientFactory.createWithMiddleware(authenticationHandler);
  }
  /**
   * @public
   * @static
   * Creates a middleware chain with the given one
   * @property {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers
   * @returns A HTTPClient instance
   */
  static createWithMiddleware(...middleware) {
    return new HTTPClient(...middleware);
  }
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/ValidatePolyFilling.js
var validatePolyFilling = () => {
  if (typeof Promise === "undefined" && typeof fetch === "undefined") {
    const error = new Error("Library cannot function without Promise and fetch. So, please provide polyfill for them.");
    error.name = "PolyFillNotAvailable";
    throw error;
  } else if (typeof Promise === "undefined") {
    const error = new Error("Library cannot function without Promise. So, please provide polyfill for it.");
    error.name = "PolyFillNotAvailable";
    throw error;
  } else if (typeof fetch === "undefined") {
    const error = new Error("Library cannot function without fetch. So, please provide polyfill for it.");
    error.name = "PolyFillNotAvailable";
    throw error;
  }
  return true;
};

// node_modules/@microsoft/mgt-element/node_modules/@microsoft/microsoft-graph-client/lib/es/Client.js
var Client = class {
  /**
   * @private
   * @constructor
   * Creates an instance of Client
   * @param {ClientOptions} clientOptions - The options to instantiate the client object
   */
  constructor(clientOptions) {
    this.config = {
      baseUrl: GRAPH_BASE_URL,
      debugLogging: false,
      defaultVersion: GRAPH_API_VERSION
    };
    try {
      validatePolyFilling();
    } catch (error) {
      throw error;
    }
    for (const key in clientOptions) {
      if (clientOptions.hasOwnProperty(key)) {
        this.config[key] = clientOptions[key];
      }
    }
    let httpClient;
    if (clientOptions.authProvider !== void 0 && clientOptions.middleware !== void 0) {
      const error = new Error();
      error.name = "AmbiguityInInitialization";
      error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain not both";
      throw error;
    } else if (clientOptions.authProvider !== void 0) {
      httpClient = HTTPClientFactory.createWithAuthenticationProvider(clientOptions.authProvider);
    } else if (clientOptions.middleware !== void 0) {
      httpClient = new HTTPClient(...[].concat(clientOptions.middleware));
    } else {
      const error = new Error();
      error.name = "InvalidMiddlewareChain";
      error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain";
      throw error;
    }
    this.httpClient = httpClient;
  }
  /**
   * @public
   * @static
   * To create a client instance with options and initializes the default middleware chain
   * @param {Options} options - The options for client instance
   * @returns The Client instance
   */
  static init(options) {
    const clientOptions = {};
    for (const i in options) {
      if (options.hasOwnProperty(i)) {
        clientOptions[i] = i === "authProvider" ? new CustomAuthenticationProvider(options[i]) : options[i];
      }
    }
    return Client.initWithMiddleware(clientOptions);
  }
  /**
   * @public
   * @static
   * To create a client instance with the Client Options
   * @param {ClientOptions} clientOptions - The options object for initializing the client
   * @returns The Client instance
   */
  static initWithMiddleware(clientOptions) {
    try {
      return new Client(clientOptions);
    } catch (error) {
      throw error;
    }
  }
  /**
   * @public
   * Entry point to make requests
   * @param {string} path - The path string value
   * @returns The graph request instance
   */
  api(path) {
    return new GraphRequest(this.httpClient, this.config, path);
  }
};

// node_modules/msal/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}

// node_modules/msal/lib-es6/utils/CryptoUtils.js
var CryptoUtils = (
  /** @class */
  function() {
    function CryptoUtils2() {
    }
    CryptoUtils2.createNewGuid = function() {
      var cryptoObj = window.crypto;
      if (cryptoObj && cryptoObj.getRandomValues) {
        var buffer = new Uint8Array(16);
        cryptoObj.getRandomValues(buffer);
        buffer[6] |= 64;
        buffer[6] &= 79;
        buffer[8] |= 128;
        buffer[8] &= 191;
        return CryptoUtils2.decimalToHex(buffer[0]) + CryptoUtils2.decimalToHex(buffer[1]) + CryptoUtils2.decimalToHex(buffer[2]) + CryptoUtils2.decimalToHex(buffer[3]) + "-" + CryptoUtils2.decimalToHex(buffer[4]) + CryptoUtils2.decimalToHex(buffer[5]) + "-" + CryptoUtils2.decimalToHex(buffer[6]) + CryptoUtils2.decimalToHex(buffer[7]) + "-" + CryptoUtils2.decimalToHex(buffer[8]) + CryptoUtils2.decimalToHex(buffer[9]) + "-" + CryptoUtils2.decimalToHex(buffer[10]) + CryptoUtils2.decimalToHex(buffer[11]) + CryptoUtils2.decimalToHex(buffer[12]) + CryptoUtils2.decimalToHex(buffer[13]) + CryptoUtils2.decimalToHex(buffer[14]) + CryptoUtils2.decimalToHex(buffer[15]);
      } else {
        var guidHolder = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
        var hex = "0123456789abcdef";
        var r = 0;
        var guidResponse = "";
        for (var i = 0; i < 36; i++) {
          if (guidHolder[i] !== "-" && guidHolder[i] !== "4") {
            r = Math.random() * 16 | 0;
          }
          if (guidHolder[i] === "x") {
            guidResponse += hex[r];
          } else if (guidHolder[i] === "y") {
            r &= 3;
            r |= 8;
            guidResponse += hex[r];
          } else {
            guidResponse += guidHolder[i];
          }
        }
        return guidResponse;
      }
    };
    CryptoUtils2.isGuid = function(guid) {
      var regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      return regexGuid.test(guid);
    };
    CryptoUtils2.decimalToHex = function(num) {
      var hex = num.toString(16);
      while (hex.length < 2) {
        hex = "0" + hex;
      }
      return hex;
    };
    CryptoUtils2.base64Encode = function(input) {
      return btoa(encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {
        return String.fromCharCode(Number("0x" + p1));
      }));
    };
    CryptoUtils2.base64Decode = function(input) {
      var encodedString = input.replace(/-/g, "+").replace(/_/g, "/");
      switch (encodedString.length % 4) {
        case 0:
          break;
        case 2:
          encodedString += "==";
          break;
        case 3:
          encodedString += "=";
          break;
        default:
          throw new Error("Invalid base64 string");
      }
      return decodeURIComponent(atob(encodedString).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(""));
    };
    CryptoUtils2.deserialize = function(query) {
      var match;
      var pl = /\+/g;
      var search = /([^&=]+)=([^&]*)/g;
      var decode = function(s) {
        return decodeURIComponent(s.replace(pl, " "));
      };
      var obj = {};
      match = search.exec(query);
      while (match) {
        obj[decode(match[1])] = decode(match[2]);
        match = search.exec(query);
      }
      return obj;
    };
    return CryptoUtils2;
  }()
);

// node_modules/msal/lib-es6/utils/Constants.js
var Constants = (
  /** @class */
  function() {
    function Constants2() {
    }
    Object.defineProperty(Constants2, "libraryName", {
      get: function() {
        return "Msal.js";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "claims", {
      get: function() {
        return "claims";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "clientId", {
      get: function() {
        return "clientId";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "adalIdToken", {
      get: function() {
        return "adal.idtoken";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "cachePrefix", {
      get: function() {
        return "msal";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "scopes", {
      get: function() {
        return "scopes";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "no_account", {
      get: function() {
        return "NO_ACCOUNT";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "upn", {
      get: function() {
        return "upn";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "domain_hint", {
      get: function() {
        return "domain_hint";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "prompt_select_account", {
      get: function() {
        return "&prompt=select_account";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "prompt_none", {
      get: function() {
        return "&prompt=none";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "prompt", {
      get: function() {
        return "prompt";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "response_mode_fragment", {
      get: function() {
        return "&response_mode=fragment";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "resourceDelimiter", {
      get: function() {
        return "|";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "cacheDelimiter", {
      get: function() {
        return ".";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "popUpWidth", {
      get: function() {
        return this._popUpWidth;
      },
      set: function(width) {
        this._popUpWidth = width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "popUpHeight", {
      get: function() {
        return this._popUpHeight;
      },
      set: function(height) {
        this._popUpHeight = height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "login", {
      get: function() {
        return "LOGIN";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "renewToken", {
      get: function() {
        return "RENEW_TOKEN";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "unknown", {
      get: function() {
        return "UNKNOWN";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "ADFS", {
      get: function() {
        return "adfs";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "homeAccountIdentifier", {
      get: function() {
        return "homeAccountIdentifier";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "common", {
      get: function() {
        return "common";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "openidScope", {
      get: function() {
        return "openid";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "profileScope", {
      get: function() {
        return "profile";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "oidcScopes", {
      get: function() {
        return [this.openidScope, this.profileScope];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "interactionTypeRedirect", {
      get: function() {
        return "redirectInteraction";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "interactionTypePopup", {
      get: function() {
        return "popupInteraction";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "interactionTypeSilent", {
      get: function() {
        return "silentInteraction";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Constants2, "inProgress", {
      get: function() {
        return "inProgress";
      },
      enumerable: false,
      configurable: true
    });
    Constants2._popUpWidth = 483;
    Constants2._popUpHeight = 600;
    return Constants2;
  }()
);
var SESSION_STORAGE = "sessionStorage";
var ServerHashParamKeys;
(function(ServerHashParamKeys2) {
  ServerHashParamKeys2["SCOPE"] = "scope";
  ServerHashParamKeys2["STATE"] = "state";
  ServerHashParamKeys2["ERROR"] = "error";
  ServerHashParamKeys2["ERROR_DESCRIPTION"] = "error_description";
  ServerHashParamKeys2["ACCESS_TOKEN"] = "access_token";
  ServerHashParamKeys2["ID_TOKEN"] = "id_token";
  ServerHashParamKeys2["EXPIRES_IN"] = "expires_in";
  ServerHashParamKeys2["SESSION_STATE"] = "session_state";
  ServerHashParamKeys2["CLIENT_INFO"] = "client_info";
})(ServerHashParamKeys || (ServerHashParamKeys = {}));
var ResponseTypes = {
  id_token: "id_token",
  token: "token",
  id_token_token: "id_token token"
};
var TemporaryCacheKeys;
(function(TemporaryCacheKeys2) {
  TemporaryCacheKeys2["AUTHORITY"] = "authority";
  TemporaryCacheKeys2["ACQUIRE_TOKEN_ACCOUNT"] = "acquireTokenAccount";
  TemporaryCacheKeys2["SESSION_STATE"] = "session.state";
  TemporaryCacheKeys2["STATE_LOGIN"] = "state.login";
  TemporaryCacheKeys2["STATE_ACQ_TOKEN"] = "state.acquireToken";
  TemporaryCacheKeys2["STATE_RENEW"] = "state.renew";
  TemporaryCacheKeys2["NONCE_IDTOKEN"] = "nonce.idtoken";
  TemporaryCacheKeys2["LOGIN_REQUEST"] = "login.request";
  TemporaryCacheKeys2["RENEW_STATUS"] = "token.renew.status";
  TemporaryCacheKeys2["URL_HASH"] = "urlHash";
  TemporaryCacheKeys2["INTERACTION_STATUS"] = "interaction.status";
  TemporaryCacheKeys2["REDIRECT_REQUEST"] = "redirect_request";
})(TemporaryCacheKeys || (TemporaryCacheKeys = {}));
var PersistentCacheKeys;
(function(PersistentCacheKeys2) {
  PersistentCacheKeys2["IDTOKEN"] = "idtoken";
  PersistentCacheKeys2["CLIENT_INFO"] = "client.info";
})(PersistentCacheKeys || (PersistentCacheKeys = {}));
var ErrorCacheKeys;
(function(ErrorCacheKeys2) {
  ErrorCacheKeys2["LOGIN_ERROR"] = "login.error";
  ErrorCacheKeys2["ERROR"] = "error";
  ErrorCacheKeys2["ERROR_DESC"] = "error.description";
})(ErrorCacheKeys || (ErrorCacheKeys = {}));
var DEFAULT_AUTHORITY = "https://login.microsoftonline.com/common/";
var AAD_INSTANCE_DISCOVERY_ENDPOINT = DEFAULT_AUTHORITY + "/discovery/instance?api-version=1.1&authorization_endpoint=";
var WELL_KNOWN_SUFFIX = ".well-known/openid-configuration";
var SSOTypes;
(function(SSOTypes2) {
  SSOTypes2["ACCOUNT"] = "account";
  SSOTypes2["SID"] = "sid";
  SSOTypes2["LOGIN_HINT"] = "login_hint";
  SSOTypes2["ORGANIZATIONS"] = "organizations";
  SSOTypes2["CONSUMERS"] = "consumers";
  SSOTypes2["ID_TOKEN"] = "id_token";
  SSOTypes2["ACCOUNT_ID"] = "accountIdentifier";
  SSOTypes2["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
})(SSOTypes || (SSOTypes = {}));
var BlacklistedEQParams = [
  SSOTypes.SID,
  SSOTypes.LOGIN_HINT
];
var NetworkRequestType = {
  GET: "GET",
  POST: "POST"
};
var PromptState = {
  LOGIN: "login",
  SELECT_ACCOUNT: "select_account",
  CONSENT: "consent",
  NONE: "none"
};
var FramePrefix = {
  ID_TOKEN_FRAME: "msalIdTokenFrame",
  TOKEN_FRAME: "msalRenewFrame"
};

// node_modules/msal/lib-es6/error/AuthError.js
var AuthErrorMessage = {
  unexpectedError: {
    code: "unexpected_error",
    desc: "Unexpected error in authentication."
  },
  noWindowObjectError: {
    code: "no_window_object",
    desc: "No window object available. Details:"
  }
};
var AuthError = (
  /** @class */
  function(_super) {
    __extends(AuthError2, _super);
    function AuthError2(errorCode, errorMessage) {
      var _this = _super.call(this, errorMessage) || this;
      Object.setPrototypeOf(_this, AuthError2.prototype);
      _this.errorCode = errorCode;
      _this.errorMessage = errorMessage;
      _this.name = "AuthError";
      return _this;
    }
    AuthError2.createUnexpectedError = function(errDesc) {
      return new AuthError2(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
    };
    AuthError2.createNoWindowObjectError = function(errDesc) {
      return new AuthError2(AuthErrorMessage.noWindowObjectError.code, AuthErrorMessage.noWindowObjectError.desc + " " + errDesc);
    };
    return AuthError2;
  }(Error)
);

// node_modules/msal/lib-es6/utils/StringUtils.js
var StringUtils = (
  /** @class */
  function() {
    function StringUtils2() {
    }
    StringUtils2.isEmpty = function(str) {
      return typeof str === "undefined" || !str || 0 === str.length;
    };
    StringUtils2.validateAndParseJsonCacheKey = function(str) {
      try {
        var parsedKey = JSON.parse(str);
        return parsedKey && typeof parsedKey === "object" ? parsedKey : null;
      } catch (error) {
        return null;
      }
    };
    return StringUtils2;
  }()
);

// node_modules/msal/lib-es6/error/ClientAuthError.js
var ClientAuthErrorMessage = {
  endpointResolutionError: {
    code: "endpoints_resolution_error",
    desc: "Error: could not resolve endpoints. Please check network and try again."
  },
  popUpWindowError: {
    code: "popup_window_error",
    desc: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser."
  },
  tokenRenewalError: {
    code: "token_renewal_error",
    desc: "Token renewal operation failed due to timeout."
  },
  invalidIdToken: {
    code: "invalid_id_token",
    desc: "Invalid ID token format."
  },
  invalidStateError: {
    code: "invalid_state_error",
    desc: "Invalid state."
  },
  nonceMismatchError: {
    code: "nonce_mismatch_error",
    desc: "Nonce is not matching, Nonce received: "
  },
  loginProgressError: {
    code: "login_progress_error",
    desc: "Login_In_Progress: Error during login call - login is already in progress."
  },
  acquireTokenProgressError: {
    code: "acquiretoken_progress_error",
    desc: "AcquireToken_In_Progress: Error during login call - login is already in progress."
  },
  userCancelledError: {
    code: "user_cancelled",
    desc: "User cancelled the flow."
  },
  callbackError: {
    code: "callback_error",
    desc: "Error occurred in token received callback function."
  },
  userLoginRequiredError: {
    code: "user_login_error",
    desc: "User login is required. For silent calls, request must contain either sid or login_hint"
  },
  userDoesNotExistError: {
    code: "user_non_existent",
    desc: "User object does not exist. Please call a login API."
  },
  clientInfoDecodingError: {
    code: "client_info_decoding_error",
    desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
  },
  clientInfoNotPopulatedError: {
    code: "client_info_not_populated_error",
    desc: "The service did not populate client_info in the response, Please verify with the service team"
  },
  nullOrEmptyIdToken: {
    code: "null_or_empty_id_token",
    desc: "The idToken is null or empty. Please review the trace to determine the root cause."
  },
  idTokenNotParsed: {
    code: "id_token_parsing_error",
    desc: "ID token cannot be parsed. Please review stack trace to determine root cause."
  },
  tokenEncodingError: {
    code: "token_encoding_error",
    desc: "The token to be decoded is not encoded correctly."
  },
  invalidInteractionType: {
    code: "invalid_interaction_type",
    desc: "The interaction type passed to the handler was incorrect or unknown"
  },
  cacheParseError: {
    code: "cannot_parse_cache",
    desc: "The cached token key is not a valid JSON and cannot be parsed"
  },
  blockTokenRequestsInHiddenIframe: {
    code: "block_token_requests",
    desc: "Token calls are blocked in hidden iframes"
  }
};
var ClientAuthError = (
  /** @class */
  function(_super) {
    __extends(ClientAuthError2, _super);
    function ClientAuthError2(errorCode, errorMessage) {
      var _this = _super.call(this, errorCode, errorMessage) || this;
      _this.name = "ClientAuthError";
      Object.setPrototypeOf(_this, ClientAuthError2.prototype);
      return _this;
    }
    ClientAuthError2.createEndpointResolutionError = function(errDetail) {
      var errorMessage = ClientAuthErrorMessage.endpointResolutionError.desc;
      if (errDetail && !StringUtils.isEmpty(errDetail)) {
        errorMessage += " Details: " + errDetail;
      }
      return new ClientAuthError2(ClientAuthErrorMessage.endpointResolutionError.code, errorMessage);
    };
    ClientAuthError2.createPopupWindowError = function(errDetail) {
      var errorMessage = ClientAuthErrorMessage.popUpWindowError.desc;
      if (errDetail && !StringUtils.isEmpty(errDetail)) {
        errorMessage += " Details: " + errDetail;
      }
      return new ClientAuthError2(ClientAuthErrorMessage.popUpWindowError.code, errorMessage);
    };
    ClientAuthError2.createTokenRenewalTimeoutError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.tokenRenewalError.code, ClientAuthErrorMessage.tokenRenewalError.desc);
    };
    ClientAuthError2.createInvalidIdTokenError = function(idToken) {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidIdToken.code, ClientAuthErrorMessage.invalidIdToken.desc + " Given token: " + idToken);
    };
    ClientAuthError2.createInvalidStateError = function(invalidState, actualState) {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " " + invalidState + ", state expected : " + actualState + ".");
    };
    ClientAuthError2.createNonceMismatchError = function(invalidNonce, actualNonce) {
      return new ClientAuthError2(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc + " " + invalidNonce + ", nonce expected : " + actualNonce + ".");
    };
    ClientAuthError2.createLoginInProgressError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.loginProgressError.code, ClientAuthErrorMessage.loginProgressError.desc);
    };
    ClientAuthError2.createAcquireTokenInProgressError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.acquireTokenProgressError.code, ClientAuthErrorMessage.acquireTokenProgressError.desc);
    };
    ClientAuthError2.createUserCancelledError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.userCancelledError.code, ClientAuthErrorMessage.userCancelledError.desc);
    };
    ClientAuthError2.createErrorInCallbackFunction = function(errorDesc) {
      return new ClientAuthError2(ClientAuthErrorMessage.callbackError.code, ClientAuthErrorMessage.callbackError.desc + " " + errorDesc + ".");
    };
    ClientAuthError2.createUserLoginRequiredError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.userLoginRequiredError.code, ClientAuthErrorMessage.userLoginRequiredError.desc);
    };
    ClientAuthError2.createUserDoesNotExistError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.userDoesNotExistError.code, ClientAuthErrorMessage.userDoesNotExistError.desc);
    };
    ClientAuthError2.createClientInfoDecodingError = function(caughtError) {
      return new ClientAuthError2(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
    };
    ClientAuthError2.createClientInfoNotPopulatedError = function(caughtError) {
      return new ClientAuthError2(ClientAuthErrorMessage.clientInfoNotPopulatedError.code, ClientAuthErrorMessage.clientInfoNotPopulatedError.desc + " Failed with error: " + caughtError);
    };
    ClientAuthError2.createIdTokenNullOrEmptyError = function(invalidRawTokenString) {
      return new ClientAuthError2(ClientAuthErrorMessage.nullOrEmptyIdToken.code, ClientAuthErrorMessage.nullOrEmptyIdToken.desc + " Raw ID Token Value: " + invalidRawTokenString);
    };
    ClientAuthError2.createIdTokenParsingError = function(caughtParsingError) {
      return new ClientAuthError2(ClientAuthErrorMessage.idTokenNotParsed.code, ClientAuthErrorMessage.idTokenNotParsed.desc + " Failed with error: " + caughtParsingError);
    };
    ClientAuthError2.createTokenEncodingError = function(incorrectlyEncodedToken) {
      return new ClientAuthError2(ClientAuthErrorMessage.tokenEncodingError.code, ClientAuthErrorMessage.tokenEncodingError.desc + " Attempted to decode: " + incorrectlyEncodedToken);
    };
    ClientAuthError2.createInvalidInteractionTypeError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidInteractionType.code, ClientAuthErrorMessage.invalidInteractionType.desc);
    };
    ClientAuthError2.createCacheParseError = function(key) {
      var errorMessage = "invalid key: " + key + ", " + ClientAuthErrorMessage.cacheParseError.desc;
      return new ClientAuthError2(ClientAuthErrorMessage.cacheParseError.code, errorMessage);
    };
    ClientAuthError2.createBlockTokenRequestsInHiddenIframeError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.blockTokenRequestsInHiddenIframe.code, ClientAuthErrorMessage.blockTokenRequestsInHiddenIframe.desc);
    };
    return ClientAuthError2;
  }(AuthError)
);

// node_modules/msal/lib-es6/error/ClientConfigurationError.js
var ClientConfigurationErrorMessage = {
  configurationNotSet: {
    code: "no_config_set",
    desc: "Configuration has not been set. Please call the UserAgentApplication constructor with a valid Configuration object."
  },
  storageNotSupported: {
    code: "storage_not_supported",
    desc: "The value for the cacheLocation is not supported."
  },
  noRedirectCallbacksSet: {
    code: "no_redirect_callbacks",
    desc: "No redirect callbacks have been set. Please call handleRedirectCallback() with the appropriate function arguments before continuing. More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
  },
  invalidCallbackObject: {
    code: "invalid_callback_object",
    desc: "The object passed for the callback was invalid. More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
  },
  scopesRequired: {
    code: "scopes_required",
    desc: "Scopes are required to obtain an access token."
  },
  emptyScopes: {
    code: "empty_input_scopes_error",
    desc: "Scopes cannot be passed as empty array."
  },
  nonArrayScopes: {
    code: "nonarray_input_scopes_error",
    desc: "Scopes cannot be passed as non-array."
  },
  invalidPrompt: {
    code: "invalid_prompt_value",
    desc: "Supported prompt values are 'login', 'select_account', 'consent' and 'none'"
  },
  invalidAuthorityType: {
    code: "invalid_authority_type",
    desc: "The given authority is not a valid type of authority supported by MSAL. Please see here for valid authorities: <insert URL here>."
  },
  authorityUriInsecure: {
    code: "authority_uri_insecure",
    desc: "Authority URIs must use https."
  },
  authorityUriInvalidPath: {
    code: "authority_uri_invalid_path",
    desc: "Given authority URI is invalid."
  },
  unsupportedAuthorityValidation: {
    code: "unsupported_authority_validation",
    desc: "The authority validation is not supported for this authority type."
  },
  untrustedAuthority: {
    code: "untrusted_authority",
    desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter or set validateAuthority=false."
  },
  b2cAuthorityUriInvalidPath: {
    code: "b2c_authority_uri_invalid_path",
    desc: "The given URI for the B2C authority is invalid."
  },
  b2cKnownAuthoritiesNotSet: {
    code: "b2c_known_authorities_not_set",
    desc: "Must set known authorities when validateAuthority is set to True and using B2C"
  },
  claimsRequestParsingError: {
    code: "claims_request_parsing_error",
    desc: "Could not parse the given claims request object."
  },
  emptyRequestError: {
    code: "empty_request_error",
    desc: "Request object is required."
  },
  invalidCorrelationIdError: {
    code: "invalid_guid_sent_as_correlationId",
    desc: "Please set the correlationId as a valid guid"
  },
  telemetryConfigError: {
    code: "telemetry_config_error",
    desc: "Telemetry config is not configured with required values"
  },
  ssoSilentError: {
    code: "sso_silent_error",
    desc: "request must contain either sid or login_hint"
  },
  invalidAuthorityMetadataError: {
    code: "authority_metadata_error",
    desc: "Invalid authorityMetadata. Must be a JSON object containing authorization_endpoint, end_session_endpoint, and issuer fields."
  }
};
var ClientConfigurationError = (
  /** @class */
  function(_super) {
    __extends(ClientConfigurationError2, _super);
    function ClientConfigurationError2(errorCode, errorMessage) {
      var _this = _super.call(this, errorCode, errorMessage) || this;
      _this.name = "ClientConfigurationError";
      Object.setPrototypeOf(_this, ClientConfigurationError2.prototype);
      return _this;
    }
    ClientConfigurationError2.createNoSetConfigurationError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.configurationNotSet.code, "" + ClientConfigurationErrorMessage.configurationNotSet.desc);
    };
    ClientConfigurationError2.createStorageNotSupportedError = function(givenCacheLocation) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.storageNotSupported.code, ClientConfigurationErrorMessage.storageNotSupported.desc + " Given location: " + givenCacheLocation);
    };
    ClientConfigurationError2.createRedirectCallbacksNotSetError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.noRedirectCallbacksSet.code, ClientConfigurationErrorMessage.noRedirectCallbacksSet.desc);
    };
    ClientConfigurationError2.createInvalidCallbackObjectError = function(callbackObject) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCallbackObject.code, ClientConfigurationErrorMessage.invalidCallbackObject.desc + " Given value for callback function: " + callbackObject);
    };
    ClientConfigurationError2.createEmptyScopesArrayError = function(scopesValue) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.emptyScopes.code, ClientConfigurationErrorMessage.emptyScopes.desc + " Given value: " + scopesValue + ".");
    };
    ClientConfigurationError2.createScopesNonArrayError = function(scopesValue) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.nonArrayScopes.code, ClientConfigurationErrorMessage.nonArrayScopes.desc + " Given value: " + scopesValue + ".");
    };
    ClientConfigurationError2.createScopesRequiredError = function(scopesValue) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.scopesRequired.code, ClientConfigurationErrorMessage.scopesRequired.desc + " Given value: " + scopesValue);
    };
    ClientConfigurationError2.createInvalidPromptError = function(promptValue) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
    };
    ClientConfigurationError2.createClaimsRequestParsingError = function(claimsRequestParseError) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
    };
    ClientConfigurationError2.createEmptyRequestError = function() {
      var _a3 = ClientConfigurationErrorMessage.emptyRequestError, code = _a3.code, desc = _a3.desc;
      return new ClientConfigurationError2(code, desc);
    };
    ClientConfigurationError2.createInvalidCorrelationIdError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCorrelationIdError.code, ClientConfigurationErrorMessage.invalidCorrelationIdError.desc);
    };
    ClientConfigurationError2.createKnownAuthoritiesNotSetError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.b2cKnownAuthoritiesNotSet.code, ClientConfigurationErrorMessage.b2cKnownAuthoritiesNotSet.desc);
    };
    ClientConfigurationError2.createInvalidAuthorityTypeError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthorityType.code, ClientConfigurationErrorMessage.invalidAuthorityType.desc);
    };
    ClientConfigurationError2.createUntrustedAuthorityError = function(host) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc + " Provided Authority: " + host);
    };
    ClientConfigurationError2.createTelemetryConfigError = function(config) {
      var _a3 = ClientConfigurationErrorMessage.telemetryConfigError, code = _a3.code, desc = _a3.desc;
      var requiredKeys = {
        applicationName: "string",
        applicationVersion: "string",
        telemetryEmitter: "function"
      };
      var missingKeys = Object.keys(requiredKeys).reduce(function(keys, key) {
        return config[key] ? keys : keys.concat([key + " (" + requiredKeys[key] + ")"]);
      }, []);
      return new ClientConfigurationError2(code, desc + " mising values: " + missingKeys.join(","));
    };
    ClientConfigurationError2.createSsoSilentError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.ssoSilentError.code, ClientConfigurationErrorMessage.ssoSilentError.desc);
    };
    ClientConfigurationError2.createInvalidAuthorityMetadataError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthorityMetadataError.code, ClientConfigurationErrorMessage.invalidAuthorityMetadataError.desc);
    };
    return ClientConfigurationError2;
  }(ClientAuthError)
);

// node_modules/msal/lib-es6/ScopeSet.js
var ScopeSet = (
  /** @class */
  function() {
    function ScopeSet2() {
    }
    ScopeSet2.isIntersectingScopes = function(cachedScopes, scopes) {
      var convertedCachedScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(cachedScopes));
      var requestScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(scopes));
      for (var i = 0; i < requestScopes.length; i++) {
        if (convertedCachedScopes.indexOf(requestScopes[i].toLowerCase()) > -1) {
          return true;
        }
      }
      return false;
    };
    ScopeSet2.containsScope = function(cachedScopes, scopes) {
      var convertedCachedScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(cachedScopes));
      var requestScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(scopes));
      return requestScopes.every(function(value) {
        return convertedCachedScopes.indexOf(value.toString().toLowerCase()) >= 0;
      });
    };
    ScopeSet2.trimAndConvertToLowerCase = function(scope) {
      return scope.trim().toLowerCase();
    };
    ScopeSet2.trimAndConvertArrayToLowerCase = function(scopes) {
      var _this = this;
      return scopes.map(function(scope) {
        return _this.trimAndConvertToLowerCase(scope);
      });
    };
    ScopeSet2.trimScopes = function(scopes) {
      return scopes.map(function(scope) {
        return scope.trim();
      });
    };
    ScopeSet2.removeElement = function(scopes, scope) {
      var scopeVal = this.trimAndConvertToLowerCase(scope);
      return scopes.filter(function(value) {
        return value !== scopeVal;
      });
    };
    ScopeSet2.parseScope = function(scopes) {
      var scopeList = "";
      if (scopes) {
        for (var i = 0; i < scopes.length; ++i) {
          scopeList += i !== scopes.length - 1 ? scopes[i] + " " : scopes[i];
        }
      }
      return scopeList;
    };
    ScopeSet2.validateInputScope = function(scopes, scopesRequired) {
      if (!scopes) {
        if (scopesRequired) {
          throw ClientConfigurationError.createScopesRequiredError(scopes);
        } else {
          return;
        }
      }
      if (!Array.isArray(scopes)) {
        throw ClientConfigurationError.createScopesNonArrayError(scopes);
      }
      if (scopes.length < 1 && scopesRequired) {
        throw ClientConfigurationError.createEmptyScopesArrayError(scopes.toString());
      }
    };
    ScopeSet2.getScopeFromState = function(state2) {
      if (state2) {
        var splitIndex = state2.indexOf(Constants.resourceDelimiter);
        if (splitIndex > -1 && splitIndex + 1 < state2.length) {
          return state2.substring(splitIndex + 1);
        }
      }
      return "";
    };
    ScopeSet2.appendScopes = function(reqScopes, reqExtraScopesToConsent) {
      if (reqScopes) {
        var convertedExtraScopes = reqExtraScopesToConsent ? this.trimAndConvertArrayToLowerCase(__spreadArrays(reqExtraScopesToConsent)) : null;
        var convertedReqScopes = this.trimAndConvertArrayToLowerCase(__spreadArrays(reqScopes));
        return convertedExtraScopes ? __spreadArrays(convertedReqScopes, convertedExtraScopes) : convertedReqScopes;
      }
      return null;
    };
    ScopeSet2.onlyContainsOidcScopes = function(scopes) {
      var scopesCount = scopes.length;
      var oidcScopesFound = 0;
      if (scopes.indexOf(Constants.openidScope) > -1) {
        oidcScopesFound += 1;
      }
      if (scopes.indexOf(Constants.profileScope) > -1) {
        oidcScopesFound += 1;
      }
      return scopesCount > 0 && scopesCount === oidcScopesFound;
    };
    ScopeSet2.containsAnyOidcScopes = function(scopes) {
      var containsOpenIdScope = scopes.indexOf(Constants.openidScope) > -1;
      var containsProfileScope = scopes.indexOf(Constants.profileScope) > -1;
      return containsOpenIdScope || containsProfileScope;
    };
    ScopeSet2.onlyContainsClientId = function(scopes, clientId) {
      return !!scopes && (scopes.indexOf(clientId) > -1 && scopes.length === 1);
    };
    ScopeSet2.appendDefaultScopes = function(scopes) {
      var extendedScopes = scopes;
      if (extendedScopes.indexOf(Constants.openidScope) === -1) {
        extendedScopes.push(Constants.openidScope);
      }
      if (extendedScopes.indexOf(Constants.profileScope) === -1) {
        extendedScopes.push(Constants.profileScope);
      }
      return extendedScopes;
    };
    ScopeSet2.removeDefaultScopes = function(scopes) {
      return scopes.filter(function(scope) {
        return scope !== Constants.openidScope && scope !== Constants.profileScope;
      });
    };
    ScopeSet2.translateClientIdIfSingleScope = function(scopes, clientId) {
      return this.onlyContainsClientId(scopes, clientId) ? Constants.oidcScopes : scopes;
    };
    return ScopeSet2;
  }()
);

// node_modules/msal/lib-es6/utils/UrlUtils.js
var UrlUtils = (
  /** @class */
  function() {
    function UrlUtils2() {
    }
    UrlUtils2.createNavigateUrl = function(serverRequestParams) {
      var str = this.createNavigationUrlString(serverRequestParams);
      var authEndpoint = serverRequestParams.authorityInstance.AuthorizationEndpoint;
      if (authEndpoint.indexOf("?") < 0) {
        authEndpoint += "?";
      } else {
        authEndpoint += "&";
      }
      var requestUrl = "" + authEndpoint + str.join("&");
      return requestUrl;
    };
    UrlUtils2.createNavigationUrlString = function(serverRequestParams) {
      var scopes = ScopeSet.appendDefaultScopes(serverRequestParams.scopes);
      var str = [];
      str.push("response_type=" + serverRequestParams.responseType);
      str.push("scope=" + encodeURIComponent(ScopeSet.parseScope(scopes)));
      str.push("client_id=" + encodeURIComponent(serverRequestParams.clientId));
      str.push("redirect_uri=" + encodeURIComponent(serverRequestParams.redirectUri));
      str.push("state=" + encodeURIComponent(serverRequestParams.state));
      str.push("nonce=" + encodeURIComponent(serverRequestParams.nonce));
      str.push("client_info=1");
      str.push("x-client-SKU=" + serverRequestParams.xClientSku);
      str.push("x-client-Ver=" + serverRequestParams.xClientVer);
      if (serverRequestParams.promptValue) {
        str.push("prompt=" + encodeURIComponent(serverRequestParams.promptValue));
      }
      if (serverRequestParams.claimsValue) {
        str.push("claims=" + encodeURIComponent(serverRequestParams.claimsValue));
      }
      if (serverRequestParams.queryParameters) {
        str.push(serverRequestParams.queryParameters);
      }
      if (serverRequestParams.extraQueryParameters) {
        str.push(serverRequestParams.extraQueryParameters);
      }
      str.push("client-request-id=" + encodeURIComponent(serverRequestParams.correlationId));
      return str;
    };
    UrlUtils2.getCurrentUrl = function() {
      return window.location.href.split("?")[0].split("#")[0];
    };
    UrlUtils2.removeHashFromUrl = function(url) {
      return url.split("#")[0];
    };
    UrlUtils2.replaceTenantPath = function(url, tenantId) {
      var lowerCaseUrl = url.toLowerCase();
      var urlObject = this.GetUrlComponents(lowerCaseUrl);
      var pathArray = urlObject.PathSegments;
      if (tenantId && (pathArray.length !== 0 && (pathArray[0] === Constants.common || pathArray[0] === SSOTypes.ORGANIZATIONS || pathArray[0] === SSOTypes.CONSUMERS))) {
        pathArray[0] = tenantId;
      }
      return this.constructAuthorityUriFromObject(urlObject, pathArray);
    };
    UrlUtils2.constructAuthorityUriFromObject = function(urlObject, pathArray) {
      return this.CanonicalizeUri(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + pathArray.join("/"));
    };
    UrlUtils2.isCommonAuthority = function(url) {
      var authority = this.CanonicalizeUri(url);
      var pathArray = this.GetUrlComponents(authority).PathSegments;
      return pathArray.length !== 0 && pathArray[0] === Constants.common;
    };
    UrlUtils2.isOrganizationsAuthority = function(url) {
      var authority = this.CanonicalizeUri(url);
      var pathArray = this.GetUrlComponents(authority).PathSegments;
      return pathArray.length !== 0 && pathArray[0] === SSOTypes.ORGANIZATIONS;
    };
    UrlUtils2.isConsumersAuthority = function(url) {
      var authority = this.CanonicalizeUri(url);
      var pathArray = this.GetUrlComponents(authority).PathSegments;
      return pathArray.length !== 0 && pathArray[0] === SSOTypes.CONSUMERS;
    };
    UrlUtils2.GetUrlComponents = function(url) {
      if (!url) {
        throw "Url required";
      }
      var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
      var match = url.match(regEx);
      if (!match || match.length < 6) {
        throw "Valid url required";
      }
      var urlComponents = {
        Protocol: match[1],
        HostNameAndPort: match[4],
        AbsolutePath: match[5]
      };
      var pathSegments = urlComponents.AbsolutePath.split("/");
      pathSegments = pathSegments.filter(function(val) {
        return val && val.length > 0;
      });
      urlComponents.PathSegments = pathSegments;
      if (match[6]) {
        urlComponents.Search = match[6];
      }
      if (match[8]) {
        urlComponents.Hash = match[8];
      }
      return urlComponents;
    };
    UrlUtils2.CanonicalizeUri = function(url) {
      if (url) {
        var lowerCaseUrl = url.toLowerCase();
        if (!UrlUtils2.endsWith(lowerCaseUrl, "/")) {
          lowerCaseUrl += "/";
        }
        return lowerCaseUrl;
      }
      return url;
    };
    UrlUtils2.endsWith = function(url, suffix) {
      if (!url || !suffix) {
        return false;
      }
      return url.indexOf(suffix, url.length - suffix.length) !== -1;
    };
    UrlUtils2.urlRemoveQueryStringParameter = function(url, name) {
      if (StringUtils.isEmpty(url)) {
        return url;
      }
      var updatedUrl = url;
      var regex = new RegExp("(\\&" + name + "=)[^&]+");
      updatedUrl = url.replace(regex, "");
      regex = new RegExp("(" + name + "=)[^&]+&");
      updatedUrl = url.replace(regex, "");
      regex = new RegExp("(" + name + "=)[^&]+");
      updatedUrl = url.replace(regex, "");
      return updatedUrl;
    };
    UrlUtils2.getHashFromUrl = function(urlStringOrFragment) {
      var hashIndex1 = urlStringOrFragment.indexOf("#");
      var hashIndex2 = urlStringOrFragment.indexOf("#/");
      if (hashIndex2 > -1) {
        return urlStringOrFragment.substring(hashIndex2 + 2);
      } else if (hashIndex1 > -1) {
        return urlStringOrFragment.substring(hashIndex1 + 1);
      }
      return urlStringOrFragment;
    };
    UrlUtils2.urlContainsHash = function(urlString) {
      var parameters = UrlUtils2.deserializeHash(urlString);
      return parameters.hasOwnProperty(ServerHashParamKeys.ERROR_DESCRIPTION) || parameters.hasOwnProperty(ServerHashParamKeys.ERROR) || parameters.hasOwnProperty(ServerHashParamKeys.ACCESS_TOKEN) || parameters.hasOwnProperty(ServerHashParamKeys.ID_TOKEN);
    };
    UrlUtils2.deserializeHash = function(urlFragment) {
      var hash = UrlUtils2.getHashFromUrl(urlFragment);
      return CryptoUtils.deserialize(hash);
    };
    UrlUtils2.getHostFromUri = function(uri) {
      var extractedUri = String(uri).replace(/^(https?:)\/\//, "");
      extractedUri = extractedUri.split("/")[0];
      return extractedUri;
    };
    return UrlUtils2;
  }()
);

// node_modules/msal/lib-es6/cache/AccessTokenKey.js
var AccessTokenKey = (
  /** @class */
  function() {
    function AccessTokenKey2(authority, clientId, scopes, uid, utid) {
      this.authority = UrlUtils.CanonicalizeUri(authority);
      this.clientId = clientId;
      this.scopes = scopes;
      this.homeAccountIdentifier = CryptoUtils.base64Encode(uid) + "." + CryptoUtils.base64Encode(utid);
    }
    return AccessTokenKey2;
  }()
);

// node_modules/msal/lib-es6/cache/AccessTokenValue.js
var AccessTokenValue = (
  /** @class */
  function() {
    function AccessTokenValue2(accessToken, idToken, expiresIn, homeAccountIdentifier) {
      this.accessToken = accessToken;
      this.idToken = idToken;
      this.expiresIn = expiresIn;
      this.homeAccountIdentifier = homeAccountIdentifier;
    }
    return AccessTokenValue2;
  }()
);

// node_modules/msal/lib-es6/packageMetadata.js
var version = "1.4.17";

// node_modules/msal/lib-es6/ServerRequestParameters.js
var ServerRequestParameters = (
  /** @class */
  function() {
    function ServerRequestParameters2(authority, clientId, responseType, redirectUri, scopes, state2, correlationId) {
      this.authorityInstance = authority;
      this.clientId = clientId;
      this.nonce = CryptoUtils.createNewGuid();
      this.scopes = scopes ? __spreadArrays(scopes) : Constants.oidcScopes;
      this.scopes = ScopeSet.trimScopes(this.scopes);
      this.state = state2;
      this.correlationId = correlationId;
      this.xClientSku = "MSAL.JS";
      this.xClientVer = version;
      this.responseType = responseType;
      this.redirectUri = redirectUri;
    }
    Object.defineProperty(ServerRequestParameters2.prototype, "authority", {
      get: function() {
        return this.authorityInstance ? this.authorityInstance.CanonicalAuthority : null;
      },
      enumerable: false,
      configurable: true
    });
    ServerRequestParameters2.prototype.populateQueryParams = function(account, request, adalIdTokenObject, silentCall) {
      var queryParameters = {};
      if (request) {
        if (request.prompt) {
          this.promptValue = request.prompt;
        }
        if (request.claimsRequest) {
          this.claimsValue = request.claimsRequest;
        }
        if (ServerRequestParameters2.isSSOParam(request)) {
          queryParameters = this.constructUnifiedCacheQueryParameter(request, null);
        }
      }
      if (adalIdTokenObject) {
        queryParameters = this.constructUnifiedCacheQueryParameter(null, adalIdTokenObject);
      }
      queryParameters = this.addHintParameters(account, queryParameters);
      var eQParams = request ? request.extraQueryParameters : null;
      this.queryParameters = ServerRequestParameters2.generateQueryParametersString(queryParameters);
      this.extraQueryParameters = ServerRequestParameters2.generateQueryParametersString(eQParams, silentCall);
    };
    ServerRequestParameters2.prototype.constructUnifiedCacheQueryParameter = function(request, idTokenObject) {
      var _a3;
      var ssoType;
      var ssoData;
      var serverReqParam = {};
      if (request) {
        if (request.account) {
          var account = request.account;
          if ((_a3 = account.idTokenClaims) === null || _a3 === void 0 ? void 0 : _a3.login_hint) {
            ssoType = SSOTypes.LOGIN_HINT;
            ssoData = account.idTokenClaims.login_hint;
          } else if (account.sid) {
            ssoType = SSOTypes.SID;
            ssoData = account.sid;
          } else if (account.userName) {
            ssoType = SSOTypes.LOGIN_HINT;
            ssoData = account.userName;
          }
        } else if (request.sid) {
          ssoType = SSOTypes.SID;
          ssoData = request.sid;
        } else if (request.loginHint) {
          ssoType = SSOTypes.LOGIN_HINT;
          ssoData = request.loginHint;
        }
      } else if (idTokenObject) {
        if (idTokenObject.hasOwnProperty(Constants.upn)) {
          ssoType = SSOTypes.ID_TOKEN;
          ssoData = idTokenObject["upn"];
        }
      }
      serverReqParam = this.addSSOParameter(ssoType, ssoData);
      return serverReqParam;
    };
    ServerRequestParameters2.prototype.addHintParameters = function(account, params) {
      var _a3, _b;
      var qParams = params;
      if (account) {
        if (!qParams[SSOTypes.SID] && !qParams[SSOTypes.LOGIN_HINT]) {
          if ((_a3 = account.idTokenClaims) === null || _a3 === void 0 ? void 0 : _a3.login_hint) {
            qParams = this.addSSOParameter(SSOTypes.LOGIN_HINT, (_b = account.idTokenClaims) === null || _b === void 0 ? void 0 : _b.login_hint, qParams);
          } else if (account.sid && this.promptValue === PromptState.NONE) {
            qParams = this.addSSOParameter(SSOTypes.SID, account.sid, qParams);
          } else if (account.userName) {
            qParams = this.addSSOParameter(SSOTypes.LOGIN_HINT, account.userName, qParams);
          }
        }
      }
      return qParams;
    };
    ServerRequestParameters2.prototype.addSSOParameter = function(ssoType, ssoData, params) {
      var ssoParam = params || {};
      if (!ssoData) {
        return ssoParam;
      }
      switch (ssoType) {
        case SSOTypes.SID: {
          ssoParam[SSOTypes.SID] = ssoData;
          break;
        }
        case SSOTypes.ID_TOKEN: {
          ssoParam[SSOTypes.LOGIN_HINT] = ssoData;
          break;
        }
        case SSOTypes.LOGIN_HINT: {
          ssoParam[SSOTypes.LOGIN_HINT] = ssoData;
          break;
        }
      }
      return ssoParam;
    };
    ServerRequestParameters2.generateQueryParametersString = function(queryParameters, silentCall) {
      var paramsString = null;
      if (queryParameters) {
        Object.keys(queryParameters).forEach(function(key) {
          if (key === Constants.domain_hint && (silentCall || queryParameters[SSOTypes.SID])) {
            return;
          }
          if (!paramsString) {
            paramsString = key + "=" + encodeURIComponent(queryParameters[key]);
          } else {
            paramsString += "&" + key + "=" + encodeURIComponent(queryParameters[key]);
          }
        });
      }
      return paramsString;
    };
    ServerRequestParameters2.isSSOParam = function(request) {
      return !!(request && (request.account || request.sid || request.loginHint));
    };
    ServerRequestParameters2.determineResponseType = function(accountsMatch, scopes) {
      if (ScopeSet.onlyContainsOidcScopes(scopes)) {
        return ResponseTypes.id_token;
      }
      return accountsMatch ? this.responseTypeForMatchingAccounts(scopes) : ResponseTypes.id_token_token;
    };
    ServerRequestParameters2.responseTypeForMatchingAccounts = function(scopes) {
      return ScopeSet.containsAnyOidcScopes(scopes) ? ResponseTypes.id_token_token : ResponseTypes.token;
    };
    return ServerRequestParameters2;
  }()
);

// node_modules/msal/lib-es6/XHRClient.js
var XhrClient = (
  /** @class */
  function() {
    function XhrClient2() {
    }
    XhrClient2.prototype.sendRequestAsync = function(url, method, enableCaching) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open(
          method,
          url,
          /* async: */
          true
        );
        if (enableCaching) {
        }
        xhr.onload = function() {
          if (xhr.status < 200 || xhr.status >= 300) {
            reject(_this.handleError(xhr.responseText));
          }
          var jsonResponse;
          try {
            jsonResponse = JSON.parse(xhr.responseText);
          } catch (e) {
            reject(_this.handleError(xhr.responseText));
          }
          var response = {
            statusCode: xhr.status,
            body: jsonResponse
          };
          resolve(response);
        };
        xhr.onerror = function() {
          reject(xhr.status);
        };
        if (method === NetworkRequestType.GET) {
          xhr.send();
        } else {
          throw "not implemented";
        }
      });
    };
    XhrClient2.prototype.handleError = function(responseText) {
      var jsonResponse;
      try {
        jsonResponse = JSON.parse(responseText);
        if (jsonResponse["error"]) {
          return jsonResponse["error"];
        } else {
          throw responseText;
        }
      } catch (e) {
        return responseText;
      }
    };
    return XhrClient2;
  }()
);

// node_modules/msal/lib-es6/authority/TrustedAuthority.js
var TrustedAuthority = (
  /** @class */
  function() {
    function TrustedAuthority2() {
    }
    TrustedAuthority2.setTrustedAuthoritiesFromConfig = function(validateAuthority, knownAuthorities) {
      if (validateAuthority && !this.getTrustedHostList().length) {
        knownAuthorities.forEach(function(authority) {
          TrustedAuthority2.TrustedHostList.push(authority.toLowerCase());
        });
      }
    };
    TrustedAuthority2.getAliases = function(authorityToVerify, telemetryManager, correlationId) {
      return __awaiter2(this, void 0, void 0, function() {
        var client, httpMethod, instanceDiscoveryEndpoint, httpEvent;
        return __generator(this, function(_a3) {
          client = new XhrClient();
          httpMethod = NetworkRequestType.GET;
          instanceDiscoveryEndpoint = "" + AAD_INSTANCE_DISCOVERY_ENDPOINT + authorityToVerify + "oauth2/v2.0/authorize";
          httpEvent = telemetryManager.createAndStartHttpEvent(correlationId, httpMethod, instanceDiscoveryEndpoint, "getAliases");
          return [2, client.sendRequestAsync(instanceDiscoveryEndpoint, httpMethod, true).then(function(response) {
            httpEvent.httpResponseStatus = response.statusCode;
            telemetryManager.stopEvent(httpEvent);
            return response.body["metadata"];
          }).catch(function(err) {
            httpEvent.serverErrorCode = err;
            telemetryManager.stopEvent(httpEvent);
            throw err;
          })];
        });
      });
    };
    TrustedAuthority2.setTrustedAuthoritiesFromNetwork = function(authorityToVerify, telemetryManager, correlationId) {
      return __awaiter2(this, void 0, void 0, function() {
        var metadata, host;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.getAliases(authorityToVerify, telemetryManager, correlationId)];
            case 1:
              metadata = _a3.sent();
              metadata.forEach(function(entry) {
                var authorities = entry["aliases"];
                authorities.forEach(function(authority) {
                  TrustedAuthority2.TrustedHostList.push(authority.toLowerCase());
                });
              });
              host = UrlUtils.GetUrlComponents(authorityToVerify).HostNameAndPort;
              if (TrustedAuthority2.getTrustedHostList().length && !TrustedAuthority2.IsInTrustedHostList(host)) {
                TrustedAuthority2.TrustedHostList.push(host.toLowerCase());
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    TrustedAuthority2.getTrustedHostList = function() {
      return this.TrustedHostList;
    };
    TrustedAuthority2.IsInTrustedHostList = function(host) {
      return this.TrustedHostList.indexOf(host.toLowerCase()) > -1;
    };
    TrustedAuthority2.TrustedHostList = [];
    return TrustedAuthority2;
  }()
);

// node_modules/msal/lib-es6/authority/Authority.js
var AuthorityType;
(function(AuthorityType2) {
  AuthorityType2[AuthorityType2["Default"] = 0] = "Default";
  AuthorityType2[AuthorityType2["Adfs"] = 1] = "Adfs";
})(AuthorityType || (AuthorityType = {}));
var Authority = (
  /** @class */
  function() {
    function Authority2(authority, validateAuthority, authorityMetadata) {
      this.IsValidationEnabled = validateAuthority;
      this.CanonicalAuthority = authority;
      this.validateAsUri();
      this.tenantDiscoveryResponse = authorityMetadata;
    }
    Authority2.isAdfs = function(authorityUrl) {
      var components = UrlUtils.GetUrlComponents(authorityUrl);
      var pathSegments = components.PathSegments;
      return pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS;
    };
    Object.defineProperty(Authority2.prototype, "AuthorityType", {
      get: function() {
        return Authority2.isAdfs(this.canonicalAuthority) ? AuthorityType.Adfs : AuthorityType.Default;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "Tenant", {
      get: function() {
        return this.CanonicalAuthorityUrlComponents.PathSegments[0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "AuthorizationEndpoint", {
      get: function() {
        this.validateResolved();
        return this.tenantDiscoveryResponse.AuthorizationEndpoint.replace(/{tenant}|{tenantid}/g, this.Tenant);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "EndSessionEndpoint", {
      get: function() {
        this.validateResolved();
        return this.tenantDiscoveryResponse.EndSessionEndpoint.replace(/{tenant}|{tenantid}/g, this.Tenant);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "SelfSignedJwtAudience", {
      get: function() {
        this.validateResolved();
        return this.tenantDiscoveryResponse.Issuer.replace(/{tenant}|{tenantid}/g, this.Tenant);
      },
      enumerable: false,
      configurable: true
    });
    Authority2.prototype.validateResolved = function() {
      if (!this.hasCachedMetadata()) {
        throw "Please call ResolveEndpointsAsync first";
      }
    };
    Object.defineProperty(Authority2.prototype, "CanonicalAuthority", {
      /**
       * A URL that is the authority set by the developer
       */
      get: function() {
        return this.canonicalAuthority;
      },
      set: function(url) {
        this.canonicalAuthority = UrlUtils.CanonicalizeUri(url);
        this.canonicalAuthorityUrlComponents = null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "CanonicalAuthorityUrlComponents", {
      get: function() {
        if (!this.canonicalAuthorityUrlComponents) {
          this.canonicalAuthorityUrlComponents = UrlUtils.GetUrlComponents(this.CanonicalAuthority);
        }
        return this.canonicalAuthorityUrlComponents;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "DefaultOpenIdConfigurationEndpoint", {
      // http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
      get: function() {
        return this.AuthorityType === AuthorityType.Adfs ? "" + this.CanonicalAuthority + WELL_KNOWN_SUFFIX : this.CanonicalAuthority + "v2.0/" + WELL_KNOWN_SUFFIX;
      },
      enumerable: false,
      configurable: true
    });
    Authority2.prototype.validateAsUri = function() {
      var components;
      try {
        components = this.CanonicalAuthorityUrlComponents;
      } catch (e) {
        throw ClientConfigurationErrorMessage.invalidAuthorityType;
      }
      if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
        throw ClientConfigurationErrorMessage.authorityUriInsecure;
      }
      if (!components.PathSegments || components.PathSegments.length < 1) {
        throw ClientConfigurationErrorMessage.authorityUriInvalidPath;
      }
    };
    Authority2.prototype.DiscoverEndpoints = function(openIdConfigurationEndpoint, telemetryManager, correlationId) {
      var client = new XhrClient();
      var httpMethod = NetworkRequestType.GET;
      var httpEvent = telemetryManager.createAndStartHttpEvent(correlationId, httpMethod, openIdConfigurationEndpoint, "openIdConfigurationEndpoint");
      return client.sendRequestAsync(
        openIdConfigurationEndpoint,
        httpMethod,
        /* enableCaching: */
        true
      ).then(function(response) {
        httpEvent.httpResponseStatus = response.statusCode;
        telemetryManager.stopEvent(httpEvent);
        return {
          AuthorizationEndpoint: response.body["authorization_endpoint"],
          EndSessionEndpoint: response.body["end_session_endpoint"],
          Issuer: response.body["issuer"]
        };
      }).catch(function(err) {
        httpEvent.serverErrorCode = err;
        telemetryManager.stopEvent(httpEvent);
        throw err;
      });
    };
    Authority2.prototype.resolveEndpointsAsync = function(telemetryManager, correlationId) {
      return __awaiter2(this, void 0, void 0, function() {
        var host, openIdConfigurationEndpointResponse, _a3;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!this.IsValidationEnabled)
                return [3, 3];
              host = this.canonicalAuthorityUrlComponents.HostNameAndPort;
              if (!(TrustedAuthority.getTrustedHostList().length === 0))
                return [3, 2];
              return [4, TrustedAuthority.setTrustedAuthoritiesFromNetwork(this.canonicalAuthority, telemetryManager, correlationId)];
            case 1:
              _b.sent();
              _b.label = 2;
            case 2:
              if (!TrustedAuthority.IsInTrustedHostList(host)) {
                throw ClientConfigurationError.createUntrustedAuthorityError(host);
              }
              _b.label = 3;
            case 3:
              openIdConfigurationEndpointResponse = this.GetOpenIdConfigurationEndpoint();
              _a3 = this;
              return [4, this.DiscoverEndpoints(openIdConfigurationEndpointResponse, telemetryManager, correlationId)];
            case 4:
              _a3.tenantDiscoveryResponse = _b.sent();
              return [2, this.tenantDiscoveryResponse];
          }
        });
      });
    };
    Authority2.prototype.hasCachedMetadata = function() {
      return !!(this.tenantDiscoveryResponse && this.tenantDiscoveryResponse.AuthorizationEndpoint && this.tenantDiscoveryResponse.EndSessionEndpoint && this.tenantDiscoveryResponse.Issuer);
    };
    Authority2.prototype.GetOpenIdConfigurationEndpoint = function() {
      return this.DefaultOpenIdConfigurationEndpoint;
    };
    return Authority2;
  }()
);

// node_modules/msal/lib-es6/ClientInfo.js
var ClientInfo = (
  /** @class */
  function() {
    function ClientInfo2(rawClientInfo, authority) {
      if (!rawClientInfo || StringUtils.isEmpty(rawClientInfo)) {
        this.uid = "";
        this.utid = "";
        return;
      }
      try {
        var decodedClientInfo = CryptoUtils.base64Decode(rawClientInfo);
        var clientInfo = JSON.parse(decodedClientInfo);
        if (clientInfo) {
          if (clientInfo.hasOwnProperty("uid")) {
            this.uid = authority ? ClientInfo2.stripPolicyFromUid(clientInfo.uid, authority) : clientInfo.uid;
          }
          if (clientInfo.hasOwnProperty("utid")) {
            this.utid = clientInfo.utid;
          }
        }
      } catch (e) {
        throw ClientAuthError.createClientInfoDecodingError(e);
      }
    }
    Object.defineProperty(ClientInfo2.prototype, "uid", {
      get: function() {
        return this._uid ? this._uid : "";
      },
      set: function(uid) {
        this._uid = uid;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ClientInfo2.prototype, "utid", {
      get: function() {
        return this._utid ? this._utid : "";
      },
      set: function(utid) {
        this._utid = utid;
      },
      enumerable: false,
      configurable: true
    });
    ClientInfo2.createClientInfoFromIdToken = function(idToken, authority) {
      var clientInfo = {
        uid: idToken.subject,
        utid: ""
      };
      return new ClientInfo2(CryptoUtils.base64Encode(JSON.stringify(clientInfo)), authority);
    };
    ClientInfo2.stripPolicyFromUid = function(uid, authority) {
      var uidSegments = uid.split("-");
      var urlSegments = authority.split("/").reverse();
      var policy2 = "";
      if (!StringUtils.isEmpty(urlSegments[0])) {
        policy2 = urlSegments[0];
      } else if (urlSegments.length > 1) {
        policy2 = urlSegments[1];
      }
      if (uidSegments[uidSegments.length - 1] === policy2) {
        return uidSegments.slice(0, uidSegments.length - 1).join("-");
      }
      return uid;
    };
    ClientInfo2.prototype.encodeClientInfo = function() {
      var clientInfo = JSON.stringify({ uid: this.uid, utid: this.utid });
      return CryptoUtils.base64Encode(clientInfo);
    };
    return ClientInfo2;
  }()
);

// node_modules/msal/lib-es6/utils/TimeUtils.js
var TimeUtils = (
  /** @class */
  function() {
    function TimeUtils2() {
    }
    TimeUtils2.parseExpiresIn = function(expiresIn) {
      var expires = expiresIn || "3599";
      return parseInt(expires, 10);
    };
    TimeUtils2.now = function() {
      return Math.round(new Date().getTime() / 1e3);
    };
    TimeUtils2.relativeNowMs = function() {
      return window.performance.now();
    };
    return TimeUtils2;
  }()
);

// node_modules/msal/lib-es6/utils/TokenUtils.js
var TokenUtils = (
  /** @class */
  function() {
    function TokenUtils2() {
    }
    TokenUtils2.decodeJwt = function(jwtToken) {
      if (StringUtils.isEmpty(jwtToken)) {
        return null;
      }
      var idTokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
      var matches = idTokenPartsRegex.exec(jwtToken);
      if (!matches || matches.length < 4) {
        return null;
      }
      var crackedToken = {
        header: matches[1],
        JWSPayload: matches[2],
        JWSSig: matches[3]
      };
      return crackedToken;
    };
    TokenUtils2.validateExpirationIsWithinOffset = function(expiration, tokenRenewalOffsetSeconds) {
      var offset = tokenRenewalOffsetSeconds || 300;
      return expiration && expiration > TimeUtils.now() + offset;
    };
    TokenUtils2.extractIdToken = function(encodedIdToken) {
      var decodedToken = this.decodeJwt(encodedIdToken);
      if (!decodedToken) {
        return null;
      }
      try {
        var base64IdToken = decodedToken["JWSPayload"];
        var base64Decoded = CryptoUtils.base64Decode(base64IdToken);
        if (!base64Decoded) {
          return null;
        }
        return JSON.parse(base64Decoded);
      } catch (err) {
      }
      return null;
    };
    return TokenUtils2;
  }()
);

// node_modules/msal/lib-es6/IdToken.js
var IdToken = (
  /** @class */
  function() {
    function IdToken2(rawIdToken) {
      if (StringUtils.isEmpty(rawIdToken)) {
        throw ClientAuthError.createIdTokenNullOrEmptyError(rawIdToken);
      }
      try {
        this.rawIdToken = rawIdToken;
        this.claims = TokenUtils.extractIdToken(rawIdToken);
        if (this.claims) {
          if (this.claims.hasOwnProperty("iss")) {
            this.issuer = this.claims["iss"];
          }
          if (this.claims.hasOwnProperty("oid")) {
            this.objectId = this.claims["oid"];
          }
          if (this.claims.hasOwnProperty("sub")) {
            this.subject = this.claims["sub"];
          }
          if (this.claims.hasOwnProperty("tid")) {
            this.tenantId = this.claims["tid"];
          }
          if (this.claims.hasOwnProperty("ver")) {
            this.version = this.claims["ver"];
          }
          if (this.claims.hasOwnProperty("preferred_username")) {
            this.preferredName = this.claims["preferred_username"];
          } else if (this.claims.hasOwnProperty("upn")) {
            this.preferredName = this.claims["upn"];
          }
          if (this.claims.hasOwnProperty("name")) {
            this.name = this.claims["name"];
          }
          if (this.claims.hasOwnProperty("nonce")) {
            this.nonce = this.claims["nonce"];
          }
          if (this.claims.hasOwnProperty("exp")) {
            this.expiration = this.claims["exp"];
          }
          if (this.claims.hasOwnProperty("home_oid")) {
            this.homeObjectId = this.claims["home_oid"];
          }
          if (this.claims.hasOwnProperty("sid")) {
            this.sid = this.claims["sid"];
          }
          if (this.claims.hasOwnProperty("cloud_instance_host_name")) {
            this.cloudInstance = this.claims["cloud_instance_host_name"];
          }
        }
      } catch (e) {
        throw ClientAuthError.createIdTokenParsingError(e);
      }
    }
    return IdToken2;
  }()
);

// node_modules/msal/lib-es6/cache/AccessTokenCacheItem.js
var AccessTokenCacheItem = (
  /** @class */
  function() {
    function AccessTokenCacheItem2(key, value) {
      this.key = key;
      this.value = value;
    }
    return AccessTokenCacheItem2;
  }()
);

// node_modules/msal/lib-es6/cache/BrowserStorage.js
var BrowserStorage = (
  /** @class */
  function() {
    function BrowserStorage2(cacheLocation) {
      if (!window) {
        throw AuthError.createNoWindowObjectError("Browser storage class could not find window object");
      }
      var storageSupported = typeof window[cacheLocation] !== "undefined" && window[cacheLocation] !== null;
      if (!storageSupported) {
        throw ClientConfigurationError.createStorageNotSupportedError(cacheLocation);
      }
      this.cacheLocation = cacheLocation;
    }
    BrowserStorage2.prototype.setItem = function(key, value, enableCookieStorage) {
      window[this.cacheLocation].setItem(key, value);
      if (enableCookieStorage) {
        this.setItemCookie(key, value);
      }
    };
    BrowserStorage2.prototype.getItem = function(key, enableCookieStorage) {
      if (enableCookieStorage && this.getItemCookie(key)) {
        return this.getItemCookie(key);
      }
      return window[this.cacheLocation].getItem(key);
    };
    BrowserStorage2.prototype.removeItem = function(key) {
      return window[this.cacheLocation].removeItem(key);
    };
    BrowserStorage2.prototype.clear = function() {
      return window[this.cacheLocation].clear();
    };
    BrowserStorage2.prototype.setItemCookie = function(cName, cValue, expires) {
      var cookieStr = encodeURIComponent(cName) + "=" + encodeURIComponent(cValue) + ";path=/;";
      if (expires) {
        var expireTime = this.getCookieExpirationTime(expires);
        cookieStr += "expires=" + expireTime + ";";
      }
      document.cookie = cookieStr;
    };
    BrowserStorage2.prototype.getItemCookie = function(cName) {
      var name = encodeURIComponent(cName) + "=";
      var ca = document.cookie.split(";");
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) === " ") {
          c = c.substring(1);
        }
        if (c.indexOf(name) === 0) {
          return decodeURIComponent(c.substring(name.length, c.length));
        }
      }
      return "";
    };
    BrowserStorage2.prototype.clearItemCookie = function(cName) {
      this.setItemCookie(cName, "", -1);
    };
    BrowserStorage2.prototype.getCookieExpirationTime = function(cookieLifeDays) {
      var today = new Date();
      var expr = new Date(today.getTime() + cookieLifeDays * 24 * 60 * 60 * 1e3);
      return expr.toUTCString();
    };
    return BrowserStorage2;
  }()
);

// node_modules/msal/lib-es6/utils/RequestUtils.js
var RequestUtils = (
  /** @class */
  function() {
    function RequestUtils2() {
    }
    RequestUtils2.validateRequest = function(request, isLoginCall, clientId, interactionType) {
      if (!isLoginCall && !request) {
        throw ClientConfigurationError.createEmptyRequestError();
      }
      var scopes;
      var extraQueryParameters;
      if (request) {
        scopes = isLoginCall ? ScopeSet.appendScopes(request.scopes, request.extraScopesToConsent) : request.scopes;
        ScopeSet.validateInputScope(scopes, !isLoginCall);
        scopes = ScopeSet.translateClientIdIfSingleScope(scopes, clientId);
        this.validatePromptParameter(request.prompt);
        extraQueryParameters = this.validateEQParameters(request.extraQueryParameters, request.claimsRequest);
        this.validateClaimsRequest(request.claimsRequest);
      }
      var state2 = this.validateAndGenerateState(request && request.state, interactionType);
      var correlationId = this.validateAndGenerateCorrelationId(request && request.correlationId);
      var validatedRequest = __assign(__assign({}, request), {
        extraQueryParameters,
        scopes,
        state: state2,
        correlationId
      });
      return validatedRequest;
    };
    RequestUtils2.validatePromptParameter = function(prompt) {
      if (prompt) {
        if ([PromptState.LOGIN, PromptState.SELECT_ACCOUNT, PromptState.CONSENT, PromptState.NONE].indexOf(prompt) < 0) {
          throw ClientConfigurationError.createInvalidPromptError(prompt);
        }
      }
    };
    RequestUtils2.validateEQParameters = function(extraQueryParameters, claimsRequest) {
      var eQParams = __assign({}, extraQueryParameters);
      if (!eQParams) {
        return null;
      }
      if (claimsRequest) {
        delete eQParams[Constants.claims];
      }
      BlacklistedEQParams.forEach(function(param) {
        if (eQParams[param]) {
          delete eQParams[param];
        }
      });
      return eQParams;
    };
    RequestUtils2.validateClaimsRequest = function(claimsRequest) {
      if (!claimsRequest) {
        return;
      }
      try {
        JSON.parse(claimsRequest);
      } catch (e) {
        throw ClientConfigurationError.createClaimsRequestParsingError(e);
      }
    };
    RequestUtils2.validateAndGenerateState = function(userState, interactionType) {
      return !StringUtils.isEmpty(userState) ? "" + RequestUtils2.generateLibraryState(interactionType) + Constants.resourceDelimiter + userState : RequestUtils2.generateLibraryState(interactionType);
    };
    RequestUtils2.generateLibraryState = function(interactionType) {
      var stateObject = {
        id: CryptoUtils.createNewGuid(),
        ts: TimeUtils.now(),
        method: interactionType
      };
      var stateString = JSON.stringify(stateObject);
      return CryptoUtils.base64Encode(stateString);
    };
    RequestUtils2.parseLibraryState = function(state2) {
      var libraryState = decodeURIComponent(state2).split(Constants.resourceDelimiter)[0];
      if (CryptoUtils.isGuid(libraryState)) {
        return {
          id: libraryState,
          ts: TimeUtils.now(),
          method: Constants.interactionTypeRedirect
        };
      }
      try {
        var stateString = CryptoUtils.base64Decode(libraryState);
        var stateObject = JSON.parse(stateString);
        return stateObject;
      } catch (e) {
        throw ClientAuthError.createInvalidStateError(state2, null);
      }
    };
    RequestUtils2.validateAndGenerateCorrelationId = function(correlationId) {
      if (correlationId && !CryptoUtils.isGuid(correlationId)) {
        throw ClientConfigurationError.createInvalidCorrelationIdError();
      }
      return CryptoUtils.isGuid(correlationId) ? correlationId : CryptoUtils.createNewGuid();
    };
    RequestUtils2.createRequestSignature = function(request) {
      return "" + request.scopes.join(" ").toLowerCase() + Constants.resourceDelimiter + request.authority;
    };
    return RequestUtils2;
  }()
);

// node_modules/msal/lib-es6/cache/AuthCache.js
var AuthCache = (
  /** @class */
  function(_super) {
    __extends(AuthCache2, _super);
    function AuthCache2(clientId, cacheLocation, storeAuthStateInCookie) {
      var _this = _super.call(this, cacheLocation) || this;
      _this.temporaryCache = new BrowserStorage(SESSION_STORAGE);
      _this.clientId = clientId;
      _this.rollbackEnabled = true;
      _this.migrateCacheEntries(storeAuthStateInCookie);
      return _this;
    }
    AuthCache2.prototype.migrateCacheEntries = function(storeAuthStateInCookie) {
      var _this = this;
      var idTokenKey = Constants.cachePrefix + "." + PersistentCacheKeys.IDTOKEN;
      var clientInfoKey = Constants.cachePrefix + "." + PersistentCacheKeys.CLIENT_INFO;
      var errorKey = Constants.cachePrefix + "." + ErrorCacheKeys.ERROR;
      var errorDescKey = Constants.cachePrefix + "." + ErrorCacheKeys.ERROR_DESC;
      var idTokenValue = _super.prototype.getItem.call(this, idTokenKey);
      var idToken;
      if (idTokenValue) {
        try {
          idToken = new IdToken(idTokenValue);
        } catch (e) {
          return;
        }
      }
      if (idToken && idToken.claims && idToken.claims.aud === this.clientId) {
        var clientInfoValue = _super.prototype.getItem.call(this, clientInfoKey);
        var errorValue = _super.prototype.getItem.call(this, errorKey);
        var errorDescValue = _super.prototype.getItem.call(this, errorDescKey);
        var values_1 = [idTokenValue, clientInfoValue, errorValue, errorDescValue];
        var keysToMigrate = [PersistentCacheKeys.IDTOKEN, PersistentCacheKeys.CLIENT_INFO, ErrorCacheKeys.ERROR, ErrorCacheKeys.ERROR_DESC];
        keysToMigrate.forEach(function(cacheKey, index) {
          return _this.duplicateCacheEntry(cacheKey, values_1[index], storeAuthStateInCookie);
        });
      }
    };
    AuthCache2.prototype.duplicateCacheEntry = function(newKey, value, storeAuthStateInCookie) {
      if (value) {
        this.setItem(newKey, value, storeAuthStateInCookie);
      }
    };
    AuthCache2.prototype.generateCacheKey = function(key, addInstanceId) {
      try {
        JSON.parse(key);
        return key;
      } catch (e) {
        if (key.indexOf("" + Constants.cachePrefix) === 0 || key.indexOf(Constants.adalIdToken) === 0) {
          return key;
        }
        return addInstanceId ? Constants.cachePrefix + "." + this.clientId + "." + key : Constants.cachePrefix + "." + key;
      }
    };
    AuthCache2.prototype.matchKeyForType = function(key, clientId, homeAccountIdentifier, tokenType) {
      var parsedKey = StringUtils.validateAndParseJsonCacheKey(key);
      if (!parsedKey) {
        return null;
      }
      var accountMatches = key.match(clientId) && key.match(homeAccountIdentifier);
      var tokenTypeMatches = false;
      switch (tokenType) {
        case ServerHashParamKeys.ACCESS_TOKEN:
          tokenTypeMatches = !!key.match(Constants.scopes);
          break;
        case ServerHashParamKeys.ID_TOKEN:
          tokenTypeMatches = !key.match(Constants.scopes);
          break;
      }
      return accountMatches && tokenTypeMatches ? parsedKey : null;
    };
    AuthCache2.prototype.setItem = function(key, value, enableCookieStorage) {
      _super.prototype.setItem.call(this, this.generateCacheKey(key, true), value, enableCookieStorage);
      if (this.rollbackEnabled && !enableCookieStorage) {
        _super.prototype.setItem.call(this, this.generateCacheKey(key, false), value, enableCookieStorage);
      }
    };
    AuthCache2.prototype.getItem = function(key, enableCookieStorage) {
      return _super.prototype.getItem.call(this, this.generateCacheKey(key, true), enableCookieStorage);
    };
    AuthCache2.prototype.removeItem = function(key) {
      this.temporaryCache.removeItem(this.generateCacheKey(key, true));
      _super.prototype.removeItem.call(this, this.generateCacheKey(key, true));
      if (this.rollbackEnabled) {
        _super.prototype.removeItem.call(this, this.generateCacheKey(key, false));
      }
    };
    AuthCache2.prototype.setTemporaryItem = function(key, value, enableCookieStorage) {
      this.temporaryCache.setItem(this.generateCacheKey(key, true), value, enableCookieStorage);
    };
    AuthCache2.prototype.getTemporaryItem = function(key, enableCookieStorage) {
      return this.temporaryCache.getItem(this.generateCacheKey(key, true), enableCookieStorage);
    };
    AuthCache2.prototype.resetCacheItems = function() {
      var storage = window[this.cacheLocation];
      var key;
      for (key in storage) {
        if (storage.hasOwnProperty(key) && key.indexOf(Constants.cachePrefix) !== -1) {
          _super.prototype.removeItem.call(this, key);
        }
      }
    };
    AuthCache2.prototype.resetTempCacheItems = function(state2) {
      var _this = this;
      var stateId = state2 && RequestUtils.parseLibraryState(state2).id;
      var isTokenRenewalInProgress = this.tokenRenewalInProgress(state2);
      var storage = window[this.cacheLocation];
      if (stateId && !isTokenRenewalInProgress) {
        Object.keys(storage).forEach(function(key) {
          if (key.indexOf(stateId) !== -1) {
            _this.removeItem(key);
            _super.prototype.clearItemCookie.call(_this, key);
          }
        });
      }
      this.setInteractionInProgress(false);
      this.removeItem(TemporaryCacheKeys.REDIRECT_REQUEST);
    };
    AuthCache2.prototype.setItemCookie = function(cName, cValue, expires) {
      _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, true), cValue, expires);
      if (this.rollbackEnabled) {
        _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, false), cValue, expires);
      }
    };
    AuthCache2.prototype.clearItemCookie = function(cName) {
      _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, true));
      if (this.rollbackEnabled) {
        _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, false));
      }
    };
    AuthCache2.prototype.getItemCookie = function(cName) {
      return _super.prototype.getItemCookie.call(this, this.generateCacheKey(cName, true));
    };
    AuthCache2.prototype.getAllTokensByType = function(clientId, homeAccountIdentifier, tokenType) {
      var _this = this;
      var results = Object.keys(window[this.cacheLocation]).reduce(function(tokens, key) {
        var matchedTokenKey = _this.matchKeyForType(key, clientId, homeAccountIdentifier, tokenType);
        if (matchedTokenKey) {
          var value = _this.getItem(key);
          if (value) {
            try {
              var newAccessTokenCacheItem = new AccessTokenCacheItem(matchedTokenKey, JSON.parse(value));
              return tokens.concat([newAccessTokenCacheItem]);
            } catch (err) {
              return tokens;
            }
          }
        }
        return tokens;
      }, []);
      return results;
    };
    AuthCache2.prototype.getAllAccessTokens = function(clientId, homeAccountIdentifier) {
      return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ACCESS_TOKEN);
    };
    AuthCache2.prototype.getAllIdTokens = function(clientId, homeAccountIdentifier) {
      return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ID_TOKEN);
    };
    AuthCache2.prototype.getAllTokens = function(clientId, homeAccountIdentifier) {
      var accessTokens = this.getAllAccessTokens(clientId, homeAccountIdentifier);
      var idTokens = this.getAllIdTokens(clientId, homeAccountIdentifier);
      return __spreadArrays(accessTokens, idTokens);
    };
    AuthCache2.prototype.isInteractionInProgress = function(matchClientId) {
      var clientId = this.getInteractionInProgress();
      if (matchClientId) {
        return clientId === this.clientId;
      } else {
        return !!clientId;
      }
    };
    AuthCache2.prototype.getInteractionInProgress = function() {
      return this.getTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS, false));
    };
    AuthCache2.prototype.setInteractionInProgress = function(newInProgressValue) {
      if (newInProgressValue) {
        if (this.isInteractionInProgress(false)) {
          throw ClientAuthError.createAcquireTokenInProgressError();
        } else {
          this.setTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS, false), this.clientId);
        }
      } else if (!newInProgressValue && this.isInteractionInProgress(true)) {
        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS, false));
      }
    };
    AuthCache2.prototype.tokenRenewalInProgress = function(stateValue) {
      var renewStatus = this.getItem(AuthCache2.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateValue));
      return !!(renewStatus && renewStatus === Constants.inProgress);
    };
    AuthCache2.prototype.clearMsalCookie = function(state2) {
      var _this = this;
      if (state2) {
        this.clearItemCookie(AuthCache2.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, state2));
        this.clearItemCookie(AuthCache2.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, state2));
        this.clearItemCookie(AuthCache2.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, state2));
        this.clearItemCookie(AuthCache2.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, state2));
      } else {
        var cookies = document.cookie.split(";");
        cookies.forEach(function(cookieString) {
          var cookieName = cookieString.trim().split("=")[0];
          if (cookieName.indexOf(Constants.cachePrefix) > -1) {
            _super.prototype.clearItemCookie.call(_this, cookieName);
          }
        });
      }
    };
    AuthCache2.generateAcquireTokenAccountKey = function(accountId, state2) {
      var stateId = RequestUtils.parseLibraryState(state2).id;
      return "" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter + accountId + Constants.resourceDelimiter + stateId;
    };
    AuthCache2.generateAuthorityKey = function(state2) {
      return AuthCache2.generateTemporaryCacheKey(TemporaryCacheKeys.AUTHORITY, state2);
    };
    AuthCache2.generateTemporaryCacheKey = function(tempCacheKey, state2) {
      var stateId = RequestUtils.parseLibraryState(state2).id;
      return "" + tempCacheKey + Constants.resourceDelimiter + stateId;
    };
    return AuthCache2;
  }(BrowserStorage)
);

// node_modules/msal/lib-es6/Account.js
var Account = (
  /** @class */
  function() {
    function Account2(accountIdentifier, homeAccountIdentifier, userName, name, idTokenClaims, sid, environment) {
      this.accountIdentifier = accountIdentifier;
      this.homeAccountIdentifier = homeAccountIdentifier;
      this.userName = userName;
      this.name = name;
      this.idToken = idTokenClaims;
      this.idTokenClaims = idTokenClaims;
      this.sid = sid;
      this.environment = environment;
    }
    Account2.createAccount = function(idToken, clientInfo) {
      var accountIdentifier = idToken.objectId || idToken.subject;
      var uid = clientInfo ? clientInfo.uid : "";
      var utid = clientInfo ? clientInfo.utid : "";
      var homeAccountIdentifier;
      if (!StringUtils.isEmpty(uid)) {
        homeAccountIdentifier = StringUtils.isEmpty(utid) ? CryptoUtils.base64Encode(uid) : CryptoUtils.base64Encode(uid) + "." + CryptoUtils.base64Encode(utid);
      }
      return new Account2(accountIdentifier, homeAccountIdentifier, idToken.preferredName, idToken.name, idToken.claims, idToken.sid, idToken.issuer);
    };
    Account2.compareAccounts = function(a1, a2) {
      if (!a1 || !a2) {
        return false;
      }
      if (a1.homeAccountIdentifier && a2.homeAccountIdentifier) {
        if (a1.homeAccountIdentifier === a2.homeAccountIdentifier) {
          return true;
        }
      }
      return false;
    };
    return Account2;
  }()
);

// node_modules/msal/lib-es6/utils/WindowUtils.js
var WindowUtils = (
  /** @class */
  function() {
    function WindowUtils2() {
    }
    WindowUtils2.isInIframe = function() {
      return window.parent !== window;
    };
    WindowUtils2.isInPopup = function() {
      return !!(window.opener && window.opener !== window);
    };
    WindowUtils2.generateFrameName = function(prefix, requestSignature) {
      return "" + prefix + Constants.resourceDelimiter + requestSignature;
    };
    WindowUtils2.monitorIframeForHash = function(contentWindow, timeout, urlNavigate, logger) {
      return new Promise(function(resolve, reject) {
        var nowMark = TimeUtils.relativeNowMs();
        var timeoutMark = nowMark + timeout;
        logger.verbose("monitorWindowForIframe polling started");
        var intervalId = setInterval(function() {
          if (TimeUtils.relativeNowMs() > timeoutMark) {
            logger.error("monitorIframeForHash unable to find hash in url, timing out");
            logger.errorPii("monitorIframeForHash polling timed out for url: " + urlNavigate);
            clearInterval(intervalId);
            reject(ClientAuthError.createTokenRenewalTimeoutError());
            return;
          }
          var href;
          try {
            href = contentWindow.location.href;
          } catch (e) {
          }
          if (href && UrlUtils.urlContainsHash(href)) {
            logger.verbose("monitorIframeForHash found url in hash");
            clearInterval(intervalId);
            resolve(contentWindow.location.hash);
          }
        }, WindowUtils2.POLLING_INTERVAL_MS);
      });
    };
    WindowUtils2.monitorPopupForHash = function(contentWindow, timeout, urlNavigate, logger) {
      return new Promise(function(resolve, reject) {
        var maxTicks = timeout / WindowUtils2.POLLING_INTERVAL_MS;
        var ticks = 0;
        logger.verbose("monitorWindowForHash polling started");
        var intervalId = setInterval(function() {
          if (contentWindow.closed) {
            logger.error("monitorWindowForHash window closed");
            clearInterval(intervalId);
            reject(ClientAuthError.createUserCancelledError());
            return;
          }
          var href;
          try {
            href = contentWindow.location.href;
          } catch (e) {
          }
          if (!href || href === "about:blank") {
            return;
          }
          ticks++;
          if (href && UrlUtils.urlContainsHash(href)) {
            logger.verbose("monitorPopupForHash found url in hash");
            clearInterval(intervalId);
            var hash = contentWindow.location.hash;
            WindowUtils2.clearUrlFragment(contentWindow);
            resolve(hash);
          } else if (ticks > maxTicks) {
            logger.error("monitorPopupForHash unable to find hash in url, timing out");
            logger.errorPii("monitorPopupForHash polling timed out for url: " + urlNavigate);
            clearInterval(intervalId);
            reject(ClientAuthError.createTokenRenewalTimeoutError());
          }
        }, WindowUtils2.POLLING_INTERVAL_MS);
      });
    };
    WindowUtils2.loadFrame = function(urlNavigate, frameName, timeoutMs, logger) {
      var _this = this;
      logger.infoPii("LoadFrame: " + frameName);
      return new Promise(function(resolve, reject) {
        setTimeout(function() {
          var frameHandle = _this.loadFrameSync(urlNavigate, frameName, logger);
          if (!frameHandle) {
            reject("Unable to load iframe with name: " + frameName);
            return;
          }
          resolve(frameHandle);
        }, timeoutMs);
      });
    };
    WindowUtils2.loadFrameSync = function(urlNavigate, frameName, logger) {
      var frameHandle = WindowUtils2.addHiddenIFrame(frameName, logger);
      if (!frameHandle) {
        return null;
      } else if (frameHandle.src === "" || frameHandle.src === "about:blank") {
        frameHandle.src = urlNavigate;
        logger.infoPii("Frame Name : " + frameName + " Navigated to: " + urlNavigate);
      }
      return frameHandle;
    };
    WindowUtils2.addHiddenIFrame = function(iframeId, logger) {
      if (typeof iframeId === "undefined") {
        return null;
      }
      logger.info("Add msal iframe to document");
      logger.infoPii("Add msal frame to document:" + iframeId);
      var adalFrame = document.getElementById(iframeId);
      if (!adalFrame) {
        logger.verbose("Add msal iframe does not exist");
        var ifr = document.createElement("iframe");
        ifr.setAttribute("id", iframeId);
        ifr.setAttribute("aria-hidden", "true");
        ifr.style.visibility = "hidden";
        ifr.style.position = "absolute";
        ifr.style.width = ifr.style.height = "0";
        ifr.style.border = "0";
        ifr.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
        adalFrame = document.getElementsByTagName("body")[0].appendChild(ifr);
      } else {
        logger.verbose("Add msal iframe already exists");
      }
      return adalFrame;
    };
    WindowUtils2.removeHiddenIframe = function(iframe) {
      if (document.body === iframe.parentNode) {
        document.body.removeChild(iframe);
      }
    };
    WindowUtils2.getIframeWithHash = function(hash) {
      var iframes = document.getElementsByTagName("iframe");
      var iframeArray = Array.apply(null, Array(iframes.length)).map(function(iframe, index) {
        return iframes.item(index);
      });
      return iframeArray.filter(function(iframe) {
        try {
          return iframe.contentWindow.location.hash === hash;
        } catch (e) {
          return false;
        }
      })[0];
    };
    WindowUtils2.getPopups = function() {
      if (!window.openedWindows) {
        window.openedWindows = [];
      }
      return window.openedWindows;
    };
    WindowUtils2.getPopUpWithHash = function(hash) {
      return WindowUtils2.getPopups().filter(function(popup) {
        try {
          return popup.location.hash === hash;
        } catch (e) {
          return false;
        }
      })[0];
    };
    WindowUtils2.trackPopup = function(popup) {
      WindowUtils2.getPopups().push(popup);
    };
    WindowUtils2.closePopups = function() {
      WindowUtils2.getPopups().forEach(function(popup) {
        return popup.close();
      });
    };
    WindowUtils2.blockReloadInHiddenIframes = function() {
      if (UrlUtils.urlContainsHash(window.location.hash) && WindowUtils2.isInIframe()) {
        throw ClientAuthError.createBlockTokenRequestsInHiddenIframeError();
      }
    };
    WindowUtils2.checkIfBackButtonIsPressed = function(cacheStorage) {
      var redirectCache = cacheStorage.getItem(TemporaryCacheKeys.REDIRECT_REQUEST);
      if (redirectCache && !UrlUtils.urlContainsHash(window.location.hash)) {
        var splitCache = redirectCache.split(Constants.resourceDelimiter);
        splitCache.shift();
        var state2 = splitCache.length > 0 ? splitCache.join(Constants.resourceDelimiter) : null;
        cacheStorage.resetTempCacheItems(state2);
      }
    };
    WindowUtils2.clearUrlFragment = function(contentWindow) {
      contentWindow.location.hash = "";
      if (typeof contentWindow.history.replaceState === "function") {
        contentWindow.history.replaceState(null, null, "" + contentWindow.location.pathname + contentWindow.location.search);
      }
    };
    WindowUtils2.POLLING_INTERVAL_MS = 50;
    return WindowUtils2;
  }()
);

// node_modules/msal/lib-es6/utils/ResponseUtils.js
var ResponseUtils = (
  /** @class */
  function() {
    function ResponseUtils2() {
    }
    ResponseUtils2.setResponseIdToken = function(originalResponse, idTokenObj) {
      if (!originalResponse) {
        return null;
      } else if (!idTokenObj) {
        return originalResponse;
      }
      var exp = Number(idTokenObj.expiration);
      if (exp && !originalResponse.expiresOn) {
        originalResponse.expiresOn = new Date(exp * 1e3);
      }
      return __assign(__assign({}, originalResponse), { idToken: idTokenObj, idTokenClaims: idTokenObj.claims, uniqueId: idTokenObj.objectId || idTokenObj.subject, tenantId: idTokenObj.tenantId });
    };
    ResponseUtils2.buildAuthResponse = function(idToken, authResponse, serverAuthenticationRequest, account, scopes, accountState) {
      switch (serverAuthenticationRequest.responseType) {
        case ResponseTypes.id_token:
          var idTokenResponse = __assign(__assign({}, authResponse), { tokenType: ServerHashParamKeys.ID_TOKEN, account, scopes, accountState });
          idTokenResponse = ResponseUtils2.setResponseIdToken(idTokenResponse, idToken);
          return idTokenResponse.idToken ? idTokenResponse : null;
        case ResponseTypes.id_token_token:
          var idTokeTokenResponse = ResponseUtils2.setResponseIdToken(authResponse, idToken);
          return idTokeTokenResponse && idTokeTokenResponse.accessToken && idTokeTokenResponse.idToken ? idTokeTokenResponse : null;
        case ResponseTypes.token:
          var tokenResponse = ResponseUtils2.setResponseIdToken(authResponse, idToken);
          return tokenResponse;
        default:
          return null;
      }
    };
    return ResponseUtils2;
  }()
);

// node_modules/msal/lib-es6/authority/AuthorityFactory.js
var AuthorityFactory = (
  /** @class */
  function() {
    function AuthorityFactory2() {
    }
    AuthorityFactory2.saveMetadataFromNetwork = function(authorityInstance, telemetryManager, correlationId) {
      return __awaiter2(this, void 0, void 0, function() {
        var metadata;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, authorityInstance.resolveEndpointsAsync(telemetryManager, correlationId)];
            case 1:
              metadata = _a3.sent();
              this.metadataMap.set(authorityInstance.CanonicalAuthority, metadata);
              return [2, metadata];
          }
        });
      });
    };
    AuthorityFactory2.getMetadata = function(authorityUrl) {
      return this.metadataMap.get(authorityUrl);
    };
    AuthorityFactory2.saveMetadataFromConfig = function(authorityUrl, authorityMetadataJson) {
      try {
        if (authorityMetadataJson) {
          var parsedMetadata = JSON.parse(authorityMetadataJson);
          if (!parsedMetadata.authorization_endpoint || !parsedMetadata.end_session_endpoint || !parsedMetadata.issuer) {
            throw ClientConfigurationError.createInvalidAuthorityMetadataError();
          }
          this.metadataMap.set(authorityUrl, {
            AuthorizationEndpoint: parsedMetadata.authorization_endpoint,
            EndSessionEndpoint: parsedMetadata.end_session_endpoint,
            Issuer: parsedMetadata.issuer
          });
        }
      } catch (e) {
        throw ClientConfigurationError.createInvalidAuthorityMetadataError();
      }
    };
    AuthorityFactory2.CreateInstance = function(authorityUrl, validateAuthority, authorityMetadata) {
      if (StringUtils.isEmpty(authorityUrl)) {
        return null;
      }
      if (authorityMetadata) {
        this.saveMetadataFromConfig(authorityUrl, authorityMetadata);
      }
      return new Authority(authorityUrl, validateAuthority, this.metadataMap.get(authorityUrl));
    };
    AuthorityFactory2.metadataMap = /* @__PURE__ */ new Map();
    return AuthorityFactory2;
  }()
);

// node_modules/msal/lib-es6/Logger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
})(LogLevel || (LogLevel = {}));
var Logger = (
  /** @class */
  function() {
    function Logger2(localCallback, options) {
      if (options === void 0) {
        options = {};
      }
      this.level = LogLevel.Info;
      var _a3 = options.correlationId, correlationId = _a3 === void 0 ? "" : _a3, _b = options.level, level = _b === void 0 ? LogLevel.Info : _b, _c = options.piiLoggingEnabled, piiLoggingEnabled = _c === void 0 ? false : _c;
      this.localCallback = localCallback;
      this.correlationId = correlationId;
      this.level = level;
      this.piiLoggingEnabled = piiLoggingEnabled;
    }
    Logger2.prototype.logMessage = function(logLevel, logMessage, containsPii) {
      if (logLevel > this.level || !this.piiLoggingEnabled && containsPii) {
        return;
      }
      var timestamp = new Date().toUTCString();
      var log;
      if (!StringUtils.isEmpty(this.correlationId)) {
        log = timestamp + ":" + this.correlationId + "-" + version + "-" + LogLevel[logLevel] + (containsPii ? "-pii" : "") + " " + logMessage;
      } else {
        log = timestamp + ":" + version + "-" + LogLevel[logLevel] + (containsPii ? "-pii" : "") + " " + logMessage;
      }
      this.executeCallback(logLevel, log, containsPii);
    };
    Logger2.prototype.executeCallback = function(level, message, containsPii) {
      if (this.localCallback) {
        this.localCallback(level, message, containsPii);
      }
    };
    Logger2.prototype.error = function(message) {
      this.logMessage(LogLevel.Error, message, false);
    };
    Logger2.prototype.errorPii = function(message) {
      this.logMessage(LogLevel.Error, message, true);
    };
    Logger2.prototype.warning = function(message) {
      this.logMessage(LogLevel.Warning, message, false);
    };
    Logger2.prototype.warningPii = function(message) {
      this.logMessage(LogLevel.Warning, message, true);
    };
    Logger2.prototype.info = function(message) {
      this.logMessage(LogLevel.Info, message, false);
    };
    Logger2.prototype.infoPii = function(message) {
      this.logMessage(LogLevel.Info, message, true);
    };
    Logger2.prototype.verbose = function(message) {
      this.logMessage(LogLevel.Verbose, message, false);
    };
    Logger2.prototype.verbosePii = function(message) {
      this.logMessage(LogLevel.Verbose, message, true);
    };
    Logger2.prototype.isPiiLoggingEnabled = function() {
      return this.piiLoggingEnabled;
    };
    return Logger2;
  }()
);

// node_modules/msal/lib-es6/Configuration.js
var FRAME_TIMEOUT = 6e3;
var OFFSET = 300;
var NAVIGATE_FRAME_WAIT = 500;
var DEFAULT_AUTH_OPTIONS = {
  clientId: "",
  authority: null,
  validateAuthority: true,
  authorityMetadata: "",
  knownAuthorities: [],
  redirectUri: function() {
    return UrlUtils.getCurrentUrl();
  },
  postLogoutRedirectUri: function() {
    return UrlUtils.getCurrentUrl();
  },
  navigateToLoginRequestUrl: true
};
var DEFAULT_CACHE_OPTIONS = {
  cacheLocation: "sessionStorage",
  storeAuthStateInCookie: false
};
var DEFAULT_SYSTEM_OPTIONS = {
  logger: new Logger(null),
  loadFrameTimeout: FRAME_TIMEOUT,
  tokenRenewalOffsetSeconds: OFFSET,
  navigateFrameWait: NAVIGATE_FRAME_WAIT
};
var DEFAULT_FRAMEWORK_OPTIONS = {
  isAngular: false,
  unprotectedResources: new Array(),
  protectedResourceMap: /* @__PURE__ */ new Map()
};
function buildConfiguration(_a3) {
  var auth = _a3.auth, _b = _a3.cache, cache = _b === void 0 ? {} : _b, _c = _a3.system, system = _c === void 0 ? {} : _c, _d = _a3.framework, framework = _d === void 0 ? {} : _d;
  var overlayedConfig = {
    auth: __assign(__assign({}, DEFAULT_AUTH_OPTIONS), auth),
    cache: __assign(__assign({}, DEFAULT_CACHE_OPTIONS), cache),
    system: __assign(__assign({}, DEFAULT_SYSTEM_OPTIONS), system),
    framework: __assign(__assign({}, DEFAULT_FRAMEWORK_OPTIONS), framework)
  };
  return overlayedConfig;
}

// node_modules/msal/lib-es6/error/ServerError.js
var ServerErrorMessage = {
  serverUnavailable: {
    code: "server_unavailable",
    desc: "Server is temporarily unavailable."
  },
  unknownServerError: {
    code: "unknown_server_error"
  }
};
var ServerError = (
  /** @class */
  function(_super) {
    __extends(ServerError2, _super);
    function ServerError2(errorCode, errorMessage) {
      var _this = _super.call(this, errorCode, errorMessage) || this;
      _this.name = "ServerError";
      Object.setPrototypeOf(_this, ServerError2.prototype);
      return _this;
    }
    ServerError2.createServerUnavailableError = function() {
      return new ServerError2(ServerErrorMessage.serverUnavailable.code, ServerErrorMessage.serverUnavailable.desc);
    };
    ServerError2.createUnknownServerError = function(errorDesc) {
      return new ServerError2(ServerErrorMessage.unknownServerError.code, errorDesc);
    };
    return ServerError2;
  }(AuthError)
);

// node_modules/msal/lib-es6/error/InteractionRequiredAuthError.js
var InteractionRequiredAuthErrorMessage = {
  interactionRequired: {
    code: "interaction_required"
  },
  consentRequired: {
    code: "consent_required"
  },
  loginRequired: {
    code: "login_required"
  }
};
var InteractionRequiredAuthError = (
  /** @class */
  function(_super) {
    __extends(InteractionRequiredAuthError2, _super);
    function InteractionRequiredAuthError2(errorCode, errorMessage) {
      var _this = _super.call(this, errorCode, errorMessage) || this;
      _this.name = "InteractionRequiredAuthError";
      Object.setPrototypeOf(_this, InteractionRequiredAuthError2.prototype);
      return _this;
    }
    InteractionRequiredAuthError2.isInteractionRequiredError = function(errorString) {
      var interactionRequiredCodes = [
        InteractionRequiredAuthErrorMessage.interactionRequired.code,
        InteractionRequiredAuthErrorMessage.consentRequired.code,
        InteractionRequiredAuthErrorMessage.loginRequired.code
      ];
      return errorString && interactionRequiredCodes.indexOf(errorString) > -1;
    };
    InteractionRequiredAuthError2.createLoginRequiredAuthError = function(errorDesc) {
      return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.loginRequired.code, errorDesc);
    };
    InteractionRequiredAuthError2.createInteractionRequiredAuthError = function(errorDesc) {
      return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.interactionRequired.code, errorDesc);
    };
    InteractionRequiredAuthError2.createConsentRequiredAuthError = function(errorDesc) {
      return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.consentRequired.code, errorDesc);
    };
    return InteractionRequiredAuthError2;
  }(ServerError)
);

// node_modules/msal/lib-es6/AuthResponse.js
function buildResponseStateOnly(state2) {
  return {
    uniqueId: "",
    tenantId: "",
    tokenType: "",
    idToken: null,
    idTokenClaims: null,
    accessToken: "",
    scopes: null,
    expiresOn: null,
    account: null,
    accountState: state2,
    fromCache: false
  };
}

// node_modules/msal/lib-es6/telemetry/TelemetryConstants.js
var EVENT_NAME_PREFIX = "msal.";
var EVENT_NAME_KEY = "event_name";
var START_TIME_KEY = "start_time";
var ELAPSED_TIME_KEY = "elapsed_time";
var TELEMETRY_BLOB_EVENT_NAMES = {
  MsalCorrelationIdConstStrKey: "Microsoft.MSAL.correlation_id",
  ApiTelemIdConstStrKey: "msal.api_telem_id",
  ApiIdConstStrKey: "msal.api_id",
  BrokerAppConstStrKey: "Microsoft_MSAL_broker_app",
  CacheEventCountConstStrKey: "Microsoft_MSAL_cache_event_count",
  HttpEventCountTelemetryBatchKey: "Microsoft_MSAL_http_event_count",
  IdpConstStrKey: "Microsoft_MSAL_idp",
  IsSilentTelemetryBatchKey: "",
  IsSuccessfulConstStrKey: "Microsoft_MSAL_is_successful",
  ResponseTimeConstStrKey: "Microsoft_MSAL_response_time",
  TenantIdConstStrKey: "Microsoft_MSAL_tenant_id",
  UiEventCountTelemetryBatchKey: "Microsoft_MSAL_ui_event_count"
};
var TENANT_PLACEHOLDER = "<tenant>";

// node_modules/msal/lib-es6/telemetry/TelemetryUtils.js
var scrubTenantFromUri = function(uri) {
  var url = UrlUtils.GetUrlComponents(uri);
  if (Authority.isAdfs(uri)) {
    return uri;
  }
  var pathParams = url.PathSegments;
  if (pathParams && pathParams.length >= 2) {
    var tenantPosition = pathParams[1] === "tfp" ? 2 : 1;
    if (tenantPosition < pathParams.length) {
      pathParams[tenantPosition] = TENANT_PLACEHOLDER;
    }
  }
  return url.Protocol + "//" + url.HostNameAndPort + "/" + pathParams.join("/");
};
var hashPersonalIdentifier = function(valueToHash) {
  return CryptoUtils.base64Encode(valueToHash);
};
var prependEventNamePrefix = function(suffix) {
  return "" + EVENT_NAME_PREFIX + (suffix || "");
};
var supportsBrowserPerformance = function() {
  return !!(typeof window !== "undefined" && "performance" in window && window.performance.mark && window.performance.measure);
};
var endBrowserPerformanceMeasurement = function(measureName, startMark, endMark) {
  if (supportsBrowserPerformance()) {
    window.performance.mark(endMark);
    window.performance.measure(measureName, startMark, endMark);
    window.performance.clearMeasures(measureName);
    window.performance.clearMarks(startMark);
    window.performance.clearMarks(endMark);
  }
};
var startBrowserPerformanceMeasurement = function(startMark) {
  if (supportsBrowserPerformance()) {
    window.performance.mark(startMark);
  }
};

// node_modules/msal/lib-es6/telemetry/TelemetryEvent.js
var TelemetryEvent = (
  /** @class */
  function() {
    function TelemetryEvent2(eventName, correlationId, eventLabel) {
      var _a3;
      this.eventId = CryptoUtils.createNewGuid();
      this.label = eventLabel;
      this.event = (_a3 = {}, _a3[prependEventNamePrefix(EVENT_NAME_KEY)] = eventName, _a3[prependEventNamePrefix(ELAPSED_TIME_KEY)] = -1, _a3["" + TELEMETRY_BLOB_EVENT_NAMES.MsalCorrelationIdConstStrKey] = correlationId, _a3);
    }
    TelemetryEvent2.prototype.setElapsedTime = function(time) {
      this.event[prependEventNamePrefix(ELAPSED_TIME_KEY)] = time;
    };
    TelemetryEvent2.prototype.stop = function() {
      this.setElapsedTime(+Date.now() - +this.startTimestamp);
      endBrowserPerformanceMeasurement(this.displayName, this.perfStartMark, this.perfEndMark);
    };
    TelemetryEvent2.prototype.start = function() {
      this.startTimestamp = Date.now();
      this.event[prependEventNamePrefix(START_TIME_KEY)] = this.startTimestamp;
      startBrowserPerformanceMeasurement(this.perfStartMark);
    };
    Object.defineProperty(TelemetryEvent2.prototype, "telemetryCorrelationId", {
      get: function() {
        return this.event["" + TELEMETRY_BLOB_EVENT_NAMES.MsalCorrelationIdConstStrKey];
      },
      set: function(value) {
        this.event["" + TELEMETRY_BLOB_EVENT_NAMES.MsalCorrelationIdConstStrKey] = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TelemetryEvent2.prototype, "eventName", {
      get: function() {
        return this.event[prependEventNamePrefix(EVENT_NAME_KEY)];
      },
      enumerable: false,
      configurable: true
    });
    TelemetryEvent2.prototype.get = function() {
      return __assign(__assign({}, this.event), { eventId: this.eventId });
    };
    Object.defineProperty(TelemetryEvent2.prototype, "key", {
      get: function() {
        return this.telemetryCorrelationId + "_" + this.eventId + "-" + this.eventName;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TelemetryEvent2.prototype, "displayName", {
      get: function() {
        return "Msal-" + this.label + "-" + this.telemetryCorrelationId;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TelemetryEvent2.prototype, "perfStartMark", {
      get: function() {
        return "start-" + this.key;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TelemetryEvent2.prototype, "perfEndMark", {
      get: function() {
        return "end-" + this.key;
      },
      enumerable: false,
      configurable: true
    });
    return TelemetryEvent2;
  }()
);
var TelemetryEvent_default = TelemetryEvent;

// node_modules/msal/lib-es6/telemetry/DefaultEvent.js
var DefaultEvent = (
  /** @class */
  function(_super) {
    __extends(DefaultEvent2, _super);
    function DefaultEvent2(platform, correlationId, clientId, eventCount) {
      var _this = _super.call(this, prependEventNamePrefix("default_event"), correlationId, "DefaultEvent") || this;
      _this.event[prependEventNamePrefix("client_id")] = clientId;
      _this.event[prependEventNamePrefix("sdk_plaform")] = platform.sdk;
      _this.event[prependEventNamePrefix("sdk_version")] = platform.sdkVersion;
      _this.event[prependEventNamePrefix("application_name")] = platform.applicationName;
      _this.event[prependEventNamePrefix("application_version")] = platform.applicationVersion;
      _this.event[prependEventNamePrefix("effective_connection_speed")] = platform.networkInformation && platform.networkInformation.connectionSpeed;
      _this.event["" + TELEMETRY_BLOB_EVENT_NAMES.UiEventCountTelemetryBatchKey] = _this.getEventCount(prependEventNamePrefix("ui_event"), eventCount);
      _this.event["" + TELEMETRY_BLOB_EVENT_NAMES.HttpEventCountTelemetryBatchKey] = _this.getEventCount(prependEventNamePrefix("http_event"), eventCount);
      _this.event["" + TELEMETRY_BLOB_EVENT_NAMES.CacheEventCountConstStrKey] = _this.getEventCount(prependEventNamePrefix("cache_event"), eventCount);
      return _this;
    }
    DefaultEvent2.prototype.getEventCount = function(eventName, eventCount) {
      if (!eventCount[eventName]) {
        return 0;
      }
      return eventCount[eventName];
    };
    return DefaultEvent2;
  }(TelemetryEvent_default)
);
var DefaultEvent_default = DefaultEvent;

// node_modules/msal/lib-es6/telemetry/ApiEvent.js
var _a;
var EVENT_KEYS = {
  AUTHORITY: prependEventNamePrefix("authority"),
  AUTHORITY_TYPE: prependEventNamePrefix("authority_type"),
  PROMPT: prependEventNamePrefix("ui_behavior"),
  TENANT_ID: prependEventNamePrefix("tenant_id"),
  USER_ID: prependEventNamePrefix("user_id"),
  WAS_SUCESSFUL: prependEventNamePrefix("was_successful"),
  API_ERROR_CODE: prependEventNamePrefix("api_error_code"),
  LOGIN_HINT: prependEventNamePrefix("login_hint")
};
var API_CODE;
(function(API_CODE2) {
  API_CODE2[API_CODE2["AcquireTokenRedirect"] = 2001] = "AcquireTokenRedirect";
  API_CODE2[API_CODE2["AcquireTokenSilent"] = 2002] = "AcquireTokenSilent";
  API_CODE2[API_CODE2["AcquireTokenPopup"] = 2003] = "AcquireTokenPopup";
  API_CODE2[API_CODE2["LoginRedirect"] = 2004] = "LoginRedirect";
  API_CODE2[API_CODE2["LoginPopup"] = 2005] = "LoginPopup";
  API_CODE2[API_CODE2["Logout"] = 2006] = "Logout";
})(API_CODE || (API_CODE = {}));
var API_EVENT_IDENTIFIER;
(function(API_EVENT_IDENTIFIER2) {
  API_EVENT_IDENTIFIER2["AcquireTokenRedirect"] = "AcquireTokenRedirect";
  API_EVENT_IDENTIFIER2["AcquireTokenSilent"] = "AcquireTokenSilent";
  API_EVENT_IDENTIFIER2["AcquireTokenPopup"] = "AcquireTokenPopup";
  API_EVENT_IDENTIFIER2["LoginRedirect"] = "LoginRedirect";
  API_EVENT_IDENTIFIER2["LoginPopup"] = "LoginPopup";
  API_EVENT_IDENTIFIER2["Logout"] = "Logout";
})(API_EVENT_IDENTIFIER || (API_EVENT_IDENTIFIER = {}));
var mapEventIdentiferToCode = (_a = {}, _a[API_EVENT_IDENTIFIER.AcquireTokenSilent] = API_CODE.AcquireTokenSilent, _a[API_EVENT_IDENTIFIER.AcquireTokenPopup] = API_CODE.AcquireTokenPopup, _a[API_EVENT_IDENTIFIER.AcquireTokenRedirect] = API_CODE.AcquireTokenRedirect, _a[API_EVENT_IDENTIFIER.LoginPopup] = API_CODE.LoginPopup, _a[API_EVENT_IDENTIFIER.LoginRedirect] = API_CODE.LoginRedirect, _a[API_EVENT_IDENTIFIER.Logout] = API_CODE.Logout, _a);
var ApiEvent = (
  /** @class */
  function(_super) {
    __extends(ApiEvent2, _super);
    function ApiEvent2(correlationId, piiEnabled, apiEventIdentifier) {
      var _this = _super.call(this, prependEventNamePrefix("api_event"), correlationId, apiEventIdentifier) || this;
      if (apiEventIdentifier) {
        _this.apiCode = mapEventIdentiferToCode[apiEventIdentifier];
        _this.apiEventIdentifier = apiEventIdentifier;
      }
      _this.piiEnabled = piiEnabled;
      return _this;
    }
    Object.defineProperty(ApiEvent2.prototype, "apiEventIdentifier", {
      set: function(apiEventIdentifier) {
        this.event[TELEMETRY_BLOB_EVENT_NAMES.ApiTelemIdConstStrKey] = apiEventIdentifier;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "apiCode", {
      set: function(apiCode) {
        this.event[TELEMETRY_BLOB_EVENT_NAMES.ApiIdConstStrKey] = apiCode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "authority", {
      set: function(uri) {
        this.event[EVENT_KEYS.AUTHORITY] = scrubTenantFromUri(uri).toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "apiErrorCode", {
      set: function(errorCode) {
        this.event[EVENT_KEYS.API_ERROR_CODE] = errorCode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "tenantId", {
      set: function(tenantId) {
        this.event[EVENT_KEYS.TENANT_ID] = this.piiEnabled && tenantId ? hashPersonalIdentifier(tenantId) : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "accountId", {
      set: function(accountId) {
        this.event[EVENT_KEYS.USER_ID] = this.piiEnabled && accountId ? hashPersonalIdentifier(accountId) : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "wasSuccessful", {
      get: function() {
        return this.event[EVENT_KEYS.WAS_SUCESSFUL] === true;
      },
      set: function(wasSuccessful) {
        this.event[EVENT_KEYS.WAS_SUCESSFUL] = wasSuccessful;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "loginHint", {
      set: function(loginHint) {
        this.event[EVENT_KEYS.LOGIN_HINT] = this.piiEnabled && loginHint ? hashPersonalIdentifier(loginHint) : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "authorityType", {
      set: function(authorityType) {
        this.event[EVENT_KEYS.AUTHORITY_TYPE] = authorityType.toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ApiEvent2.prototype, "promptType", {
      set: function(promptType) {
        this.event[EVENT_KEYS.PROMPT] = promptType.toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    return ApiEvent2;
  }(TelemetryEvent_default)
);
var ApiEvent_default = ApiEvent;

// node_modules/msal/lib-es6/telemetry/HttpEvent.js
var EVENT_KEYS2 = {
  HTTP_PATH: prependEventNamePrefix("http_path"),
  USER_AGENT: prependEventNamePrefix("user_agent"),
  QUERY_PARAMETERS: prependEventNamePrefix("query_parameters"),
  API_VERSION: prependEventNamePrefix("api_version"),
  RESPONSE_CODE: prependEventNamePrefix("response_code"),
  O_AUTH_ERROR_CODE: prependEventNamePrefix("oauth_error_code"),
  HTTP_METHOD: prependEventNamePrefix("http_method"),
  REQUEST_ID_HEADER: prependEventNamePrefix("request_id_header"),
  SPE_INFO: prependEventNamePrefix("spe_info"),
  SERVER_ERROR_CODE: prependEventNamePrefix("server_error_code"),
  SERVER_SUB_ERROR_CODE: prependEventNamePrefix("server_sub_error_code"),
  URL: prependEventNamePrefix("url")
};
var HttpEvent = (
  /** @class */
  function(_super) {
    __extends(HttpEvent2, _super);
    function HttpEvent2(correlationId, eventLabel) {
      return _super.call(this, prependEventNamePrefix("http_event"), correlationId, eventLabel) || this;
    }
    Object.defineProperty(HttpEvent2.prototype, "url", {
      set: function(url) {
        var scrubbedUri = scrubTenantFromUri(url);
        this.event[EVENT_KEYS2.URL] = scrubbedUri && scrubbedUri.toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "httpPath", {
      set: function(httpPath) {
        this.event[EVENT_KEYS2.HTTP_PATH] = scrubTenantFromUri(httpPath).toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "userAgent", {
      set: function(userAgent) {
        this.event[EVENT_KEYS2.USER_AGENT] = userAgent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "queryParams", {
      set: function(queryParams) {
        this.event[EVENT_KEYS2.QUERY_PARAMETERS] = ServerRequestParameters.generateQueryParametersString(queryParams);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "apiVersion", {
      set: function(apiVersion) {
        this.event[EVENT_KEYS2.API_VERSION] = apiVersion.toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "httpResponseStatus", {
      set: function(statusCode) {
        this.event[EVENT_KEYS2.RESPONSE_CODE] = statusCode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "oAuthErrorCode", {
      set: function(errorCode) {
        this.event[EVENT_KEYS2.O_AUTH_ERROR_CODE] = errorCode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "httpMethod", {
      set: function(httpMethod) {
        this.event[EVENT_KEYS2.HTTP_METHOD] = httpMethod;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "requestIdHeader", {
      set: function(requestIdHeader) {
        this.event[EVENT_KEYS2.REQUEST_ID_HEADER] = requestIdHeader;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "speInfo", {
      /**
       * Indicates whether the request was executed on a ring serving SPE traffic.
       * An empty string indicates this occurred on an outer ring, and the string "I"
       * indicates the request occurred on the inner ring
       */
      set: function(speInfo) {
        this.event[EVENT_KEYS2.SPE_INFO] = speInfo;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "serverErrorCode", {
      set: function(errorCode) {
        this.event[EVENT_KEYS2.SERVER_ERROR_CODE] = errorCode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HttpEvent2.prototype, "serverSubErrorCode", {
      set: function(subErrorCode) {
        this.event[EVENT_KEYS2.SERVER_SUB_ERROR_CODE] = subErrorCode;
      },
      enumerable: false,
      configurable: true
    });
    return HttpEvent2;
  }(TelemetryEvent_default)
);
var HttpEvent_default = HttpEvent;

// node_modules/msal/lib-es6/telemetry/TelemetryManager.js
var TelemetryManager = (
  /** @class */
  function() {
    function TelemetryManager2(config, telemetryEmitter, logger) {
      this.completedEvents = {};
      this.inProgressEvents = {};
      this.eventCountByCorrelationId = {};
      this.onlySendFailureTelemetry = false;
      this.telemetryPlatform = __assign({ sdk: Constants.libraryName, sdkVersion: version, networkInformation: {
        // @ts-ignore
        connectionSpeed: typeof navigator !== "undefined" && navigator.connection && navigator.connection.effectiveType
      } }, config.platform);
      this.clientId = config.clientId;
      this.onlySendFailureTelemetry = config.onlySendFailureTelemetry;
      this.telemetryEmitter = telemetryEmitter;
      this.logger = logger;
    }
    TelemetryManager2.getTelemetrymanagerStub = function(clientId, logger) {
      var applicationName = "UnSetStub";
      var applicationVersion = "0.0";
      var telemetryEmitter = function() {
      };
      var telemetryPlatform = {
        applicationName,
        applicationVersion
      };
      var telemetryManagerConfig = {
        platform: telemetryPlatform,
        clientId
      };
      return new this(telemetryManagerConfig, telemetryEmitter, logger);
    };
    TelemetryManager2.prototype.startEvent = function(event) {
      this.logger.verbose("Telemetry Event started: " + event.key);
      if (!this.telemetryEmitter) {
        return;
      }
      event.start();
      this.inProgressEvents[event.key] = event;
    };
    TelemetryManager2.prototype.stopEvent = function(event) {
      this.logger.verbose("Telemetry Event stopped: " + event.key);
      if (!this.telemetryEmitter || !this.inProgressEvents[event.key]) {
        return;
      }
      event.stop();
      this.incrementEventCount(event);
      var completedEvents = this.completedEvents[event.telemetryCorrelationId];
      this.completedEvents[event.telemetryCorrelationId] = __spreadArrays(completedEvents || [], [event]);
      delete this.inProgressEvents[event.key];
    };
    TelemetryManager2.prototype.flush = function(correlationId) {
      var _this = this;
      this.logger.verbose("Flushing telemetry events: " + correlationId);
      if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {
        return;
      }
      var orphanedEvents = this.getOrphanedEvents(correlationId);
      orphanedEvents.forEach(function(event) {
        return _this.incrementEventCount(event);
      });
      var eventsToFlush = __spreadArrays(this.completedEvents[correlationId], orphanedEvents);
      delete this.completedEvents[correlationId];
      var eventCountsToFlush = this.eventCountByCorrelationId[correlationId];
      delete this.eventCountByCorrelationId[correlationId];
      if (!eventsToFlush || !eventsToFlush.length) {
        return;
      }
      var defaultEvent = new DefaultEvent_default(this.telemetryPlatform, correlationId, this.clientId, eventCountsToFlush);
      var eventsWithDefaultEvent = __spreadArrays(eventsToFlush, [defaultEvent]);
      this.telemetryEmitter(eventsWithDefaultEvent.map(function(e) {
        return e.get();
      }));
    };
    TelemetryManager2.prototype.createAndStartApiEvent = function(correlationId, apiEventIdentifier) {
      var apiEvent = new ApiEvent_default(correlationId, this.logger.isPiiLoggingEnabled(), apiEventIdentifier);
      this.startEvent(apiEvent);
      return apiEvent;
    };
    TelemetryManager2.prototype.stopAndFlushApiEvent = function(correlationId, apiEvent, wasSuccessful, errorCode) {
      apiEvent.wasSuccessful = wasSuccessful;
      if (errorCode) {
        apiEvent.apiErrorCode = errorCode;
      }
      this.stopEvent(apiEvent);
      this.flush(correlationId);
    };
    TelemetryManager2.prototype.createAndStartHttpEvent = function(correlation, httpMethod, url, eventLabel) {
      var httpEvent = new HttpEvent_default(correlation, eventLabel);
      httpEvent.url = url;
      httpEvent.httpMethod = httpMethod;
      this.startEvent(httpEvent);
      return httpEvent;
    };
    TelemetryManager2.prototype.incrementEventCount = function(event) {
      var _a3;
      var eventName = event.eventName;
      var eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];
      if (!eventCount) {
        this.eventCountByCorrelationId[event.telemetryCorrelationId] = (_a3 = {}, _a3[eventName] = 1, _a3);
      } else {
        eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;
      }
    };
    TelemetryManager2.prototype.getOrphanedEvents = function(correlationId) {
      var _this = this;
      return Object.keys(this.inProgressEvents).reduce(function(memo, eventKey) {
        if (eventKey.indexOf(correlationId) !== -1) {
          var event_1 = _this.inProgressEvents[eventKey];
          delete _this.inProgressEvents[eventKey];
          return __spreadArrays(memo, [event_1]);
        }
        return memo;
      }, []);
    };
    return TelemetryManager2;
  }()
);
var TelemetryManager_default = TelemetryManager;

// node_modules/msal/lib-es6/utils/AuthCacheUtils.js
var AuthCacheUtils = (
  /** @class */
  function() {
    function AuthCacheUtils2() {
    }
    AuthCacheUtils2.filterTokenCacheItemsByScope = function(tokenCacheItems, requestScopes) {
      return tokenCacheItems.filter(function(cacheItem) {
        var cachedScopes = cacheItem.key.scopes.split(" ");
        var searchScopes = ScopeSet.removeDefaultScopes(requestScopes);
        return searchScopes.length === 0 ? ScopeSet.containsScope(cachedScopes, requestScopes) : ScopeSet.containsScope(cachedScopes, searchScopes);
      });
    };
    AuthCacheUtils2.filterTokenCacheItemsByAuthority = function(tokenCacheItems, authority) {
      return tokenCacheItems.filter(function(cacheItem) {
        return UrlUtils.CanonicalizeUri(cacheItem.key.authority) === authority;
      });
    };
    AuthCacheUtils2.filterTokenCacheItemsByDomain = function(tokenCacheItems, requestDomain) {
      return tokenCacheItems.filter(function(cacheItem) {
        var cacheItemDomain = UrlUtils.GetUrlComponents(cacheItem.key.authority).HostNameAndPort;
        return cacheItemDomain === requestDomain;
      });
    };
    return AuthCacheUtils2;
  }()
);

// node_modules/msal/lib-es6/UserAgentApplication.js
var DEFAULT_AUTHORITY2 = "https://login.microsoftonline.com/common";
var UserAgentApplication = (
  /** @class */
  function() {
    function UserAgentApplication2(configuration) {
      this.authResponseCallback = null;
      this.tokenReceivedCallback = null;
      this.errorReceivedCallback = null;
      this.config = buildConfiguration(configuration);
      this.logger = this.config.system.logger;
      this.clientId = this.config.auth.clientId;
      this.inCookie = this.config.cache.storeAuthStateInCookie;
      this.telemetryManager = this.getTelemetryManagerFromConfig(this.config.system.telemetry, this.clientId);
      TrustedAuthority.setTrustedAuthoritiesFromConfig(this.config.auth.validateAuthority, this.config.auth.knownAuthorities);
      AuthorityFactory.saveMetadataFromConfig(this.config.auth.authority, this.config.auth.authorityMetadata);
      this.authority = this.config.auth.authority || DEFAULT_AUTHORITY2;
      this.cacheStorage = new AuthCache(this.clientId, this.config.cache.cacheLocation, this.inCookie);
      if (!window.activeRenewals) {
        window.activeRenewals = {};
      }
      if (!window.renewStates) {
        window.renewStates = [];
      }
      if (!window.callbackMappedToRenewStates) {
        window.callbackMappedToRenewStates = {};
      }
      if (!window.promiseMappedToRenewStates) {
        window.promiseMappedToRenewStates = {};
      }
      window.msal = this;
      var urlHash = window.location.hash;
      var urlContainsHash = UrlUtils.urlContainsHash(urlHash);
      WindowUtils.checkIfBackButtonIsPressed(this.cacheStorage);
      if (urlContainsHash && this.cacheStorage.isInteractionInProgress(true)) {
        var stateInfo = this.getResponseState(urlHash);
        if (stateInfo.method === Constants.interactionTypeRedirect) {
          this.handleRedirectAuthenticationResponse(urlHash);
        }
      }
    }
    Object.defineProperty(UserAgentApplication2.prototype, "authority", {
      /**
       * Method to manage the authority URL.
       *
       * @returns {string} authority
       */
      get: function() {
        return this.authorityInstance.CanonicalAuthority;
      },
      /**
       * setter for the authority URL
       * @param {string} authority
       */
      // If the developer passes an authority, create an instance
      set: function(val) {
        this.authorityInstance = AuthorityFactory.CreateInstance(val, this.config.auth.validateAuthority);
      },
      enumerable: false,
      configurable: true
    });
    UserAgentApplication2.prototype.getAuthorityInstance = function() {
      return this.authorityInstance;
    };
    UserAgentApplication2.prototype.handleRedirectCallback = function(authOrTokenCallback, errorReceivedCallback) {
      if (!authOrTokenCallback) {
        throw ClientConfigurationError.createInvalidCallbackObjectError(authOrTokenCallback);
      }
      if (errorReceivedCallback) {
        this.tokenReceivedCallback = authOrTokenCallback;
        this.errorReceivedCallback = errorReceivedCallback;
        this.logger.warning("This overload for callback is deprecated - please change the format of the callbacks to a single callback as shown: (err: AuthError, response: AuthResponse).");
      } else {
        this.authResponseCallback = authOrTokenCallback;
      }
      if (this.redirectError) {
        this.authErrorHandler(Constants.interactionTypeRedirect, this.redirectError, this.redirectResponse);
      } else if (this.redirectResponse) {
        this.authResponseHandler(Constants.interactionTypeRedirect, this.redirectResponse);
      }
    };
    UserAgentApplication2.prototype.urlContainsHash = function(hash) {
      this.logger.verbose("UrlContainsHash has been called");
      return UrlUtils.urlContainsHash(hash);
    };
    UserAgentApplication2.prototype.authResponseHandler = function(interactionType, response, resolve) {
      this.logger.verbose("AuthResponseHandler has been called");
      this.cacheStorage.setInteractionInProgress(false);
      if (interactionType === Constants.interactionTypeRedirect) {
        this.logger.verbose("Interaction type is redirect");
        if (this.errorReceivedCallback) {
          this.logger.verbose("Two callbacks were provided to handleRedirectCallback, calling success callback with response");
          this.tokenReceivedCallback(response);
        } else if (this.authResponseCallback) {
          this.logger.verbose("One callback was provided to handleRedirectCallback, calling authResponseCallback with response");
          this.authResponseCallback(null, response);
        }
      } else if (interactionType === Constants.interactionTypePopup) {
        this.logger.verbose("Interaction type is popup, resolving");
        resolve(response);
      } else {
        throw ClientAuthError.createInvalidInteractionTypeError();
      }
    };
    UserAgentApplication2.prototype.authErrorHandler = function(interactionType, authErr, response, reject) {
      this.logger.verbose("AuthErrorHandler has been called");
      this.cacheStorage.setInteractionInProgress(false);
      if (interactionType === Constants.interactionTypeRedirect) {
        this.logger.verbose("Interaction type is redirect");
        if (this.errorReceivedCallback) {
          this.logger.verbose("Two callbacks were provided to handleRedirectCallback, calling error callback");
          this.errorReceivedCallback(authErr, response.accountState);
        } else if (this.authResponseCallback) {
          this.logger.verbose("One callback was provided to handleRedirectCallback, calling authResponseCallback with error");
          this.authResponseCallback(authErr, response);
        } else {
          this.logger.verbose("handleRedirectCallback has not been called and no callbacks are registered, throwing error");
          throw authErr;
        }
      } else if (interactionType === Constants.interactionTypePopup) {
        this.logger.verbose("Interaction type is popup, rejecting");
        reject(authErr);
      } else {
        throw ClientAuthError.createInvalidInteractionTypeError();
      }
    };
    UserAgentApplication2.prototype.loginRedirect = function(userRequest) {
      this.logger.verbose("LoginRedirect has been called");
      var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypeRedirect);
      this.acquireTokenInteractive(Constants.interactionTypeRedirect, true, request, null, null);
    };
    UserAgentApplication2.prototype.acquireTokenRedirect = function(userRequest) {
      this.logger.verbose("AcquireTokenRedirect has been called");
      var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeRedirect);
      this.acquireTokenInteractive(Constants.interactionTypeRedirect, false, request, null, null);
    };
    UserAgentApplication2.prototype.loginPopup = function(userRequest) {
      var _this = this;
      this.logger.verbose("LoginPopup has been called");
      var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypePopup);
      var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.LoginPopup);
      return new Promise(function(resolve, reject) {
        _this.acquireTokenInteractive(Constants.interactionTypePopup, true, request, resolve, reject);
      }).then(function(resp) {
        _this.logger.verbose("Successfully logged in");
        _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);
        return resp;
      }).catch(function(error) {
        _this.cacheStorage.resetTempCacheItems(request.state);
        _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);
        throw error;
      });
    };
    UserAgentApplication2.prototype.acquireTokenPopup = function(userRequest) {
      var _this = this;
      this.logger.verbose("AcquireTokenPopup has been called");
      var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypePopup);
      var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenPopup);
      return new Promise(function(resolve, reject) {
        _this.acquireTokenInteractive(Constants.interactionTypePopup, false, request, resolve, reject);
      }).then(function(resp) {
        _this.logger.verbose("Successfully acquired token");
        _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);
        return resp;
      }).catch(function(error) {
        _this.cacheStorage.resetTempCacheItems(request.state);
        _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);
        throw error;
      });
    };
    UserAgentApplication2.prototype.acquireTokenInteractive = function(interactionType, isLoginCall, request, resolve, reject) {
      var _this = this;
      this.logger.verbose("AcquireTokenInteractive has been called");
      WindowUtils.blockReloadInHiddenIframes();
      try {
        this.cacheStorage.setInteractionInProgress(true);
      } catch (e) {
        var thrownError = isLoginCall ? ClientAuthError.createLoginInProgressError() : ClientAuthError.createAcquireTokenInProgressError();
        var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));
        this.cacheStorage.resetTempCacheItems(request.state);
        this.authErrorHandler(interactionType, thrownError, stateOnlyResponse, reject);
        return;
      }
      if (interactionType === Constants.interactionTypeRedirect) {
        this.cacheStorage.setItem(TemporaryCacheKeys.REDIRECT_REQUEST, "" + Constants.inProgress + Constants.resourceDelimiter + request.state);
      }
      var account;
      if (request && request.account && !isLoginCall) {
        account = request.account;
        this.logger.verbose("Account set from request");
      } else {
        account = this.getAccount();
        this.logger.verbose("Account set from MSAL Cache");
      }
      if (!account && !ServerRequestParameters.isSSOParam(request)) {
        if (isLoginCall) {
          var adalIdToken = this.extractADALIdToken();
          if (adalIdToken && !request.scopes) {
            this.logger.info("ADAL's idToken exists. Extracting login information from ADAL's idToken");
            var tokenRequest = this.buildIDTokenRequest(request);
            this.silentLogin = true;
            this.acquireTokenSilent(tokenRequest).then(function(response) {
              _this.silentLogin = false;
              _this.logger.info("Unified cache call is successful");
              _this.authResponseHandler(interactionType, response, resolve);
              return;
            }, function(error) {
              _this.silentLogin = false;
              _this.logger.error("Error occurred during unified cache ATS: " + error);
              _this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);
            });
          } else {
            this.logger.verbose("Login call but no token found, proceed to login");
            this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);
          }
        } else {
          this.logger.verbose("AcquireToken call, no context or account given");
          this.logger.info("User login is required");
          var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));
          this.cacheStorage.resetTempCacheItems(request.state);
          this.authErrorHandler(interactionType, ClientAuthError.createUserLoginRequiredError(), stateOnlyResponse, reject);
          return;
        }
      } else {
        this.logger.verbose("User session exists, login not required");
        this.acquireTokenHelper(account, interactionType, isLoginCall, request, resolve, reject);
      }
    };
    UserAgentApplication2.prototype.acquireTokenHelper = function(account, interactionType, isLoginCall, request, resolve, reject) {
      return __awaiter2(this, void 0, void 0, function() {
        var requestSignature, serverAuthenticationRequest, acquireTokenAuthority, popUpWindow, responseType, loginStartPage, urlNavigate, hash, error_1, navigate, err_1;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              this.logger.verbose("AcquireTokenHelper has been called");
              this.logger.verbose("Interaction type: " + interactionType + ". isLoginCall: " + isLoginCall);
              requestSignature = request.scopes ? request.scopes.join(" ").toLowerCase() : Constants.oidcScopes.join(" ");
              this.logger.verbosePii("Request signature: " + requestSignature);
              acquireTokenAuthority = request && request.authority ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata) : this.authorityInstance;
              _a3.label = 1;
            case 1:
              _a3.trys.push([1, 11, , 12]);
              if (!!acquireTokenAuthority.hasCachedMetadata())
                return [3, 3];
              this.logger.verbose("No cached metadata for authority");
              return [4, AuthorityFactory.saveMetadataFromNetwork(acquireTokenAuthority, this.telemetryManager, request.correlationId)];
            case 2:
              _a3.sent();
              return [3, 4];
            case 3:
              this.logger.verbose("Cached metadata found for authority");
              _a3.label = 4;
            case 4:
              responseType = isLoginCall ? ResponseTypes.id_token : this.getTokenType(account, request.scopes);
              loginStartPage = request.redirectStartPage || window.location.href;
              serverAuthenticationRequest = new ServerRequestParameters(acquireTokenAuthority, this.clientId, responseType, this.getRedirectUri(request && request.redirectUri), request.scopes, request.state, request.correlationId);
              this.logger.verbose("Finished building server authentication request");
              this.updateCacheEntries(serverAuthenticationRequest, account, isLoginCall, loginStartPage);
              this.logger.verbose("Updating cache entries");
              serverAuthenticationRequest.populateQueryParams(account, request);
              this.logger.verbose("Query parameters populated from account");
              urlNavigate = UrlUtils.createNavigateUrl(serverAuthenticationRequest) + Constants.response_mode_fragment;
              if (interactionType === Constants.interactionTypeRedirect) {
                if (!isLoginCall) {
                  this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, request.state), serverAuthenticationRequest.state, this.inCookie);
                  this.logger.verbose("State cached for redirect");
                  this.logger.verbosePii("State cached: " + serverAuthenticationRequest.state);
                } else {
                  this.logger.verbose("Interaction type redirect but login call is true. State not cached");
                }
              } else if (interactionType === Constants.interactionTypePopup) {
                window.renewStates.push(serverAuthenticationRequest.state);
                window.requestType = isLoginCall ? Constants.login : Constants.renewToken;
                this.logger.verbose("State saved to window");
                this.logger.verbosePii("State saved: " + serverAuthenticationRequest.state);
                this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);
              } else {
                this.logger.verbose("Invalid interaction error. State not cached");
                throw ClientAuthError.createInvalidInteractionTypeError();
              }
              if (!(interactionType === Constants.interactionTypePopup))
                return [3, 9];
              this.logger.verbose("Interaction type is popup. Generating popup window");
              try {
                popUpWindow = this.openPopup(urlNavigate, "msal", Constants.popUpWidth, Constants.popUpHeight);
                WindowUtils.trackPopup(popUpWindow);
              } catch (e) {
                this.logger.info(ClientAuthErrorMessage.popUpWindowError.code + ":" + ClientAuthErrorMessage.popUpWindowError.desc);
                this.cacheStorage.setItem(ErrorCacheKeys.ERROR, ClientAuthErrorMessage.popUpWindowError.code);
                this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, ClientAuthErrorMessage.popUpWindowError.desc);
                if (reject) {
                  reject(ClientAuthError.createPopupWindowError());
                  return [
                    2
                    /*return*/
                  ];
                }
              }
              if (!popUpWindow)
                return [3, 8];
              _a3.label = 5;
            case 5:
              _a3.trys.push([5, 7, , 8]);
              return [4, WindowUtils.monitorPopupForHash(popUpWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];
            case 6:
              hash = _a3.sent();
              this.handleAuthenticationResponse(hash);
              this.cacheStorage.setInteractionInProgress(false);
              this.logger.info("Closing popup window");
              if (this.config.framework.isAngular) {
                this.broadcast("msal:popUpHashChanged", hash);
              }
              WindowUtils.closePopups();
              return [3, 8];
            case 7:
              error_1 = _a3.sent();
              if (reject) {
                reject(error_1);
              }
              if (this.config.framework.isAngular) {
                this.broadcast("msal:popUpClosed", error_1.errorCode + Constants.resourceDelimiter + error_1.errorMessage);
              } else {
                this.cacheStorage.setInteractionInProgress(false);
                popUpWindow.close();
              }
              return [3, 8];
            case 8:
              return [3, 10];
            case 9:
              if (request.onRedirectNavigate) {
                this.logger.verbose("Invoking onRedirectNavigate callback");
                navigate = request.onRedirectNavigate(urlNavigate);
                if (navigate !== false) {
                  this.logger.verbose("onRedirectNavigate did not return false, navigating");
                  this.navigateWindow(urlNavigate);
                } else {
                  this.logger.verbose("onRedirectNavigate returned false, stopping navigation");
                }
              } else {
                this.logger.verbose("Navigating window to urlNavigate");
                this.navigateWindow(urlNavigate);
              }
              _a3.label = 10;
            case 10:
              return [3, 12];
            case 11:
              err_1 = _a3.sent();
              this.logger.error(err_1);
              this.cacheStorage.resetTempCacheItems(request.state);
              this.authErrorHandler(interactionType, ClientAuthError.createEndpointResolutionError(err_1.toString), buildResponseStateOnly(request.state), reject);
              if (popUpWindow) {
                popUpWindow.close();
              }
              return [3, 12];
            case 12:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    UserAgentApplication2.prototype.ssoSilent = function(request) {
      this.logger.verbose("ssoSilent has been called");
      if (!request) {
        throw ClientConfigurationError.createEmptyRequestError();
      }
      if (!request.sid && !request.loginHint) {
        throw ClientConfigurationError.createSsoSilentError();
      }
      return this.acquireTokenSilent(__assign(__assign({}, request), { scopes: Constants.oidcScopes }));
    };
    UserAgentApplication2.prototype.acquireTokenSilent = function(userRequest) {
      var _this = this;
      this.logger.verbose("AcquireTokenSilent has been called");
      var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeSilent);
      var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenSilent);
      var requestSignature = RequestUtils.createRequestSignature(request);
      return new Promise(function(resolve, reject) {
        return __awaiter2(_this, void 0, void 0, function() {
          var scope, account, adalIdToken, responseType, serverAuthenticationRequest, adalIdTokenObject, userContainedClaims, authErr, cacheResultResponse, logMessage, err_2;
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                WindowUtils.blockReloadInHiddenIframes();
                scope = request.scopes.join(" ").toLowerCase();
                this.logger.verbosePii("Serialized scopes: " + scope);
                if (request.account) {
                  account = request.account;
                  this.logger.verbose("Account set from request");
                } else {
                  account = this.getAccount();
                  this.logger.verbose("Account set from MSAL Cache");
                }
                adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);
                if (!account && !(request.sid || request.loginHint) && StringUtils.isEmpty(adalIdToken)) {
                  this.logger.info("User login is required");
                  return [2, reject(ClientAuthError.createUserLoginRequiredError())];
                }
                responseType = this.getTokenType(account, request.scopes);
                this.logger.verbose("Response type: " + responseType);
                serverAuthenticationRequest = new ServerRequestParameters(AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata), this.clientId, responseType, this.getRedirectUri(request.redirectUri), request.scopes, request.state, request.correlationId);
                this.logger.verbose("Finished building server authentication request");
                if (ServerRequestParameters.isSSOParam(request) || account) {
                  serverAuthenticationRequest.populateQueryParams(account, request, null, true);
                  this.logger.verbose("Query parameters populated from existing SSO or account");
                } else if (!account && !StringUtils.isEmpty(adalIdToken)) {
                  adalIdTokenObject = TokenUtils.extractIdToken(adalIdToken);
                  this.logger.verbose("ADAL's idToken exists. Extracting login information from ADAL's idToken to populate query parameters");
                  serverAuthenticationRequest.populateQueryParams(account, null, adalIdTokenObject, true);
                } else {
                  this.logger.verbose("No additional query parameters added");
                }
                userContainedClaims = request.claimsRequest || serverAuthenticationRequest.claimsValue;
                if (!userContainedClaims && !request.forceRefresh) {
                  try {
                    cacheResultResponse = this.getCachedToken(serverAuthenticationRequest, account);
                  } catch (e) {
                    authErr = e;
                  }
                }
                if (!cacheResultResponse)
                  return [3, 1];
                this.logger.verbose("Token found in cache lookup");
                this.logger.verbosePii("Scopes found: " + JSON.stringify(cacheResultResponse.scopes));
                resolve(cacheResultResponse);
                return [2, null];
              case 1:
                if (!authErr)
                  return [3, 2];
                this.logger.infoPii(authErr.errorCode + ":" + authErr.errorMessage);
                reject(authErr);
                return [2, null];
              case 2:
                logMessage = void 0;
                if (userContainedClaims) {
                  logMessage = "Skipped cache lookup since claims were given";
                } else if (request.forceRefresh) {
                  logMessage = "Skipped cache lookup since request.forceRefresh option was set to true";
                } else {
                  logMessage = "No valid token found in cache lookup";
                }
                this.logger.verbose(logMessage);
                if (!serverAuthenticationRequest.authorityInstance) {
                  serverAuthenticationRequest.authorityInstance = request.authority ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata) : this.authorityInstance;
                }
                this.logger.verbosePii("Authority instance: " + serverAuthenticationRequest.authority);
                _a3.label = 3;
              case 3:
                _a3.trys.push([3, 7, , 8]);
                if (!!serverAuthenticationRequest.authorityInstance.hasCachedMetadata())
                  return [3, 5];
                this.logger.verbose("No cached metadata for authority");
                return [4, AuthorityFactory.saveMetadataFromNetwork(serverAuthenticationRequest.authorityInstance, this.telemetryManager, request.correlationId)];
              case 4:
                _a3.sent();
                this.logger.verbose("Authority has been updated with endpoint discovery response");
                return [3, 6];
              case 5:
                this.logger.verbose("Cached metadata found for authority");
                _a3.label = 6;
              case 6:
                if (window.activeRenewals[requestSignature]) {
                  this.logger.verbose("Renewing token in progress. Registering callback");
                  this.registerCallback(window.activeRenewals[requestSignature], requestSignature, resolve, reject);
                } else {
                  if (request.scopes && ScopeSet.onlyContainsOidcScopes(request.scopes)) {
                    this.logger.verbose("OpenID Connect scopes only, renewing idToken");
                    this.silentLogin = true;
                    this.renewIdToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);
                  } else {
                    this.logger.verbose("Renewing access token");
                    this.renewToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);
                  }
                }
                return [3, 8];
              case 7:
                err_2 = _a3.sent();
                this.logger.error(err_2);
                reject(ClientAuthError.createEndpointResolutionError(err_2.toString()));
                return [2, null];
              case 8:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }).then(function(res) {
        _this.logger.verbose("Successfully acquired token");
        _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);
        return res;
      }).catch(function(error) {
        _this.cacheStorage.resetTempCacheItems(request.state);
        _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);
        throw error;
      });
    };
    UserAgentApplication2.prototype.openPopup = function(urlNavigate, title, popUpWidth, popUpHeight) {
      this.logger.verbose("OpenPopup has been called");
      try {
        var winLeft = window.screenLeft ? window.screenLeft : window.screenX;
        var winTop = window.screenTop ? window.screenTop : window.screenY;
        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        var left = width / 2 - popUpWidth / 2 + winLeft;
        var top_1 = height / 2 - popUpHeight / 2 + winTop;
        var popupWindow = window.open(urlNavigate, title, "width=" + popUpWidth + ", height=" + popUpHeight + ", top=" + top_1 + ", left=" + left + ", scrollbars=yes");
        if (!popupWindow) {
          throw ClientAuthError.createPopupWindowError();
        }
        if (popupWindow.focus) {
          popupWindow.focus();
        }
        return popupWindow;
      } catch (e) {
        this.cacheStorage.setInteractionInProgress(false);
        throw ClientAuthError.createPopupWindowError(e.toString());
      }
    };
    UserAgentApplication2.prototype.loadIframeTimeout = function(urlNavigate, frameName, requestSignature) {
      return __awaiter2(this, void 0, void 0, function() {
        var expectedState, iframe, _a3, hash, error_2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              expectedState = window.activeRenewals[requestSignature];
              this.logger.verbosePii("Set loading state to pending for: " + requestSignature + ":" + expectedState);
              this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState), Constants.inProgress);
              if (!this.config.system.navigateFrameWait)
                return [3, 2];
              return [4, WindowUtils.loadFrame(urlNavigate, frameName, this.config.system.navigateFrameWait, this.logger)];
            case 1:
              _a3 = _b.sent();
              return [3, 3];
            case 2:
              _a3 = WindowUtils.loadFrameSync(urlNavigate, frameName, this.logger);
              _b.label = 3;
            case 3:
              iframe = _a3;
              _b.label = 4;
            case 4:
              _b.trys.push([4, 6, , 7]);
              return [4, WindowUtils.monitorIframeForHash(iframe.contentWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];
            case 5:
              hash = _b.sent();
              if (hash) {
                this.handleAuthenticationResponse(hash);
              }
              return [3, 7];
            case 6:
              error_2 = _b.sent();
              if (this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState)) === Constants.inProgress) {
                this.logger.verbose("Loading frame has timed out after: " + this.config.system.loadFrameTimeout / 1e3 + " seconds for scope/authority " + requestSignature + ":" + expectedState);
                if (expectedState && window.callbackMappedToRenewStates[expectedState]) {
                  window.callbackMappedToRenewStates[expectedState](null, error_2);
                }
                this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState));
              }
              WindowUtils.removeHiddenIframe(iframe);
              throw error_2;
            case 7:
              WindowUtils.removeHiddenIframe(iframe);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    UserAgentApplication2.prototype.navigateWindow = function(urlNavigate, popupWindow) {
      if (urlNavigate && !StringUtils.isEmpty(urlNavigate)) {
        var navigateWindow = popupWindow ? popupWindow : window;
        var logMessage = popupWindow ? "Navigated Popup window to:" + urlNavigate : "Navigate to:" + urlNavigate;
        this.logger.infoPii(logMessage);
        navigateWindow.location.assign(urlNavigate);
      } else {
        this.logger.info("Navigate url is empty");
        throw AuthError.createUnexpectedError("Navigate url is empty");
      }
    };
    UserAgentApplication2.prototype.registerCallback = function(expectedState, requestSignature, resolve, reject) {
      var _this = this;
      window.activeRenewals[requestSignature] = expectedState;
      if (!window.promiseMappedToRenewStates[expectedState]) {
        window.promiseMappedToRenewStates[expectedState] = [];
      }
      window.promiseMappedToRenewStates[expectedState].push({ resolve, reject });
      if (!window.callbackMappedToRenewStates[expectedState]) {
        window.callbackMappedToRenewStates[expectedState] = function(response, error) {
          delete window.activeRenewals[requestSignature];
          for (var i = 0; i < window.promiseMappedToRenewStates[expectedState].length; ++i) {
            try {
              if (error) {
                window.promiseMappedToRenewStates[expectedState][i].reject(error);
              } else if (response) {
                window.promiseMappedToRenewStates[expectedState][i].resolve(response);
              } else {
                _this.cacheStorage.resetTempCacheItems(expectedState);
                throw AuthError.createUnexpectedError("Error and response are both null");
              }
            } catch (e) {
              _this.logger.warning(e);
            }
          }
          delete window.promiseMappedToRenewStates[expectedState];
          delete window.callbackMappedToRenewStates[expectedState];
        };
      }
    };
    UserAgentApplication2.prototype.logout = function(correlationId) {
      this.logger.verbose("Logout has been called");
      this.logoutAsync(correlationId);
    };
    UserAgentApplication2.prototype.logoutAsync = function(correlationId) {
      return __awaiter2(this, void 0, void 0, function() {
        var requestCorrelationId, apiEvent, correlationIdParam, postLogoutQueryParam, urlNavigate, error_3;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              requestCorrelationId = correlationId || CryptoUtils.createNewGuid();
              apiEvent = this.telemetryManager.createAndStartApiEvent(requestCorrelationId, API_EVENT_IDENTIFIER.Logout);
              this.clearCache();
              this.account = null;
              _a3.label = 1;
            case 1:
              _a3.trys.push([1, 5, , 6]);
              if (!!this.authorityInstance.hasCachedMetadata())
                return [3, 3];
              this.logger.verbose("No cached metadata for authority");
              return [4, AuthorityFactory.saveMetadataFromNetwork(this.authorityInstance, this.telemetryManager, correlationId)];
            case 2:
              _a3.sent();
              return [3, 4];
            case 3:
              this.logger.verbose("Cached metadata found for authority");
              _a3.label = 4;
            case 4:
              correlationIdParam = "client-request-id=" + requestCorrelationId;
              postLogoutQueryParam = void 0;
              if (this.getPostLogoutRedirectUri()) {
                postLogoutQueryParam = "&post_logout_redirect_uri=" + encodeURIComponent(this.getPostLogoutRedirectUri());
                this.logger.verbose("redirectUri found and set");
              } else {
                postLogoutQueryParam = "";
                this.logger.verbose("No redirectUri set for app. postLogoutQueryParam is empty");
              }
              urlNavigate = void 0;
              if (this.authorityInstance.EndSessionEndpoint) {
                urlNavigate = this.authorityInstance.EndSessionEndpoint + "?" + correlationIdParam + postLogoutQueryParam;
                this.logger.verbose("EndSessionEndpoint found and urlNavigate set");
                this.logger.verbosePii("urlNavigate set to: " + this.authorityInstance.EndSessionEndpoint);
              } else {
                urlNavigate = this.authority + "oauth2/v2.0/logout?" + correlationIdParam + postLogoutQueryParam;
                this.logger.verbose("No endpoint, urlNavigate set to default");
              }
              this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, true);
              this.logger.verbose("Navigating window to urlNavigate");
              this.navigateWindow(urlNavigate);
              return [3, 6];
            case 5:
              error_3 = _a3.sent();
              this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, false, error_3.errorCode);
              return [3, 6];
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    UserAgentApplication2.prototype.clearCache = function() {
      this.logger.verbose("Clearing cache");
      window.renewStates = [];
      var tokenCacheItems = this.cacheStorage.getAllTokens(Constants.clientId, Constants.homeAccountIdentifier);
      for (var i = 0; i < tokenCacheItems.length; i++) {
        this.cacheStorage.removeItem(JSON.stringify(tokenCacheItems[i].key));
      }
      this.cacheStorage.resetCacheItems();
      this.cacheStorage.clearMsalCookie();
      this.logger.verbose("Cache cleared");
    };
    UserAgentApplication2.prototype.clearCacheForScope = function(accessToken) {
      this.logger.verbose("Clearing access token from cache");
      var accessTokenItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);
      for (var i = 0; i < accessTokenItems.length; i++) {
        var token = accessTokenItems[i];
        if (token.value.accessToken === accessToken) {
          this.cacheStorage.removeItem(JSON.stringify(token.key));
          this.logger.verbosePii("Access token removed: " + token.key);
        }
      }
    };
    UserAgentApplication2.prototype.isCallback = function(hash) {
      this.logger.info("isCallback will be deprecated in favor of urlContainsHash in MSAL.js v2.0.");
      this.logger.verbose("isCallback has been called");
      return UrlUtils.urlContainsHash(hash);
    };
    UserAgentApplication2.prototype.processCallBack = function(hash, respStateInfo, parentCallback) {
      this.logger.info("ProcessCallBack has been called. Processing callback from redirect response");
      var stateInfo = respStateInfo;
      if (!stateInfo) {
        this.logger.verbose("StateInfo is null, getting stateInfo from hash");
        stateInfo = this.getResponseState(hash);
      }
      var response;
      var authErr;
      try {
        response = this.saveTokenFromHash(hash, stateInfo);
      } catch (err) {
        authErr = err;
      }
      try {
        this.cacheStorage.clearMsalCookie(stateInfo.state);
        var accountState = this.getAccountState(stateInfo.state);
        if (response) {
          if (stateInfo.requestType === Constants.renewToken || response.accessToken) {
            if (window.parent !== window) {
              this.logger.verbose("Window is in iframe, acquiring token silently");
            } else {
              this.logger.verbose("Acquiring token interactive in progress");
            }
            this.logger.verbose("Response tokenType set to " + ServerHashParamKeys.ACCESS_TOKEN);
            response.tokenType = ServerHashParamKeys.ACCESS_TOKEN;
          } else if (stateInfo.requestType === Constants.login) {
            this.logger.verbose("Response tokenType set to " + ServerHashParamKeys.ID_TOKEN);
            response.tokenType = ServerHashParamKeys.ID_TOKEN;
          }
          if (!parentCallback) {
            this.logger.verbose("Setting redirectResponse");
            this.redirectResponse = response;
            return;
          }
        } else if (!parentCallback) {
          this.logger.verbose("Response is null, setting redirectResponse with state");
          this.redirectResponse = buildResponseStateOnly(accountState);
          this.redirectError = authErr;
          this.cacheStorage.resetTempCacheItems(stateInfo.state);
          return;
        }
        this.logger.verbose("Calling callback provided to processCallback");
        parentCallback(response, authErr);
      } catch (err) {
        this.logger.error("Error occurred in token received callback function: " + err);
        throw ClientAuthError.createErrorInCallbackFunction(err.toString());
      }
    };
    UserAgentApplication2.prototype.handleAuthenticationResponse = function(hash) {
      this.logger.verbose("HandleAuthenticationResponse has been called");
      var locationHash = hash || window.location.hash;
      var stateInfo = this.getResponseState(locationHash);
      this.logger.verbose("Obtained state from response");
      var tokenResponseCallback = window.callbackMappedToRenewStates[stateInfo.state];
      this.processCallBack(locationHash, stateInfo, tokenResponseCallback);
    };
    UserAgentApplication2.prototype.handleRedirectAuthenticationResponse = function(hash) {
      this.logger.info("Returned from redirect url");
      this.logger.verbose("HandleRedirectAuthenticationResponse has been called");
      WindowUtils.clearUrlFragment(window);
      this.logger.verbose("Window.location.hash cleared");
      var stateInfo = this.getResponseState(hash);
      if (this.config.auth.navigateToLoginRequestUrl && window.parent === window) {
        this.logger.verbose("Window.parent is equal to window, not in popup or iframe. Navigation to login request url after login turned on");
        var loginRequestUrl = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, stateInfo.state), this.inCookie);
        if (!loginRequestUrl || loginRequestUrl === "null") {
          this.logger.error("Unable to get valid login request url from cache, redirecting to home page");
          window.location.assign("/");
          return;
        } else {
          this.logger.verbose("Valid login request url obtained from cache");
          var currentUrl = UrlUtils.removeHashFromUrl(window.location.href);
          var finalRedirectUrl = UrlUtils.removeHashFromUrl(loginRequestUrl);
          if (currentUrl !== finalRedirectUrl) {
            this.logger.verbose("Current url is not login request url, navigating");
            this.logger.verbosePii("CurrentUrl: " + currentUrl + ", finalRedirectUrl: " + finalRedirectUrl);
            window.location.assign("" + finalRedirectUrl + hash);
            return;
          } else {
            this.logger.verbose("Current url matches login request url");
            var loginRequestUrlComponents = UrlUtils.GetUrlComponents(loginRequestUrl);
            if (loginRequestUrlComponents.Hash) {
              this.logger.verbose("Login request url contains hash, resetting non-msal hash");
              window.location.hash = loginRequestUrlComponents.Hash;
            }
          }
        }
      } else if (!this.config.auth.navigateToLoginRequestUrl) {
        this.logger.verbose("Default navigation to start page after login turned off");
      }
      this.processCallBack(hash, stateInfo, null);
    };
    UserAgentApplication2.prototype.getResponseState = function(hash) {
      this.logger.verbose("GetResponseState has been called");
      var parameters = UrlUtils.deserializeHash(hash);
      var stateResponse;
      if (!parameters) {
        throw AuthError.createUnexpectedError("Hash was not parsed correctly.");
      }
      if (parameters.hasOwnProperty(ServerHashParamKeys.STATE)) {
        this.logger.verbose("Hash contains state. Creating stateInfo object");
        var parsedState = RequestUtils.parseLibraryState(parameters["state"]);
        stateResponse = {
          requestType: Constants.unknown,
          state: parameters["state"],
          timestamp: parsedState.ts,
          method: parsedState.method,
          stateMatch: false
        };
      } else {
        throw AuthError.createUnexpectedError("Hash does not contain state.");
      }
      if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateResponse.state), this.inCookie) || stateResponse.state === this.silentAuthenticationState) {
        this.logger.verbose("State matches cached state, setting requestType to login");
        stateResponse.requestType = Constants.login;
        stateResponse.stateMatch = true;
        return stateResponse;
      } else if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, stateResponse.state), this.inCookie)) {
        this.logger.verbose("State matches cached state, setting requestType to renewToken");
        stateResponse.requestType = Constants.renewToken;
        stateResponse.stateMatch = true;
        return stateResponse;
      }
      if (!stateResponse.stateMatch) {
        this.logger.verbose("State does not match cached state, setting requestType to type from window");
        stateResponse.requestType = window.requestType;
        var statesInParentContext = window.renewStates;
        for (var i = 0; i < statesInParentContext.length; i++) {
          if (statesInParentContext[i] === stateResponse.state) {
            this.logger.verbose("Matching state found for request");
            stateResponse.stateMatch = true;
            break;
          }
        }
        if (!stateResponse.stateMatch) {
          this.logger.verbose("Matching state not found for request");
        }
      }
      return stateResponse;
    };
    UserAgentApplication2.prototype.getCachedToken = function(serverAuthenticationRequest, account) {
      this.logger.verbose("GetCachedToken has been called");
      var scopes = serverAuthenticationRequest.scopes;
      var idToken = this.getCachedIdToken(serverAuthenticationRequest, account);
      var authResponse = this.getCachedAccessToken(serverAuthenticationRequest, account, scopes);
      var accountState = this.getAccountState(serverAuthenticationRequest.state);
      return ResponseUtils.buildAuthResponse(idToken, authResponse, serverAuthenticationRequest, account, scopes, accountState);
    };
    UserAgentApplication2.prototype.getTokenCacheItemByAuthority = function(authority, tokenCacheItems, requestScopes, tokenType) {
      var _this = this;
      var filteredAuthorityItems;
      if (UrlUtils.isCommonAuthority(authority) || UrlUtils.isOrganizationsAuthority(authority) || UrlUtils.isConsumersAuthority(authority)) {
        filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByDomain(tokenCacheItems, UrlUtils.GetUrlComponents(authority).HostNameAndPort);
      } else {
        filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByAuthority(tokenCacheItems, authority);
      }
      if (filteredAuthorityItems.length === 1) {
        return filteredAuthorityItems[0];
      } else if (filteredAuthorityItems.length > 1) {
        this.logger.warning("Multiple matching tokens found. Cleaning cache and requesting a new token.");
        filteredAuthorityItems.forEach(function(accessTokenCacheItem) {
          _this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));
        });
        return null;
      } else {
        this.logger.verbose("No matching tokens of type " + tokenType + " found");
        return null;
      }
    };
    UserAgentApplication2.prototype.getCachedIdToken = function(serverAuthenticationRequest, account) {
      this.logger.verbose("Getting all cached tokens of type ID Token");
      var idTokenCacheItems = this.cacheStorage.getAllIdTokens(this.clientId, account ? account.homeAccountIdentifier : null);
      var matchAuthority = serverAuthenticationRequest.authority || this.authority;
      var idTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, idTokenCacheItems, null, ServerHashParamKeys.ID_TOKEN);
      if (idTokenCacheItem) {
        this.logger.verbose("Evaluating ID token found");
        var idTokenIsStillValid = this.evaluateTokenExpiration(idTokenCacheItem);
        if (idTokenIsStillValid) {
          this.logger.verbose("ID token expiration is within offset, using ID token found in cache");
          var idTokenValue = idTokenCacheItem.value;
          if (idTokenValue) {
            this.logger.verbose("ID Token found in cache is valid and unexpired");
          } else {
            this.logger.verbose("ID Token found in cache is invalid");
          }
          return idTokenValue ? new IdToken(idTokenValue.idToken) : null;
        } else {
          this.logger.verbose("Cached ID token is expired, removing from cache");
          this.cacheStorage.removeItem(JSON.stringify(idTokenCacheItem.key));
          return null;
        }
      } else {
        this.logger.verbose("No tokens found");
        return null;
      }
    };
    UserAgentApplication2.prototype.getCachedAccessToken = function(serverAuthenticationRequest, account, scopes) {
      this.logger.verbose("Getting all cached tokens of type Access Token");
      var tokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, account ? account.homeAccountIdentifier : null);
      var scopeFilteredTokenCacheItems = AuthCacheUtils.filterTokenCacheItemsByScope(tokenCacheItems, scopes);
      var matchAuthority = serverAuthenticationRequest.authority || this.authority;
      var accessTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, scopeFilteredTokenCacheItems, scopes, ServerHashParamKeys.ACCESS_TOKEN);
      if (!accessTokenCacheItem) {
        this.logger.verbose("No matching token found when filtering by scope and authority");
        return null;
      } else {
        serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(accessTokenCacheItem.key.authority, this.config.auth.validateAuthority);
        this.logger.verbose("Evaluating access token found");
        var tokenIsStillValid = this.evaluateTokenExpiration(accessTokenCacheItem);
        if (tokenIsStillValid) {
          this.logger.verbose("Access token expiration is within offset, using access token found in cache");
          var responseAccount = account || this.getAccount();
          if (!responseAccount) {
            throw AuthError.createUnexpectedError("Account should not be null here.");
          }
          var aState = this.getAccountState(serverAuthenticationRequest.state);
          var response = {
            uniqueId: "",
            tenantId: "",
            tokenType: ServerHashParamKeys.ACCESS_TOKEN,
            idToken: null,
            idTokenClaims: null,
            accessToken: accessTokenCacheItem.value.accessToken,
            scopes: accessTokenCacheItem.key.scopes.split(" "),
            expiresOn: new Date(Number(accessTokenCacheItem.value.expiresIn) * 1e3),
            account: responseAccount,
            accountState: aState,
            fromCache: true
          };
          return response;
        } else {
          this.logger.verbose("Access token expired, removing from cache");
          this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));
          return null;
        }
      }
    };
    UserAgentApplication2.prototype.evaluateTokenExpiration = function(tokenCacheItem) {
      var expiration = Number(tokenCacheItem.value.expiresIn);
      return TokenUtils.validateExpirationIsWithinOffset(expiration, this.config.system.tokenRenewalOffsetSeconds);
    };
    UserAgentApplication2.prototype.extractADALIdToken = function() {
      this.logger.verbose("ExtractADALIdToken has been called");
      var adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);
      return !StringUtils.isEmpty(adalIdToken) ? TokenUtils.extractIdToken(adalIdToken) : null;
    };
    UserAgentApplication2.prototype.renewToken = function(requestSignature, resolve, reject, account, serverAuthenticationRequest) {
      this.logger.verbose("RenewToken has been called");
      this.logger.verbosePii("RenewToken scope and authority: " + requestSignature);
      var frameName = WindowUtils.generateFrameName(FramePrefix.TOKEN_FRAME, requestSignature);
      WindowUtils.addHiddenIFrame(frameName, this.logger);
      this.updateCacheEntries(serverAuthenticationRequest, account, false);
      this.logger.verbosePii("RenewToken expected state: " + serverAuthenticationRequest.state);
      var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;
      window.renewStates.push(serverAuthenticationRequest.state);
      window.requestType = Constants.renewToken;
      this.logger.verbose("Set window.renewState and requestType");
      this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);
      this.logger.infoPii("Navigate to: " + urlNavigate);
      this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function(error) {
        return reject(error);
      });
    };
    UserAgentApplication2.prototype.renewIdToken = function(requestSignature, resolve, reject, account, serverAuthenticationRequest) {
      this.logger.info("RenewIdToken has been called");
      var frameName = WindowUtils.generateFrameName(FramePrefix.ID_TOKEN_FRAME, requestSignature);
      WindowUtils.addHiddenIFrame(frameName, this.logger);
      this.updateCacheEntries(serverAuthenticationRequest, account, false);
      this.logger.verbose("RenewIdToken expected state: " + serverAuthenticationRequest.state);
      var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;
      if (this.silentLogin) {
        this.logger.verbose("Silent login is true, set silentAuthenticationState");
        window.requestType = Constants.login;
        this.silentAuthenticationState = serverAuthenticationRequest.state;
      } else {
        this.logger.verbose("Not silent login, set window.renewState and requestType");
        window.requestType = Constants.renewToken;
        window.renewStates.push(serverAuthenticationRequest.state);
      }
      this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);
      this.logger.infoPii('Navigate to:" ' + urlNavigate);
      this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function(error) {
        return reject(error);
      });
    };
    UserAgentApplication2.prototype.saveToken = function(response, authority, scopes, clientInfo, expiration) {
      var accessTokenKey = new AccessTokenKey(authority, this.clientId, scopes, clientInfo.uid, clientInfo.utid);
      var accessTokenValue = new AccessTokenValue(response.accessToken, response.idToken.rawIdToken, expiration.toString(), clientInfo.encodeClientInfo());
      this.cacheStorage.setItem(JSON.stringify(accessTokenKey), JSON.stringify(accessTokenValue));
      if (expiration) {
        this.logger.verbose("New expiration set for token");
        response.expiresOn = new Date(expiration * 1e3);
      } else {
        this.logger.error("Could not parse expiresIn parameter for access token");
      }
      return response;
    };
    UserAgentApplication2.prototype.saveIdToken = function(response, authority, parameters, clientInfo, idTokenObj) {
      this.logger.verbose("SaveIdToken has been called");
      var idTokenResponse = __assign({}, response);
      var scopes;
      idTokenResponse.scopes = Constants.oidcScopes;
      idTokenResponse.accessToken = parameters[ServerHashParamKeys.ID_TOKEN];
      var expiration = Number(idTokenObj.expiration);
      this.logger.verbose("Saving ID token to cache");
      return this.saveToken(idTokenResponse, authority, scopes, clientInfo, expiration);
    };
    UserAgentApplication2.prototype.saveAccessToken = function(response, authority, parameters, clientInfo) {
      this.logger.verbose("SaveAccessToken has been called");
      var accessTokenResponse = __assign({}, response);
      var scope = parameters[ServerHashParamKeys.SCOPE];
      var consentedScopes = scope.split(" ");
      var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, authority);
      this.logger.verbose("Retrieving all access tokens from cache and removing duplicates");
      for (var i = 0; i < accessTokenCacheItems.length; i++) {
        var accessTokenCacheItem = accessTokenCacheItems[i];
        if (accessTokenCacheItem.key.homeAccountIdentifier === response.account.homeAccountIdentifier) {
          var cachedScopes = accessTokenCacheItem.key.scopes.split(" ");
          if (ScopeSet.isIntersectingScopes(cachedScopes, consentedScopes)) {
            this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));
          }
        }
      }
      accessTokenResponse.accessToken = parameters[ServerHashParamKeys.ACCESS_TOKEN];
      accessTokenResponse.scopes = consentedScopes;
      var expiresIn = TimeUtils.parseExpiresIn(parameters[ServerHashParamKeys.EXPIRES_IN]);
      var parsedState = RequestUtils.parseLibraryState(parameters[ServerHashParamKeys.STATE]);
      var expiration = parsedState.ts + expiresIn;
      this.logger.verbose("Saving access token to cache");
      return this.saveToken(accessTokenResponse, authority, scope, clientInfo, expiration);
    };
    UserAgentApplication2.prototype.saveTokenFromHash = function(hash, stateInfo) {
      this.logger.verbose("SaveTokenFromHash has been called");
      this.logger.info("State status: " + stateInfo.stateMatch + "; Request type: " + stateInfo.requestType);
      var response = {
        uniqueId: "",
        tenantId: "",
        tokenType: "",
        idToken: null,
        idTokenClaims: null,
        accessToken: null,
        scopes: [],
        expiresOn: null,
        account: null,
        accountState: "",
        fromCache: false
      };
      var error;
      var hashParams = UrlUtils.deserializeHash(hash);
      var authorityKey = "";
      var acquireTokenAccountKey = "";
      var idTokenObj = null;
      if (hashParams.hasOwnProperty(ServerHashParamKeys.ERROR_DESCRIPTION) || hashParams.hasOwnProperty(ServerHashParamKeys.ERROR)) {
        this.logger.verbose("Server returned an error");
        this.logger.infoPii("Error : " + hashParams[ServerHashParamKeys.ERROR] + "; Error description: " + hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);
        this.cacheStorage.setItem(ErrorCacheKeys.ERROR, hashParams[ServerHashParamKeys.ERROR]);
        this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);
        if (stateInfo.requestType === Constants.login) {
          this.logger.verbose("RequestType is login, caching login error, generating authorityKey");
          this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION] + ":" + hashParams[ServerHashParamKeys.ERROR]);
          authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);
        }
        if (stateInfo.requestType === Constants.renewToken) {
          this.logger.verbose("RequestType is renewToken, generating acquireTokenAccountKey");
          authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);
          var account = this.getAccount();
          var accountId = void 0;
          if (account && !StringUtils.isEmpty(account.homeAccountIdentifier)) {
            accountId = account.homeAccountIdentifier;
            this.logger.verbose("AccountId is set");
          } else {
            accountId = Constants.no_account;
            this.logger.verbose("AccountId is set as no_account");
          }
          acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, stateInfo.state);
        }
        var hashErr = hashParams[ServerHashParamKeys.ERROR];
        var hashErrDesc = hashParams[ServerHashParamKeys.ERROR_DESCRIPTION];
        if (InteractionRequiredAuthError.isInteractionRequiredError(hashErr) || InteractionRequiredAuthError.isInteractionRequiredError(hashErrDesc)) {
          error = new InteractionRequiredAuthError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);
        } else {
          error = new ServerError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);
        }
      } else {
        this.logger.verbose("Server returns success");
        if (stateInfo.stateMatch) {
          this.logger.info("State is right");
          if (hashParams.hasOwnProperty(ServerHashParamKeys.SESSION_STATE)) {
            this.logger.verbose("Fragment has session state, caching");
            this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.SESSION_STATE, stateInfo.state), hashParams[ServerHashParamKeys.SESSION_STATE]);
          }
          response.accountState = this.getAccountState(stateInfo.state);
          var clientInfo = void 0;
          if (hashParams.hasOwnProperty(ServerHashParamKeys.ACCESS_TOKEN)) {
            this.logger.info("Fragment has access token");
            response.accessToken = hashParams[ServerHashParamKeys.ACCESS_TOKEN];
            if (hashParams.hasOwnProperty(ServerHashParamKeys.SCOPE)) {
              response.scopes = hashParams[ServerHashParamKeys.SCOPE].split(" ");
            }
            if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {
              this.logger.verbose("Fragment has id_token");
              idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]);
            } else {
              this.logger.verbose("No idToken on fragment, getting idToken from cache");
              idTokenObj = new IdToken(this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN));
            }
            response = ResponseUtils.setResponseIdToken(response, idTokenObj);
            var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);
            this.logger.verbose("Got authority from cache");
            if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {
              this.logger.verbose("Fragment has clientInfo");
              clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);
            } else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {
              clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);
            } else {
              this.logger.warning("ClientInfo not received in the response from AAD");
            }
            response.account = Account.createAccount(idTokenObj, clientInfo);
            this.logger.verbose("Account object created from response");
            var accountKey = void 0;
            if (response.account && !StringUtils.isEmpty(response.account.homeAccountIdentifier)) {
              this.logger.verbose("AccountKey set");
              accountKey = response.account.homeAccountIdentifier;
            } else {
              this.logger.verbose("AccountKey set as no_account");
              accountKey = Constants.no_account;
            }
            acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountKey, stateInfo.state);
            var acquireTokenAccountKey_noaccount = AuthCache.generateAcquireTokenAccountKey(Constants.no_account, stateInfo.state);
            this.logger.verbose("AcquireTokenAccountKey generated");
            var cachedAccount = this.cacheStorage.getItem(acquireTokenAccountKey);
            var acquireTokenAccount = void 0;
            if (!StringUtils.isEmpty(cachedAccount)) {
              acquireTokenAccount = JSON.parse(cachedAccount);
              this.logger.verbose("AcquireToken request account retrieved from cache");
              if (response.account && acquireTokenAccount && Account.compareAccounts(response.account, acquireTokenAccount)) {
                response = this.saveAccessToken(response, authority, hashParams, clientInfo);
                this.logger.info("The user object received in the response is the same as the one passed in the acquireToken request");
              } else {
                this.logger.warning("The account object created from the response is not the same as the one passed in the acquireToken request");
              }
            } else if (!StringUtils.isEmpty(this.cacheStorage.getItem(acquireTokenAccountKey_noaccount))) {
              this.logger.verbose("No acquireToken account retrieved from cache");
              response = this.saveAccessToken(response, authority, hashParams, clientInfo);
            }
          }
          if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {
            this.logger.info("Fragment has idToken");
            idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]);
            var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);
            response = ResponseUtils.setResponseIdToken(response, idTokenObj);
            if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {
              this.logger.verbose("Fragment has clientInfo");
              clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);
            } else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {
              clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);
            } else {
              this.logger.warning("ClientInfo not received in the response from AAD");
            }
            this.account = Account.createAccount(idTokenObj, clientInfo);
            response.account = this.account;
            this.logger.verbose("Account object created from response");
            if (idTokenObj && idTokenObj.nonce) {
              this.logger.verbose("IdToken has nonce");
              var cachedNonce = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, stateInfo.state), this.inCookie);
              if (idTokenObj.nonce !== cachedNonce) {
                this.account = null;
                this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, "Nonce Mismatch. Expected Nonce: " + cachedNonce + ",Actual Nonce: " + idTokenObj.nonce);
                this.logger.error("Nonce Mismatch. Expected Nonce: " + cachedNonce + ", Actual Nonce: " + idTokenObj.nonce);
                error = ClientAuthError.createNonceMismatchError(cachedNonce, idTokenObj.nonce);
              } else {
                this.logger.verbose("Nonce matches, saving idToken to cache");
                this.cacheStorage.setItem(PersistentCacheKeys.IDTOKEN, hashParams[ServerHashParamKeys.ID_TOKEN], this.inCookie);
                this.cacheStorage.setItem(PersistentCacheKeys.CLIENT_INFO, clientInfo.encodeClientInfo(), this.inCookie);
                this.saveIdToken(response, authority, hashParams, clientInfo, idTokenObj);
              }
            } else {
              this.logger.verbose("No idToken or no nonce. Cache key for Authority set as state");
              authorityKey = stateInfo.state;
              acquireTokenAccountKey = stateInfo.state;
              this.logger.error("Invalid id_token received in the response");
              error = ClientAuthError.createInvalidIdTokenError(idTokenObj);
              this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);
              this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);
            }
          }
        } else {
          this.logger.verbose("State mismatch");
          authorityKey = stateInfo.state;
          acquireTokenAccountKey = stateInfo.state;
          var expectedState = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateInfo.state), this.inCookie);
          this.logger.error("State Mismatch. Expected State: " + expectedState + ", Actual State: " + stateInfo.state);
          error = ClientAuthError.createInvalidStateError(stateInfo.state, expectedState);
          this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);
          this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);
        }
      }
      this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateInfo.state));
      this.cacheStorage.resetTempCacheItems(stateInfo.state);
      this.logger.verbose("Status set to complete, temporary cache cleared");
      if (this.inCookie) {
        this.logger.verbose("InCookie is true, setting authorityKey in cookie");
        this.cacheStorage.setItemCookie(authorityKey, "", -1);
        this.cacheStorage.clearMsalCookie(stateInfo.state);
      }
      if (error) {
        throw error;
      }
      if (!response) {
        throw AuthError.createUnexpectedError("Response is null");
      }
      return response;
    };
    UserAgentApplication2.prototype.populateAuthority = function(state2, inCookie, cacheStorage, idTokenObj) {
      this.logger.verbose("PopulateAuthority has been called");
      var authorityKey = AuthCache.generateAuthorityKey(state2);
      var cachedAuthority = cacheStorage.getItem(authorityKey, inCookie);
      return StringUtils.isEmpty(cachedAuthority) ? cachedAuthority : UrlUtils.replaceTenantPath(cachedAuthority, idTokenObj.tenantId);
    };
    UserAgentApplication2.prototype.getAccount = function() {
      if (this.account) {
        return this.account;
      }
      var rawIdToken = this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN, this.inCookie);
      var rawClientInfo = this.cacheStorage.getItem(PersistentCacheKeys.CLIENT_INFO, this.inCookie);
      if (!StringUtils.isEmpty(rawIdToken) && !StringUtils.isEmpty(rawClientInfo)) {
        var idToken = new IdToken(rawIdToken);
        var clientInfo = new ClientInfo(rawClientInfo, "");
        this.account = Account.createAccount(idToken, clientInfo);
        return this.account;
      }
      return null;
    };
    UserAgentApplication2.prototype.getAccountState = function(state2) {
      if (state2) {
        var splitIndex = state2.indexOf(Constants.resourceDelimiter);
        if (splitIndex > -1 && splitIndex + 1 < state2.length) {
          return state2.substring(splitIndex + 1);
        }
      }
      return state2;
    };
    UserAgentApplication2.prototype.getAllAccounts = function() {
      var accounts = [];
      var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);
      for (var i = 0; i < accessTokenCacheItems.length; i++) {
        var idToken = new IdToken(accessTokenCacheItems[i].value.idToken);
        var clientInfo = new ClientInfo(accessTokenCacheItems[i].value.homeAccountIdentifier, "");
        var account = Account.createAccount(idToken, clientInfo);
        accounts.push(account);
      }
      return this.getUniqueAccounts(accounts);
    };
    UserAgentApplication2.prototype.getUniqueAccounts = function(accounts) {
      if (!accounts || accounts.length <= 1) {
        return accounts;
      }
      var flags = [];
      var uniqueAccounts = [];
      for (var index = 0; index < accounts.length; ++index) {
        if (accounts[index].homeAccountIdentifier && flags.indexOf(accounts[index].homeAccountIdentifier) === -1) {
          flags.push(accounts[index].homeAccountIdentifier);
          uniqueAccounts.push(accounts[index]);
        }
      }
      return uniqueAccounts;
    };
    UserAgentApplication2.prototype.broadcast = function(eventName, data) {
      var evt = new CustomEvent(eventName, { detail: data });
      window.dispatchEvent(evt);
    };
    UserAgentApplication2.prototype.getCachedTokenInternal = function(scopes, account, state2, correlationId) {
      var accountObject = account || this.getAccount();
      if (!accountObject) {
        return null;
      }
      var newAuthority = this.authorityInstance ? this.authorityInstance : AuthorityFactory.CreateInstance(this.authority, this.config.auth.validateAuthority);
      var responseType = this.getTokenType(accountObject, scopes);
      var serverAuthenticationRequest = new ServerRequestParameters(newAuthority, this.clientId, responseType, this.getRedirectUri(), scopes, state2, correlationId);
      return this.getCachedToken(serverAuthenticationRequest, account);
    };
    UserAgentApplication2.prototype.getScopesForEndpoint = function(endpoint) {
      if (this.config.framework.unprotectedResources.length > 0) {
        for (var i = 0; i < this.config.framework.unprotectedResources.length; i++) {
          if (endpoint.indexOf(this.config.framework.unprotectedResources[i]) > -1) {
            return null;
          }
        }
      }
      if (this.config.framework.protectedResourceMap.size > 0) {
        for (var _i = 0, _a3 = Array.from(this.config.framework.protectedResourceMap.keys()); _i < _a3.length; _i++) {
          var key = _a3[_i];
          if (endpoint.indexOf(key) > -1) {
            return this.config.framework.protectedResourceMap.get(key);
          }
        }
      }
      if (endpoint.indexOf("http://") > -1 || endpoint.indexOf("https://") > -1) {
        if (UrlUtils.getHostFromUri(endpoint) === UrlUtils.getHostFromUri(this.getRedirectUri())) {
          return new Array(this.clientId);
        }
      } else {
        return new Array(this.clientId);
      }
      return null;
    };
    UserAgentApplication2.prototype.getLoginInProgress = function() {
      return this.cacheStorage.isInteractionInProgress(true);
    };
    UserAgentApplication2.prototype.setInteractionInProgress = function(inProgress) {
      this.cacheStorage.setInteractionInProgress(inProgress);
    };
    UserAgentApplication2.prototype.setloginInProgress = function(loginInProgress) {
      this.setInteractionInProgress(loginInProgress);
    };
    UserAgentApplication2.prototype.getAcquireTokenInProgress = function() {
      return this.cacheStorage.isInteractionInProgress(true);
    };
    UserAgentApplication2.prototype.setAcquireTokenInProgress = function(acquireTokenInProgress) {
      this.setInteractionInProgress(acquireTokenInProgress);
    };
    UserAgentApplication2.prototype.getLogger = function() {
      return this.logger;
    };
    UserAgentApplication2.prototype.setLogger = function(logger) {
      this.logger = logger;
    };
    UserAgentApplication2.prototype.getRedirectUri = function(reqRedirectUri) {
      if (reqRedirectUri) {
        return reqRedirectUri;
      } else if (typeof this.config.auth.redirectUri === "function") {
        return this.config.auth.redirectUri();
      }
      return this.config.auth.redirectUri;
    };
    UserAgentApplication2.prototype.getPostLogoutRedirectUri = function() {
      if (typeof this.config.auth.postLogoutRedirectUri === "function") {
        return this.config.auth.postLogoutRedirectUri();
      }
      return this.config.auth.postLogoutRedirectUri;
    };
    UserAgentApplication2.prototype.getCurrentConfiguration = function() {
      if (!this.config) {
        throw ClientConfigurationError.createNoSetConfigurationError();
      }
      return this.config;
    };
    UserAgentApplication2.prototype.getTokenType = function(accountObject, scopes) {
      var accountsMatch = Account.compareAccounts(accountObject, this.getAccount());
      return ServerRequestParameters.determineResponseType(accountsMatch, scopes);
    };
    UserAgentApplication2.prototype.setAccountCache = function(account, state2) {
      var accountId = account ? this.getAccountId(account) : Constants.no_account;
      var acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, state2);
      this.cacheStorage.setItem(acquireTokenAccountKey, JSON.stringify(account));
    };
    UserAgentApplication2.prototype.setAuthorityCache = function(state2, authority) {
      var authorityKey = AuthCache.generateAuthorityKey(state2);
      this.cacheStorage.setItem(authorityKey, UrlUtils.CanonicalizeUri(authority), this.inCookie);
    };
    UserAgentApplication2.prototype.updateCacheEntries = function(serverAuthenticationRequest, account, isLoginCall, loginStartPage) {
      if (loginStartPage) {
        this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, serverAuthenticationRequest.state), loginStartPage, this.inCookie);
      }
      if (isLoginCall) {
        this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, serverAuthenticationRequest.state), serverAuthenticationRequest.state, this.inCookie);
      } else {
        this.setAccountCache(account, serverAuthenticationRequest.state);
      }
      this.setAuthorityCache(serverAuthenticationRequest.state, serverAuthenticationRequest.authority);
      this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, serverAuthenticationRequest.state), serverAuthenticationRequest.nonce, this.inCookie);
    };
    UserAgentApplication2.prototype.getAccountId = function(account) {
      var accountId;
      if (!StringUtils.isEmpty(account.homeAccountIdentifier)) {
        accountId = account.homeAccountIdentifier;
      } else {
        accountId = Constants.no_account;
      }
      return accountId;
    };
    UserAgentApplication2.prototype.buildIDTokenRequest = function(request) {
      var tokenRequest = {
        scopes: Constants.oidcScopes,
        authority: this.authority,
        account: this.getAccount(),
        extraQueryParameters: request.extraQueryParameters,
        correlationId: request.correlationId
      };
      return tokenRequest;
    };
    UserAgentApplication2.prototype.getTelemetryManagerFromConfig = function(config, clientId) {
      if (!config) {
        return TelemetryManager_default.getTelemetrymanagerStub(clientId, this.logger);
      }
      var applicationName = config.applicationName, applicationVersion = config.applicationVersion, telemetryEmitter = config.telemetryEmitter;
      if (!applicationName || !applicationVersion || !telemetryEmitter) {
        throw ClientConfigurationError.createTelemetryConfigError(config);
      }
      var telemetryPlatform = {
        applicationName,
        applicationVersion
      };
      var telemetryManagerConfig = {
        platform: telemetryPlatform,
        clientId
      };
      return new TelemetryManager_default(telemetryManagerConfig, telemetryEmitter, this.logger);
    };
    return UserAgentApplication2;
  }()
);

// node_modules/@microsoft/mgt-element/dist/es6/utils/index.js
function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

// node_modules/@microsoft/mgt-element/dist/es6/utils/GraphHelpers.js
function prepScopes(...scopes) {
  const authProviderOptions = {
    scopes
  };
  if (!Providers.globalProvider.isIncrementalConsentDisabled) {
    return [new AuthenticationHandlerOptions(void 0, authProviderOptions)];
  } else {
    return [];
  }
}
function chainMiddleware(...middleware) {
  const rootMiddleware = middleware[0];
  let current = rootMiddleware;
  for (let i = 1; i < middleware.length; ++i) {
    const next = middleware[i];
    if (current.setNext) {
      current.setNext(next);
    }
    current = next;
  }
  return rootMiddleware;
}
function validateBaseURL(url) {
  try {
    const urlObj = new URL(url);
    const originAsEndpoint = urlObj.origin;
    if (MICROSOFT_GRAPH_ENDPOINTS.has(originAsEndpoint)) {
      return originAsEndpoint;
    }
  } catch (error) {
    return;
  }
}

// node_modules/@microsoft/mgt-element/dist/es6/utils/Batch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BatchRequest = class {
  constructor(index, id, resource, method) {
    if (resource.charAt(0) !== "/") {
      resource = "/" + resource;
    }
    this.resource = resource;
    this.method = method;
    this.index = index;
    this.id = id;
  }
};
var Batch = class {
  constructor(graph) {
    this.graph = graph;
    this.allRequests = [];
    this.requestsQueue = [];
    this.scopes = [];
    this.nextIndex = 0;
    this.retryAfter = 0;
  }
  /**
   * Get whether there are requests that have not been executed
   *
   * @readonly
   * @memberof Batch
   */
  get hasRequests() {
    return this.requestsQueue.length > 0;
  }
  /**
   * sets new request and scopes
   *
   * @param {string} id
   * @param {string} resource
   * @param {string[]} [scopes]
   * @memberof Batch
   */
  get(id, resource, scopes, headers) {
    const index = this.nextIndex++;
    const request = new BatchRequest(index, id, resource, "GET");
    request.headers = headers;
    this.allRequests.push(request);
    this.requestsQueue.push(index);
    if (scopes) {
      this.scopes = this.scopes.concat(scopes);
    }
  }
  /**
   * Execute the next set of requests.
   * This will execute up to 20 requests at a time
   *
   * @returns {Promise<Map<string, BatchResponse>>}
   * @memberof Batch
   */
  executeNext() {
    return __awaiter3(this, void 0, void 0, function* () {
      const responses = /* @__PURE__ */ new Map();
      if (this.retryAfter) {
        yield delay(this.retryAfter * 1e3);
        this.retryAfter = 0;
      }
      if (!this.hasRequests) {
        return responses;
      }
      const nextBatch = this.requestsQueue.splice(0, 20);
      const batchRequestContent = new BatchRequestContent();
      for (const request of nextBatch.map((i) => this.allRequests[i])) {
        batchRequestContent.addRequest({
          id: request.index.toString(),
          request: new Request(Batch.baseUrl + request.resource, {
            method: request.method,
            headers: request.headers
          })
        });
      }
      const middlewareOptions = this.scopes.length ? prepScopes(...this.scopes) : [];
      const batchRequest = this.graph.api("$batch").middlewareOptions(middlewareOptions);
      const batchRequestBody = yield batchRequestContent.getContent();
      const batchResponse = yield batchRequest.post(batchRequestBody);
      for (const r of batchResponse.responses) {
        const response = new BatchResponse();
        const request = this.allRequests[r.id];
        response.id = request.id;
        response.index = request.index;
        response.headers = r.headers;
        if (r.status !== 200) {
          if (r.status === 429) {
            this.requestsQueue.unshift(r.id);
            this.retryAfter = Math.max(this.retryAfter, parseInt(r.headers["Retry-After"], 10) || 1);
          }
          continue;
        } else if (r.headers["Content-Type"].includes("image/jpeg")) {
          response.content = "data:image/jpeg;base64," + r.body;
        } else if (r.headers["Content-Type"].includes("image/pjpeg")) {
          response.content = "data:image/pjpeg;base64," + r.body;
        } else if (r.headers["Content-Type"].includes("image/png")) {
          response.content = "data:image/png;base64," + r.body;
        } else {
          response.content = r.body;
        }
        responses.set(request.id, response);
      }
      return responses;
    });
  }
  /**
   * Execute all requests, up to 20 at a time until
   * all requests have been executed
   *
   * @returns {Promise<Map<string, BatchResponse>>}
   * @memberof Batch
   */
  executeAll() {
    return __awaiter3(this, void 0, void 0, function* () {
      const responses = /* @__PURE__ */ new Map();
      while (this.hasRequests) {
        const r = yield this.executeNext();
        for (const [key, value] of r) {
          responses.set(key, value);
        }
      }
      return responses;
    });
  }
};
Batch.baseUrl = "https://graph.microsoft.com";

// node_modules/@microsoft/mgt-element/dist/es6/utils/ComponentMiddlewareOptions.js
var ComponentMiddlewareOptions = class {
  constructor(component) {
    if (typeof component === "string") {
      this.componentName = component;
    } else {
      this.componentName = component.tagName.toLowerCase();
    }
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/utils/SdkVersionMiddleware.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SdkVersionMiddleware = class {
  constructor(packageVersion, providerName) {
    this._packageVersion = packageVersion;
    this._providerName = providerName;
  }
  // tslint:disable-next-line: completed-docs
  execute(context) {
    var _a3;
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        if (typeof context.request === "string") {
          if (validateBaseURL(context.request)) {
            const headerParts = [];
            const componentOptions = context.middlewareControl.getMiddlewareOptions(ComponentMiddlewareOptions);
            if (componentOptions) {
              const componentVersion = `${componentOptions.componentName}/${this._packageVersion}`;
              headerParts.push(componentVersion);
            }
            if (this._providerName) {
              const providerVersion = `${this._providerName}/${this._packageVersion}`;
              headerParts.push(providerVersion);
            }
            const packageVersion = `mgt/${this._packageVersion}`;
            headerParts.push(packageVersion);
            headerParts.push(getRequestHeader(context.request, context.options, "SdkVersion"));
            const sdkVersionHeaderValue = headerParts.join(", ");
            setRequestHeader(context.request, context.options, "SdkVersion", sdkVersionHeaderValue);
          } else {
            (_a3 = context === null || context === void 0 ? void 0 : context.options) === null || _a3 === void 0 ? true : delete _a3.headers["SdkVersion"];
          }
        }
      } catch (error) {
      }
      return yield this._nextMiddleware.execute(context);
    });
  }
  /**
   * Handles setting of next middleware
   *
   * @param {Middleware} next
   * @memberof SdkVersionMiddleware
   */
  setNext(next) {
    this._nextMiddleware = next;
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/utils/version.js
var PACKAGE_VERSION2 = "2.9.2";

// node_modules/@microsoft/mgt-element/dist/es6/Graph.js
var GRAPH_VERSION = "v1.0";
var Graph = class {
  /**
   * the internal client used to make graph calls
   *
   * @readonly
   * @type {Client}
   * @memberof Graph
   */
  get client() {
    return this._client;
  }
  /**
   * the component name appended to Graph request headers
   *
   * @readonly
   * @type {string}
   * @memberof Graph
   */
  get componentName() {
    return this._componentName;
  }
  /**
   * the version of the graph to query
   *
   * @readonly
   * @type {string}
   * @memberof Graph
   */
  get version() {
    return this._version;
  }
  constructor(client, version2 = GRAPH_VERSION) {
    this._client = client;
    this._version = version2;
  }
  /**
   * Returns a new instance of the Graph using the same
   * client within the context of the provider.
   *
   * @param {Element} component
   * @returns {IGraph}
   * @memberof Graph
   */
  forComponent(component) {
    const graph = new Graph(this._client, this._version);
    graph.setComponent(component);
    return graph;
  }
  /**
   * Returns a new graph request for a specific component
   * Used internally for analytics purposes
   *
   * @param {string} path
   * @memberof Graph
   */
  api(path) {
    let request = this._client.api(path).version(this._version);
    if (this._componentName) {
      request.middlewareOptions = (options) => {
        const requestObj = request;
        requestObj._middlewareOptions = requestObj._middlewareOptions.concat(options);
        return request;
      };
      request = request.middlewareOptions([new ComponentMiddlewareOptions(this._componentName)]);
    }
    return request;
  }
  /**
   * creates a new batch request
   *
   * @returns {Batch}
   * @memberof Graph
   */
  createBatch() {
    return new Batch(this);
  }
  /**
   * sets the component name used in request headers.
   *
   * @protected
   * @param {Element} component
   * @memberof Graph
   */
  setComponent(component) {
    this._componentName = component instanceof Element ? component.tagName : component;
  }
};
function createFromProvider(provider, version2, component) {
  const middleware = [
    new AuthenticationHandler(provider),
    new RetryHandler(new RetryHandlerOptions()),
    new TelemetryHandler(),
    new SdkVersionMiddleware(PACKAGE_VERSION2, provider.name),
    new HTTPMessageHandler()
  ];
  const client = Client.initWithMiddleware({
    middleware: chainMiddleware(...middleware)
  });
  const graph = new Graph(client, version2);
  return component ? graph.forComponent(component) : graph;
}

// node_modules/@microsoft/mgt-element/dist/es6/BetaGraph.js
var GRAPH_VERSION2 = "beta";
var BetaGraph = class extends Graph {
  /**
   * get a BetaGraph instance based on an existing IGraph implementation.
   *
   * @static
   * @param {Graph} graph
   * @returns {BetaGraph}
   * @memberof BetaGraph
   */
  static fromGraph(graph) {
    const betaGraph = new BetaGraph(graph.client);
    betaGraph.setComponent(graph.componentName);
    return betaGraph;
  }
  constructor(client, version2 = GRAPH_VERSION2) {
    super(client, version2);
  }
  /**
   * Returns a new instance of the Graph using the same
   * client within the context of the provider.
   *
   * @param {Element} component
   * @returns {BetaGraph}
   * @memberof BetaGraph
   */
  forComponent(component) {
    const graph = new BetaGraph(this.client);
    this.setComponent(component);
    return graph;
  }
};

// node_modules/lit-html/lib/dom.js
var isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
var reparentNodes = (container, start, end = null, before = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.insertBefore(start, before);
    start = n;
  }
};
var removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.removeChild(start);
    start = n;
  }
};

// node_modules/lit-html/lib/template.js
var marker = `{{lit-${String(Math.random()).slice(2)}}}`;
var nodeMarker = `<!--${marker}-->`;
var markerRegex = new RegExp(`${marker}|${nodeMarker}`);
var boundAttributeSuffix = "$lit$";
var Template = class {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = [];
    const walker = document.createTreeWalker(element.content, 133, null, false);
    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const { strings, values: { length } } = result;
    while (partIndex < length) {
      const node = walker.nextNode();
      if (node === null) {
        walker.currentNode = stack.pop();
        continue;
      }
      index++;
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attributes = node.attributes;
          const { length: length2 } = attributes;
          let count = 0;
          for (let i = 0; i < length2; i++) {
            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
              count++;
            }
          }
          while (count-- > 0) {
            const stringForPart = strings[partIndex];
            const name = lastAttributeNameRegex.exec(stringForPart)[2];
            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
            const attributeValue = node.getAttribute(attributeLookupName);
            node.removeAttribute(attributeLookupName);
            const statics = attributeValue.split(markerRegex);
            this.parts.push({ type: "attribute", index, name, strings: statics });
            partIndex += statics.length - 1;
          }
        }
        if (node.tagName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
      } else if (node.nodeType === 3) {
        const data = node.data;
        if (data.indexOf(marker) >= 0) {
          const parent = node.parentNode;
          const strings2 = data.split(markerRegex);
          const lastIndex = strings2.length - 1;
          for (let i = 0; i < lastIndex; i++) {
            let insert;
            let s = strings2[i];
            if (s === "") {
              insert = createMarker();
            } else {
              const match = lastAttributeNameRegex.exec(s);
              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
              }
              insert = document.createTextNode(s);
            }
            parent.insertBefore(insert, node);
            this.parts.push({ type: "node", index: ++index });
          }
          if (strings2[lastIndex] === "") {
            parent.insertBefore(createMarker(), node);
            nodesToRemove.push(node);
          } else {
            node.data = strings2[lastIndex];
          }
          partIndex += lastIndex;
        }
      } else if (node.nodeType === 8) {
        if (node.data === marker) {
          const parent = node.parentNode;
          if (node.previousSibling === null || index === lastPartIndex) {
            index++;
            parent.insertBefore(createMarker(), node);
          }
          lastPartIndex = index;
          this.parts.push({ type: "node", index });
          if (node.nextSibling === null) {
            node.data = "";
          } else {
            nodesToRemove.push(node);
            index--;
          }
          partIndex++;
        } else {
          let i = -1;
          while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
            this.parts.push({ type: "node", index: -1 });
            partIndex++;
          }
        }
      }
    }
    for (const n of nodesToRemove) {
      n.parentNode.removeChild(n);
    }
  }
};
var endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};
var isTemplatePartActive = (part) => part.index !== -1;
var createMarker = () => document.createComment("");
var lastAttributeNameRegex = (
  // eslint-disable-next-line no-control-regex
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/
);

// node_modules/lit-html/lib/modify-template.js
var walkerNodeFilter = 133;
function removeNodesFromTemplate(template, nodesToRemove) {
  const { element: { content }, parts: parts2 } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let part = parts2[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;
  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode;
    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    }
    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node);
      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    }
    if (currentRemovingNode !== null) {
      removeCount++;
    }
    while (part !== void 0 && part.index === nodeIndex) {
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
      part = parts2[partIndex];
    }
  }
  nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
}
var countNodes = (node) => {
  let count = node.nodeType === 11 ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
  while (walker.nextNode()) {
    count++;
  }
  return count;
};
var nextActiveIndexInTemplateParts = (parts2, startIndex = -1) => {
  for (let i = startIndex + 1; i < parts2.length; i++) {
    const part = parts2[i];
    if (isTemplatePartActive(part)) {
      return i;
    }
  }
  return -1;
};
function insertNodeIntoTemplate(template, node, refNode = null) {
  const { element: { content }, parts: parts2 } = template;
  if (refNode === null || refNode === void 0) {
    content.appendChild(node);
    return;
  }
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let insertCount = 0;
  let walkerIndex = -1;
  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;
    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }
    while (partIndex !== -1 && parts2[partIndex].index === walkerIndex) {
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts2[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
        }
        return;
      }
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
    }
  }
}

// node_modules/lit-html/lib/directive.js
var directives = /* @__PURE__ */ new WeakMap();
var directive = (f) => (...args) => {
  const d = f(...args);
  directives.set(d, true);
  return d;
};
var isDirective = (o) => {
  return typeof o === "function" && directives.has(o);
};

// node_modules/lit-html/lib/part.js
var noChange = {};
var nothing = {};

// node_modules/lit-html/lib/template-instance.js
var TemplateInstance = class {
  constructor(template, processor, options) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }
  update(values) {
    let i = 0;
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.setValue(values[i]);
      }
      i++;
    }
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.commit();
      }
    }
  }
  _clone() {
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts2 = this.template.parts;
    const walker = document.createTreeWalker(fragment, 133, null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode();
    while (partIndex < parts2.length) {
      part = parts2[partIndex];
      if (!isTemplatePartActive(part)) {
        this.__parts.push(void 0);
        partIndex++;
        continue;
      }
      while (nodeIndex < part.index) {
        nodeIndex++;
        if (node.nodeName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
        if ((node = walker.nextNode()) === null) {
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      }
      if (part.type === "node") {
        const part2 = this.processor.handleTextExpression(this.options);
        part2.insertAfterNode(node.previousSibling);
        this.__parts.push(part2);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }
      partIndex++;
    }
    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }
    return fragment;
  }
};

// node_modules/lit-html/lib/template-result.js
var policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (s) => s });
var commentMarker = ` ${marker} `;
var TemplateResult = class {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  /**
   * Returns a string of HTML used to create a `<template>` element.
   */
  getHTML() {
    const l = this.strings.length - 1;
    let html2 = "";
    let isCommentBinding = false;
    for (let i = 0; i < l; i++) {
      const s = this.strings[i];
      const commentOpen = s.lastIndexOf("<!--");
      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf("-->", commentOpen + 1) === -1;
      const attributeMatch = lastAttributeNameRegex.exec(s);
      if (attributeMatch === null) {
        html2 += s + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        html2 += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }
    html2 += this.strings[l];
    return html2;
  }
  getTemplateElement() {
    const template = document.createElement("template");
    let value = this.getHTML();
    if (policy !== void 0) {
      value = policy.createHTML(value);
    }
    template.innerHTML = value;
    return template;
  }
};

// node_modules/lit-html/lib/parts.js
var isPrimitive = (value) => {
  return value === null || !(typeof value === "object" || typeof value === "function");
};
var isIterable = (value) => {
  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  !!(value && value[Symbol.iterator]);
};
var AttributeCommitter = class {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];
    for (let i = 0; i < strings.length - 1; i++) {
      this.parts[i] = this._createPart();
    }
  }
  /**
   * Creates a single part. Override this to create a differnt type of part.
   */
  _createPart() {
    return new AttributePart(this);
  }
  _getValue() {
    const strings = this.strings;
    const l = strings.length - 1;
    const parts2 = this.parts;
    if (l === 1 && strings[0] === "" && strings[1] === "") {
      const v = parts2[0].value;
      if (typeof v === "symbol") {
        return String(v);
      }
      if (typeof v === "string" || !isIterable(v)) {
        return v;
      }
    }
    let text = "";
    for (let i = 0; i < l; i++) {
      text += strings[i];
      const part = parts2[i];
      if (part !== void 0) {
        const v = part.value;
        if (isPrimitive(v) || !isIterable(v)) {
          text += typeof v === "string" ? v : String(v);
        } else {
          for (const t of v) {
            text += typeof t === "string" ? t : String(t);
          }
        }
      }
    }
    text += strings[l];
    return text;
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }
};
var AttributePart = class {
  constructor(committer) {
    this.value = void 0;
    this.committer = committer;
  }
  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value;
      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }
  commit() {
    while (isDirective(this.value)) {
      const directive2 = this.value;
      this.value = noChange;
      directive2(this);
    }
    if (this.value === noChange) {
      return;
    }
    this.committer.commit();
  }
};
var NodePart = class {
  constructor(options) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.options = options;
  }
  /**
   * Appends this part into a container.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  /**
   * Inserts this part after the `ref` node (between `ref` and `ref`'s next
   * sibling). Both `ref` and its next sibling must be static, unchanging nodes
   * such as those that appear in a literal section of a template.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  /**
   * Appends this part into a parent part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());
    part.__insert(this.endNode = createMarker());
  }
  /**
   * Inserts this part after the `ref` part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  insertAfterPart(ref) {
    ref.__insert(this.startNode = createMarker());
    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    const value = this.__pendingValue;
    if (value === noChange) {
      return;
    }
    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof TemplateResult) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      this.__commitText(value);
    }
  }
  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }
  __commitNode(value) {
    if (this.value === value) {
      return;
    }
    this.clear();
    this.__insert(value);
    this.value = value;
  }
  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? "" : value;
    const valueAsString = typeof value === "string" ? value : String(value);
    if (node === this.endNode.previousSibling && node.nodeType === 3) {
      node.data = valueAsString;
    } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }
    this.value = value;
  }
  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);
    if (this.value instanceof TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      const instance = new TemplateInstance(template, value.processor, this.options);
      const fragment = instance._clone();
      instance.update(value.values);
      this.__commitNode(fragment);
      this.value = instance;
    }
  }
  __commitIterable(value) {
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    }
    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      itemPart = itemParts[partIndex];
      if (itemPart === void 0) {
        itemPart = new NodePart(this.options);
        itemParts.push(itemPart);
        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }
      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }
  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }
};
var BooleanAttributePart = class {
  constructor(element, name, strings) {
    this.value = void 0;
    this.__pendingValue = void 0;
    if (strings.length !== 2 || strings[0] !== "" || strings[1] !== "") {
      throw new Error("Boolean attributes can only contain a single expression");
    }
    this.element = element;
    this.name = name;
    this.strings = strings;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const value = !!this.__pendingValue;
    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, "");
      } else {
        this.element.removeAttribute(this.name);
      }
      this.value = value;
    }
    this.__pendingValue = noChange;
  }
};
var PropertyCommitter = class extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === "" && strings[1] === "";
  }
  _createPart() {
    return new PropertyPart(this);
  }
  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }
    return super._getValue();
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element[this.name] = this._getValue();
    }
  }
};
var PropertyPart = class extends AttributePart {
};
var eventOptionsSupported = false;
(() => {
  try {
    const options = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }
    };
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (_e) {
  }
})();
var EventPart = class {
  constructor(element, eventName, eventContext) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;
    this.__boundHandleEvent = (e) => this.handleEvent(e);
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    this.value = newListener;
    this.__pendingValue = noChange;
  }
  handleEvent(event) {
    if (typeof this.value === "function") {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }
};
var getOptions = (o) => o && (eventOptionsSupported ? { capture: o.capture, passive: o.passive, once: o.once } : o.capture);

// node_modules/lit-html/lib/template-factory.js
function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(result.type, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    template = new Template(result, result.getTemplateElement());
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
}
var templateCaches = /* @__PURE__ */ new Map();

// node_modules/lit-html/lib/render.js
var parts = /* @__PURE__ */ new WeakMap();
var render = (result, container, options) => {
  let part = parts.get(container);
  if (part === void 0) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
    part.appendInto(container);
  }
  part.setValue(result);
  part.commit();
};

// node_modules/lit-html/lib/default-template-processor.js
var DefaultTemplateProcessor = class {
  /**
   * Create parts for an attribute-position binding, given the event, attribute
   * name, and string literals.
   *
   * @param element The element containing the binding
   * @param name  The attribute name
   * @param strings The string literals. There are always at least two strings,
   *   event for fully-controlled bindings with a single expression.
   */
  handleAttributeExpressions(element, name, strings, options) {
    const prefix = name[0];
    if (prefix === ".") {
      const committer2 = new PropertyCommitter(element, name.slice(1), strings);
      return committer2.parts;
    }
    if (prefix === "@") {
      return [new EventPart(element, name.slice(1), options.eventContext)];
    }
    if (prefix === "?") {
      return [new BooleanAttributePart(element, name.slice(1), strings)];
    }
    const committer = new AttributeCommitter(element, name, strings);
    return committer.parts;
  }
  /**
   * Create parts for a text-position binding.
   * @param templateFactory
   */
  handleTextExpression(options) {
    return new NodePart(options);
  }
};
var defaultTemplateProcessor = new DefaultTemplateProcessor();

// node_modules/lit-html/lit-html.js
if (typeof window !== "undefined") {
  (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
}
var html = (strings, ...values) => new TemplateResult(strings, values, "html", defaultTemplateProcessor);

// node_modules/lit-html/lib/shady-render.js
var getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
var compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === "undefined") {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === "undefined") {
  console.warn(`Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
var shadyTemplateFactory = (scopeName) => (result) => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    const element = result.getTemplateElement();
    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }
    template = new Template(result, element);
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
};
var TEMPLATE_TYPES = ["html", "svg"];
var removeStylesFromLitTemplates = (scopeName) => {
  TEMPLATE_TYPES.forEach((type) => {
    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
    if (templates !== void 0) {
      templates.keyString.forEach((template) => {
        const { element: { content } } = template;
        const styles = /* @__PURE__ */ new Set();
        Array.from(content.querySelectorAll("style")).forEach((s) => {
          styles.add(s);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};
var shadyRenderSet = /* @__PURE__ */ new Set();
var prepareTemplateStyles = (scopeName, renderedDOM, template) => {
  shadyRenderSet.add(scopeName);
  const templateElement = !!template ? template.element : document.createElement("template");
  const styles = renderedDOM.querySelectorAll("style");
  const { length } = styles;
  if (length === 0) {
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }
  const condensedStyle = document.createElement("style");
  for (let i = 0; i < length; i++) {
    const style2 = styles[i];
    style2.parentNode.removeChild(style2);
    condensedStyle.textContent += style2.textContent;
  }
  removeStylesFromLitTemplates(scopeName);
  const content = templateElement.content;
  if (!!template) {
    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
  } else {
    content.insertBefore(condensedStyle, content.firstChild);
  }
  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style = content.querySelector("style");
  if (window.ShadyCSS.nativeShadow && style !== null) {
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template) {
    content.insertBefore(condensedStyle, content.firstChild);
    const removes = /* @__PURE__ */ new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
var render2 = (result, container, options) => {
  if (!options || typeof options !== "object" || !options.scopeName) {
    throw new Error("The `scopeName` option is required.");
  }
  const scopeName = options.scopeName;
  const hasRendered = parts.has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
  if (firstScopeRender) {
    const part = parts.get(renderContainer);
    parts.delete(renderContainer);
    const template = part.value instanceof TemplateInstance ? part.value.template : void 0;
    prepareTemplateStyles(scopeName, renderContainer, template);
    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    parts.set(container, part);
  }
  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};

// node_modules/lit-element/lib/updating-element.js
var _a2;
window.JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? "" : null;
      case Object:
      case Array:
        return value == null ? value : JSON.stringify(value);
    }
    return value;
  },
  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;
      case Number:
        return value === null ? null : Number(value);
      case Object:
      case Array:
        return JSON.parse(value);
    }
    return value;
  }
};
var notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var STATE_HAS_UPDATED = 1;
var STATE_UPDATE_REQUESTED = 1 << 2;
var STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
var STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
var finalized = "finalized";
var UpdatingElement = class extends HTMLElement {
  constructor() {
    super();
    this.initialize();
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   */
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this._classProperties.forEach((v, p) => {
      const attr = this._attributeNameForProperty(p, v);
      if (attr !== void 0) {
        this._attributeToPropertyMap.set(attr, p);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  /**
   * Ensures the private `_classProperties` property metadata is created.
   * In addition to `finalize` this is also called in `createProperty` to
   * ensure the `@property` decorator can add property metadata.
   */
  /** @nocollapse */
  static _ensureClassProperties() {
    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
      this._classProperties = /* @__PURE__ */ new Map();
      const superProperties = Object.getPrototypeOf(this)._classProperties;
      if (superProperties !== void 0) {
        superProperties.forEach((v, k) => this._classProperties.set(k, v));
      }
    }
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a PropertyDeclaration for the property with the given options.
   * The property setter calls the property's `hasChanged` property option
   * or uses a strict identity check to determine whether or not to request
   * an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   *
   * @nocollapse
   */
  static createProperty(name, options = defaultPropertyDeclaration) {
    this._ensureClassProperties();
    this._classProperties.set(name, options);
    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }
    const key = typeof name === "symbol" ? Symbol() : `__${name}`;
    const descriptor = this.getPropertyDescriptor(name, key, options);
    if (descriptor !== void 0) {
      Object.defineProperty(this.prototype, name, descriptor);
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   *   class MyElement extends LitElement {
   *     static getPropertyDescriptor(name, key, options) {
   *       const defaultDescriptor =
   *           super.getPropertyDescriptor(name, key, options);
   *       const setter = defaultDescriptor.set;
   *       return {
   *         get: defaultDescriptor.get,
   *         set(value) {
   *           setter.call(this, value);
   *           // custom action.
   *         },
   *         configurable: true,
   *         enumerable: true
   *       }
   *     }
   *   }
   *
   * @nocollapse
   */
  static getPropertyDescriptor(name, key, options) {
    return {
      // tslint:disable-next-line:no-any no symbol in index
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdateInternal(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a PropertyDeclaration via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override `createProperty`.
   *
   * @nocollapse
   * @final
   */
  static getPropertyOptions(name) {
    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
  }
  /**
   * Creates property accessors for registered properties and ensures
   * any superclasses are also finalized.
   * @nocollapse
   */
  static finalize() {
    const superCtor = Object.getPrototypeOf(this);
    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }
    this[finalized] = true;
    this._ensureClassProperties();
    this._attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...typeof Object.getOwnPropertySymbols === "function" ? Object.getOwnPropertySymbols(props) : []
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static _attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  /**
   * Returns true if a property should request an update.
   * Called when a property value is set and uses the `hasChanged`
   * option for the property if present or a strict identity check.
   * @nocollapse
   */
  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  /**
   * Returns the property value for the given attribute value.
   * Called via the `attributeChangedCallback` and uses the property's
   * `converter` or `converter.fromAttribute` property option.
   * @nocollapse
   */
  static _propertyValueFromAttribute(value, options) {
    const type = options.type;
    const converter = options.converter || defaultConverter;
    const fromAttribute = typeof converter === "function" ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  /**
   * Returns the attribute value for the given property value. If this
   * returns undefined, the property will *not* be reflected to an attribute.
   * If this returns null, the attribute will be removed, otherwise the
   * attribute will be set to the value.
   * This uses the property's `reflect` and `type.toAttribute` property options.
   * @nocollapse
   */
  static _propertyValueToAttribute(value, options) {
    if (options.reflect === void 0) {
      return;
    }
    const type = options.type;
    const converter = options.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  /**
   * Performs element initialization. By default captures any pre-set values for
   * registered properties.
   */
  initialize() {
    this._updateState = 0;
    this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);
    this._changedProperties = /* @__PURE__ */ new Map();
    this._saveInstanceProperties();
    this.requestUpdateInternal();
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */
  _saveInstanceProperties() {
    this.constructor._classProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        const value = this[p];
        delete this[p];
        if (!this._instanceProperties) {
          this._instanceProperties = /* @__PURE__ */ new Map();
        }
        this._instanceProperties.set(p, value);
      }
    });
  }
  /**
   * Applies previously saved instance properties.
   */
  _applyInstanceProperties() {
    this._instanceProperties.forEach((v, p) => this[p] = v);
    this._instanceProperties = void 0;
  }
  connectedCallback() {
    this.enableUpdating();
  }
  enableUpdating() {
    if (this._enableUpdatingResolver !== void 0) {
      this._enableUpdatingResolver();
      this._enableUpdatingResolver = void 0;
    }
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   */
  disconnectedCallback() {
  }
  /**
   * Synchronizes property values when attributes change.
   */
  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }
  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    const ctor = this.constructor;
    const attr = ctor._attributeNameForProperty(name, options);
    if (attr !== void 0) {
      const attrValue = ctor._propertyValueToAttribute(value, options);
      if (attrValue === void 0) {
        return;
      }
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }
  _attributeToProperty(name, value) {
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }
    const ctor = this.constructor;
    const propName = ctor._attributeToPropertyMap.get(name);
    if (propName !== void 0) {
      const options = ctor.getPropertyOptions(propName);
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = // tslint:disable-next-line:no-any
      ctor._propertyValueFromAttribute(value, options);
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  /**
   * This protected version of `requestUpdate` does not access or return the
   * `updateComplete` promise. This promise can be overridden and is therefore
   * not free to access.
   */
  requestUpdateInternal(name, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      const ctor = this.constructor;
      options = options || ctor.getPropertyOptions(name);
      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        }
        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === void 0) {
            this._reflectingProperties = /* @__PURE__ */ new Map();
          }
          this._reflectingProperties.set(name, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._updatePromise = this._enqueueUpdate();
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should
   * be called when an element should update based on some state not triggered
   * by setting a property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored. Returns the `updateComplete` Promise which is resolved
   * when the update completes.
   *
   * @param name {PropertyKey} (optional) name of requesting property
   * @param oldValue {any} (optional) old value of requesting property
   * @returns {Promise} A Promise that is resolved when the update completes.
   */
  requestUpdate(name, oldValue) {
    this.requestUpdateInternal(name, oldValue);
    return this.updateComplete;
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async _enqueueUpdate() {
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    try {
      await this._updatePromise;
    } catch (e) {
    }
    const result = this.performUpdate();
    if (result != null) {
      await result;
    }
    return !this._hasRequestedUpdate;
  }
  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }
  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * You can override this method to change the timing of updates. If this
   * method is overridden, `super.performUpdate()` must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```
   * protected async performUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.performUpdate();
   * }
   * ```
   */
  performUpdate() {
    if (!this._hasRequestedUpdate) {
      return;
    }
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }
    let shouldUpdate = false;
    const changedProperties = this._changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.update(changedProperties);
      } else {
        this._markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this._markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
    }
  }
  _markUpdated() {
    this._changedProperties = /* @__PURE__ */ new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `_getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super._getUpdateComplete()`, then any subsequent state.
   *
   * @returns {Promise} The Promise returns a boolean that indicates if the
   * update resolved without triggering another update.
   */
  get updateComplete() {
    return this._getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async _getUpdateComplete() {
   *       await super._getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   * @deprecated Override `getUpdateComplete()` instead for forward
   *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.
   */
  _getUpdateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async getUpdateComplete() {
   *       await super.getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   */
  getUpdateComplete() {
    return this._updatePromise;
  }
  /**
   * Controls whether or not `update` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  update(_changedProperties) {
    if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
      this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
      this._reflectingProperties = void 0;
    }
    this._markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  firstUpdated(_changedProperties) {
  }
};
_a2 = finalized;
UpdatingElement[_a2] = true;

// node_modules/lit-element/lib/decorators.js
var legacyCustomElement = (tagName, clazz) => {
  window.customElements.define(tagName, clazz);
  return clazz;
};
var standardCustomElement = (tagName, descriptor) => {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    // This callback is called once the class is otherwise fully defined
    finisher(clazz) {
      window.customElements.define(tagName, clazz);
    }
  };
};
var customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
var standardProperty = (options, element) => {
  if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
    return Object.assign(Object.assign({}, element), { finisher(clazz) {
      clazz.createProperty(element.key, options);
    } });
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      // When @babel/plugin-proposal-decorators implements initializers,
      // do this instead of the initializer below. See:
      // https://github.com/babel/babel/issues/9260 extras: [
      //   {
      //     kind: 'initializer',
      //     placement: 'own',
      //     initializer: descriptor.initializer,
      //   }
      // ],
      initializer() {
        if (typeof element.initializer === "function") {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  }
};
var legacyProperty = (options, proto, name) => {
  proto.constructor.createProperty(name, options);
};
function property(options) {
  return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
}
function internalProperty(options) {
  return property({ attribute: false, hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged });
}
var state = (options) => internalProperty(options);
var ElementProto = Element.prototype;
var legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;

// node_modules/lit-element/lib/css-tag.js
var supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var CSSResult = class {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  // Note, this is a getter so that it's lazy. In practice, this means
  // stylesheets are not created until the first element instance is made.
  get styleSheet() {
    if (this._styleSheet === void 0) {
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();
        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }
    return this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var unsafeCSS = (value) => {
  return new CSSResult(String(value), constructionToken);
};
var textFromCSSResult = (value) => {
  if (value instanceof CSSResult) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
var css = (strings, ...values) => {
  const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, constructionToken);
};

// node_modules/lit-element/lit-element.js
(window["litElementVersions"] || (window["litElementVersions"] = [])).push("2.5.1");
var renderNotImplemented = {};
var LitElement = class extends UpdatingElement {
  /**
   * Return the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * @nocollapse
   */
  static getStyles() {
    return this.styles;
  }
  /** @nocollapse */
  static _getUniqueStyles() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
      return;
    }
    const userStyles = this.getStyles();
    if (Array.isArray(userStyles)) {
      const addStyles = (styles2, set2) => styles2.reduceRight((set3, s) => (
        // Note: On IE set.add() does not return the set
        Array.isArray(s) ? addStyles(s, set3) : (set3.add(s), set3)
      ), set2);
      const set = addStyles(userStyles, /* @__PURE__ */ new Set());
      const styles = [];
      set.forEach((v) => styles.unshift(v));
      this._styles = styles;
    } else {
      this._styles = userStyles === void 0 ? [] : [userStyles];
    }
    this._styles = this._styles.map((s) => {
      if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
        const cssText = Array.prototype.slice.call(s.cssRules).reduce((css2, rule) => css2 + rule.cssText, "");
        return unsafeCSS(cssText);
      }
      return s;
    });
  }
  /**
   * Performs element initialization. By default this calls
   * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
   * captures any pre-set values for registered properties.
   */
  initialize() {
    super.initialize();
    this.constructor._getUniqueStyles();
    this.renderRoot = this.createRenderRoot();
    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   * @returns {Element|DocumentFragment} Returns a node into which to render.
   */
  createRenderRoot() {
    return this.attachShadow(this.constructor.shadowRootOptions);
  }
  /**
   * Applies styling to the element shadowRoot using the [[`styles`]]
   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
   * available and will fallback otherwise. When Shadow DOM is polyfilled,
   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
   * is available but `adoptedStyleSheets` is not, styles are appended to the
   * end of the `shadowRoot` to [mimic spec
   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
   */
  adoptStyles() {
    const styles = this.constructor._styles;
    if (styles.length === 0) {
      return;
    }
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
    } else {
      this._needsShimAdoptedStyleSheets = true;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.hasUpdated && window.ShadyCSS !== void 0) {
      window.ShadyCSS.styleElement(this);
    }
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param _changedProperties Map of changed properties with old values
   */
  update(changedProperties) {
    const templateResult = this.render();
    super.update(changedProperties);
    if (templateResult !== renderNotImplemented) {
      this.constructor.render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
    }
    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;
      this.constructor._styles.forEach((s) => {
        const style = document.createElement("style");
        style.textContent = s.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `NodePart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   */
  render() {
    return renderNotImplemented;
  }
};
LitElement["finalized"] = true;
LitElement.render = render2;
LitElement.shadowRootOptions = { mode: "open" };

// node_modules/@microsoft/mgt-element/dist/es6/utils/EventDispatcher.js
var EventDispatcher = class {
  constructor() {
    this.eventHandlers = [];
  }
  /**
   * fires event handler
   *
   * @param {E} event
   * @memberof EventDispatcher
   */
  fire(event) {
    for (const handler of this.eventHandlers) {
      handler(event);
    }
  }
  /**
   * adds eventHandler
   *
   * @param {EventHandler<E>} eventHandler
   * @memberof EventDispatcher
   */
  add(eventHandler) {
    this.eventHandlers.push(eventHandler);
  }
  /**
   * removes eventHandler
   *
   * @param {EventHandler<E>} eventHandler
   * @memberof EventDispatcher
   */
  remove(eventHandler) {
    for (let i = 0; i < this.eventHandlers.length; i++) {
      if (this.eventHandlers[i] === eventHandler) {
        this.eventHandlers.splice(i, 1);
        i--;
      }
    }
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/providers/IProvider.js
var IProvider = class {
  /**
   * returns state of Provider
   *
   * @readonly
   * @type {ProviderState}
   * @memberof IProvider
   */
  get state() {
    return this._state;
  }
  /**
   * Incremental consent setting
   *
   * @readonly
   * @memberof IProvider
   */
  get isIncrementalConsentDisabled() {
    return this._isIncrementalConsentDisabled;
  }
  /**
   * Enable/Disable incremental consent
   *
   * @readonly
   * @memberof IProvider
   */
  set isIncrementalConsentDisabled(disabled) {
    this._isIncrementalConsentDisabled = disabled;
  }
  /**
   * Name used for analytics
   *
   * @readonly
   * @memberof IProvider
   */
  get name() {
    return "MgtIProvider";
  }
  constructor() {
    this.isMultipleAccountDisabled = true;
    this._loginChangedDispatcher = new EventDispatcher();
    this._activeAccountChangedDispatcher = new EventDispatcher();
    this._isIncrementalConsentDisabled = false;
    this._state = ProviderState.Loading;
  }
  /**
   * sets state of Provider and fires loginchangedDispatcher
   *
   * @param {ProviderState} state
   * @memberof IProvider
   */
  setState(state2) {
    if (state2 !== this._state) {
      this._state = state2;
      this._loginChangedDispatcher.fire({});
    }
  }
  /**
   * event handler when login changes
   *
   * @param {EventHandler<LoginChangedEvent>} eventHandler
   * @memberof IProvider
   */
  onStateChanged(eventHandler) {
    this._loginChangedDispatcher.add(eventHandler);
  }
  /**
   * removes event handler for when login changes
   *
   * @param {EventHandler<LoginChangedEvent>} eventHandler
   * @memberof IProvider
   */
  removeStateChangedHandler(eventHandler) {
    this._loginChangedDispatcher.remove(eventHandler);
  }
  /**
   * Switch between two signed in accounts
   *
   * @param {*} user
   * @memberof IProvider
   */
  setActiveAccount(user) {
    this.fireActiveAccountChanged();
  }
  /**
   * Event handler when Active account changes
   *
   * @param {EventHandler<ActiveAccountChanged>} eventHandler
   * @memberof IProvider
   */
  onActiveAccountChanged(eventHandler) {
    this._activeAccountChangedDispatcher.add(eventHandler);
  }
  /**
   * Removes event handler for when Active account changes
   *
   * @param {EventHandler<ActiveAccountChanged>} eventHandler
   * @memberof IProvider
   */
  removeActiveAccountChangedHandler(eventHandler) {
    this._activeAccountChangedDispatcher.remove(eventHandler);
  }
  /**
   * Fires event when active account changes
   *
   * @memberof IProvider
   */
  fireActiveAccountChanged() {
    this._activeAccountChangedDispatcher.fire({});
  }
  /**
   * uses scopes to recieve access token
   *
   * @param {...string[]} scopes
   * @returns {Promise<string>}
   * @memberof IProvider
   */
  getAccessTokenForScopes(...scopes) {
    return this.getAccessToken({ scopes });
  }
};
var LoginType;
(function(LoginType2) {
  LoginType2[LoginType2["Popup"] = 0] = "Popup";
  LoginType2[LoginType2["Redirect"] = 1] = "Redirect";
})(LoginType || (LoginType = {}));
var ProviderState;
(function(ProviderState2) {
  ProviderState2[ProviderState2["Loading"] = 0] = "Loading";
  ProviderState2[ProviderState2["SignedOut"] = 1] = "SignedOut";
  ProviderState2[ProviderState2["SignedIn"] = 2] = "SignedIn";
})(ProviderState || (ProviderState = {}));

// node_modules/@microsoft/mgt-element/dist/es6/providers/Providers.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Providers = class {
  /**
   * returns the value of provider used globally. All components use this property to get a reference to the provider.
   *
   * @static
   * @type {IProvider}
   * @memberof Providers
   */
  static get globalProvider() {
    return this._globalProvider;
  }
  static set globalProvider(provider) {
    if (provider !== this._globalProvider) {
      if (this._globalProvider) {
        this._globalProvider.removeStateChangedHandler(this.handleProviderStateChanged);
        this._globalProvider.removeActiveAccountChangedHandler(this.handleActiveAccountChanged);
      }
      if (provider) {
        provider.onStateChanged(this.handleProviderStateChanged);
        provider.onActiveAccountChanged(this.handleActiveAccountChanged);
      }
      this._globalProvider = provider;
      this._eventDispatcher.fire(ProvidersChangedState.ProviderChanged);
    }
  }
  /**
   * Fires event when Provider changes state
   *
   * @static
   * @param {EventHandler<ProvidersChangedState>} event
   * @memberof Providers
   */
  static onProviderUpdated(event) {
    this._eventDispatcher.add(event);
  }
  /**
   * Remove event handler
   *
   * @static
   * @param {EventHandler<ProvidersChangedState>} event
   * @memberof Providers
   */
  static removeProviderUpdatedListener(event) {
    this._eventDispatcher.remove(event);
  }
  /**
   * Fires event when Provider changes state
   *
   * @static
   * @param {EventHandler<ProvidersChangedState>} event
   * @memberof Providers
   */
  static onActiveAccountChanged(event) {
    this._activeAccountChangedDispatcher.add(event);
  }
  /**
   * Remove event handler
   *
   * @static
   * @param {EventHandler<ProvidersChangedState>} event
   * @memberof Providers
   */
  static removeActiveAccountChangedListener(event) {
    this._activeAccountChangedDispatcher.remove(event);
  }
  /**
   * Gets the current signed in user
   *
   * @static
   * @memberof Providers
   */
  static me() {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!this._me) {
        const client = this.client;
        if (client) {
          try {
            const response = yield client.api("me").get();
            if (response && response.id) {
              this._me = response;
            }
          } catch (_a3) {
          }
        }
      }
      return this._me;
    });
  }
  /**
   * Gets the current graph client
   *
   * @readonly
   * @static
   * @type {Client}
   * @memberof Providers
   */
  static get client() {
    if (Providers.globalProvider && Providers.globalProvider.state === ProviderState.SignedIn) {
      return Providers.globalProvider.graph.client;
    }
    return null;
  }
  static handleProviderStateChanged() {
    if (!Providers.globalProvider || Providers.globalProvider.state !== ProviderState.SignedIn) {
      Providers._me = null;
    }
    Providers._eventDispatcher.fire(ProvidersChangedState.ProviderStateChanged);
  }
  static handleActiveAccountChanged() {
    Providers._activeAccountChangedDispatcher.fire(null);
  }
};
Providers._eventDispatcher = new EventDispatcher();
Providers._activeAccountChangedDispatcher = new EventDispatcher();
var ProvidersChangedState;
(function(ProvidersChangedState2) {
  ProvidersChangedState2[ProvidersChangedState2["ProviderChanged"] = 0] = "ProviderChanged";
  ProvidersChangedState2[ProvidersChangedState2["ProviderStateChanged"] = 1] = "ProviderStateChanged";
})(ProvidersChangedState || (ProvidersChangedState = {}));

// node_modules/@microsoft/mgt-element/dist/es6/utils/LocalizationHelper.js
var LocalizationHelper = class {
  static get strings() {
    return this._strings;
  }
  /**
   * Set strings to be localized
   *
   * @static
   * @memberof LocalizationHelper
   */
  static set strings(value) {
    this._strings = value;
    this._stringsEventDispatcher.fire(null);
  }
  /**
   * returns body dir attribute to determine rtl or ltr
   *
   * @static
   * @returns {string} dir
   * @memberof LocalizationHelper
   */
  static getDocumentDirection() {
    var _a3, _b;
    return ((_a3 = document.body) === null || _a3 === void 0 ? void 0 : _a3.getAttribute("dir")) || ((_b = document.documentElement) === null || _b === void 0 ? void 0 : _b.getAttribute("dir"));
  }
  /**
   * Fires event when LocalizationHelper changes state
   *
   * @static
   * @param {EventHandler<ProvidersChangedState>} event
   * @memberof LocalizationHelper
   */
  static onStringsUpdated(event) {
    this._stringsEventDispatcher.add(event);
  }
  static removeOnStringsUpdated(event) {
    this._stringsEventDispatcher.remove(event);
  }
  static onDirectionUpdated(event) {
    this._directionEventDispatcher.add(event);
    this.initDirection();
  }
  static removeOnDirectionUpdated(event) {
    this._directionEventDispatcher.remove(event);
  }
  /**
   * Checks for direction setup and adds mutationObserver
   *
   * @private
   * @static
   * @returns
   * @memberof LocalizationHelper
   */
  static initDirection() {
    if (this._isDirectionInit) {
      return;
    }
    this._isDirectionInit = true;
    this.mutationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName == "dir") {
          this._directionEventDispatcher.fire(null);
        }
      });
    });
    const options = { attributes: true, attributeFilter: ["dir"] };
    this.mutationObserver.observe(document.body, options);
    this.mutationObserver.observe(document.documentElement, options);
  }
  /**
   * Provided helper method to determine localized or defaultString for specific string is returned
   *
   * @static updateStringsForTag
   * @param {string} tagName
   * @param  stringsObj
   * @returns
   * @memberof LocalizationHelper
   */
  static updateStringsForTag(tagName, stringObj) {
    tagName = tagName.toLowerCase();
    if (tagName.startsWith("mgt-")) {
      tagName = tagName.substring(4);
    }
    if (this._strings && stringObj) {
      for (let prop of Object.entries(stringObj)) {
        if (this._strings[prop[0]]) {
          stringObj[prop[0]] = this._strings[prop[0]];
        }
      }
      if (this._strings["_components"] && this._strings["_components"][tagName]) {
        let strings = this._strings["_components"][tagName];
        for (let key of Object.keys(strings)) {
          if (stringObj[key]) {
            stringObj[key] = strings[key];
          }
        }
      }
    }
    return stringObj;
  }
};
LocalizationHelper._stringsEventDispatcher = new EventDispatcher();
LocalizationHelper._directionEventDispatcher = new EventDispatcher();
LocalizationHelper._isDirectionInit = false;

// node_modules/@microsoft/mgt-element/dist/es6/components/baseComponent.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ComponentMediaQuery;
(function(ComponentMediaQuery2) {
  ComponentMediaQuery2["mobile"] = "";
  ComponentMediaQuery2["tablet"] = "tablet";
  ComponentMediaQuery2["desktop"] = "desktop";
})(ComponentMediaQuery || (ComponentMediaQuery = {}));
var MgtBaseComponent = class extends LitElement {
  /**
   * Gets the ComponentMediaQuery of the component
   *
   * @readonly
   * @type {MgtElement.ComponentMediaQuery}
   * @memberof MgtBaseComponent
   */
  get mediaQuery() {
    if (this.offsetWidth < 768) {
      return ComponentMediaQuery.mobile;
    } else if (this.offsetWidth < 1200) {
      return ComponentMediaQuery.tablet;
    } else {
      return ComponentMediaQuery.desktop;
    }
  }
  /**
   * A flag to check if the component is loading data state.
   *
   * @protected
   * @memberof MgtBaseComponent
   */
  get isLoadingState() {
    return this._isLoadingState;
  }
  /**
   * A flag to check if the component has updated once.
   *
   * @readonly
   * @protected
   * @type {boolean}
   * @memberof MgtBaseComponent
   */
  get isFirstUpdated() {
    return this._isFirstUpdated;
  }
  /**
   * returns component strings
   *
   * @readonly
   * @protected
   * @memberof MgtBaseComponent
   */
  get strings() {
    return {};
  }
  constructor() {
    super();
    this.direction = "ltr";
    this._isLoadingState = false;
    this._isFirstUpdated = false;
    this.handleLocalizationChanged = this.handleLocalizationChanged.bind(this);
    this.handleDirectionChanged = this.handleDirectionChanged.bind(this);
    this.handleProviderUpdates = this.handleProviderUpdates.bind(this);
    this.handleActiveAccountUpdates = this.handleActiveAccountUpdates.bind(this);
    this.handleDirectionChanged();
    this.handleLocalizationChanged();
  }
  /**
   * Invoked each time the custom element is appended into a document-connected element
   *
   * @memberof MgtBaseComponent
   */
  connectedCallback() {
    super.connectedCallback();
    LocalizationHelper.onStringsUpdated(this.handleLocalizationChanged);
    LocalizationHelper.onDirectionUpdated(this.handleDirectionChanged);
  }
  /**
   * Invoked each time the custom element is removed from a document-connected element
   *
   * @memberof MgtBaseComponent
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    LocalizationHelper.removeOnStringsUpdated(this.handleLocalizationChanged);
    LocalizationHelper.removeOnDirectionUpdated(this.handleDirectionChanged);
    Providers.removeProviderUpdatedListener(this.handleProviderUpdates);
    Providers.removeActiveAccountChangedListener(this.handleActiveAccountUpdates);
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    this._isFirstUpdated = true;
    Providers.onProviderUpdated(this.handleProviderUpdates);
    Providers.onActiveAccountChanged(this.handleActiveAccountUpdates);
    this.requestStateUpdate();
  }
  /**
   * load state into the component.
   * Override this function to provide additional loading logic.
   */
  loadState() {
    return Promise.resolve();
  }
  clearState() {
  }
  /**
   * helps facilitate creation of events across components
   *
   * @protected
   * @param {string} eventName
   * @param {*} [detail]
   * @param {boolean} [bubbles=false]
   * @param {boolean} [cancelable=false]
   * @return {*}  {boolean}
   * @memberof MgtBaseComponent
   */
  fireCustomEvent(eventName, detail, bubbles = false, cancelable = false) {
    const event = new CustomEvent(eventName, {
      bubbles,
      cancelable,
      detail
    });
    return this.dispatchEvent(event);
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * * @param changedProperties Map of changed properties with old values
   */
  updated(changedProperties) {
    super.updated(changedProperties);
    const event = new CustomEvent("updated", {
      bubbles: true,
      cancelable: true
    });
    this.dispatchEvent(event);
  }
  /**
   * Request to reload the state.
   * Use reload instead of load to ensure loading events are fired.
   *
   * @protected
   * @memberof MgtBaseComponent
   */
  requestStateUpdate(force = false) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this._isFirstUpdated) {
        return;
      }
      if (this.isLoadingState && !force) {
        yield this._currentLoadStatePromise;
      }
      const provider = Providers.globalProvider;
      if (!provider) {
        return Promise.resolve();
      }
      if (provider.state === ProviderState.SignedOut) {
        this.clearState();
        return;
      } else if (provider.state === ProviderState.Loading) {
        return Promise.resolve();
      } else {
        const loadStatePromise = new Promise((resolve, reject) => __awaiter6(this, void 0, void 0, function* () {
          try {
            this.setLoadingState(true);
            this.fireCustomEvent("loadingInitiated");
            yield this.loadState();
            this.setLoadingState(false);
            this.fireCustomEvent("loadingCompleted");
            resolve();
          } catch (e) {
            this.clearState();
            this.setLoadingState(false);
            this.fireCustomEvent("loadingFailed");
            reject(e);
          }
          return this._currentLoadStatePromise = this.isLoadingState && !!this._currentLoadStatePromise && force ? this._currentLoadStatePromise.then(() => loadStatePromise) : loadStatePromise;
        }));
      }
    });
  }
  setLoadingState(value) {
    if (this._isLoadingState === value) {
      return;
    }
    this._isLoadingState = value;
    this.requestUpdate("isLoadingState");
  }
  handleProviderUpdates() {
    this.requestStateUpdate();
  }
  handleActiveAccountUpdates() {
    return __awaiter6(this, void 0, void 0, function* () {
      this.clearState();
      this.requestStateUpdate();
    });
  }
  handleLocalizationChanged() {
    LocalizationHelper.updateStringsForTag(this.tagName, this.strings);
    this.requestUpdate();
  }
  handleDirectionChanged() {
    this.direction = LocalizationHelper.getDocumentDirection();
  }
};
__decorate([
  internalProperty(),
  __metadata("design:type", Object)
], MgtBaseComponent.prototype, "direction", void 0);

// node_modules/@microsoft/mgt-element/dist/es6/components/baseProvider.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata2 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtBaseProvider = class extends MgtBaseComponent {
  /**
   * The IProvider created by this component
   *
   * @memberof MgtBaseProvider
   */
  get provider() {
    return this._provider;
  }
  set provider(value) {
    if (this._provider) {
      this.provider.removeStateChangedHandler(() => this.stateChangedHandler);
    }
    this._provider = value;
    if (this._provider) {
      this.provider.onStateChanged(() => this.stateChangedHandler);
    }
  }
  /**
   * Gets weather this provider can be used in this environment
   *
   * @readonly
   * @type {boolean}
   * @memberof MgtBaseProvider
   */
  get isAvailable() {
    return true;
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * * @param _changedProperties Map of changed properties with old values
   */
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    let higherPriority = false;
    if (this.dependsOn) {
      let higherPriorityProvider = this.dependsOn;
      while (higherPriorityProvider) {
        if (higherPriorityProvider.isAvailable) {
          higherPriority = true;
          break;
        }
        higherPriorityProvider = higherPriorityProvider.dependsOn;
      }
    }
    if (!higherPriority && this.isAvailable) {
      this.initializeProvider();
    }
  }
  /**
   * method called to initialize the provider. Each derived class should provide
   * their own implementation
   *
   * @protected
   * @memberof MgtBaseProvider
   */
  // tslint:disable-next-line: no-empty
  initializeProvider() {
  }
  stateChangedHandler() {
    this.fireCustomEvent("onStateChanged", this.provider.state);
  }
};
__decorate2([
  property({
    attribute: "depends-on",
    converter: (newValue) => {
      return document.querySelector(newValue);
    },
    type: String
  }),
  __metadata2("design:type", MgtBaseProvider)
], MgtBaseProvider.prototype, "dependsOn", void 0);

// node_modules/@microsoft/mgt-element/dist/es6/utils/equals.js
function equals(o1, o2) {
  return equalsInternal(o1, o2, /* @__PURE__ */ new Set());
}
function equalsInternal(o1, o2, refs) {
  const o1Label = Object.prototype.toString.call(o1);
  const o2Label = Object.prototype.toString.call(o2);
  if (o1Label === o2Label && o1Label === "[object Object]" && !refs.has(o1)) {
    refs.add(o1);
    for (const k in o1) {
      if (!equalsInternal(o1[k], o2[k], refs)) {
        return false;
      }
    }
    for (const k in o2) {
      if (!o1.hasOwnProperty(k)) {
        return false;
      }
    }
    return true;
  }
  if (o1Label === o2Label && o1Label === "[object Array]" && !refs.has(o1)) {
    refs.add(o1);
    if (o1.length !== o2.length) {
      return false;
    }
    for (let i = 0; i < o1.length; i++) {
      if (!equalsInternal(o1[i], o2[i], refs)) {
        return false;
      }
    }
    return true;
  }
  return o1 === o2;
}
function arraysAreEqual(arr1, arr2) {
  if (arr1 === arr2) {
    return true;
  }
  if (!arr1 || !arr2) {
    return false;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  if (arr1.length === 0) {
    return true;
  }
  const setArr1 = new Set(arr1);
  for (const i of arr2) {
    if (!setArr1.has(i)) {
      return false;
    }
  }
  return true;
}

// node_modules/@microsoft/mgt-element/dist/es6/utils/TemplateHelper.js
var TemplateHelper = class {
  /**
   * Render a template into a HTMLElement with the appropriate data context
   *
   * Ex:
   * ```
   * <template>
   *  <div>{{myObj.someStr}}</div>
   *  <div data-for="key in myObj.list">
   *    <div>{{key.anotherStr}}</div>
   *  </div>
   * </template>
   * ```
   *
   * @param root the root element to parent the rendered content
   * @param template the template to render
   * @param context the data context to be applied
   */
  static renderTemplate(root, template, context) {
    if (template.$parentTemplateContext) {
      context = Object.assign(Object.assign({}, context), { $parent: template.$parentTemplateContext });
    }
    let rendered;
    if (template.content && template.content.childNodes.length) {
      const templateContent = template.content.cloneNode(true);
      rendered = this.renderNode(templateContent, root, context);
    } else if (template.childNodes.length) {
      const div = document.createElement("div");
      for (let i = 0; i < template.childNodes.length; i++) {
        div.appendChild(this.simpleCloneNode(template.childNodes[i]));
      }
      rendered = this.renderNode(div, root, context);
    }
    if (rendered) {
      root.appendChild(rendered);
    }
  }
  /**
   * Set an alternative binding syntax. Default is {{ <value> }}
   *
   * @static
   * @param {string} startStr start of binding syntax
   * @param {string} endStr end of binding syntax
   * @memberof TemplateHelper
   */
  static setBindingSyntax(startStr, endStr) {
    this._startExpression = startStr;
    this._endExpression = endStr;
    const start = this.escapeRegex(this._startExpression);
    const end = this.escapeRegex(this._endExpression);
    this._expression = new RegExp(`${start}\\s*([$\\w\\.,'"\\s()\\[\\]]+)\\s*${end}`, "g");
  }
  /**
   * Global context containing data or functions available to
   * all templates for binding
   *
   * @readonly
   * @static
   * @memberof TemplateHelper
   */
  static get globalContext() {
    return this._globalContext;
  }
  static get expression() {
    if (!this._expression) {
      this.setBindingSyntax("{{", "}}");
    }
    return this._expression;
  }
  static escapeRegex(string) {
    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  // simple implementation of deep cloneNode
  // required for nested templates in polyfilled browsers
  static simpleCloneNode(node) {
    if (!node) {
      return null;
    }
    const clone = node.cloneNode(false);
    for (let i = 0; i < node.childNodes.length; i++) {
      const childClone = this.simpleCloneNode(node.childNodes[i]);
      if (childClone) {
        clone.appendChild(childClone);
      }
    }
    return clone;
  }
  static expandExpressionsAsString(str, context) {
    return str.replace(this.expression, (match, p1) => {
      const value = this.evalInContext(p1 || this.trimExpression(match), context);
      if (value) {
        if (typeof value === "object") {
          return JSON.stringify(value);
        } else {
          return value.toString();
        }
      }
      return "";
    });
  }
  static renderNode(node, root, context) {
    if (node.nodeName === "#text") {
      node.textContent = this.expandExpressionsAsString(node.textContent, context);
      return node;
    } else if (node.nodeName === "TEMPLATE") {
      node.$parentTemplateContext = context;
      return node;
    }
    let nodeElement = node;
    if (nodeElement.attributes) {
      for (let i = 0; i < nodeElement.attributes.length; i++) {
        const attribute = nodeElement.attributes[i];
        if (attribute.name === "data-props") {
          const propsValue = this.trimExpression(attribute.value);
          for (const prop of propsValue.split(",")) {
            const keyValue = prop.trim().split(":");
            if (keyValue.length === 2) {
              const key = keyValue[0].trim();
              const value = this.evalInContext(keyValue[1].trim(), context);
              if (key.startsWith("@")) {
                if (typeof value === "function") {
                  nodeElement.addEventListener(key.substring(1), (e) => value(e, context, root));
                }
              } else {
                nodeElement[key] = value;
              }
            }
          }
        } else {
          nodeElement.setAttribute(attribute.name, this.expandExpressionsAsString(attribute.value, context));
        }
      }
    }
    const loopChildren = [];
    const removeChildren = [];
    let previousChildWasIfAndTrue = false;
    for (let i = 0; i < node.childNodes.length; i++) {
      const childNode = node.childNodes[i];
      const childElement = childNode;
      let previousChildWasIfAndTrueSet = false;
      if (childElement.dataset) {
        let childWillBeRemoved = false;
        if (childElement.dataset.if) {
          const expression = childElement.dataset.if;
          if (!this.evalBoolInContext(this.trimExpression(expression), context)) {
            removeChildren.push(childElement);
            childWillBeRemoved = true;
          } else {
            childElement.removeAttribute("data-if");
            previousChildWasIfAndTrue = true;
            previousChildWasIfAndTrueSet = true;
          }
        } else if (typeof childElement.dataset.else !== "undefined") {
          if (previousChildWasIfAndTrue) {
            removeChildren.push(childElement);
            childWillBeRemoved = true;
          } else {
            childElement.removeAttribute("data-else");
          }
        }
        if (childElement.dataset.for && !childWillBeRemoved) {
          loopChildren.push(childElement);
        } else if (!childWillBeRemoved) {
          this.renderNode(childNode, root, context);
        }
      } else {
        this.renderNode(childNode, root, context);
      }
      if (!previousChildWasIfAndTrueSet && childNode.nodeName !== "#text") {
        previousChildWasIfAndTrue = false;
      }
    }
    for (const child of removeChildren) {
      nodeElement.removeChild(child);
    }
    for (let i = 0; i < loopChildren.length; i++) {
      const childElement = loopChildren[i];
      const loopExpression = childElement.dataset.for;
      const loopTokens = this.trimExpression(loopExpression).split(/\s(in|of)\s/i);
      if (loopTokens.length === 3) {
        const itemName = loopTokens[0].trim();
        const listKey = loopTokens[2].trim();
        const list = this.evalInContext(listKey, context);
        if (Array.isArray(list)) {
          childElement.removeAttribute("data-for");
          for (let j = 0; j < list.length; j++) {
            const newContext = Object.assign({ $index: j }, context);
            newContext[itemName] = list[j];
            const clone = childElement.cloneNode(true);
            this.renderNode(clone, root, newContext);
            nodeElement.insertBefore(clone, childElement);
          }
        }
        nodeElement.removeChild(childElement);
      }
    }
    return node;
  }
  static evalBoolInContext(expression, context) {
    context = Object.assign(Object.assign({}, context), this.globalContext);
    return new Function("with(this) { return !!(" + expression + ")}").call(context);
  }
  static evalInContext(expression, context) {
    context = Object.assign(Object.assign({}, context), this.globalContext);
    const func = new Function("with(this) { return " + expression + ";}");
    let result;
    try {
      result = func.call(context);
    } catch (e) {
    }
    return result;
  }
  static trimExpression(expression) {
    expression = expression.trim();
    if (expression.startsWith(this._startExpression) && expression.endsWith(this._endExpression)) {
      expression = expression.substr(this._startExpression.length, expression.length - this._startExpression.length - this._endExpression.length);
      expression = expression.trim();
    }
    return expression;
  }
};
TemplateHelper._globalContext = {};

// node_modules/@microsoft/mgt-element/dist/es6/components/templatedComponent.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata3 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtTemplatedComponent = class extends MgtBaseComponent {
  constructor() {
    super();
    this.templates = {};
    this._renderedSlots = false;
    this._renderedTemplates = {};
    this._slotNamesAddedDuringRender = [];
    this.templateContext = this.templateContext || {};
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * * @param _changedProperties Map of changed properties with old values
   */
  update(changedProperties) {
    this.templates = this.getTemplates();
    this._slotNamesAddedDuringRender = [];
    super.update(changedProperties);
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * * @param changedProperties Map of changed properties with old values
   */
  updated(changedProperties) {
    super.updated(changedProperties);
    this.removeUnusedSlottedElements();
  }
  /**
   * Render a <template> by type and return content to render
   *
   * @param templateType type of template (indicated by the data-type attribute)
   * @param context the data context that should be expanded in template
   * @param slotName the slot name that will be used to host the new rendered template. set to a unique value if multiple templates of this type will be rendered. default is templateType
   */
  renderTemplate(templateType, context, slotName) {
    if (!this.hasTemplate(templateType)) {
      return null;
    }
    slotName = slotName || templateType;
    this._slotNamesAddedDuringRender.push(slotName);
    this._renderedSlots = true;
    const template = html`
      <slot name=${slotName}></slot>
    `;
    const dataContext = Object.assign(Object.assign({}, context), this.templateContext);
    if (this._renderedTemplates.hasOwnProperty(slotName)) {
      const { context: existingContext, slot } = this._renderedTemplates[slotName];
      if (equals(existingContext, dataContext)) {
        return template;
      }
      this.removeChild(slot);
    }
    const div = document.createElement("div");
    div.slot = slotName;
    div.dataset.generated = "template";
    TemplateHelper.renderTemplate(div, this.templates[templateType], dataContext);
    this.appendChild(div);
    this._renderedTemplates[slotName] = { context: dataContext, slot: div };
    this.fireCustomEvent("templateRendered", { templateType, context: dataContext, element: div });
    return template;
  }
  /**
   * Check if a specific template has been provided.
   *
   * @protected
   * @param {string} templateName
   * @returns {boolean}
   * @memberof MgtTemplatedComponent
   */
  hasTemplate(templateName) {
    return this.templates && this.templates[templateName];
  }
  getTemplates() {
    const templates = {};
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (child.nodeName === "TEMPLATE") {
        const template = child;
        if (template.dataset.type) {
          templates[template.dataset.type] = template;
        } else {
          templates.default = template;
        }
        template.templateOrder = i;
      }
    }
    return templates;
  }
  removeUnusedSlottedElements() {
    if (this._renderedSlots) {
      for (let i = 0; i < this.children.length; i++) {
        const child = this.children[i];
        if (child.dataset && child.dataset.generated && !this._slotNamesAddedDuringRender.includes(child.slot)) {
          this.removeChild(child);
          delete this._renderedTemplates[child.slot];
          i--;
        }
      }
      this._renderedSlots = false;
    }
  }
};
__decorate3([
  property({ attribute: false }),
  __metadata3("design:type", Object)
], MgtTemplatedComponent.prototype, "templateContext", void 0);

// node_modules/@microsoft/mgt-element/dist/es6/providers/SimpleProvider.js
var SimpleProvider = class extends IProvider {
  /**
   * Name used for analytics
   *
   * @readonly
   * @memberof IProvider
   */
  get name() {
    return "MgtSimpleProvider";
  }
  constructor(getAccessTokenHandler, loginHandler, logoutHandler) {
    super();
    this._getAccessTokenHandler = getAccessTokenHandler;
    this._loginHandler = loginHandler;
    this._logoutHandler = logoutHandler;
    this.graph = createFromProvider(this);
  }
  /**
   * Invokes the getAccessToken function
   *
   * @param {AuthenticationProviderOptions} [options]
   * @returns {Promise<string>}
   * @memberof SimpleProvider
   */
  getAccessToken(options) {
    return this._getAccessTokenHandler(options === null || options === void 0 ? void 0 : options.scopes);
  }
  /**
   * Invokes login function
   *
   * @returns {Promise<void>}
   * @memberof SimpleProvider
   */
  login() {
    return this._loginHandler();
  }
  /**
   * Invokes logout function
   *
   * @returns {Promise<void>}
   * @memberof SimpleProvider
   */
  logout() {
    return this._logoutHandler();
  }
};

// node_modules/idb/build/esm/wrap-idb-value.js
var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);

// node_modules/idb/build/esm/index.js
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));
    });
  }
  if (blocked)
    request.addEventListener("blocked", () => blocked());
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking)
      db.addEventListener("versionchange", () => blocking());
  }).catch(() => {
  });
  return openPromise;
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// node_modules/@microsoft/mgt-element/dist/es6/utils/Cache.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CacheService = class {
  /**
   *  Looks for existing cache, otherwise creates a new one
   *
   * @static
   * @template T
   * @param {CacheSchema} schema
   * @param {string} storeName
   * @returns {CacheStore<T>}
   * @memberof CacheService
   */
  static getCache(schema, storeName) {
    const key = `${schema.name}/${storeName}`;
    if (!this.isInitialized) {
      this.init();
    }
    if (!this.cacheStore.has(storeName)) {
      this.cacheStore.set(key, new CacheStore(schema, storeName));
    }
    return this.cacheStore.get(key);
  }
  /**
   * Clears all the stores within the cache
   */
  static clearCaches() {
    this.cacheStore.forEach((x) => indexedDB.deleteDatabase(x.getDBName()));
  }
  /**
   * returns the cacheconfig object
   *
   * @readonly
   * @static
   * @type {CacheConfig}
   * @memberof CacheService
   */
  static get config() {
    return this.cacheConfig;
  }
  /**
   * Checks for current sign in state and see if it has changed from signed-in to signed out
   *
   *
   * @private
   * @static
   * @memberof CacheService
   */
  static init() {
    let previousState;
    if (Providers.globalProvider) {
      previousState = Providers.globalProvider.state;
    }
    Providers.onProviderUpdated(() => {
      if (previousState === ProviderState.SignedIn && Providers.globalProvider.state === ProviderState.SignedOut) {
        this.clearCaches();
      }
      previousState = Providers.globalProvider.state;
    });
    this.isInitialized = true;
  }
};
CacheService.cacheStore = /* @__PURE__ */ new Map();
CacheService.isInitialized = false;
CacheService.cacheConfig = {
  defaultInvalidationPeriod: 36e5,
  groups: {
    invalidationPeriod: null,
    isEnabled: true
  },
  isEnabled: true,
  people: {
    invalidationPeriod: null,
    isEnabled: true
  },
  photos: {
    invalidationPeriod: null,
    isEnabled: true
  },
  presence: {
    invalidationPeriod: 3e5,
    isEnabled: true
  },
  users: {
    invalidationPeriod: null,
    isEnabled: true
  },
  response: {
    invalidationPeriod: null,
    isEnabled: true
  },
  files: {
    invalidationPeriod: null,
    isEnabled: true
  },
  fileLists: {
    invalidationPeriod: null,
    isEnabled: true
  }
};
var CacheStore = class {
  constructor(schema, store) {
    if (!(store in schema.stores)) {
      throw Error('"store" must be defined in the "schema"');
    }
    this.schema = schema;
    this.store = store;
  }
  /**
   * gets value from cache for the given key
   *
   * @param {string} key
   * @returns {Promise<T>}
   * @memberof Cache
   */
  getValue(key) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!window.indexedDB) {
        return null;
      }
      try {
        return (yield this.getDb()).get(this.store, key);
      } catch (e) {
        return null;
      }
    });
  }
  /**
   * inserts value into cache for the given key
   *
   * @param {string} key
   * @param {T} item
   * @returns
   * @memberof Cache
   */
  putValue(key, item) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!window.indexedDB) {
        return;
      }
      try {
        yield (yield this.getDb()).put(this.store, Object.assign(Object.assign({}, item), { timeCached: Date.now() }), key);
      } catch (e) {
        return;
      }
    });
  }
  /**
   * Clears the store of all stored values
   *
   * @returns
   * @memberof Cache
   */
  clearStore() {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!window.indexedDB) {
        return;
      }
      try {
        (yield this.getDb()).clear(this.store);
      } catch (e) {
        return;
      }
    });
  }
  /**
   * Returns the name of the parent DB that the cache store belongs to
   */
  getDBName() {
    return `mgt-${this.schema.name}`;
  }
  getDb() {
    return openDB(this.getDBName(), this.schema.version, {
      upgrade: (db, oldVersion, newVersion, transaction) => {
        for (const storeName in this.schema.stores) {
          if (this.schema.stores.hasOwnProperty(storeName)) {
            db.objectStoreNames.contains(storeName) || db.createObjectStore(storeName);
          }
        }
      }
    });
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/utils/TeamsHelper.js
var TeamsHelper = class {
  /**
   * Optional entry point to the teams library
   * If this value is not set, the provider will attempt to use
   * the microsoftTeams global variable.
   *
   * @static
   * @type {*}
   * @memberof TeamsHelper
   */
  static get microsoftTeamsLib() {
    return this._microsoftTeamsLib || window["microsoftTeams"];
  }
  static set microsoftTeamsLib(value) {
    this._microsoftTeamsLib = value;
  }
  /**
   * Gets whether the Teams provider can be used in the current context
   * (Whether the app is running in Microsoft Teams)
   *
   * @readonly
   * @static
   * @memberof TeamsHelper
   */
  static get isAvailable() {
    if (!this.microsoftTeamsLib) {
      return false;
    }
    if (window.parent === window.self && window.nativeInterface) {
      return true;
    } else if (window.name === "embedded-page-container" || window.name === "extension-tab-frame") {
      return true;
    }
    return false;
  }
  /**
   * Execute a deeplink against the Teams lib.
   *
   * @static
   * @param {string} deeplink
   * @param {(status: boolean, reason?: string) => void} [onComplete]
   * @memberof TeamsHelper
   */
  static executeDeepLink(deeplink, onComplete) {
    const teams = this.microsoftTeamsLib;
    teams.initialize();
    teams.executeDeepLink(deeplink, onComplete);
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/utils/GraphPageIterator.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var GraphPageIterator = class {
  /**
   * Gets all the items already fetched for this request
   *
   * @readonly
   * @type {T[]}
   * @memberof GraphPageIterator
   */
  get value() {
    return this._value;
  }
  /**
   * Gets wheather this request has more pages
   *
   * @readonly
   * @type {boolean}
   * @memberof GraphPageIterator
   */
  get hasNext() {
    return !!this._nextLink;
  }
  /**
   * Creates a new GraphPageIterator
   *
   * @static
   * @template T - the type of entities expected from this request
   * @param {IGraph} graph - the graph instance to use for making requests
   * @param {GraphRequest} request - the initial request
   * @param {string} [version] - optional version to use for the requests - by default uses the default version
   * from the graph parameter
   * @returns a GraphPageIterator
   * @memberof GraphPageIterator
   */
  static create(graph, request, version2) {
    return __awaiter8(this, void 0, void 0, function* () {
      const response = yield request.get();
      if (response && response.value) {
        const iterator = new GraphPageIterator();
        iterator._graph = graph;
        iterator._value = response.value;
        iterator._nextLink = response["@odata.nextLink"];
        iterator._version = version2 || graph.version;
        return iterator;
      }
      return null;
    });
  }
  /**
   * Creates a new GraphPageIterator from existing value
   *
   * @static
   * @template T - the type of entities expected from this request
   * @param {IGraph} graph - the graph instance to use for making requests
   * @param value - the existing value
   * @param nextLink - optional nextLink to use to get the next page
   * from the graph parameter
   * @returns a GraphPageIterator
   * @memberof GraphPageIterator
   */
  static createFromValue(graph, value, nextLink) {
    let iterator = new GraphPageIterator();
    iterator._graph = graph;
    iterator._value = value;
    iterator._nextLink = nextLink ? nextLink : null;
    iterator._version = graph.version;
    return iterator || null;
  }
  /**
   * Gets the next page for this request
   *
   * @returns {Promise<T[]>}
   * @memberof GraphPageIterator
   */
  next() {
    return __awaiter8(this, void 0, void 0, function* () {
      if (this._nextLink) {
        const nextResource = this._nextLink.split(this._version)[1];
        const response = yield this._graph.api(nextResource).version(this._version).get();
        if (response && response.value && response.value.length) {
          this._value = this._value.concat(response.value);
          this._nextLink = response["@odata.nextLink"];
          return response.value;
        }
      }
      return null;
    });
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/utils/SessionCache.js
var SessionCache = class {
  constructor() {
    this.session = window.sessionStorage;
  }
  setItem(key, value) {
    this.session.setItem(key, value);
  }
  getItem(key) {
    return this.session.getItem(key);
  }
  clear() {
    this.session.clear();
  }
};
function storageAvailable(storageType) {
  let storage;
  try {
    storage = window[storageType];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e) {
    return e instanceof DOMException && // everything except Firefox
    (e.code === 22 || // Firefox
    e.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    e.name === "QuotaExceededError" || // Firefox
    e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0;
  }
}

// node_modules/@microsoft/mgt-element/dist/es6/mock/MockGraph.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MockGraph = class extends Graph {
  constructor(mockProvider) {
    const middleware = [
      new AuthenticationHandler(mockProvider),
      new RetryHandler(new RetryHandlerOptions()),
      new TelemetryHandler(),
      new MockMiddleware(),
      new HTTPMessageHandler()
    ];
    super(Client.initWithMiddleware({
      middleware: chainMiddleware(...middleware)
    }));
  }
  /**
   * Returns an instance of the Graph in the context of the provided component.
   *
   * @param {MgtBaseComponent} component
   * @returns
   * @memberof Graph
   */
  forComponent(component) {
    return this;
  }
};
var MockMiddleware = class {
  constructor() {
    if (storageAvailable("sessionStorage")) {
      this._session = new SessionCache();
    }
  }
  // tslint:disable-next-line: completed-docs
  execute(context) {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const baseUrl = yield this.getBaseUrl();
        context.request = baseUrl + encodeURIComponent(context.request);
      } catch (error) {
      }
      return yield this._nextMiddleware.execute(context);
    });
  }
  /**
   * Handles setting of next middleware
   *
   * @param {Middleware} next
   * @memberof SdkVersionMiddleware
   */
  setNext(next) {
    this._nextMiddleware = next;
  }
  getBaseUrl() {
    var _a3, _b;
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this._baseUrl) {
        const sessionEndpoint = (_a3 = this._session) === null || _a3 === void 0 ? void 0 : _a3.getItem("endpointURL");
        if (sessionEndpoint) {
          this._baseUrl = sessionEndpoint;
        } else {
          try {
            let response = yield fetch("https://cdn.graph.office.net/en-us/graph/api/proxy/endpoint");
            this._baseUrl = (yield response.json()) + "?url=";
          } catch (_c) {
            this._baseUrl = "https://proxy.apisandbox.msdn.microsoft.com/svc?url=";
          }
          (_b = this._session) === null || _b === void 0 ? void 0 : _b.setItem("endpointURL", this._baseUrl);
        }
      }
      return this._baseUrl;
    });
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/mock/MockProvider.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MockProvider = class extends IProvider {
  constructor(signedIn = false) {
    super();
    this.graph = new MockGraph(this);
    if (signedIn) {
      this.setState(ProviderState.SignedIn);
    } else {
      this.setState(ProviderState.SignedOut);
    }
  }
  /**
   * sets Provider state to SignedIn
   *
   * @returns {Promise<void>}
   * @memberof MockProvider
   */
  login() {
    return __awaiter10(this, void 0, void 0, function* () {
      this.setState(ProviderState.Loading);
      yield new Promise((resolve) => setTimeout(resolve, 3e3));
      this.setState(ProviderState.SignedIn);
    });
  }
  /**
   * sets Provider state to signed out
   *
   * @returns {Promise<void>}
   * @memberof MockProvider
   */
  logout() {
    return __awaiter10(this, void 0, void 0, function* () {
      this.setState(ProviderState.Loading);
      yield new Promise((resolve) => setTimeout(resolve, 3e3));
      this.setState(ProviderState.SignedOut);
    });
  }
  /**
   * Promise returning token from graph.microsoft.com
   *
   * @returns {Promise<string>}
   * @memberof MockProvider
   */
  getAccessToken() {
    return Promise.resolve("{token:https://graph.microsoft.com/}");
  }
  /**
   * Name used for analytics
   *
   * @readonly
   * @memberof IProvider
   */
  get name() {
    return "MgtMockProvider";
  }
};

// node_modules/@microsoft/mgt-element/dist/es6/mock/mgt-mock-provider.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata4 = function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var MgtMockProvider = class MgtMockProvider2 extends MgtBaseProvider {
  /**
   * method called to initialize the provider. Each derived class should provide
   * their own implementation
   *
   * @protected
   * @memberof MgtBaseProvider
   */
  initializeProvider() {
    Providers.globalProvider = new MockProvider(!this.signedOut);
  }
};
__decorate4([
  property({
    attribute: "signed-out",
    type: Boolean
  }),
  __metadata4("design:type", Object)
], MgtMockProvider.prototype, "signedOut", void 0);
MgtMockProvider = __decorate4([
  customElement("mgt-mock-provider")
], MgtMockProvider);

export {
  BatchResponse,
  MICROSOFT_GRAPH_ENDPOINTS,
  MICROSOFT_GRAPH_DEFAULT_ENDPOINT,
  prepScopes,
  chainMiddleware,
  validateBaseURL,
  PACKAGE_VERSION2 as PACKAGE_VERSION,
  Graph,
  createFromProvider,
  BetaGraph,
  reparentNodes,
  removeNodes,
  createMarker,
  directive,
  AttributePart,
  NodePart,
  PropertyPart,
  html,
  customElement,
  property,
  internalProperty,
  state,
  css,
  EventDispatcher,
  IProvider,
  LoginType,
  ProviderState,
  Providers,
  ProvidersChangedState,
  LocalizationHelper,
  ComponentMediaQuery,
  MgtBaseComponent,
  MgtBaseProvider,
  equals,
  arraysAreEqual,
  TemplateHelper,
  MgtTemplatedComponent,
  SimpleProvider,
  CacheService,
  CacheStore,
  TeamsHelper,
  GraphPageIterator,
  MockProvider,
  MgtMockProvider
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

lit-html/lib/dom.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/modify-template.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/directive.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/part.js:
  (**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template-instance.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template-result.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/parts.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template-factory.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/render.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/default-template-processor.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/shady-render.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-element/lib/updating-element.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-element/lib/decorators.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-element/lib/css-tag.js:
  (**
  @license
  Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)
*/
//# sourceMappingURL=chunk-EVB4GM5G.js.map
