{
  "version": 3,
  "sources": ["../../@azure/communication-common/src/tokenParser.ts", "../../@azure/communication-common/src/autoRefreshTokenCredential.ts", "../../@azure/communication-common/src/staticTokenCredential.ts", "../../@azure/communication-common/src/azureCommunicationTokenCredential.ts", "../../@azure/communication-common/src/credential/encodeUtils.browser.ts", "../../@azure/communication-common/src/credential/cryptoUtils.browser.ts", "../../@azure/communication-common/src/credential/isNode.browser.ts", "../../@azure/communication-common/src/credential/communicationAccessKeyCredentialPolicy.ts", "../../@azure/communication-common/src/credential/communicationAuthPolicy.ts", "../../@azure/communication-common/src/credential/clientArguments.ts", "../../@azure/communication-common/src/credential/connectionString.ts", "../../@azure/communication-common/src/identifierModels.ts", "../../@azure/communication-common/src/identifierModelSerializer.ts"],
  "sourcesContent": ["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-auth\";\nimport jwtDecode from \"jwt-decode\";\n\ninterface JwtToken {\n  exp: number;\n}\n\nexport const parseToken = (token: string): AccessToken => {\n  const { exp } = jwtDecode<JwtToken>(token);\n  return {\n    token,\n    expiresOnTimestamp: exp * 1000,\n  };\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CommunicationGetTokenOptions, TokenCredential } from \"./communicationTokenCredential\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { parseToken } from \"./tokenParser\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Callback function that returns a string JWT token acquired from the Communication Identity API.\n   * The returned token must be valid (expiration date must be in the future).\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultExpiringSoonInterval = minutesToMs(10);\nconst defaultRefreshAfterLifetimePercentage = 0.5;\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly expiringSoonIntervalInMs: number = defaultExpiringSoonInterval;\n  private readonly refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isTokenExpiringSoon(this.currentToken)) {\n      return this.currentToken;\n    }\n\n    if (!this.isTokenValid(this.currentToken)) {\n      const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    const newToken = await this.refreshToken(abortSignal);\n\n    if (!this.isTokenValid(newToken)) {\n      throw new Error(\"The token returned from the tokenRefresher is expired.\");\n    }\n\n    this.currentToken = newToken;\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();\n    let timespanInMs = null;\n\n    if (this.isTokenExpiringSoon(this.currentToken)) {\n      // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.\n      timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;\n    } else {\n      // Schedule the next refresh for when it gets in to the soon-to-expire window.\n      timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;\n    }\n\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private isTokenValid(token: AccessToken): boolean {\n    return token && Date.now() < token.expiresOnTimestamp;\n  }\n\n  private isTokenExpiringSoon(token: AccessToken): boolean {\n    return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-auth\";\nimport { TokenCredential } from \"./communicationTokenCredential\";\n\n/**\n * StaticTokenCredential\n */\nexport class StaticTokenCredential implements TokenCredential {\n  constructor(private readonly token: AccessToken) {}\n\n  public async getToken(): Promise<AccessToken> {\n    return this.token;\n  }\n\n  public dispose(): void {\n    /* intentionally empty */\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions,\n} from \"./autoRefreshTokenCredential\";\nimport {\n  CommunicationGetTokenOptions,\n  CommunicationTokenCredential,\n  TokenCredential,\n} from \"./communicationTokenCredential\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport { parseToken } from \"./tokenParser\";\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\n\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token - A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions - Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(options);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const encodeUTF8 = (str: string): Uint8Array => new TextEncoder().encode(str);\n\nexport function encodeUTF8fromBase64(str: string): Uint8Array {\n  if (typeof atob !== \"function\") {\n    throw new Error(\"Your browser environment is missing the global `atob` function\");\n  }\n  const binary = atob(str);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\nexport function encodeBase64(value: ArrayBuffer): string {\n  if (typeof btoa !== \"function\") {\n    throw new Error(\"Your browser environment is missing the global `btoa` function\");\n  }\n  const bytes = new Uint8Array(value);\n  let binary = \"\";\n  for (const byte of bytes) {\n    binary += String.fromCharCode(byte);\n  }\n  return btoa(binary);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/// <reference lib=\"dom\" />\n\nimport { encodeBase64, encodeUTF8, encodeUTF8fromBase64 } from \"./encodeUtils.browser\";\n\nconst subtle = (globalThis as any)?.crypto?.subtle as SubtleCrypto;\n\nexport const shaHash = async (content: string): Promise<string> => {\n  const data = encodeUTF8(content);\n  const hash = await subtle.digest(\"SHA-256\", data);\n  return encodeBase64(hash);\n};\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const importParams: HmacImportParams = { name: \"HMAC\", hash: { name: \"SHA-256\" } };\n  const encodedMessage = encodeUTF8(content);\n  const encodedKey = encodeUTF8fromBase64(secret);\n  const crypto = subtle;\n  const cryptoKey = await crypto.importKey(\"raw\", encodedKey, importParams, false, [\"sign\"]);\n  const signature = await crypto.sign(importParams, cryptoKey, encodedMessage);\n  return encodeBase64(signature);\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n */\nexport const isNode = false;\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { shaHMAC, shaHash } from \"./cryptoUtils\";\nimport { KeyCredential } from \"@azure/core-auth\";\nimport { isNode } from \"./isNode\";\n\n/**\n * CommunicationKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nconst communicationAccessKeyCredentialPolicy = \"CommunicationAccessKeyCredentialPolicy\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport function createCommunicationAccessKeyCredentialPolicy(\n  credential: KeyCredential\n): PipelinePolicy {\n  return {\n    name: communicationAccessKeyCredentialPolicy,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const verb = request.method.toUpperCase();\n      const utcNow = new Date().toUTCString();\n      const contentHash = await shaHash(request.body?.toString() || \"\");\n      const dateHeader = \"x-ms-date\";\n      const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n      const url = new URL(request.url);\n      const query = url.searchParams;\n      const urlPathAndQuery = query ? `${url.pathname}?${query}` : url.pathname;\n      const port = url.port;\n      const hostAndPort = port ? `${url.host}:${port}` : url.host;\n\n      const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n      const signature = await shaHMAC(credential.key, stringToSign);\n\n      if (isNode) {\n        request.headers.set(\"Host\", hostAndPort || \"\");\n      }\n\n      request.headers.set(dateHeader, utcNow);\n      request.headers.set(\"x-ms-content-sha256\", contentHash);\n      request.headers.set(\n        \"Authorization\",\n        `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`\n      );\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BearerTokenAuthenticationPolicyOptions,\n  PipelinePolicy,\n  bearerTokenAuthenticationPolicy,\n} from \"@azure/core-rest-pipeline\";\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { createCommunicationAccessKeyCredentialPolicy } from \"./communicationAccessKeyCredentialPolicy\";\n/**\n * Creates a pipeline policy to authenticate request based\n * on the credential passed in.\n * @hidden\n *\n * @param credential - The KeyCredential or TokenCredential.\n */\nexport function createCommunicationAuthPolicy(\n  credential: KeyCredential | TokenCredential\n): PipelinePolicy {\n  if (isTokenCredential(credential)) {\n    const policyOptions: BearerTokenAuthenticationPolicyOptions = {\n      credential: credential,\n      scopes: [\"https://communication.azure.com//.default\"],\n    };\n    return bearerTokenAuthenticationPolicy(policyOptions);\n  } else {\n    return createCommunicationAccessKeyCredentialPolicy(credential);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = new URL(host);\n\n  return (\n    !!url.protocol?.match(/^http[s]?/) &&\n    url.host !== undefined &&\n    url.host !== \"\" &&\n    (url.pathname === undefined || url.pathname === \"\" || url.pathname === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureKeyCredential, KeyCredential } from \"@azure/core-auth\";\n/**\n * Represents different properties of connection string\n * using format \"/endpoint=(.*);accesskey=(.*)\".\n * @hidden\n */\nexport interface EndpointCredential {\n  /**\n   * The endpoint as string\n   */\n  endpoint: string;\n  /**\n   * The access key represented as a KeyCredential object\n   */\n  credential: KeyCredential;\n}\n\n// TODO: update when connection string format is finalized\nconst CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;\n\nconst tryParseConnectionString = (s: string): EndpointCredential | undefined => {\n  const match = s.match(CONNECTION_STRING_REGEX);\n  if (match?.[1] && match[2]) {\n    return { endpoint: match[1], credential: new AzureKeyCredential(match[2]) };\n  }\n  return undefined;\n};\n/**\n * Returns an EndpointCredential to easily access properties of the connection string.\n * @hidden\n *\n * @param connectionString - The connection string to parse\n * @returns Object to access the endpoint and the credentials\n */\nexport const parseConnectionString = (connectionString: string): EndpointCredential => {\n  const parsedConnectionString = tryParseConnectionString(connectionString);\n  if (parsedConnectionString) {\n    return parsedConnectionString;\n  } else {\n    throw new Error(`Invalid connection string ${connectionString}`);\n  }\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier =\n  | CommunicationUserIdentifier\n  | PhoneNumberIdentifier\n  | MicrosoftTeamsUserIdentifier\n  | UnknownIdentifier;\n\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n  /**\n   * Id of the CommunicationUser as returned from the Communication Service.\n   */\n  communicationUserId: string;\n}\n\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n  /**\n   * Optional raw id of the phone number.\n   */\n  rawId?: string;\n  /**\n   * The phone number in E.164 format.\n   */\n  phoneNumber: string;\n}\n\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams user.\n   */\n  rawId?: string;\n\n  /**\n   * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n   */\n  microsoftTeamsUserId: string;\n\n  /**\n   * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n   */\n  isAnonymous?: boolean;\n\n  /**\n   * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n  /**\n   * Id of the UnknownIdentifier.\n   */\n  id: string;\n}\n\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is CommunicationUserIdentifier => {\n  return typeof (identifier as any).communicationUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is PhoneNumberIdentifier => {\n  return typeof (identifier as any).phoneNumber === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is MicrosoftTeamsUserIdentifier => {\n  return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is UnknownIdentifier => {\n  return typeof (identifier as any).id === \"string\";\n};\n\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind =\n  | CommunicationUserKind\n  | PhoneNumberKind\n  | MicrosoftTeamsUserKind\n  | UnknownIdentifierKind;\n\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"communicationUser\";\n}\n\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"phoneNumber\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsUser\";\n}\n\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"unknown\";\n}\n\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (\n  identifier: CommunicationIdentifier\n): CommunicationIdentifierKind => {\n  if (isCommunicationUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"communicationUser\" };\n  }\n  if (isPhoneNumberIdentifier(identifier)) {\n    return { ...identifier, kind: \"phoneNumber\" };\n  }\n  if (isMicrosoftTeamsUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsUser\" };\n  }\n  return { ...identifier, kind: \"unknown\" };\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommunicationIdentifier,\n  CommunicationIdentifierKind,\n  getIdentifierKind,\n} from \"./identifierModels\";\n\n/**\n * @hidden\n * Identifies a participant in Azure Communication services. A participant is, for example, a phone number or an Azure communication user. This model must be interpreted as a union: Apart from rawId, at most one further property may be set.\n */\nexport interface SerializedCommunicationIdentifier {\n  /**\n   * Raw Id of the identifier. Optional in requests, required in responses.\n   */\n  rawId?: string;\n  /**\n   * The communication user.\n   */\n  communicationUser?: SerializedCommunicationUserIdentifier;\n  /**\n   * The phone number.\n   */\n  phoneNumber?: SerializedPhoneNumberIdentifier;\n  /**\n   * The Microsoft Teams user.\n   */\n  microsoftTeamsUser?: SerializedMicrosoftTeamsUserIdentifier;\n}\n\n/**\n * @hidden\n * A user that got created with an Azure Communication Services resource.\n */\nexport interface SerializedCommunicationUserIdentifier {\n  /**\n   * The Id of the communication user.\n   */\n  id: string;\n}\n\n/**\n * @hidden\n * A phone number.\n */\nexport interface SerializedPhoneNumberIdentifier {\n  /**\n   * The phone number in E.164 format.\n   */\n  value: string;\n}\n\n/**\n * @hidden\n * A Microsoft Teams user.\n */\nexport interface SerializedMicrosoftTeamsUserIdentifier {\n  /**\n   * The Id of the Microsoft Teams user. If not anonymous, this is the AAD object Id of the user.\n   */\n  userId: string;\n  /**\n   * True if the Microsoft Teams user is anonymous. By default false if missing.\n   */\n  isAnonymous?: boolean;\n  /**\n   * The cloud that the Microsoft Teams user belongs to. By default 'public' if missing.\n   */\n  cloud?: SerializedCommunicationCloudEnvironment;\n}\n\n/**\n * @hidden\n * Defines values for CommunicationCloudEnvironmentModel.\n */\nexport type SerializedCommunicationCloudEnvironment = \"public\" | \"dod\" | \"gcch\";\n\nconst addRawIdIfExisting = <T>(\n  identifier: T,\n  rawId: string | undefined\n): T & { rawId?: string } => {\n  return rawId === undefined ? identifier : { ...identifier, rawId: rawId };\n};\n\nconst assertNotNullOrUndefined = <\n  T extends Record<string, unknown>,\n  P extends keyof T,\n  Q extends keyof T[P]\n>(\n  obj: T,\n  prop: Q\n): Required<Required<T>[P]>[Q] => {\n  const subObjName = Object.keys(obj)[0];\n  const subObj = (obj as any)[subObjName];\n  if (prop in subObj) {\n    return subObj[prop];\n  }\n  throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);\n};\n\nconst assertMaximumOneNestedModel = (identifier: SerializedCommunicationIdentifier): void => {\n  const { rawId: _rawId, ...props } = identifier;\n  const keys = Object.keys(props);\n  if (keys.length > 1) {\n    throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);\n  }\n};\n\n/**\n * @hidden\n * Translates a CommunicationIdentifier to its serialized format for sending a request.\n * @param identifier - The CommunicationIdentifier to be serialized.\n */\nexport const serializeCommunicationIdentifier = (\n  identifier: CommunicationIdentifier\n): SerializedCommunicationIdentifier => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return { communicationUser: { id: identifierKind.communicationUserId } };\n    case \"phoneNumber\":\n      return addRawIdIfExisting(\n        { phoneNumber: { value: identifierKind.phoneNumber } },\n        identifierKind.rawId\n      );\n    case \"microsoftTeamsUser\":\n      return addRawIdIfExisting(\n        {\n          microsoftTeamsUser: {\n            userId: identifierKind.microsoftTeamsUserId,\n            isAnonymous: identifierKind.isAnonymous ?? false,\n            cloud: identifierKind.cloud ?? \"public\",\n          },\n        },\n        identifierKind.rawId\n      );\n    case \"unknown\":\n      return { rawId: identifierKind.id };\n    default:\n      throw new Error(`Can't serialize an identifier with kind ${(identifierKind as any).kind}`);\n  }\n};\n\n/**\n * @hidden\n * Translates the serialized format of a communication identifier to CommunicationIdentifier.\n * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.\n */\nexport const deserializeCommunicationIdentifier = (\n  serializedIdentifier: SerializedCommunicationIdentifier\n): CommunicationIdentifierKind => {\n  assertMaximumOneNestedModel(serializedIdentifier);\n\n  const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;\n  if (communicationUser) {\n    return {\n      kind: \"communicationUser\",\n      communicationUserId: assertNotNullOrUndefined({ communicationUser }, \"id\"),\n    };\n  }\n  if (phoneNumber) {\n    return {\n      kind: \"phoneNumber\",\n      phoneNumber: assertNotNullOrUndefined({ phoneNumber }, \"value\"),\n      rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  if (microsoftTeamsUser) {\n    return {\n      kind: \"microsoftTeamsUser\",\n      microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, \"userId\"),\n      isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, \"isAnonymous\"),\n      cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, \"cloud\"),\n      rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  return {\n    kind: \"unknown\",\n    id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, \"rawId\"),\n  };\n};\n"],
  "mappings": "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",
  "names": ["_a", "_a", "_a", "_b"]
}
