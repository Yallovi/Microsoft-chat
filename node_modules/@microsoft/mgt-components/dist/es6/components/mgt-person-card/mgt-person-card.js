/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var MgtPersonCard_1;
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { MgtTemplatedComponent, Providers, ProviderState, TeamsHelper, mgtHtml, customElement } from '@microsoft/mgt-element';
import { findPeople, getEmailFromGraphEntity } from '../../graph/graph.people';
import { ViewType } from '../../graph/types';
import { getPersonImage } from '../../graph/graph.photos';
import { getUserWithPhoto } from '../../graph/graph.userWithPhoto';
import { getSvg, SvgIcon } from '../../utils/SvgHelper';
import { getUserPresence } from '../../graph/graph.presence';
import { getPersonCardGraphData, createChat, sendMessage } from './mgt-person-card.graph';
import { styles } from './mgt-person-card-css';
import { MgtContact } from '../mgt-contact/mgt-contact';
import { MgtFileList } from '../mgt-file-list/mgt-file-list';
import { MgtMessages } from '../mgt-messages/mgt-messages';
import { MgtOrganization } from '../mgt-organization/mgt-organization';
import { MgtProfile } from '../mgt-profile/mgt-profile';
import { strings } from './strings';
import '../sub-components/mgt-spinner/mgt-spinner';
export * from './mgt-person-card.types';
import { fluentTabs, fluentTab, fluentTabPanel, fluentButton, fluentTextField } from '@fluentui/web-components';
import { registerFluentComponents } from '../../utils/FluentComponents';
registerFluentComponents(fluentTabs, fluentTab, fluentTabPanel, fluentButton, fluentTextField);
/**
 * Web Component used to show detailed data for a person in the Microsoft Graph
 *
 * @export
 * @class MgtPersonCard
 * @extends {MgtTemplatedComponent}
 *
 * @fires {CustomEvent<null>} expanded - Fired when expanded details section is opened
 *
 * @cssprop --person-card-display-name-font-size - {Length} Font size of display name title
 * @cssprop --person-card-display-name-line-height - {Length} Line height of display name
 * @cssprop --person-card-display-name-color - {Color} Color of display name font
 * @cssprop --person-card-title-font-size - {Length} Font size of title
 * @cssprop --person-card-title-line-height - {Length} Line height of title
 * @cssprop --person-card-title-color - {Color} Color of title
 * @cssprop --person-card-subtitle-font-size - {Length} Font size of subtitle
 * @cssprop --person-card-subtitle-line-height - {Length} Line height of subtitle
 * @cssprop --person-card-subtitle-color - {Color} Color of subttitle
 * @cssprop --person-card-background-color - {Color} Color of person card background
 * @cssprop --person-card-nav-back-arrow-color - {Color} Color of person back arrow when you click on a person
 * @cssprop --person-card-nav-back-arrow-hover-color - {Color} Color of the person back arrow when you hover on it
 * @cssprop --token-overflow-color - {Color} Color of the text showing more undisplayed values i.e. +3 more
 */
let MgtPersonCard = MgtPersonCard_1 = class MgtPersonCard extends MgtTemplatedComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    get strings() {
        return strings;
    }
    /**
     * Get the scopes required for the person card
     * The scopes depend on what sections are shown
     *
     * Use the `MgtPersonCard.config` object to configure
     * what sections are shown
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtPersonCard
     */
    static get requiredScopes() {
        return MgtPersonCard_1.getScopes();
    }
    static getScopes() {
        const scopes = [];
        if (this.config.sections.files) {
            scopes.push('Sites.Read.All');
        }
        if (this.config.sections.mailMessages) {
            scopes.push('Mail.Read');
            scopes.push('Mail.ReadBasic');
        }
        if (this.config.sections.organization) {
            scopes.push('User.Read.All');
            if (typeof this.config.sections.organization !== 'boolean' && this.config.sections.organization.showWorksWith) {
                scopes.push('People.Read.All');
            }
        }
        if (this.config.sections.profile) {
            scopes.push('User.Read.All');
        }
        if (this.config.useContactApis) {
            scopes.push('Contacts.Read');
        }
        if (scopes.indexOf('User.Read.All') < 0) {
            // at minimum, we need these scopes
            scopes.push('User.ReadBasic.All');
            scopes.push('User.Read');
        }
        if (scopes.indexOf('People.Read.All') < 0) {
            // at minimum, we need these scopes
            scopes.push('People.Read');
        }
        scopes.push('Chat.Create', 'Chat.ReadWrite');
        // return unique
        return [...new Set(scopes)];
    }
    /**
     * Global configuration object for
     * all person card components
     *
     * @static
     * @type {MgtPersonCardConfig}
     * @memberof MgtPersonCard
     */
    static get config() {
        return this._config;
    }
    /**
     * Set the person details to render
     *
     * @type {IDynamicPerson}
     * @memberof MgtPersonCard
     */
    get personDetails() {
        return this._personDetails;
    }
    set personDetails(value) {
        if (this._personDetails === value) {
            return;
        }
        this._personDetails = value;
        this.personImage = this.getImage();
        this.requestStateUpdate();
    }
    /**
     * user-id property allows developer to use id value for component
     * @type {string}
     */
    get userId() {
        return this._userId;
    }
    set userId(value) {
        if (value === this._userId) {
            return;
        }
        this._userId = value;
        this.personDetails = null;
        this._cardState = null;
        this.requestStateUpdate();
    }
    get internalPersonDetails() {
        return (this._cardState && this._cardState.person) || this.personDetails;
    }
    constructor() {
        super();
        this.isSending = false;
        this.hoverStates = {
            // triggers a re-render when hovering on the CTA icons
            email: false,
            chat: false,
            video: false,
            call: false
        };
        this.setHoveredState = (icon, hoverState) => {
            this.hoverStates[icon] = hoverState;
            this.hoverStates = Object.assign({}, this.hoverStates);
        };
        this.isHovered = (icon) => {
            return this.hoverStates[icon];
        };
        this._chatInput = '';
        this._currentSection = null;
        this._history = [];
        this.sections = [];
        this._graph = null;
    }
    /**
     * Synchronizes property values when attributes change.
     *
     * @param {*} name
     * @param {*} oldValue
     * @param {*} newValue
     * @memberof MgtPersonCard
     */
    attributeChangedCallback(name, oldValue, newValue) {
        super.attributeChangedCallback(name, oldValue, newValue);
        if (oldValue === newValue) {
            return;
        }
        switch (name) {
            case 'person-query':
                this.personDetails = null;
                this._cardState = null;
                this.requestStateUpdate();
                break;
        }
    }
    /**
     * Navigate the card to a different person.
     *
     * @protected
     * @memberof MgtPersonCard
     */
    navigate(person) {
        this._history.push({
            personDetails: this.personDetails,
            personImage: this.getImage(),
            state: this._cardState
        });
        this._personDetails = person;
        this._cardState = null;
        this.personImage = null;
        this._currentSection = null;
        this.sections = [];
        this._chatInput = '';
        this.requestStateUpdate();
    }
    /**
     * Navigate the card back to the previous person
     *
     * @returns {void}
     * @memberof MgtPersonCard
     */
    goBack() {
        if (!this._history || !this._history.length) {
            return;
        }
        const historyState = this._history.pop();
        this._currentSection = null;
        // resets to first tab being selected
        const firstTab = this.renderRoot.querySelector('fluent-tab');
        if (firstTab) {
            firstTab.click();
        }
        this._cardState = historyState.state;
        this._personDetails = historyState.state.person;
        this.personImage = historyState.personImage;
        this.loadSections();
    }
    /**
     * Navigate the card back to first person and clear history
     *
     * @returns {void}
     * @memberof MgtPersonCard
     */
    clearHistory() {
        this._currentSection = null;
        if (!this._history || !this._history.length) {
            return;
        }
        const historyState = this._history[0];
        this._history = [];
        this._cardState = historyState.state;
        this._personDetails = historyState.state;
        this.personImage = historyState.personImage;
        this.loadSections();
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */
    render() {
        // Handle no data
        if (!this.internalPersonDetails) {
            return this.renderNoData();
        }
        const person = this.internalPersonDetails;
        const image = this.getImage();
        // Check for a default template.
        // tslint:disable-next-line: no-string-literal
        if (this.hasTemplate('default')) {
            return this.renderTemplate('default', {
                person: this.internalPersonDetails,
                personImage: image
            });
        }
        const closeCardTemplate = this.isExpanded
            ? html `
           <div class="close-card-container">
             <fluent-button appearance="lightweight" class="close-button" @click=${() => this.closeCard()} >
               ${getSvg(SvgIcon.Close)}
             </fluent-button>
           </div>
         `
            : null;
        const navigationTemplate = this._history && this._history.length
            ? html `
            <div class="nav">
              <div class="nav__back" tabindex="0" @keydown=${(e) => {
                e.code === 'Enter' ? this.goBack() : '';
            }} @click=${() => this.goBack()}>${getSvg(SvgIcon.Back)}</div>
            </div>
          `
            : null;
        // Check for a person-details template
        let personDetailsTemplate = this.renderTemplate('person-details', {
            person: this.internalPersonDetails,
            personImage: image
        });
        if (!personDetailsTemplate) {
            const personTemplate = this.renderPerson();
            const contactIconsTemplate = this.renderContactIcons(person);
            personDetailsTemplate = html `
         ${personTemplate} ${contactIconsTemplate}
       `;
        }
        const expandedDetailsTemplate = this.isExpanded ? this.renderExpandedDetails() : this.renderExpandedDetailsButton();
        this._windowHeight =
            window.innerHeight && document.documentElement.clientHeight
                ? Math.min(window.innerHeight, document.documentElement.clientHeight)
                : window.innerHeight || document.documentElement.clientHeight;
        if (this._windowHeight < 250) {
            this._smallView = true;
        }
        const tabLocker = this.lockTabNavigation
            ? html `<div @keydown=${this.handleEndOfCard} aria-label=${this.strings.endOfCard} tabindex="0" id="end-of-container"></div>`
            : html ``;
        return html `
      <div class="root" dir=${this.direction}>
        <div class=${this._smallView ? 'small' : ''}>
          ${navigationTemplate}
          ${closeCardTemplate}
          <div class="person-details-container">${personDetailsTemplate}</div>
          <div class="expanded-details-container">${expandedDetailsTemplate}</div>
          ${tabLocker}
        </div>
      </div>
     `;
    }
    handleEndOfCard(e) {
        if (e && e.code === 'Tab') {
            const endOfCardEl = this.renderRoot.querySelector('#end-of-container');
            if (endOfCardEl) {
                endOfCardEl.blur();
                const imageCardEl = this.renderRoot.querySelector('mgt-person');
                if (imageCardEl) {
                    imageCardEl.focus();
                }
            }
        }
    }
    /**
     * Render the state when no data is available.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    closeCard() {
        // reset tabs
        this.updateCurrentSection(null);
        this.isExpanded = false;
    }
    /**
     * Render the state when no data is available.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderNoData() {
        return this.renderTemplate('no-data', null) || html ``;
    }
    /**
     * Render a display image for the person.
     *
     * @protected
     * @param {*} image
     * @memberof MgtPersonCard
     */
    renderPerson() {
        const avatarSize = 'large';
        return mgtHtml `
      <mgt-person
        tabindex="0"
        class="person-image"
        .personDetails=${this.internalPersonDetails}
        .personImage=${this.getImage()}
        .personPresence=${this.personPresence}
        .showPresence=${this.showPresence}
        .avatarSize=${avatarSize}
        .view=${ViewType.threelines}
      ></mgt-person>
    `;
    }
    /**
     * Render person subtitle.
     *
     * @protected
     * @param {IDynamicPerson} person
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderPersonSubtitle(person) {
        person = person || this.internalPersonDetails;
        if (!person.department) {
            return;
        }
        return html `
       <div class="department">${person.department}</div>
     `;
    }
    /**
     * Render the various icons for contacting the person.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderContactIcons(person) {
        person = person || this.internalPersonDetails;
        const userPerson = person;
        // Email
        let email;
        if (getEmailFromGraphEntity(person)) {
            email = html `
         <div class="icon"
           @click=${() => this.emailUser()}
           @mouseenter=${() => this.setHoveredState('email', true)}
           @mouseleave=${() => this.setHoveredState('email', false)}
           tabindex=0
           role="button">
           ${this.isHovered('email') ? getSvg(SvgIcon.SmallEmailHovered) : getSvg(SvgIcon.SmallEmail)}
         </div>
       `;
        }
        // Chat
        let chat;
        if (userPerson === null || userPerson === void 0 ? void 0 : userPerson.userPrincipalName) {
            chat = html `
         <div class="icon"
           @click=${() => this.chatUser()}
           @mouseenter=${() => this.setHoveredState('chat', true)}
           @mouseleave=${() => this.setHoveredState('chat', false)}
           tabindex=0
           role="button">
           ${this.isHovered('chat') ? getSvg(SvgIcon.SmallChatHovered) : getSvg(SvgIcon.SmallChat)}
         </div>
       `;
        }
        // Video
        let video;
        video = html `
        <div class="icon"
           @click=${() => this.videoCallUser()}
           @mouseenter=${() => this.setHoveredState('video', true)}
           @mouseleave=${() => this.setHoveredState('video', false)}
           tabindex=0
           role="button">
           ${this.isHovered('video') ? getSvg(SvgIcon.VideoHovered) : getSvg(SvgIcon.Video)}
         </div>
      `;
        // Call
        let call;
        if (userPerson.userPrincipalName) {
            call = html `
         <div class="icon"
           @click=${() => this.callUser()}
           @mouseenter=${() => this.setHoveredState('call', true)}
           @mouseleave=${() => this.setHoveredState('call', false)}
           tabindex=0
           role="button">
           ${this.isHovered('call') ? getSvg(SvgIcon.CallHovered) : getSvg(SvgIcon.Call)}
         </div>
       `;
        }
        return html `
       <div class="base-icons">
         ${email} ${chat} ${video} ${call}
       </div>
     `;
    }
    /**
     * Render the button used to expand the expanded details.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderExpandedDetailsButton() {
        return html `
      <div
        class="expanded-details-button"
        @click=${this.showExpandedDetails}
        @keydown=${this.handleKeyDown}
        tabindex=0
      >
        ${getSvg(SvgIcon.ExpandDown)}
      </div>
     `;
    }
    /**
     * Render expanded details.
     *
     * @protected
     * @param {IDynamicPerson} [person]
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderExpandedDetails(person) {
        if (!this._cardState && this._isStateLoading) {
            return mgtHtml `
         <div class="loading">
           <mgt-spinner></mgt-spinner>
         </div>
       `;
        }
        // load sections when details are expanded
        // when not singed in
        const provider = Providers.globalProvider;
        if (provider.state === ProviderState.SignedOut) {
            this.loadSections();
        }
        person = person || this.internalPersonDetails;
        const sectionNavTemplate = this.renderSectionNavigation();
        return html `
      <div class="section-nav">
        ${sectionNavTemplate}
      </div>
      <div
        class="section-host ${this._smallView ? 'small' : ''} ${this._smallView ? 'small' : ''}"
        @wheel=${(e) => this.handleSectionScroll(e)}
        tabindex=0
      ></div>
    `;
    }
    /**
     * Render the navigation ribbon for subsections
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderSectionNavigation() {
        if (!this.sections || (this.sections.length < 2 && !this.hasTemplate('additional-details'))) {
            return;
        }
        const currentSectionIndex = this._currentSection ? this.sections.indexOf(this._currentSection) : -1;
        const additionalSectionTemplates = this.sections.map((section, i) => {
            const name = section.tagName.toLowerCase();
            const classes = classMap({
                active: i === currentSectionIndex,
                'section-nav__icon': true
            });
            return html `
        <fluent-tab
          id="${name}-Tab"
          class=${classes}
          slot="tab"
          @keyup="${() => this.updateCurrentSection(section)}"
          @click=${() => this.updateCurrentSection(section)}
        >
          ${section.renderIcon()}
        </fluent-tab>
      `;
        });
        const additionalPanelTemplates = this.sections.map((section, i) => {
            return html `
        <fluent-tab-panel slot="tabpanel">
          <div class="inserted">${this._currentSection ? section.asFullView() : null}</div>
        </fluent-tab-panel>
      `;
        });
        const overviewClasses = classMap({
            active: currentSectionIndex === -1,
            'section-nav__icon': true,
            overviewTab: true
        });
        return html `
      <fluent-tabs
        orientation="horizontal"
        activeindicator
        @wheel=${(e) => this.handleSectionScroll(e)}
      >
        <fluent-tab
          class="${overviewClasses}"
          slot="tab"
          @keyup="${() => this.updateCurrentSection(null)}"
          @click=${() => this.updateCurrentSection(null)}
        >
          <div>${getSvg(SvgIcon.Overview)}</div>
        </fluent-tab>
        ${additionalSectionTemplates}
        <fluent-tab-panel slot="tabpanel" >
          <div class="overview-panel">${!this._currentSection ? this.renderOverviewSection() : null}</div>
        </fluent-tab-panel>
        ${additionalPanelTemplates}
      </fluent-tabs>
    `;
    }
    /**
     * Render the default section with compact views for each subsection.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderOverviewSection() {
        const compactTemplates = this.sections.map((section) => html `
        <div class="section">
          <div class="section__header">
            <div class="section__title" tabindex=0>${section.displayName}</div>
              <fluent-button
                appearance="lightweight"
                class="section__show-more"
                @click=${() => this.updateCurrentSection(section)}
              >
                ${this.strings.showMoreSectionButton}
              </fluent-button>
          </div>
          <div class="section__content">${section.asCompactView()}</div>
        </div>
      `);
        const additionalDetails = this.renderTemplate('additional-details', {
            person: this.internalPersonDetails,
            personImage: this.getImage(),
            state: this._cardState
        });
        if (additionalDetails) {
            compactTemplates.splice(1, 0, html `
           <div class="section">
             <div class="additional-details">${additionalDetails}</div>
           </div>
         `);
        }
        return html `
       <div class="sections">
          ${this.renderMessagingSection()}
          ${compactTemplates}
       </div>
     `;
    }
    /**
     * Render the actively selected section.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderCurrentSection() {
        if ((!this.sections || !this.sections.length) && !this.hasTemplate('additional-details')) {
            return;
        }
        if (this.sections.length === 1 && !this.hasTemplate('additional-details')) {
            return html `
         ${this.sections[0].asFullView()}
       `;
        }
        if (!this._currentSection) {
            return this.renderOverviewSection();
        }
        return html `
       ${this._currentSection.asFullView()}
     `;
    }
    /**
     * Render the messaging section.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPersonCard
     */
    renderMessagingSection() {
        const person = this.personDetails;
        const user = this._me.userPrincipalName;
        const chatInput = this._chatInput;
        if ((person === null || person === void 0 ? void 0 : person.userPrincipalName) === user) {
            return;
        }
        else {
            return html `
      <div class="message-section">
        <fluent-text-field appearance="outline" placeholder="${this.strings.quickMessage}"
          .value=${chatInput}
          @input=${(e) => {
                this._chatInput = e.target.value;
                this.requestUpdate();
            }}
          @keydown="${(e) => this.sendQuickMessageOnEnter(e)}">
        </fluent-text-field>
        <fluent-button class="send-message-icon" 
          @click=${() => this.sendQuickMessage()}
          ?disabled=${this.isSending}>
          ${!this.isSending ? getSvg(SvgIcon.Send) : getSvg(SvgIcon.Confirmation)}
        </fluent-button>
      </div>
      `;
        }
    }
    /**
     * load state into the component
     *
     * @protected
     * @returns
     * @memberof MgtPersonCard
     */
    loadState() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._cardState) {
                return;
            }
            if (!this.personDetails && this.inheritDetails) {
                // User person details inherited from parent tree
                let parent = this.parentElement;
                while (parent && parent.tagName !== 'MGT-PERSON') {
                    parent = parent.parentElement;
                }
                // tslint:disable-next-line: no-string-literal
                const parentPerson = parent.personDetails || parent['personDetailsInternal'];
                if (parent && parentPerson) {
                    this.personDetails = parentPerson;
                    this.personImage = parent.personImage;
                }
            }
            const provider = Providers.globalProvider;
            // check if user is signed in
            if (!provider || provider.state !== ProviderState.SignedIn) {
                return;
            }
            const graph = provider.graph.forComponent(this);
            this._graph = graph;
            this._isStateLoading = true;
            if (!this._me) {
                this._me = yield Providers.me();
            }
            // check if personDetail already populated
            if (this.personDetails) {
                const user = this.personDetails;
                const id = user.userPrincipalName || user.id;
                // if we have an id but no email, we should get data from the graph
                // in some graph calls, the user object does not contain the email
                if (id && !getEmailFromGraphEntity(user)) {
                    const person = yield getUserWithPhoto(graph, id);
                    this.personDetails = person;
                    this.personImage = this.getImage();
                }
            }
            else if (this.userId || this.personQuery === 'me') {
                // Use userId or 'me' query to get the person and image
                const person = yield getUserWithPhoto(graph, this.userId);
                this.personDetails = person;
                this.personImage = this.getImage();
            }
            else if (this.personQuery) {
                // Use the personQuery to find our person.
                const people = yield findPeople(graph, this.personQuery, 1);
                if (people && people.length) {
                    this.personDetails = people[0];
                    getPersonImage(graph, this.personDetails, MgtPersonCard_1.config.useContactApis).then(image => {
                        if (image) {
                            this.personDetails.personImage = image;
                            this.personImage = image;
                        }
                    });
                }
            }
            // populate presence
            const defaultPresence = {
                activity: 'Offline',
                availability: 'Offline',
                id: null
            };
            if (!this.personPresence && this.showPresence) {
                try {
                    if (this.personDetails && this.personDetails.id) {
                        getUserPresence(graph, this.personDetails.id).then(presence => {
                            this.personPresence = presence;
                        });
                    }
                    else {
                        this.personPresence = defaultPresence;
                    }
                }
                catch (_) {
                    // set up a default Presence in case beta api changes or getting error code
                    this.personPresence = defaultPresence;
                }
            }
            // populate state
            if ((_a = this.personDetails) === null || _a === void 0 ? void 0 : _a.id) {
                this._cardState = yield getPersonCardGraphData(graph, this.personDetails, this._me === this.personDetails.id, MgtPersonCard_1.config);
            }
            this.loadSections();
            this._isStateLoading = false;
        });
    }
    /**
     * Send a chat message to the user from the quick message input.
     *
     * @protected
     * @returns {void}
     * @memberof MgtPersonCard
     */
    sendQuickMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            const message = this._chatInput.trim();
            if (!message || !message.length) {
                return;
            }
            const person = this.personDetails;
            const user = this._me.userPrincipalName;
            this.isSending = true;
            const chat = yield createChat(this._graph, person.userPrincipalName, user);
            const messageData = {
                body: {
                    content: message
                }
            };
            yield sendMessage(this._graph, chat.id, messageData);
            this.isSending = false;
            this.clearInputData();
        });
    }
    /**
     * Use the mailto: protocol to initiate a new email to the user.
     *
     * @protected
     * @memberof MgtPersonCard
     */
    emailUser() {
        const user = this.internalPersonDetails;
        if (user) {
            const email = getEmailFromGraphEntity(user);
            if (email) {
                window.open('mailto:' + email, '_blank', 'noreferrer');
            }
        }
    }
    get hasPhone() {
        var _a, _b;
        const user = this.personDetails;
        const person = this.personDetails;
        return Boolean((_a = user === null || user === void 0 ? void 0 : user.businessPhones) === null || _a === void 0 ? void 0 : _a.length) || Boolean((_b = person === null || person === void 0 ? void 0 : person.phones) === null || _b === void 0 ? void 0 : _b.length);
    }
    /**
     * Use the tel: protocol to initiate a new call to the user.
     *
     * @protected
     * @memberof MgtPersonCard
     */
    callUser() {
        const user = this.personDetails;
        const person = this.personDetails;
        if (user && user.businessPhones && user.businessPhones.length) {
            const phone = user.businessPhones[0];
            if (phone) {
                window.open('tel:' + phone, '_blank', 'noreferrer');
            }
        }
        else if (person && person.phones && person.phones.length) {
            const businessPhones = this.getPersonBusinessPhones(person);
            const phone = businessPhones[0];
            if (phone) {
                window.open('tel:' + phone, '_blank', 'noreferrer');
            }
        }
    }
    /**
     * Initiate a chat message to the user via deeplink.
     *
     * @protected
     * @memberof MgtPersonCard
     */
    chatUser(message = null) {
        const user = this.personDetails;
        if (user && user.userPrincipalName) {
            const users = user.userPrincipalName;
            let url = `https://teams.microsoft.com/l/chat/0/0?users=${users}`;
            if (message && message.length) {
                url += `&message=${message}`;
            }
            const openWindow = () => window.open(url, '_blank', 'noreferrer');
            if (TeamsHelper.isAvailable) {
                TeamsHelper.executeDeepLink(url, (status) => {
                    if (!status) {
                        openWindow();
                    }
                });
            }
            else {
                openWindow();
            }
        }
    }
    /**
     * Initiate a teams call with video with a user via deeplink.
     *
     * @protected
     * @memberof MgtPersonCard
     */
    videoCallUser() {
        const user = this.personDetails;
        if (user && user.userPrincipalName) {
            const users = user.userPrincipalName;
            const url = `https://teams.microsoft.com/l/call/0/0?users=${users}&withVideo=true`;
            const openWindow = () => window.open(url, '_blank');
            if (TeamsHelper.isAvailable) {
                TeamsHelper.executeDeepLink(url, (status) => {
                    if (!status) {
                        openWindow();
                    }
                });
            }
            else {
                openWindow();
            }
        }
    }
    /**
     * Display the expanded details panel.
     *
     * @protected
     * @memberof MgtPersonCard
     */
    showExpandedDetails() {
        const root = this.renderRoot.querySelector('.root');
        if (root && root.animate) {
            // play back
            root.animate([
                {
                    height: 'auto',
                    transformOrigin: 'top left'
                },
                {
                    height: 'auto',
                    transformOrigin: 'top left'
                }
            ], {
                duration: 1000,
                easing: 'ease-in-out',
                fill: 'both'
            });
        }
        this.isExpanded = true;
        this.fireCustomEvent('expanded', null, true);
    }
    loadSections() {
        this.sections = [];
        if (!this.internalPersonDetails) {
            return;
        }
        const contactSections = new MgtContact(this.internalPersonDetails);
        if (contactSections.hasData) {
            this.sections.push(contactSections);
        }
        if (!this._cardState) {
            return;
        }
        const { person, directReports, messages, files, profile } = this._cardState;
        if (MgtPersonCard_1.config.sections.organization &&
            ((person && person.manager) || (directReports && directReports.length))) {
            this.sections.push(new MgtOrganization(this._cardState, this._me));
        }
        if (MgtPersonCard_1.config.sections.mailMessages && messages && messages.length) {
            this.sections.push(new MgtMessages(messages));
        }
        if (MgtPersonCard_1.config.sections.files && files && files.length) {
            this.sections.push(new MgtFileList());
        }
        if (MgtPersonCard_1.config.sections.profile && profile) {
            const profileSection = new MgtProfile(profile);
            if (profileSection.hasData) {
                this.sections.push(profileSection);
            }
        }
    }
    getImage() {
        if (this.personImage) {
            return this.personImage;
        }
        const person = this.personDetails;
        return person && person.personImage ? person.personImage : null;
    }
    clearInputData() {
        this._chatInput = '';
        this.requestUpdate();
    }
    getPersonBusinessPhones(person) {
        const phones = person.phones;
        const businessPhones = [];
        for (const p of phones) {
            if (p.type === 'business') {
                businessPhones.push(p.number);
            }
        }
        return businessPhones;
    }
    updateCurrentSection(section) {
        if (section) {
            const sectionName = section.tagName.toLowerCase();
            const tabs = this.renderRoot.querySelector(`#${sectionName}-Tab`);
            tabs.click();
        }
        const panels = this.renderRoot.querySelectorAll('fluent-tab-panel');
        for (const target of panels) {
            target.scrollTop = 0;
        }
        this._currentSection = section;
        this.requestUpdate();
    }
    handleSectionScroll(e) {
        const panels = this.renderRoot.querySelectorAll('fluent-tab-panel');
        for (const target of panels) {
            if (target) {
                if (!(e.deltaY < 0 && target.scrollTop === 0) &&
                    !(e.deltaY > 0 && target.clientHeight + target.scrollTop >= target.scrollHeight - 1)) {
                    e.stopPropagation();
                }
            }
        }
    }
    handleKeyDown(e) {
        // enter activates person-card
        if (e) {
            if (e.code === 'Enter') {
                this.showExpandedDetails();
            }
        }
    }
    sendQuickMessageOnEnter(e) {
        if (e.code === 'Enter') {
            this.sendQuickMessage();
        }
    }
};
MgtPersonCard._config = {
    sections: {
        files: true,
        mailMessages: true,
        organization: { showWorksWith: true },
        profile: true
    },
    useContactApis: true,
    isSendMessageVisible: true
};
__decorate([
    property({
        attribute: 'person-details',
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPersonCard.prototype, "personDetails", null);
__decorate([
    property({
        attribute: 'person-query'
    }),
    __metadata("design:type", String)
], MgtPersonCard.prototype, "personQuery", void 0);
__decorate([
    property({
        attribute: 'lock-tab-navigation',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPersonCard.prototype, "lockTabNavigation", void 0);
__decorate([
    property({
        attribute: 'user-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPersonCard.prototype, "userId", null);
__decorate([
    property({
        attribute: 'person-image',
        type: String
    }),
    __metadata("design:type", String)
], MgtPersonCard.prototype, "personImage", void 0);
__decorate([
    property({
        attribute: 'fetch-image',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPersonCard.prototype, "fetchImage", void 0);
__decorate([
    property({
        attribute: 'is-expanded',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPersonCard.prototype, "isExpanded", void 0);
__decorate([
    property({
        attribute: 'inherit-details',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPersonCard.prototype, "inheritDetails", void 0);
__decorate([
    property({
        attribute: 'show-presence',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPersonCard.prototype, "showPresence", void 0);
__decorate([
    property({
        attribute: 'person-presence',
        type: Object
    }),
    __metadata("design:type", Object)
], MgtPersonCard.prototype, "personPresence", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtPersonCard.prototype, "isSending", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPersonCard.prototype, "_cardState", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtPersonCard.prototype, "_isStateLoading", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPersonCard.prototype, "hoverStates", void 0);
MgtPersonCard = MgtPersonCard_1 = __decorate([
    customElement('person-card')
    // @customElement('mgt-person-card')
    ,
    __metadata("design:paramtypes", [])
], MgtPersonCard);
export { MgtPersonCard };
//# sourceMappingURL=mgt-person-card.js.map